
TempDataLogger.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000860  00800100  0001612e  000161e2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0001612e  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000ac7  00800960  00800960  00016a42  2**0
                  ALLOC
  3 .eeprom       0000002a  00810000  00810000  00016a42  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00001518  00000000  00000000  00016a6c  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000006b7  00000000  00000000  00017f84  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000b80  00000000  00000000  0001863b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00002177  00000000  00000000  000191bb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00012d9d  00000000  00000000  0001b332  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00004325  00000000  00000000  0002e0cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00010aeb  00000000  00000000  000323f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00001260  00000000  00000000  00042ee0  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00005996  00000000  00000000  00044140  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000c490  00000000  00000000  00049ad6  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_pubtypes 00001821  00000000  00000000  00055f66  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000ed8  00000000  00000000  00057787  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 8d 6c 	jmp	0xd91a	; 0xd91a <__ctors_end>
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
       4:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
       8:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
       c:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      10:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      14:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      18:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      1c:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      20:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      24:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      28:	0c 94 46 a5 	jmp	0x14a8c	; 0x14a8c <__vector_10>
      2c:	0c 94 12 a6 	jmp	0x14c24	; 0x14c24 <__vector_11>
      30:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      34:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      38:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      3c:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      40:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      44:	0c 94 8b 77 	jmp	0xef16	; 0xef16 <__vector_17>
      48:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      4c:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      50:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      54:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      58:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      5c:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      60:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      64:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      68:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      6c:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      70:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      74:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      78:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      7c:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      80:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      84:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      88:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      8c:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      90:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>
      94:	0c 94 ac 6c 	jmp	0xd958	; 0xd958 <__bad_interrupt>

00000098 <Arial12x12>:
      98:	19 0c 0c 02 07 00 00 00 00 00 00 00 00 00 00 00     ................
      a8:	00 00 00 00 00 00 00 00 00 00 00 00 00 02 00 00     ................
      b8:	7f 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
      c8:	00 00 00 00 00 00 03 07 00 00 00 07 00 00 00 00     ................
      d8:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 07     ................
      e8:	24 00 a4 01 7c 00 a7 01 7c 00 27 00 24 00 00 00     $...|...|.'.$...
      f8:	00 00 00 00 00 00 00 00 06 00 00 ce 00 11 01 ff     ................
     108:	03 11 01 e2 00 00 00 00 00 00 00 00 00 00 00 00     ................
     118:	00 0a 00 00 0e 00 11 00 11 01 ce 00 38 00 e6 00     ............8...
     128:	11 01 10 01 e0 00 00 00 00 00 08 00 00 e0 00 1e     ................
     138:	01 11 01 29 01 c6 00 a0 00 00 01 00 00 00 00 00     ...)............
     148:	00 00 00 02 00 00 07 00 00 00 00 00 00 00 00 00     ................
     158:	00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 f8     ................
     168:	00 06 03 01 04 00 00 00 00 00 00 00 00 00 00 00     ................
     178:	00 00 00 00 00 03 01 04 06 03 f8 00 00 00 00 00     ................
     188:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 05 02     ................
     198:	00 0a 00 07 00 0a 00 02 00 00 00 00 00 00 00 00     ................
     1a8:	00 00 00 00 00 00 00 06 00 00 10 00 10 00 7c 00     ..............|.
     1b8:	10 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     1c8:	02 00 00 00 07 00 00 00 00 00 00 00 00 00 00 00     ................
     1d8:	00 00 00 00 00 00 00 00 00 03 20 00 20 00 20 00     .......... . . .
     1e8:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     1f8:	00 00 02 00 00 00 01 00 00 00 00 00 00 00 00 00     ................
     208:	00 00 00 00 00 00 00 00 00 00 00 03 80 01 7c 00     ..............|.
     218:	03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     228:	00 00 00 00 06 00 00 fe 00 01 01 01 01 01 01 fe     ................
     238:	00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00     ................
     248:	04 00 02 00 ff 01 00 00 00 00 00 00 00 00 00 00     ................
     258:	00 00 00 00 00 00 06 00 00 02 01 81 01 41 01 31     .............A.1
     268:	01 0e 01 00 00 00 00 00 00 00 00 00 00 00 00 06     ................
     278:	00 00 82 00 01 01 11 01 11 01 ee 00 00 00 00 00     ................
     288:	00 00 00 00 00 00 00 00 06 00 00 60 00 58 00 46     ...........`.X.F
     298:	00 ff 01 40 00 00 00 00 00 00 00 00 00 00 00 00     ...@............
     2a8:	00 06 00 00 9c 00 0b 01 09 01 09 01 f1 00 00 00     ................
     2b8:	00 00 00 00 00 00 00 00 00 00 06 00 00 fe 00 11     ................
     2c8:	01 09 01 09 01 f2 00 00 00 00 00 00 00 00 00 00     ................
     2d8:	00 00 00 06 00 00 01 00 c1 01 39 00 07 00 01 00     ..........9.....
     2e8:	00 00 00 00 00 00 00 00 00 00 00 00 06 00 00 ee     ................
     2f8:	00 11 01 11 01 11 01 ee 00 00 00 00 00 00 00 00     ................
     308:	00 00 00 00 00 06 00 00 9e 00 21 01 21 01 11 01     ..........!.!...
     318:	fe 00 00 00 00 00 00 00 00 00 00 00 00 00 02 00     ................
     328:	00 04 01 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     338:	00 00 00 00 00 00 00 02 00 00 04 07 00 00 00 00     ................
     348:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     358:	06 00 00 10 00 28 00 28 00 28 00 44 00 00 00 00     .....(.(.(.D....
     368:	00 00 00 00 00 00 00 00 00 06 48 00 48 00 48 00     ..........H.H.H.
     378:	48 00 48 00 48 00 00 00 00 00 00 00 00 00 00 00     H.H.H...........
     388:	00 00 06 00 00 44 00 28 00 28 00 28 00 10 00 00     .....D.(.(.(....
     398:	00 00 00 00 00 00 00 00 00 00 00 06 00 00 06 00     ................
     3a8:	01 00 61 01 11 00 0e 00 00 00 00 00 00 00 00 00     ..a.............
     3b8:	00 00 00 00 0c 00 00 f0 01 0c 02 e2 04 12 09 09     ................
     3c8:	09 09 09 f1 09 19 09 02 05 86 04 78 02 07 80 01     ...........x....
     3d8:	70 00 2e 00 21 00 2e 00 70 00 80 01 00 00 00 00     p...!...p.......
     3e8:	00 00 00 00 00 00 07 00 00 ff 01 11 01 11 01 11     ................
     3f8:	01 11 01 fe 00 00 00 00 00 00 00 00 00 00 00 08     ................
     408:	00 00 7c 00 82 00 01 01 01 01 01 01 82 00 44 00     ..|...........D.
     418:	00 00 00 00 00 00 00 00 08 00 00 ff 01 01 01 01     ................
     428:	01 01 01 01 01 82 00 7c 00 00 00 00 00 00 00 00     .......|........
     438:	00 07 00 00 ff 01 11 01 11 01 11 01 11 01 11 01     ................
     448:	00 00 00 00 00 00 00 00 00 00 06 00 00 ff 01 11     ................
     458:	00 11 00 11 00 01 00 00 00 00 00 00 00 00 00 00     ................
     468:	00 00 00 08 00 00 7c 00 82 00 01 01 01 01 11 01     ......|.........
     478:	92 00 74 00 00 00 00 00 00 00 00 00 08 00 00 ff     ..t.............
     488:	01 10 00 10 00 10 00 10 00 10 00 ff 01 00 00 00     ................
     498:	00 00 00 00 00 02 00 00 ff 01 00 00 00 00 00 00     ................
     4a8:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 05 c0     ................
     4b8:	00 00 01 00 01 00 01 ff 00 00 00 00 00 00 00 00     ................
     4c8:	00 00 00 00 00 00 00 08 00 00 ff 01 20 00 10 00     ............ ...
     4d8:	28 00 44 00 82 00 01 01 00 00 00 00 00 00 00 00     (.D.............
     4e8:	07 00 00 ff 01 00 01 00 01 00 01 00 01 00 01 00     ................
     4f8:	00 00 00 00 00 00 00 00 00 08 00 00 ff 01 06 00     ................
     508:	78 00 80 01 78 00 06 00 ff 01 00 00 00 00 00 00     x...x...........
     518:	00 00 08 00 00 ff 01 02 00 0c 00 10 00 60 00 80     .............`..
     528:	00 ff 01 00 00 00 00 00 00 00 00 08 00 00 7c 00     ..............|.
     538:	82 00 01 01 01 01 01 01 82 00 7c 00 00 00 00 00     ..........|.....
     548:	00 00 00 00 07 00 00 ff 01 11 00 11 00 11 00 11     ................
     558:	00 0e 00 00 00 00 00 00 00 00 00 00 00 08 00 00     ................
     568:	7c 00 82 00 01 01 41 01 41 01 82 00 7c 01 00 00     |.....A.A...|...
     578:	00 00 00 00 00 00 08 00 00 ff 01 11 00 11 00 11     ................
     588:	00 31 00 d1 00 0e 01 00 00 00 00 00 00 00 00 07     .1..............
     598:	00 00 ce 00 11 01 11 01 11 01 11 01 e6 00 00 00     ................
     5a8:	00 00 00 00 00 00 00 00 07 01 00 01 00 01 00 ff     ................
     5b8:	01 01 00 01 00 01 00 00 00 00 00 00 00 00 00 00     ................
     5c8:	00 08 00 00 7f 00 80 00 00 01 00 01 00 01 80 00     ................
     5d8:	7f 00 00 00 00 00 00 00 00 00 07 03 00 1c 00 60     ...............`
     5e8:	00 80 01 60 00 1c 00 03 00 00 00 00 00 00 00 00     ...`............
     5f8:	00 00 00 0b 07 00 78 00 80 01 70 00 0e 00 01 00     ......x...p.....
     608:	0e 00 70 00 80 01 7c 00 03 00 00 00 07 01 01 c6     ..p...|.........
     618:	00 28 00 10 00 28 00 c6 00 01 01 00 00 00 00 00     .(...(..........
     628:	00 00 00 00 00 07 01 00 06 00 08 00 f0 01 08 00     ................
     638:	06 00 01 00 00 00 00 00 00 00 00 00 00 00 07 00     ................
     648:	01 81 01 61 01 11 01 0d 01 03 01 01 01 00 00 00     ...a............
     658:	00 00 00 00 00 00 00 03 00 00 ff 07 01 04 00 00     ................
     668:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     678:	03 03 00 7c 00 80 01 00 00 00 00 00 00 00 00 00     ...|............
     688:	00 00 00 00 00 00 00 00 00 02 01 04 ff 07 00 00     ................
     698:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     6a8:	00 00 05 10 00 0e 00 01 00 0e 00 10 00 00 00 00     ................
     6b8:	00 00 00 00 00 00 00 00 00 00 00 07 00 04 00 04     ................
     6c8:	00 04 00 04 00 04 00 04 00 04 00 00 00 00 00 00     ................
     6d8:	00 00 00 00 03 00 00 01 00 02 00 00 00 00 00 00     ................
     6e8:	00 00 00 00 00 00 00 00 00 00 00 00 00 06 00 00     ................
     6f8:	c8 00 24 01 24 01 a4 00 f8 01 00 00 00 00 00 00     ..$.$...........
     708:	00 00 00 00 00 00 06 00 00 ff 01 88 00 04 01 04     ................
     718:	01 f8 00 00 00 00 00 00 00 00 00 00 00 00 00 05     ................
     728:	00 00 f8 00 04 01 04 01 88 00 00 00 00 00 00 00     ................
     738:	00 00 00 00 00 00 00 00 06 00 00 f8 00 04 01 04     ................
     748:	01 08 01 ff 01 00 00 00 00 00 00 00 00 00 00 00     ................
     758:	00 06 00 00 f8 00 24 01 24 01 24 01 b8 00 00 00     ......$.$.$.....
     768:	00 00 00 00 00 00 00 00 00 00 04 04 00 fe 01 05     ................
     778:	00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     788:	00 00 00 06 00 00 f8 04 04 05 04 05 88 04 fc 03     ................
     798:	00 00 00 00 00 00 00 00 00 00 00 00 06 00 00 ff     ................
     7a8:	01 08 00 04 00 04 00 f8 01 00 00 00 00 00 00 00     ................
     7b8:	00 00 00 00 00 02 00 00 fd 01 00 00 00 00 00 00     ................
     7c8:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 02 00     ................
     7d8:	04 fd 03 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     7e8:	00 00 00 00 00 00 00 06 00 00 ff 01 20 00 30 00     ............ .0.
     7f8:	c8 00 04 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
     808:	02 00 00 ff 01 00 00 00 00 00 00 00 00 00 00 00     ................
     818:	00 00 00 00 00 00 00 00 00 0a 00 00 fc 01 08 00     ................
     828:	04 00 04 00 f8 01 08 00 04 00 04 00 f8 01 00 00     ................
     838:	00 00 06 00 00 fc 01 08 00 04 00 04 00 f8 01 00     ................
     848:	00 00 00 00 00 00 00 00 00 00 00 06 00 00 f8 00     ................
     858:	04 01 04 01 04 01 f8 00 00 00 00 00 00 00 00 00     ................
     868:	00 00 00 00 06 00 00 fc 07 88 00 04 01 04 01 f8     ................
     878:	00 00 00 00 00 00 00 00 00 00 00 00 00 06 00 00     ................
     888:	f8 00 04 01 04 01 88 00 fc 07 00 00 00 00 00 00     ................
     898:	00 00 00 00 00 00 04 00 00 fc 01 08 00 04 00 00     ................
     8a8:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06     ................
     8b8:	00 00 98 00 24 01 24 01 24 01 c8 00 00 00 00 00     ....$.$.$.......
     8c8:	00 00 00 00 00 00 00 00 03 04 00 ff 01 04 01 00     ................
     8d8:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     8e8:	00 06 00 00 fc 00 00 01 00 01 00 01 fc 01 00 00     ................
     8f8:	00 00 00 00 00 00 00 00 00 00 05 0c 00 70 00 80     .............p..
     908:	01 70 00 0c 00 00 00 00 00 00 00 00 00 00 00 00     .p..............
     918:	00 00 00 09 0c 00 70 00 80 01 70 00 0c 00 70 00     ......p...p...p.
     928:	80 01 70 00 0c 00 00 00 00 00 00 00 05 04 01 d8     ..p.............
     938:	00 20 00 d8 00 04 01 00 00 00 00 00 00 00 00 00     . ..............
     948:	00 00 00 00 00 05 0c 00 70 04 80 03 70 00 0c 00     ........p...p...
     958:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 05 04     ................
     968:	01 c4 01 24 01 1c 01 04 01 00 00 00 00 00 00 00     ...$............
     978:	00 00 00 00 00 00 00 03 20 00 de 03 01 04 00 00     ........ .......
     988:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     998:	02 00 00 ff 07 00 00 00 00 00 00 00 00 00 00 00     ................
     9a8:	00 00 00 00 00 00 00 00 00 04 00 00 01 04 de 03     ................
     9b8:	20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00      ...............
     9c8:	00 00 05 00 00 0e 00 11 00 11 00 0e 00 00 00 00     ................
     9d8:	00 00 00 00 00 00 00 00 00 00 00 03 fe 03 02 02     ................
     9e8:	fe 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     9f8:	00 00 00 00                                         ....

000009fc <Arial24x23>:
     9fc:	49 18 17 03 0d 00 00 00 00 00 00 00 00 00 00 00     I...............
     a0c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     a1c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     a2c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     a3c:	00 00 00 00 00 00 00 00 00 00 00 00 00 0a 00 00     ................
     a4c:	00 00 00 00 00 00 02 00 00 03 00 30 01 00 0f 00     ...........0....
     a5c:	e0 03 00 7c 00 00 1e 00 00 02 00 00 00 00 00 00     ...|............
     a6c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     a7c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     a8c:	00 00 00 00 00 00 0d 00 00 00 00 00 00 00 00 00     ................
     a9c:	00 00 00 00 00 00 40 00 00 7c 00 00 0e 00 00 02     ......@..|......
     aac:	00 00 40 00 00 7c 00 00 0e 00 00 02 00 00 00 00     ..@..|..........
     abc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     acc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11     ................
     adc:	00 00 00 00 00 02 00 98 03 80 f8 01 c0 78 00 c0     .............x..
     aec:	1e 00 c0 1f 02 e0 99 03 f8 f8 01 de 78 00 c6 1e     ............x...
     afc:	00 c2 1f 00 e0 19 00 f8 18 00 de 00 00 c6 00 00     ................
     b0c:	02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     b1c:	00 00 00 00 00 00 00 00 10 00 00 00 00 00 00 00     ................
     b2c:	00 00 00 f0 01 00 f0 03 e0 80 0b f8 01 07 9c c3     ................
     b3c:	03 0c 3b 03 06 87 01 e6 87 01 1e c6 00 07 7e 00     ..;...........~.
     b4c:	0e 3c 00 3e 00 00 3c 00 00 00 00 00 00 00 00 00     .<.>..<.........
     b5c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     b6c:	00 16 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     b7c:	04 00 00 04 e0 01 06 f8 83 03 1c c2 01 06 62 00     ..............b.
     b8c:	82 31 00 e2 18 00 7e 0c 00 1c c6 03 80 f3 07 c0     .1....~.........
     b9c:	39 04 60 0c 04 30 04 03 18 e4 01 0c fc 00 06 10     9.`..0..........
     bac:	00 02 00 00 00 00 00 00 00 00 11 00 00 00 00 00     ................
     bbc:	00 00 c0 00 00 f0 01 00 f8 03 00 0c 03 00 06 03     ................
     bcc:	60 02 03 f8 03 03 dc 87 01 8c 8f 01 c6 fc 00 c6     `...............
     bdc:	f0 00 6e f0 03 3e 98 01 1c 0c 01 00 04 00 00 00     ..n..>..........
     bec:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     bfc:	00 00 00 09 00 00 00 00 00 00 00 00 00 00 00 00     ................
     c0c:	00 00 00 40 00 00 7c 00 00 0e 00 00 02 00 00 00     ...@..|.........
     c1c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     c2c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     c3c:	00 00 00 00 00 00 00 00 00 00 00 00 17 00 00 00     ................
     c4c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     c5c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     c6c:	00 00 00 00 00 00 00 00 f8 1f 00 1f 3c 80 03 10     ............<...
     c7c:	e0 00 00 30 00 00 18 00 00 0c 00 00 06 00 00 03     ...0............
     c8c:	00 00 00 00 00 09 00 00 18 00 00 0c 00 00 06 00     ................
     c9c:	00 03 00 c0 01 02 f0 00 0f 3e 00 fe 0f 00 60 00     .........>....`.
     cac:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     cbc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     ccc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 0e 00     ................
     cdc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 90 00     ................
     cec:	00 d8 00 00 58 00 00 30 00 00 3c 00 00 fe 00 00     ....X..0..<.....
     cfc:	52 00 00 18 00 00 08 00 00 00 00 00 00 00 00 00     R...............
     d0c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     d1c:	00 00 00 00 00 00 00 10 00 00 00 00 00 00 00 00     ................
     d2c:	00 00 04 00 00 06 00 00 06 00 00 06 00 00 c6 00     ................
     d3c:	00 fe 00 00 3f 00 e0 07 00 f0 06 00 10 06 00 00     ....?...........
     d4c:	06 00 00 06 00 00 06 00 00 00 00 00 00 00 00 00     ................
     d5c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     d6c:	05 00 00 00 00 00 10 00 00 0a 00 00 07 00 00 01     ................
     d7c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     d8c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     d9c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     dac:	00 00 00 00 00 00 00 00 00 09 00 00 00 00 00 00     ................
     dbc:	00 00 00 00 18 00 00 18 00 00 18 00 00 18 00 00     ................
     dcc:	18 00 00 18 00 00 00 00 00 00 00 00 00 00 00 00     ................
     ddc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     dec:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     dfc:	00 00 05 00 00 00 00 00 00 00 00 02 00 00 03 00     ................
     e0c:	00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     e1c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     e2c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     e3c:	00 00 00 00 00 00 00 00 00 00 00 0d 00 00 02 00     ................
     e4c:	00 03 00 c0 01 00 f0 00 00 38 00 00 0e 00 00 07     .........8......
     e5c:	00 c0 01 00 e0 00 00 38 00 00 1e 00 00 06 00 00     .......8........
     e6c:	02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     e7c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     e8c:	00 00 00 00 11 00 00 00 00 00 00 00 00 00 00 f8     ................
     e9c:	01 00 ff 03 c0 87 03 f0 00 03 38 00 03 0c 00 03     ..........8.....
     eac:	0c 80 01 06 c0 01 06 e0 00 06 38 00 8e 1f 00 fc     ..........8.....
     ebc:	07 00 78 00 00 00 00 00 00 00 00 00 00 00 00 00     ..x.............
     ecc:	00 00 00 00 00 00 00 00 00 00 00 00 00 11 00 00     ................
     edc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     eec:	00 00 00 60 00 02 20 c0 03 30 f8 01 10 3f 00 e8     ...`.. ..0...?..
     efc:	07 00 fc 00 00 1e 00 00 02 00 00 00 00 00 00 00     ................
     f0c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     f1c:	00 00 00 00 00 00 11 00 00 00 00 00 02 00 00 03     ................
     f2c:	00 80 03 00 c0 03 20 60 03 30 30 03 18 30 03 0c     ...... `.00..0..
     f3c:	18 03 04 0c 03 06 0c 03 06 06 03 06 03 01 86 01     ................
     f4c:	00 fe 00 00 7c 00 00 00 00 00 00 00 00 00 00 00     ....|...........
     f5c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11     ................
     f6c:	00 00 00 00 00 00 00 40 00 00 e0 01 00 e0 03 20     .......@....... 
     f7c:	00 03 30 00 03 18 00 03 0c 03 03 06 03 01 06 83     ..0.............
     f8c:	01 86 e7 00 86 7e 00 fe 1c 00 7c 00 00 10 00 00     .....~....|.....
     f9c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     fac:	00 00 00 00 00 00 00 00 11 00 00 00 00 20 00 00     ............. ..
     fbc:	30 00 00 38 00 00 3c 00 00 36 00 00 33 00 80 31     0..8..<..6..3..1
     fcc:	00 c0 30 02 60 f0 03 30 f8 01 18 3f 00 ec 37 00     ..0.`..0...?..7.
     fdc:	fc 30 00 1e 00 00 02 00 00 00 00 00 00 00 00 00     .0..............
     fec:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     ffc:	00 11 00 00 00 00 00 00 00 40 00 00 e0 01 00 e1     .........@......
    100c:	03 c0 01 03 f0 01 03 be 00 03 ce 00 03 c6 80 01     ................
    101c:	c6 c0 01 c6 e1 00 c6 7f 00 86 1f 00 06 02 00 06     ................
    102c:	00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    103c:	00 00 00 00 00 00 00 00 00 00 11 00 00 00 00 00     ................
    104c:	00 00 00 00 00 f8 01 00 ff 01 c0 87 03 f0 02 03     ................
    105c:	38 03 03 9c 01 03 8c 81 01 86 81 01 86 e3 00 86     8...............
    106c:	7f 00 06 1f 00 1e 00 00 1c 00 00 18 00 00 00 00     ................
    107c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    108c:	00 00 00 11 00 00 00 00 00 00 00 00 00 00 00 02     ................
    109c:	00 80 03 00 e0 01 04 70 00 06 3c 00 06 0e 00 06     .......p..<.....
    10ac:	07 00 86 01 00 c6 00 00 66 00 00 36 00 00 1e 00     ........f..6....
    10bc:	00 0e 00 00 06 00 00 02 00 00 00 00 00 00 00 00     ................
    10cc:	00 00 00 00 00 00 00 00 00 00 00 00 11 00 00 00     ................
    10dc:	00 00 00 00 c0 00 00 f8 01 00 fc 03 00 0c 03 e0     ................
    10ec:	06 03 f8 03 03 9c 03 03 0c 83 01 06 83 01 06 e7     ................
    10fc:	00 86 7f 00 fe 3c 00 7c 00 00 08 00 00 00 00 00     .....<.|........
    110c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    111c:	00 00 00 00 00 11 00 00 00 00 00 00 00 c0 01 00     ................
    112c:	c0 01 00 81 03 e0 07 03 f0 0f 03 18 0c 03 0c 0c     ................
    113c:	03 0c 8c 01 06 c4 00 06 66 00 06 3a 00 8e 1f 00     ........f..:....
    114c:	fc 07 00 f8 00 00 00 00 00 00 00 00 00 00 00 00     ................
    115c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 0a 00     ................
    116c:	00 00 00 00 00 00 00 02 00 00 03 00 00 01 80 00     ................
    117c:	00 c0 00 00 c0 00 00 00 00 00 00 00 00 00 00 00     ................
    118c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    119c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    11ac:	00 00 00 00 00 00 00 08 00 00 00 00 00 10 00 00     ................
    11bc:	0a 00 00 07 00 00 01 80 00 00 c0 00 00 c0 00 00     ................
    11cc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    11dc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    11ec:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    11fc:	11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    120c:	00 07 00 00 0f 00 00 0d 00 80 1d 00 80 19 00 c0     ................
    121c:	38 00 c0 30 00 40 70 00 60 20 00 60 00 00 30 00     8..0.@p.` .`..0.
    122c:	00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    123c:	00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00     ................
    124c:	00 00 00 00 00 00 00 18 00 80 18 00 c0 18 00 c0     ................
    125c:	18 00 c0 18 00 c0 18 00 c0 18 00 c0 18 00 c0 18     ................
    126c:	00 c0 18 00 c0 00 00 c0 00 00 00 00 00 00 00 00     ................
    127c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    128c:	00 00 0f 00 00 00 00 00 00 00 00 00 00 40 00 00     .............@..
    129c:	20 00 00 30 00 20 30 00 70 18 00 60 18 00 e0 18      ..0. 0.p..`....
    12ac:	00 c0 0c 00 c0 0d 00 80 05 00 80 07 00 00 07 00     ................
    12bc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    12cc:	00 00 00 00 00 00 00 00 00 00 00 10 00 00 00 00     ................
    12dc:	00 00 00 00 00 00 00 00 00 00 00 20 00 02 30 20     ........... ..0 
    12ec:	03 18 38 01 0c 3c 00 04 0c 00 06 06 00 06 03 00     ..8..<..........
    12fc:	06 01 00 86 01 00 fe 00 00 7c 00 00 00 00 00 00     .........|......
    130c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    131c:	00 00 00 00 17 00 c0 03 00 f8 0f 00 3e 1e 00 07     ............>...
    132c:	38 80 01 30 c0 c0 70 60 f8 71 30 bc 63 18 06 63     8..0..p`.q0.c..c
    133c:	18 03 63 8c 01 61 8c 81 61 c4 80 60 c6 c0 63 c6     ..c..a..a..`..c.
    134c:	e0 63 c6 79 33 86 1f 33 86 87 11 c6 81 18 ce c0     .c.y3..3........
    135c:	08 0c 70 0c fc 3f 04 f0 0f 00 00 00 00 0f 00 00     ..p..?..........
    136c:	02 00 00 03 00 c0 01 00 e0 00 00 38 00 00 1c 00     ...........8....
    137c:	00 1e 00 80 1b 00 c0 19 00 60 18 00 38 18 00 1c     .........`..8...
    138c:	18 00 06 18 00 fe ff 03 fe ff 03 00 00 00 00 00     ................
    139c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    13ac:	00 00 00 00 00 00 10 00 00 00 00 00 02 00 c0 03     ................
    13bc:	00 f8 03 00 3f 03 e0 07 03 fc 03 03 1e 03 03 06     ....?...........
    13cc:	03 03 06 03 03 06 03 01 06 83 01 06 c7 00 86 7e     ...............~
    13dc:	00 fe 3c 00 3c 00 00 00 00 00 00 00 00 00 00 00     ..<.<...........
    13ec:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11     ................
    13fc:	00 00 00 00 78 00 00 ff 01 c0 c7 01 e0 80 03 30     ....x..........0
    140c:	00 03 18 00 03 0c 00 03 0c 00 03 06 80 01 06 80     ................
    141c:	01 06 c0 00 06 e0 00 06 30 00 1e 10 00 7c 00 00     ........0....|..
    142c:	78 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     x...............
    143c:	00 00 00 00 00 00 00 00 12 00 00 00 00 00 02 00     ................
    144c:	c0 03 00 f8 03 00 3f 03 e0 07 03 fc 00 03 1e 00     ......?.........
    145c:	03 06 00 03 06 00 03 06 80 01 06 80 01 06 c0 00     ................
    146c:	06 60 00 0e 38 00 9e 1f 00 fc 07 00 70 00 00 00     .`..8.......p...
    147c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    148c:	00 14 00 00 00 00 00 00 00 00 02 00 c0 03 00 f8     ................
    149c:	03 00 3f 03 e0 07 03 fc 03 03 1e 03 03 06 03 03     ..?.............
    14ac:	06 03 03 06 03 03 06 03 03 06 03 03 06 03 01 06     ................
    14bc:	03 00 06 00 00 06 00 00 06 00 00 02 00 00 00 00     ................
    14cc:	00 00 00 00 00 00 00 00 00 00 13 00 00 00 00 00     ................
    14dc:	00 00 00 02 00 c0 03 00 f8 01 00 3f 00 e0 07 00     ...........?....
    14ec:	fc 03 00 1e 03 00 06 03 00 06 03 00 06 03 00 06     ................
    14fc:	03 00 06 03 00 06 03 00 06 00 00 06 00 00 06 00     ................
    150c:	00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    151c:	00 00 00 14 00 00 00 00 00 00 00 38 00 00 ff 00     ...........8....
    152c:	c0 e7 01 e0 80 01 30 80 03 18 00 03 18 00 03 0c     ......0.........
    153c:	00 03 0c 00 03 06 04 03 06 86 01 06 86 01 06 86     ................
    154c:	01 06 c6 00 0e fe 00 1e 3e 00 7c 06 00 78 00 00     ........>.|..x..
    155c:	00 00 00 00 00 00 00 00 00 00 00 00 14 00 00 00     ................
    156c:	00 00 00 00 00 02 00 c0 03 00 f8 01 00 3f 00 e0     .............?..
    157c:	07 00 fc 03 00 1e 03 00 02 03 00 00 03 00 00 03     ................
    158c:	00 00 03 02 00 c3 03 00 fb 01 00 3f 00 e0 07 00     ...........?....
    159c:	fc 00 00 1e 00 00 02 00 00 00 00 00 00 00 00 00     ................
    15ac:	00 00 00 00 00 0a 00 00 00 00 00 00 00 00 02 00     ................
    15bc:	c0 03 00 f8 01 00 3f 00 e0 07 00 fc 00 00 1e 00     ......?.........
    15cc:	00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    15dc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    15ec:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 0f 00     ................
    15fc:	00 00 00 00 00 00 c0 01 00 e0 03 00 a0 03 00 00     ................
    160c:	03 00 00 03 00 80 01 00 c0 01 00 78 00 00 1f 00     ...........x....
    161c:	e0 07 00 fc 00 00 1e 00 00 02 00 00 00 00 00 00     ................
    162c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    163c:	00 00 00 00 00 00 00 15 00 00 00 00 00 00 00 00     ................
    164c:	02 00 c0 03 00 f8 01 00 3f 00 e0 0f 00 fc 0c 00     ........?.......
    165c:	1e 06 00 02 03 00 80 0f 00 80 1d 00 c0 78 00 60     .............x.`
    166c:	e0 01 30 80 03 10 00 02 18 00 00 0c 00 00 06 00     ..0.............
    167c:	00 02 00 00 02 00 00 00 00 00 00 00 00 00 00 00     ................
    168c:	0d 00 00 00 00 00 00 00 00 02 00 c0 03 00 f8 03     ................
    169c:	00 3f 03 e0 07 03 fc 00 03 1e 00 03 02 00 03 00     .?..............
    16ac:	00 03 00 00 03 00 00 01 00 00 00 00 00 00 00 00     ................
    16bc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    16cc:	00 00 00 00 00 00 00 00 00 17 00 00 00 00 00 00     ................
    16dc:	00 00 02 00 c0 03 00 f8 01 00 3f 00 e0 07 00 fc     ..........?.....
    16ec:	00 00 1e f0 03 fe ff 03 fe 8f 03 00 c0 01 00 70     ...............p
    16fc:	00 00 38 00 00 0e 00 80 07 02 c0 c1 03 70 f8 01     ..8..........p..
    170c:	38 3f 00 ee 07 00 fe 00 00 1e 00 00 02 00 00 00     8?..............
    171c:	00 00 14 00 00 00 00 00 00 00 00 02 00 c0 03 00     ................
    172c:	f8 01 00 3f 00 e0 07 00 fc 00 00 1e 00 00 fe 00     ...?............
    173c:	00 f8 0f 00 00 ff 01 00 f0 03 00 c0 03 00 f8 01     ................
    174c:	00 3f 00 e0 07 00 fc 00 00 1e 00 00 02 00 00 00     .?..............
    175c:	00 00 00 00 00 00 00 00 00 00 00 14 00 00 00 00     ................
    176c:	00 00 00 38 00 00 ff 00 c0 c3 01 e0 80 03 30 00     ...8..........0.
    177c:	03 18 00 03 0c 00 03 0c 00 03 04 00 03 06 80 01     ................
    178c:	06 80 01 06 c0 00 06 c0 00 06 70 00 0e 38 00 3c     ..........p..8.<
    179c:	0e 00 f8 07 00 e0 01 00 00 00 00 00 00 00 00 00     ................
    17ac:	00 00 00 00 12 00 00 00 00 00 00 00 00 02 00 c0     ................
    17bc:	03 00 f8 01 00 3f 00 e0 07 00 fc 06 00 1e 06 00     .....?..........
    17cc:	06 06 00 06 06 00 06 06 00 06 06 00 06 06 00 06     ................
    17dc:	03 00 86 03 00 fe 01 00 7c 00 00 00 00 00 00 00     ........|.......
    17ec:	00 00 00 00 00 00 00 00 00 00 00 00 00 14 00 00     ................
    17fc:	00 00 00 00 00 38 00 00 ff 00 c0 e7 01 e0 80 03     .....8..........
    180c:	30 00 03 18 00 03 0c 00 03 0c 40 03 04 60 03 06     0.........@..`..
    181c:	c0 01 06 c0 01 06 c0 03 06 60 07 06 70 02 0e 38     .........`..p..8
    182c:	00 3c 0e 00 f8 07 00 e0 01 00 00 00 00 00 00 00     .<..............
    183c:	00 00 00 00 00 00 13 00 00 00 00 00 00 00 00 02     ................
    184c:	00 c0 03 00 f8 01 00 3f 00 e0 07 00 fc 03 00 1e     .......?........
    185c:	03 00 06 03 00 06 03 00 06 03 00 06 0f 00 06 7f     ................
    186c:	00 06 fb 03 86 81 03 86 01 00 fe 00 00 7c 00 00     .............|..
    187c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 10     ................
    188c:	00 00 00 00 00 00 00 f0 01 00 f0 01 00 80 03 e0     ................
    189c:	00 03 f8 01 03 9c 03 03 0c 03 03 06 03 03 06 83     ................
    18ac:	01 06 87 01 06 c6 00 06 7e 00 3e 3c 00 3c 00 00     ........~.><.<..
    18bc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    18cc:	00 00 00 00 00 00 00 00 11 00 00 00 00 00 00 04     ................
    18dc:	00 00 06 00 02 06 c0 03 06 f8 01 06 3f 00 e6 07     ............?...
    18ec:	00 fe 00 00 1e 00 00 06 00 00 06 00 00 06 00 00     ................
    18fc:	06 00 00 06 00 00 06 00 00 02 00 00 00 00 00 00     ................
    190c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    191c:	00 12 00 00 00 00 00 00 00 f8 01 00 ff 03 e0 07     ................
    192c:	03 fc 00 03 1e 00 03 02 00 03 00 00 03 00 00 03     ................
    193c:	00 80 01 00 e0 00 00 78 00 00 1f 00 e0 07 00 fc     .......x........
    194c:	00 00 1e 00 00 02 00 00 00 00 00 00 00 00 00 00     ................
    195c:	00 00 00 00 00 00 00 00 00 00 11 00 00 00 00 00     ................
    196c:	00 fe ff 03 fe ff 03 00 00 03 00 c0 01 00 e0 00     ................
    197c:	00 38 00 00 1c 00 00 07 00 80 03 00 c0 01 00 70     .8.............p
    198c:	00 00 38 00 00 0e 00 00 06 00 00 02 00 00 00 00     ..8.............
    199c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    19ac:	00 00 00 18 00 00 00 00 00 00 00 e0 03 f0 ff 03     ................
    19bc:	fe ff 03 0e c0 01 00 70 00 00 38 00 00 0e 00 00     .......p..8.....
    19cc:	07 00 c0 01 00 e0 00 00 38 00 00 1c c0 03 fe ff     ........8.......
    19dc:	03 fe bf 03 1e c0 01 00 70 00 00 38 00 00 0e 00     ........p..8....
    19ec:	80 07 00 e0 01 00 78 00 00 1e 00 00 16 00 00 02     ......x.........
    19fc:	00 00 02 00 00 03 00 80 01 00 c0 00 00 60 00 00     .............`..
    1a0c:	30 00 06 38 00 1e 18 00 fc 0c 00 e0 07 00 80 1f     0..8............
    1a1c:	00 80 7d 00 c0 f0 01 60 c0 03 30 00 02 30 00 00     ..}....`..0..0..
    1a2c:	18 00 00 0c 00 00 06 00 00 02 00 00 02 00 00 00     ................
    1a3c:	00 00 00 00 00 12 00 00 00 00 00 00 06 00 00 3e     ...............>
    1a4c:	00 02 f8 c0 03 e0 fb 01 80 3f 00 00 06 00 00 03     .........?......
    1a5c:	00 80 01 00 c0 00 00 60 00 00 30 00 00 18 00 00     .......`..0.....
    1a6c:	0c 00 00 06 00 00 02 00 00 02 00 00 00 00 00 00     ................
    1a7c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 14 00     ................
    1a8c:	00 02 00 80 03 00 c0 03 00 60 03 00 60 03 00 30     .........`..`..0
    1a9c:	03 04 18 03 06 0c 03 06 0c 03 06 06 03 06 03 03     ................
    1aac:	86 01 03 86 01 03 c6 00 03 66 00 01 36 00 00 36     .........f..6..6
    1abc:	00 00 1e 00 00 0e 00 00 02 00 00 00 00 00 00 00     ................
    1acc:	00 00 00 00 00 00 00 0c 00 00 78 00 00 7e 00 c0     ..........x..~..
    1adc:	67 00 f8 61 00 3f 20 e0 07 00 fc 00 00 1e 00 00     g..a.? .........
    1aec:	06 00 00 06 00 00 06 00 00 02 00 00 00 00 00 00     ................
    1afc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1b0c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1b1c:	08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1b2c:	80 ff 03 fe ff 03 7e 00 00 00 00 00 00 00 00 00     ......~.........
    1b3c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1b4c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1b5c:	00 00 00 00 00 00 00 00 00 0b 00 00 60 00 00 60     ............`..`
    1b6c:	00 00 78 00 00 3e 00 c0 07 04 f8 01 06 3f 00 e6     ..x..>.......?..
    1b7c:	07 00 fe 00 00 1e 00 00 02 00 00 00 00 00 00 00     ................
    1b8c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1b9c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1bac:	00 00 0d 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1bbc:	02 00 80 03 00 c0 01 00 60 00 00 38 00 00 1c 00     ........`..8....
    1bcc:	00 0e 00 00 fe 03 00 fc 03 00 00 00 00 00 00 00     ................
    1bdc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1bec:	00 00 00 00 00 00 00 00 00 00 00 15 00 00 60 00     ..............`.
    1bfc:	00 60 00 00 60 00 00 60 00 00 60 00 00 60 00 00     .`..`..`..`..`..
    1c0c:	60 00 00 60 00 00 60 00 00 60 00 00 60 00 00 60     `..`..`..`..`..`
    1c1c:	00 00 60 00 00 60 00 00 60 00 00 60 00 00 60 00     ..`..`..`..`..`.
    1c2c:	00 60 00 00 60 00 00 60 00 00 20 00 00 00 00 00     .`..`..`.. .....
    1c3c:	00 00 00 00 0a 00 00 00 00 00 00 00 00 00 00 00     ................
    1c4c:	00 00 00 00 00 00 00 00 00 00 06 00 00 0e 00 00     ................
    1c5c:	0e 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1c6c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1c7c:	00 00 00 00 00 00 00 00 00 00 00 00 00 0e 00 00     ................
    1c8c:	00 00 00 00 00 c0 01 00 f0 03 00 32 03 00 1b 03     ...........2....
    1c9c:	80 19 03 c0 18 01 c0 98 01 c0 8c 00 c0 ec 03 c0     ................
    1cac:	fc 03 c0 3f 00 80 07 00 00 00 00 00 00 00 00 00     ...?............
    1cbc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1ccc:	00 00 00 00 00 00 0d 00 00 00 00 00 02 00 c0 03     ................
    1cdc:	00 f8 01 00 bf 01 e0 07 03 fc 01 03 9e 01 03 c2     ................
    1cec:	00 01 c0 80 01 c0 c0 00 c0 79 00 80 1f 00 00 00     .........y......
    1cfc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1d0c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0c     ................
    1d1c:	00 00 00 00 00 00 00 f8 01 00 fe 03 00 07 03 80     ................
    1d2c:	01 03 80 00 03 c0 80 01 c0 c0 01 c0 41 00 c0 03     ............A...
    1d3c:	00 80 03 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1d4c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1d5c:	00 00 00 00 00 00 00 00 10 00 00 00 00 00 00 00     ................
    1d6c:	f8 01 00 de 03 00 03 03 80 01 03 80 00 03 c0 80     ................
    1d7c:	01 c0 80 02 c0 e0 03 c0 ff 01 00 3f 00 e0 07 00     ...........?....
    1d8c:	fc 00 00 1e 00 00 02 00 00 00 00 00 00 00 00 00     ................
    1d9c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1dac:	00 0d 00 00 00 00 00 00 00 f8 01 00 fe 03 00 0f     ................
    1dbc:	03 80 0d 03 80 0c 03 c0 0c 03 c0 8c 01 c0 cc 00     ................
    1dcc:	c0 4d 00 80 0f 00 00 03 00 00 00 00 00 00 00 00     .M..............
    1ddc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1dec:	00 00 00 00 00 00 00 00 00 00 0e 00 00 00 00 00     ................
    1dfc:	00 00 00 02 80 c0 03 c0 f8 01 c0 3f 00 e0 07 00     ...........?....
    1e0c:	f8 00 00 dc 00 00 c6 00 00 c6 00 00 06 00 00 06     ................
    1e1c:	00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1e2c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1e3c:	00 00 00 0f 00 00 10 00 00 38 00 00 78 00 f8 61     .........8..x..a
    1e4c:	00 fe 63 00 07 63 80 01 63 80 01 33 c0 00 39 c0     ..c..c..c..3..9.
    1e5c:	80 1e c0 e0 07 80 fd 01 00 3f 00 c0 07 00 c0 00     .........?......
    1e6c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1e7c:	00 00 00 00 00 00 00 00 00 00 00 00 0e 00 00 00     ................
    1e8c:	00 00 02 00 c0 03 00 f8 01 00 3f 00 e0 07 00 fc     ..........?.....
    1e9c:	01 00 9e 01 00 c2 00 00 c0 00 02 c0 c0 03 c0 f9     ................
    1eac:	01 c0 3f 00 80 07 00 00 00 00 00 00 00 00 00 00     ..?.............
    1ebc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1ecc:	00 00 00 00 00 09 00 00 00 00 00 02 00 c0 03 00     ................
    1edc:	f8 01 00 3f 00 c0 07 00 c4 00 00 06 00 00 02 00     ...?............
    1eec:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1efc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1f0c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 09 00     ................
    1f1c:	00 38 00 00 1e 00 c0 07 00 f8 01 00 3f 00 c0 07     .8..........?...
    1f2c:	00 c4 00 00 06 00 00 02 00 00 00 00 00 00 00 00     ................
    1f3c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1f4c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1f5c:	00 00 00 00 00 00 00 0f 00 00 00 00 00 02 00 c0     ................
    1f6c:	03 00 f8 01 00 3f 00 e0 1f 00 fc 18 00 1e 3c 00     .....?........<.
    1f7c:	02 e6 01 00 c2 03 00 03 02 80 01 00 c0 00 00 40     ...............@
    1f8c:	00 00 40 00 00 00 00 00 00 00 00 00 00 00 00 00     ..@.............
    1f9c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1fac:	09 00 00 00 00 00 02 00 c0 03 00 f8 01 00 3f 00     ..............?.
    1fbc:	e0 07 00 fc 00 00 1e 00 00 02 00 00 00 00 00 00     ................
    1fcc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1fdc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1fec:	00 00 00 00 00 00 00 00 00 14 00 00 00 00 00 02     ................
    1ffc:	00 c0 03 00 f8 01 00 3f 00 c0 07 00 c0 01 00 80     .......?........
    200c:	00 00 c0 00 02 c0 c0 03 c0 f8 01 c0 3f 00 80 07     ............?...
    201c:	00 80 01 00 80 00 00 c0 00 02 c0 c0 03 c0 f8 01     ................
    202c:	c0 3f 00 80 07 00 00 00 00 00 00 00 00 00 00 00     .?..............
    203c:	00 00 0e 00 00 00 00 00 02 00 c0 03 00 f8 01 00     ................
    204c:	3f 00 c0 07 00 c0 01 00 80 01 00 c0 00 00 c0 00     ?...............
    205c:	02 c0 c0 03 c0 f9 01 c0 3f 00 80 07 00 00 00 00     ........?.......
    206c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    207c:	00 00 00 00 00 00 00 00 00 00 00 0e 00 00 00 00     ................
    208c:	00 00 00 00 00 00 f8 01 00 de 03 00 03 03 80 01     ................
    209c:	03 80 00 03 c0 00 01 c0 80 01 c0 c0 00 c0 79 00     ..............y.
    20ac:	80 1f 00 00 07 00 00 00 00 00 00 00 00 00 00 00     ................
    20bc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    20cc:	00 00 00 00 0e 00 00 78 00 00 3e 00 c0 07 00 f8     .......x..>.....
    20dc:	01 00 ff 03 c0 07 03 c0 01 03 80 00 03 c0 00 01     ................
    20ec:	c0 80 01 c0 e0 00 c0 7f 00 80 1f 00 00 03 00 00     ................
    20fc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    210c:	00 00 00 00 00 00 00 00 00 00 00 00 00 0e 00 00     ................
    211c:	00 00 00 00 00 f8 01 00 fe 03 00 07 03 80 01 03     ................
    212c:	80 00 43 c0 00 71 c0 80 3e c0 e0 07 80 ff 01 00     ..C..q..>.......
    213c:	3f 00 c0 07 00 c0 00 00 00 00 00 00 00 00 00 00     ?...............
    214c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    215c:	00 00 00 00 00 00 0c 00 00 00 00 00 02 00 c0 03     ................
    216c:	00 f8 01 00 3f 00 c0 07 00 c0 01 00 80 00 00 c0     ....?...........
    217c:	00 00 c0 00 00 c0 00 00 40 00 00 00 00 00 00 00     ........@.......
    218c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    219c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     ................
    21ac:	00 00 00 00 00 00 00 c0 01 00 c0 03 00 8f 03 80     ................
    21bc:	0f 03 80 1d 03 c0 18 03 c0 98 01 c0 f8 01 c0 f1     ................
    21cc:	00 c0 03 00 80 03 00 00 00 00 00 00 00 00 00 00     ................
    21dc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    21ec:	00 00 00 00 00 00 00 00 0a 00 00 00 00 00 00 80     ................
    21fc:	c0 03 c0 f8 03 c0 3f 03 e0 07 03 f8 00 00 dc 00     ......?.........
    220c:	00 c0 00 00 c0 00 00 00 00 00 00 00 00 00 00 00     ................
    221c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    222c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    223c:	00 0f 00 00 00 00 00 00 00 c0 01 00 f8 03 00 bf     ................
    224c:	03 c0 07 03 c0 00 03 00 00 01 00 80 01 00 80 02     ................
    225c:	00 e0 03 00 f8 01 00 3f 00 c0 07 00 c0 00 00 00     .......?........
    226c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    227c:	00 00 00 00 00 00 00 00 00 00 0d 00 00 00 00 00     ................
    228c:	00 c0 ff 03 c0 ff 03 00 80 03 00 c0 01 00 70 00     ..............p.
    229c:	00 38 00 00 1c 00 00 07 00 80 03 00 c0 00 00 40     .8.............@
    22ac:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    22bc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    22cc:	00 00 00 14 00 00 00 00 00 00 00 f0 03 c0 ff 03     ................
    22dc:	c0 9f 03 00 c0 01 00 70 00 00 38 00 00 0e 00 80     .......p..8.....
    22ec:	07 00 c0 fd 03 c0 ff 03 c0 9f 03 00 c0 01 00 70     ...............p
    22fc:	00 00 3c 00 00 0e 00 80 03 00 c0 01 00 40 00 00     ..<..........@..
    230c:	00 00 00 00 00 00 00 00 00 00 00 00 10 00 00 02     ................
    231c:	00 00 02 00 00 03 00 80 01 40 c0 00 c0 61 00 c0     .........@...a..
    232c:	37 00 00 1f 00 00 78 00 00 ec 03 00 86 03 00 03     7.....x.........
    233c:	02 80 01 00 c0 00 00 40 00 00 40 00 00 00 00 00     .......@..@.....
    234c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    235c:	00 00 00 00 00 0f 00 00 60 00 00 60 00 00 60 00     ........`..`..`.
    236c:	00 38 c0 ff 1f c0 ff 07 00 f8 03 00 c0 01 00 70     .8.............p
    237c:	00 00 38 00 00 0e 00 00 07 00 80 03 00 c0 00 00     ..8.............
    238c:	40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     @...............
    239c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 0f 00     ................
    23ac:	00 02 00 00 03 00 80 03 80 c0 03 c0 60 03 c0 20     ............`.. 
    23bc:	03 c0 30 03 c0 18 03 c0 0c 03 c0 04 03 c0 06 03     ..0.............
    23cc:	c0 03 01 c0 01 00 c0 00 00 c0 00 00 00 00 00 00     ................
    23dc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    23ec:	00 00 00 00 00 00 00 18 00 00 00 00 00 00 00 00     ................
    23fc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    240c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    241c:	00 00 00 08 1e 00 fc 3f 00 fe 10 00 03 00 e0 01     .......?........
    242c:	00 78 00 00 0c 00 00 06 00 00 03 00 00 02 00 00     .x..............
    243c:	0a 00 00 40 00 00 78 00 00 3e 00 c0 07 00 f8 01     ...@..x..>......
    244c:	00 3f 00 e0 07 00 fc 00 00 1e 00 00 02 00 00 00     .?..............
    245c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    246c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    247c:	00 00 00 00 00 00 00 00 00 08 00 00 10 00 00 08     ................
    248c:	00 00 0f 00 c0 03 00 70 00 82 1b 00 f7 0f 00 3e     .......p.......>
    249c:	04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    24ac:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    24bc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    24cc:	00 00 0f 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    24dc:	04 00 00 06 00 00 03 00 00 03 00 00 03 00 00 07     ................
    24ec:	00 00 07 00 00 06 00 00 06 00 00 06 00 00 03 00     ................
    24fc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    250c:	00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00     ................
    251c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    252c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    253c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    254c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    255c:	00 00 00 00                                         ....

00002560 <Arial28x28>:
    2560:	69 1a 1c 04 0e 00 00 00 00 00 00 00 00 00 00 00     i...............
    2570:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2580:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2590:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    25a0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    25b0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    25c0:	00 00 00 00 00 00 00 00 00 00 00 00 00 06 00 00     ................
    25d0:	00 00 00 00 00 00 fe 03 1e 00 fe 7f 1e 00 fe 7f     ................
    25e0:	1e 00 fe 03 1e 00 00 00 00 00 00 00 00 00 00 00     ................
    25f0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2600:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2610:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2620:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2630:	00 00 00 00 00 00 0b 00 00 00 00 7e 00 00 00 fe     ...........~....
    2640:	00 00 00 fe 00 00 00 7e 00 00 00 00 00 00 00 00     .......~........
    2650:	00 00 00 7e 00 00 00 fe 00 00 00 fe 00 00 00 7e     ...~...........~
    2660:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2670:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2680:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2690:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0f     ................
    26a0:	c0 e1 00 00 c0 e1 1c 00 c0 e1 1f 00 c0 ff 1f 00     ................
    26b0:	f8 ff 07 00 fe ff 00 00 fe e1 00 00 ce e1 1c 00     ................
    26c0:	c0 e1 1f 00 c0 ff 1f 00 f8 ff 07 00 fe ff 00 00     ................
    26d0:	fe e1 00 00 ce e1 00 00 c0 e1 00 00 00 00 00 00     ................
    26e0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    26f0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2700:	00 00 00 00 00 00 00 00 0e 00 00 00 00 00 00 00     ................
    2710:	00 f0 81 01 00 f8 83 07 00 fc 87 0f 00 1e 0f 1f     ................
    2720:	00 0e 0f 1c 00 ff ff 7f 00 ff ff 7f 00 0e 1e 1c     ................
    2730:	00 1e 3c 1e 00 3c fc 0f 00 38 f8 07 00 30 f0 03     ..<..<...8...0..
    2740:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2750:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2760:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2770:	00 17 00 00 00 00 f8 01 00 00 fc 03 00 00 fe 07     ................
    2780:	00 00 06 06 00 00 06 06 00 00 06 06 30 00 fe 07     ............0...
    2790:	3c 00 fc 03 3f 00 f8 c1 0f 00 00 f0 03 00 00 fc     <...?...........
    27a0:	00 00 00 3f 00 00 e0 0f 00 00 f8 c3 0f 00 fe e0     ...?............
    27b0:	1f 00 3e f0 3f 00 06 30 30 00 00 30 30 00 00 30     ..>.?..00..00..0
    27c0:	30 00 00 f0 3f 00 00 e0 1f 00 00 c0 0f 00 00 00     0...?...........
    27d0:	00 00 00 00 00 00 00 00 00 00 13 00 00 00 00 00     ................
    27e0:	e0 03 00 00 f0 07 00 78 f8 0f 00 fc fd 0f 00 fc     .......x........
    27f0:	3f 1e 00 fe 1f 1c 00 8e 1f 1c 00 0e 3f 1c 00 8e     ?...........?...
    2800:	7f 1e 00 fe ff 1f 00 fc f1 0f 00 fc e1 0f 00 78     ...............x
    2810:	e0 07 00 00 f0 0f 00 00 f0 0f 00 00 70 1e 00 00     ............p...
    2820:	00 0e 00 00 00 04 00 00 00 00 00 00 00 00 00 00     ................
    2830:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2840:	00 00 00 05 00 00 00 00 7e 00 00 00 fe 00 00 00     ........~.......
    2850:	fe 00 00 00 7e 00 00 00 00 00 00 00 00 00 00 00     ....~...........
    2860:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2870:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2880:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2890:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    28a0:	00 00 00 00 00 00 00 00 00 00 00 00 08 00 00 00     ................
    28b0:	00 00 fe 03 00 c0 ff 1f 00 f0 ff 7f 00 fc ff ff     ................
    28c0:	01 fe 00 f8 03 1e 00 c0 03 02 00 00 02 00 00 00     ................
    28d0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    28e0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    28f0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2900:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2910:	00 00 00 00 00 08 00 00 00 00 02 00 00 02 1e 00     ................
    2920:	c0 03 fe 00 f8 03 fc ff ff 01 f0 ff 7f 00 c0 ff     ................
    2930:	1f 00 00 fe 03 00 00 00 00 00 00 00 00 00 00 00     ................
    2940:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2950:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2960:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2970:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 0a 18     ................
    2980:	00 00 00 18 01 00 00 90 03 00 00 f0 01 00 00 7e     ...............~
    2990:	00 00 00 7e 00 00 00 f0 01 00 00 90 03 00 00 18     ...~............
    29a0:	01 00 00 18 00 00 00 00 00 00 00 00 00 00 00 00     ................
    29b0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    29c0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    29d0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    29e0:	00 00 00 00 00 00 00 0f 00 00 00 00 00 1e 00 00     ................
    29f0:	00 1e 00 00 00 1e 00 00 00 1e 00 00 00 1e 00 00     ................
    2a00:	f0 ff 03 00 f0 ff 03 00 f0 ff 03 00 f0 ff 03 00     ................
    2a10:	00 1e 00 00 00 1e 00 00 00 1e 00 00 00 1e 00 00     ................
    2a20:	00 1e 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2a30:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2a40:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2a50:	06 00 00 00 00 00 00 00 00 00 00 9e 00 00 00 de     ................
    2a60:	01 00 00 fe 00 00 00 7e 00 00 00 00 00 00 00 00     .......~........
    2a70:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2a80:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2a90:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2aa0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2ab0:	00 00 00 00 00 00 00 00 00 09 00 00 00 00 00 f0     ................
    2ac0:	00 00 00 f0 00 00 00 f0 00 00 00 f0 00 00 00 f0     ................
    2ad0:	00 00 00 f0 00 00 00 f0 00 00 00 f0 00 00 00 00     ................
    2ae0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2af0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2b00:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2b10:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2b20:	00 00 06 00 00 00 00 00 00 00 00 00 00 1e 00 00     ................
    2b30:	00 1e 00 00 00 1e 00 00 00 1e 00 00 00 00 00 00     ................
    2b40:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2b50:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2b60:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2b70:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2b80:	00 00 00 00 00 00 00 00 00 00 00 08 00 00 18 00     ................
    2b90:	00 80 1f 00 00 f8 1f 00 80 ff 07 00 f8 7f 00 00     ................
    2ba0:	fe 07 00 00 7e 00 00 00 06 00 00 00 00 00 00 00     ....~...........
    2bb0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2bc0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2bd0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2be0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2bf0:	00 00 00 00 0e 00 00 00 00 c0 ff 00 00 f0 ff 03     ................
    2c00:	00 fc ff 0f 00 fc ff 0f 00 3e 00 1f 00 0e 00 1c     .........>......
    2c10:	00 0e 00 1c 00 0e 00 1c 00 3e 00 1f 00 fc ff 0f     .........>......
    2c20:	00 fc ff 0f 00 f0 ff 03 00 c0 ff 00 00 00 00 00     ................
    2c30:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2c40:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2c50:	00 00 00 00 00 00 00 00 00 00 00 00 00 0b 00 00     ................
    2c60:	00 00 00 00 00 00 c0 03 00 00 e0 01 00 00 e0 01     ................
    2c70:	00 00 f0 00 00 00 78 00 00 00 fc ff 1f 00 fe ff     ......x.........
    2c80:	1f 00 fe ff 1f 00 fe ff 1f 00 00 00 00 00 00 00     ................
    2c90:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2ca0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2cb0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2cc0:	00 00 00 00 00 00 0e 00 00 00 00 60 00 18 00 78     ...........`...x
    2cd0:	00 1e 00 7c 80 1f 00 7c c0 1f 00 1e e0 1f 00 0e     ...|...|........
    2ce0:	f0 1d 00 0e f8 1c 00 0e 7c 1c 00 1e 3e 1c 00 fe     ........|...>...
    2cf0:	1f 1c 00 fc 0f 1c 00 f8 07 1c 00 f0 01 1c 00 00     ................
    2d00:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2d10:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2d20:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0e     ................
    2d30:	00 00 00 00 30 80 01 00 38 80 07 00 3c 80 0f 00     ....0...8...<...
    2d40:	3e 80 0f 00 1e 00 1e 00 0e 07 1c 00 0e 07 1c 00     >...............
    2d50:	9e 07 1c 00 fe 0f 1e 00 fc fd 0f 00 f8 fd 0f 00     ................
    2d60:	70 f8 07 00 00 f0 01 00 00 00 00 00 00 00 00 00     p...............
    2d70:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2d80:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2d90:	00 00 00 00 00 00 00 00 0e 00 e0 01 00 00 f0 01     ................
    2da0:	00 00 fc 01 00 00 de 01 00 80 cf 01 00 c0 c3 01     ................
    2db0:	00 f0 c1 01 00 78 c0 01 00 fe ff 1f 00 fe ff 1f     .....x..........
    2dc0:	00 fe ff 1f 00 fe ff 1f 00 00 c0 01 00 00 c0 01     ................
    2dd0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2de0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2df0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2e00:	00 0e 00 00 00 00 00 07 03 00 f8 07 07 00 fe 07     ................
    2e10:	0f 00 fe 07 1f 00 1e 03 1e 00 8e 03 1c 00 8e 03     ................
    2e20:	1c 00 8e 03 1c 00 8e 07 1e 00 8e ff 0f 00 0e ff     ................
    2e30:	0f 00 0e fe 03 00 00 f8 01 00 00 00 00 00 00 00     ................
    2e40:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2e50:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2e60:	00 00 00 00 00 00 00 00 00 00 0e 00 00 00 00 80     ................
    2e70:	ff 00 00 f0 ff 03 00 f8 ff 07 00 fc ff 0f 00 3c     ...............<
    2e80:	0e 1e 00 0e 07 1c 00 0e 07 1c 00 0e 07 1c 00 1e     ................
    2e90:	0f 1e 00 3e ff 0f 00 3c fe 0f 00 38 fc 07 00 30     ...>...<...8...0
    2ea0:	f0 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2eb0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2ec0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2ed0:	00 00 00 0e 00 00 00 00 0e 00 00 00 0e 00 00 00     ................
    2ee0:	0e 00 1e 00 0e e0 1f 00 0e fc 1f 00 0e ff 1f 00     ................
    2ef0:	8e ff 01 00 ee 1f 00 00 fe 07 00 00 fe 01 00 00     ................
    2f00:	7e 00 00 00 3e 00 00 00 1e 00 00 00 00 00 00 00     ~...>...........
    2f10:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2f20:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2f30:	00 00 00 00 00 00 00 00 00 00 00 00 0e 00 00 00     ................
    2f40:	00 f0 e0 03 00 f8 f1 07 00 fc fb 0f 00 fe ff 0f     ................
    2f50:	00 1e 1f 1e 00 0e 0e 1c 00 0e 0e 1c 00 0e 0e 1c     ................
    2f60:	00 1e 1f 1e 00 fe ff 0f 00 fc fb 0f 00 f8 f1 07     ................
    2f70:	00 f0 e0 03 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2f80:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2f90:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2fa0:	00 00 00 00 00 0e 00 00 00 00 e0 03 03 00 f8 0f     ................
    2fb0:	0f 00 fc 1f 0f 00 fc 3f 1f 00 1e 3c 1e 00 0e 38     .......?...<...8
    2fc0:	1c 00 0e 38 1c 00 0e 38 1c 00 1e 1c 0f 00 fc ff     ...8...8........
    2fd0:	0f 00 f8 ff 07 00 f0 ff 03 00 c0 7f 00 00 00 00     ................
    2fe0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2ff0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3000:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 07 00     ................
    3010:	00 00 00 00 00 00 00 00 00 00 00 c0 03 1e 00 c0     ................
    3020:	03 1e 00 c0 03 1e 00 c0 03 1e 00 00 00 00 00 00     ................
    3030:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3040:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3050:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3060:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3070:	00 00 00 00 00 00 00 07 00 00 00 00 00 00 00 00     ................
    3080:	00 00 00 00 c0 03 9e 00 c0 03 de 01 c0 03 fe 00     ................
    3090:	c0 03 7e 00 00 00 00 00 00 00 00 00 00 00 00 00     ..~.............
    30a0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    30b0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    30c0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    30d0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    30e0:	0e 00 00 00 00 00 1c 00 00 00 3e 00 00 00 3e 00     ..........>...>.
    30f0:	00 00 7f 00 00 00 77 00 00 80 f7 00 00 80 e3 00     ......w.........
    3100:	00 c0 e3 01 00 c0 e3 01 00 c0 c1 01 00 e0 c1 03     ................
    3110:	00 e0 c1 03 00 f0 80 07 00 00 00 00 00 00 00 00     ................
    3120:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3130:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3140:	00 00 00 00 00 00 00 00 00 0f 00 00 00 00 c0 f3     ................
    3150:	00 00 c0 f3 00 00 c0 f3 00 00 c0 f3 00 00 c0 f3     ................
    3160:	00 00 c0 f3 00 00 c0 f3 00 00 c0 f3 00 00 c0 f3     ................
    3170:	00 00 c0 f3 00 00 c0 f3 00 00 c0 f3 00 00 c0 f3     ................
    3180:	00 00 c0 f3 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3190:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    31a0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    31b0:	00 00 0e 00 00 00 00 f0 80 07 00 e0 c1 03 00 e0     ................
    31c0:	c1 03 00 c0 c1 01 00 c0 e3 01 00 c0 e3 01 00 80     ................
    31d0:	e3 00 00 80 f7 00 00 00 77 00 00 00 7f 00 00 00     ........w.......
    31e0:	3e 00 00 00 3e 00 00 00 1c 00 00 00 00 00 00 00     >...>...........
    31f0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3200:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3210:	00 00 00 00 00 00 00 00 00 00 00 0f 00 00 00 00     ................
    3220:	60 00 00 00 78 00 00 00 7c 00 00 00 7c 00 00 00     `...x...|...|...
    3230:	3e 00 00 00 0e 70 1e 00 0e 7c 1e 00 0e 7c 1e 00     >....p...|...|..
    3240:	0e 7e 1e 00 1e 1f 00 00 fc 0f 00 00 fc 07 00 00     .~..............
    3250:	f8 03 00 00 f0 01 00 00 00 00 00 00 00 00 00 00     ................
    3260:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3270:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3280:	00 00 00 00 1a 00 00 00 00 00 f8 07 00 00 ff 3f     ...............?
    3290:	00 c0 ff 7f 00 e0 0f f8 01 f0 01 e0 01 78 f0 c3     .............x..
    32a0:	03 38 fe 8f 07 1c ff 1f 07 9c 0f 1e 07 de 03 1c     .8..............
    32b0:	0e ce 01 1c 0e ce 01 0e 0e ce 83 0f 0e 8e ff 1f     ................
    32c0:	0e ce ff 1f 0e ce ff 1f 0e de 3f 1c 0e dc 01 1c     ..........?.....
    32d0:	0f 3c 00 0e 07 78 00 8f 07 f8 c1 c7 03 f0 ff e3     .<...x..........
    32e0:	03 c0 ff e1 01 00 3f e0 00 00 00 20 00 13 00 00     ......?.... ....
    32f0:	10 00 00 00 1e 00 00 c0 1f 00 00 f8 1f 00 00 ff     ................
    3300:	0f 00 e0 ff 01 00 fc ff 00 00 fe e7 00 00 fe e0     ................
    3310:	00 00 1e e0 00 00 fe e0 00 00 fe e7 00 00 fc ff     ................
    3320:	00 00 e0 ff 01 00 00 ff 0f 00 00 f8 1f 00 00 c0     ................
    3330:	1f 00 00 00 1e 00 00 00 10 00 00 00 00 00 00 00     ................
    3340:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3350:	00 00 00 00 00 00 13 00 00 00 00 00 00 00 00 fe     ................
    3360:	ff 1f 00 fe ff 1f 00 fe ff 1f 00 fe ff 1f 00 1e     ................
    3370:	1e 1e 00 1e 1e 1e 00 1e 1e 1e 00 1e 1e 1e 00 1e     ................
    3380:	1e 1e 00 1e 1e 1e 00 1e 1e 1e 00 3e 1f 1e 00 fe     ...........>....
    3390:	3f 1f 00 fc ff 1f 00 f8 fb 0f 00 f0 f0 07 00 00     ?...............
    33a0:	e0 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    33b0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 13     ................
    33c0:	00 00 00 00 80 7f 00 00 e0 ff 01 00 f0 ff 03 00     ................
    33d0:	f8 ff 07 00 fc c0 0f 00 3c 00 0f 00 3e 00 1f 00     ........<...>...
    33e0:	1e 00 1e 00 1e 00 1e 00 1e 00 1e 00 1e 00 1e 00     ................
    33f0:	1e 00 1f 00 3e 00 1f 00 7c c0 0f 00 fc e0 0f 00     ....>...|.......
    3400:	f8 e0 07 00 70 c0 03 00 40 c0 00 00 00 00 00 00     ....p...@.......
    3410:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3420:	00 00 00 00 00 00 00 00 13 00 00 00 00 00 00 00     ................
    3430:	00 fe ff 1f 00 fe ff 1f 00 fe ff 1f 00 fe ff 1f     ................
    3440:	00 1e 00 1e 00 1e 00 1e 00 1e 00 1e 00 1e 00 1e     ................
    3450:	00 1e 00 1e 00 1e 00 1e 00 1e 00 1e 00 3e 00 1f     .............>..
    3460:	00 fc c0 0f 00 fc ff 0f 00 f8 ff 07 00 e0 ff 01     ................
    3470:	00 80 7f 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3480:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3490:	00 11 00 00 00 00 00 00 00 00 fe ff 1f 00 fe ff     ................
    34a0:	1f 00 fe ff 1f 00 fe ff 1f 00 1e 1e 1e 00 1e 1e     ................
    34b0:	1e 00 1e 1e 1e 00 1e 1e 1e 00 1e 1e 1e 00 1e 1e     ................
    34c0:	1e 00 1e 1e 1e 00 1e 1e 1e 00 1e 1e 1e 00 1e 1e     ................
    34d0:	1e 00 1e 00 1e 00 00 00 00 00 00 00 00 00 00 00     ................
    34e0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    34f0:	00 00 00 00 00 00 00 00 00 00 10 00 00 00 00 00     ................
    3500:	00 00 00 fe ff 1f 00 fe ff 1f 00 fe ff 1f 00 fe     ................
    3510:	ff 1f 00 1e 1e 00 00 1e 1e 00 00 1e 1e 00 00 1e     ................
    3520:	1e 00 00 1e 1e 00 00 1e 1e 00 00 1e 1e 00 00 1e     ................
    3530:	1e 00 00 1e 1e 00 00 1e 00 00 00 00 00 00 00 00     ................
    3540:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3550:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3560:	00 00 00 13 00 00 00 00 80 3f 00 00 e0 ff 01 00     .........?......
    3570:	f0 ff 03 00 f8 ff 07 00 fc c0 0f 00 3c 80 0f 00     ............<...
    3580:	3e 00 1f 00 1e 00 1e 00 1e 00 1e 00 1e 00 1e 00     >...............
    3590:	1e 3c 1e 00 1e 3c 1e 00 3e 3c 1f 00 7c 3c 0f 00     .<...<..><..|<..
    35a0:	fc fc 0f 00 f8 fc 07 00 70 fc 07 00 60 fc 03 00     ........p...`...
    35b0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    35c0:	00 00 00 00 00 00 00 00 00 00 00 00 12 00 00 00     ................
    35d0:	00 00 00 00 00 fe ff 1f 00 fe ff 1f 00 fe ff 1f     ................
    35e0:	00 fe ff 1f 00 00 1e 00 00 00 1e 00 00 00 1e 00     ................
    35f0:	00 00 1e 00 00 00 1e 00 00 00 1e 00 00 00 1e 00     ................
    3600:	00 00 1e 00 00 fe ff 1f 00 fe ff 1f 00 fe ff 1f     ................
    3610:	00 fe ff 1f 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3620:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3630:	00 00 00 00 00 06 00 00 00 00 00 00 00 00 fe ff     ................
    3640:	1f 00 fe ff 1f 00 fe ff 1f 00 fe ff 1f 00 00 00     ................
    3650:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3660:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3670:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3680:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3690:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 0d 00     ................
    36a0:	c0 01 00 00 c0 07 00 00 c0 0f 00 00 c0 1f 00 00     ................
    36b0:	00 1f 00 00 00 1e 00 00 00 1e 00 00 00 1e 00 00     ................
    36c0:	00 1f 00 fe ff 0f 00 fe ff 0f 00 fe ff 07 00 fe     ................
    36d0:	ff 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    36e0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    36f0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3700:	00 00 00 00 00 00 00 13 00 00 00 00 00 00 00 00     ................
    3710:	fe ff 1f 00 fe ff 1f 00 fe ff 1f 00 fe ff 1f 00     ................
    3720:	00 3e 00 00 00 1f 00 00 80 0f 00 00 c0 0f 00 00     .>..............
    3730:	e0 3f 00 00 f0 7f 00 00 f8 fc 01 00 7c f8 07 00     .?..........|...
    3740:	3e e0 0f 00 1e 80 1f 00 0e 00 1f 00 06 00 1c 00     >...............
    3750:	02 00 18 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3760:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3770:	10 00 00 00 00 00 00 00 00 fe ff 1f 00 fe ff 1f     ................
    3780:	00 fe ff 1f 00 fe ff 1f 00 00 00 1e 00 00 00 1e     ................
    3790:	00 00 00 1e 00 00 00 1e 00 00 00 1e 00 00 00 1e     ................
    37a0:	00 00 00 1e 00 00 00 1e 00 00 00 1e 00 00 00 1e     ................
    37b0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    37c0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    37d0:	00 00 00 00 00 00 00 00 00 14 00 00 00 00 fe ff     ................
    37e0:	1f 00 fe ff 1f 00 fe ff 1f 00 fe ff 1f 00 1e 00     ................
    37f0:	00 00 fe 03 00 00 fc 3f 00 00 c0 ff 07 00 00 fc     .......?........
    3800:	1f 00 00 80 1f 00 00 fc 1f 00 c0 ff 07 00 fc 3f     ...............?
    3810:	00 00 fe 03 00 00 1e 00 00 00 fe ff 1f 00 fe ff     ................
    3820:	1f 00 fe ff 1f 00 fe ff 1f 00 00 00 00 00 00 00     ................
    3830:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3840:	00 00 12 00 00 00 00 00 00 00 00 fe ff 1f 00 fe     ................
    3850:	ff 1f 00 fe ff 1f 00 fe ff 1f 00 fc 00 00 00 f8     ................
    3860:	03 00 00 e0 0f 00 00 80 1f 00 00 00 7e 00 00 00     ............~...
    3870:	fc 01 00 00 f0 07 00 00 c0 1f 00 fe ff 1f 00 fe     ................
    3880:	ff 1f 00 fe ff 1f 00 fe ff 1f 00 00 00 00 00 00     ................
    3890:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    38a0:	00 00 00 00 00 00 00 00 00 00 00 14 00 00 00 00     ................
    38b0:	80 7f 00 00 e0 ff 01 00 f0 ff 03 00 f8 ff 07 00     ................
    38c0:	fc c0 0f 00 3c 80 0f 00 3e 00 1f 00 1e 00 1e 00     ....<...>.......
    38d0:	1e 00 1e 00 1e 00 1e 00 1e 00 1e 00 1e 00 1e 00     ................
    38e0:	3e 00 1f 00 7c 80 0f 00 fc c0 0f 00 f8 ff 07 00     >...|...........
    38f0:	f0 ff 03 00 e0 ff 01 00 80 7f 00 00 00 00 00 00     ................
    3900:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3910:	00 00 00 00 11 00 00 00 00 00 00 00 00 fe ff 1f     ................
    3920:	00 fe ff 1f 00 fe ff 1f 00 fe ff 1f 00 1e 1e 00     ................
    3930:	00 1e 1e 00 00 1e 1e 00 00 1e 1e 00 00 1e 1e 00     ................
    3940:	00 1e 1e 00 00 3e 1f 00 00 fe 0f 00 00 fc 0f 00     .....>..........
    3950:	00 f8 07 00 00 f0 03 00 00 00 00 00 00 00 00 00     ................
    3960:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3970:	00 00 00 00 00 00 00 00 00 00 00 00 00 15 00 00     ................
    3980:	00 00 80 7f 00 00 e0 ff 01 00 f0 ff 03 00 f8 ff     ................
    3990:	07 00 fc c0 0f 00 7c 80 0f 00 3e 00 1f 00 1e 00     ......|...>.....
    39a0:	1e 00 1e 00 1e 00 1e 80 1e 00 1e c0 1e 00 1e c0     ................
    39b0:	1f 00 3e 80 1f 00 7c 80 0f 00 fc c0 0f 00 f8 ff     ..>...|.........
    39c0:	1f 00 f0 ff 3f 00 e0 ff 79 00 80 7f 78 00 00 00     ....?...y...x...
    39d0:	10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    39e0:	00 00 00 00 00 00 14 00 00 00 00 00 00 00 00 fe     ................
    39f0:	ff 1f 00 fe ff 1f 00 fe ff 1f 00 fe ff 1f 00 1e     ................
    3a00:	1e 00 00 1e 1e 00 00 1e 1e 00 00 1e 1e 00 00 1e     ................
    3a10:	3e 00 00 1e 7e 00 00 1e fe 01 00 3e ef 03 00 fe     >...~......>....
    3a20:	ef 0f 00 fc cf 1f 00 f8 07 1f 00 f0 01 1e 00 00     ................
    3a30:	00 18 00 00 00 10 00 00 00 00 00 00 00 00 00 00     ................
    3a40:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11     ................
    3a50:	00 00 00 00 00 c0 00 00 f0 c1 03 00 f8 c3 07 00     ................
    3a60:	fc c7 0f 00 fc 87 0f 00 be 0f 1f 00 1e 0f 1e 00     ................
    3a70:	1e 0f 1e 00 1e 1f 1e 00 1e 1e 1e 00 3e 1e 1e 00     ............>...
    3a80:	7c 3e 1f 00 7c fc 0f 00 78 fc 0f 00 60 f8 07 00     |>..|...x...`...
    3a90:	00 f0 01 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3aa0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3ab0:	00 00 00 00 00 00 00 00 11 00 00 00 00 1e 00 00     ................
    3ac0:	00 1e 00 00 00 1e 00 00 00 1e 00 00 00 1e 00 00     ................
    3ad0:	00 1e 00 00 00 fe ff 1f 00 fe ff 1f 00 fe ff 1f     ................
    3ae0:	00 fe ff 1f 00 1e 00 00 00 1e 00 00 00 1e 00 00     ................
    3af0:	00 1e 00 00 00 1e 00 00 00 1e 00 00 00 00 00 00     ................
    3b00:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3b10:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3b20:	00 12 00 00 00 00 00 00 00 00 fe ff 01 00 fe ff     ................
    3b30:	07 00 fe ff 0f 00 fe ff 0f 00 00 80 1f 00 00 00     ................
    3b40:	1f 00 00 00 1e 00 00 00 1e 00 00 00 1e 00 00 00     ................
    3b50:	1e 00 00 00 1f 00 00 00 1f 00 fe ff 0f 00 fe ff     ................
    3b60:	0f 00 fe ff 07 00 fe ff 01 00 00 00 00 00 00 00     ................
    3b70:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3b80:	00 00 00 00 00 00 00 00 00 00 11 06 00 00 00 3e     ...............>
    3b90:	00 00 00 fe 01 00 00 fe 1f 00 00 fc ff 00 00 c0     ................
    3ba0:	ff 07 00 00 fc 1f 00 00 c0 1f 00 00 00 1c 00 00     ................
    3bb0:	c0 1f 00 00 fc 1f 00 c0 ff 07 00 fc ff 00 00 fe     ................
    3bc0:	1f 00 00 fe 01 00 00 3e 00 00 00 06 00 00 00 00     .......>........
    3bd0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3be0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3bf0:	00 00 00 19 06 00 00 00 fe 00 00 00 fe 1f 00 00     ................
    3c00:	fe ff 03 00 f0 ff 1f 00 00 fc 1f 00 00 00 1e 00     ................
    3c10:	00 e0 1f 00 00 ff 1f 00 f0 ff 01 00 fe 1f 00 00     ................
    3c20:	fe 01 00 00 1e 00 00 00 fe 01 00 00 fe 1f 00 00     ................
    3c30:	f0 ff 01 00 00 ff 1f 00 00 e0 1f 00 00 00 1e 00     ................
    3c40:	00 fc 1f 00 f0 ff 1f 00 fe ff 03 00 fe 1f 00 00     ................
    3c50:	fe 00 00 00 06 00 00 00 00 00 00 00 11 00 00 00     ................
    3c60:	00 00 00 18 00 06 00 1c 00 0e 00 1f 00 3e c0 1f     .............>..
    3c70:	00 fe f0 0f 00 fc f9 03 00 f0 ff 00 00 c0 3f 00     ..............?.
    3c80:	00 c0 3f 00 00 f0 ff 00 00 fc f9 03 00 fe e0 0f     ..?.............
    3c90:	00 3e c0 1f 00 0e 00 1f 00 06 00 1c 00 00 00 18     .>..............
    3ca0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3cb0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3cc0:	00 00 00 00 00 12 06 00 00 00 0e 00 00 00 3e 00     ..............>.
    3cd0:	00 00 7e 00 00 00 fc 01 00 00 f8 03 00 00 e0 0f     ..~.............
    3ce0:	00 00 80 ff 1f 00 00 ff 1f 00 00 ff 1f 00 80 ff     ................
    3cf0:	1f 00 e0 0f 00 00 f8 03 00 00 fc 01 00 00 7e 00     ..............~.
    3d00:	00 00 3e 00 00 00 0e 00 00 00 06 00 00 00 00 00     ..>.............
    3d10:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3d20:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 10 00     ................
    3d30:	00 1e 00 1e 00 1f 00 1e 80 1f 00 1e c0 1f 00 1e     ................
    3d40:	e0 1f 00 1e f8 1e 00 1e 7c 1e 00 1e 3e 1e 00 1e     ........|...>...
    3d50:	1f 1e 00 9e 0f 1e 00 de 03 1e 00 fe 01 1e 00 fe     ................
    3d60:	00 1e 00 7e 00 1e 00 3e 00 1e 00 1e 00 1e 00 00     ...~...>........
    3d70:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3d80:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3d90:	00 00 00 00 00 00 00 09 00 00 00 00 00 00 00 00     ................
    3da0:	fe ff ff 03 fe ff ff 03 fe ff ff 03 fe ff ff 03     ................
    3db0:	1e 00 c0 03 1e 00 c0 03 1e 00 c0 03 00 00 00 00     ................
    3dc0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3dd0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3de0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3df0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3e00:	08 06 00 00 00 7e 00 00 00 fe 07 00 00 f8 7f 00     .....~..........
    3e10:	00 80 ff 07 00 00 f8 1f 00 00 80 1f 00 00 00 18     ................
    3e20:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3e30:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3e40:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3e50:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3e60:	00 00 00 00 00 00 00 00 00 07 1e 00 c0 03 1e 00     ................
    3e70:	c0 03 1e 00 c0 03 fe ff ff 03 fe ff ff 03 fe ff     ................
    3e80:	ff 03 fe ff ff 03 00 00 00 00 00 00 00 00 00 00     ................
    3e90:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3ea0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3eb0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3ec0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3ed0:	00 00 0d 00 00 00 00 00 04 00 00 00 07 00 00 c0     ................
    3ee0:	07 00 00 f8 07 00 00 fe 01 00 00 3e 00 00 00 3e     ...........>...>
    3ef0:	00 00 00 fe 01 00 00 f8 07 00 00 c0 07 00 00 00     ................
    3f00:	07 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00     ................
    3f10:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3f20:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3f30:	00 00 00 00 00 00 00 00 00 00 00 0f 00 00 80 03     ................
    3f40:	00 00 80 03 00 00 80 03 00 00 80 03 00 00 80 03     ................
    3f50:	00 00 80 03 00 00 80 03 00 00 80 03 00 00 80 03     ................
    3f60:	00 00 80 03 00 00 80 03 00 00 80 03 00 00 80 03     ................
    3f70:	00 00 80 03 00 00 80 03 00 00 00 00 00 00 00 00     ................
    3f80:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3f90:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3fa0:	00 00 00 00 06 02 00 00 00 06 00 00 00 0e 00 00     ................
    3fb0:	00 1e 00 00 00 1c 00 00 00 10 00 00 00 00 00 00     ................
    3fc0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3fd0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3fe0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    3ff0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4000:	00 00 00 00 00 00 00 00 00 00 00 00 00 0e 00 00     ................
    4010:	00 00 00 86 07 00 00 c7 0f 00 80 e7 1f 00 c0 e3     ................
    4020:	1f 00 c0 61 1c 00 c0 61 1c 00 c0 31 1c 00 c0 33     ...a...a...1...3
    4030:	0e 00 c0 ff 07 00 c0 ff 1f 00 80 ff 1f 00 00 ff     ................
    4040:	1f 00 00 00 10 00 00 00 00 00 00 00 00 00 00 00     ................
    4050:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4060:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4070:	00 00 00 00 00 00 10 00 00 00 00 00 00 00 00 fe     ................
    4080:	ff 1f 00 fe ff 1f 00 fe ff 1f 00 fe ff 1f 00 80     ................
    4090:	07 0f 00 80 01 0e 00 c0 01 1c 00 c0 01 1c 00 c0     ................
    40a0:	01 1c 00 c0 07 1f 00 80 ff 0f 00 80 ff 0f 00 00     ................
    40b0:	ff 07 00 00 fc 01 00 00 00 00 00 00 00 00 00 00     ................
    40c0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    40d0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0e     ................
    40e0:	00 00 00 00 00 fc 01 00 00 ff 07 00 80 ff 0f 00     ................
    40f0:	80 ff 0f 00 c0 03 1e 00 c0 01 1c 00 c0 01 1c 00     ................
    4100:	c0 01 1c 00 c0 03 1e 00 c0 07 1f 00 80 07 0f 00     ................
    4110:	00 03 0e 00 00 02 02 00 00 00 00 00 00 00 00 00     ................
    4120:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4130:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4140:	00 00 00 00 00 00 00 00 0f 00 00 00 00 00 fc 01     ................
    4150:	00 00 ff 07 00 80 ff 0f 00 80 ff 0f 00 c0 07 1f     ................
    4160:	00 c0 01 1c 00 c0 01 1c 00 c0 01 1c 00 80 01 0c     ................
    4170:	00 80 07 0f 00 fe ff 1f 00 fe ff 1f 00 fe ff 1f     ................
    4180:	00 fe ff 1f 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4190:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    41a0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    41b0:	00 0e 00 00 00 00 00 fc 01 00 00 ff 07 00 80 ff     ................
    41c0:	0f 00 80 ff 0f 00 c0 73 1e 00 c0 71 1c 00 c0 71     .......s...q...q
    41d0:	1c 00 c0 71 1c 00 c0 73 1c 00 80 7f 1e 00 80 7f     ...q...s........
    41e0:	0e 00 00 7f 0c 00 00 78 04 00 00 00 00 00 00 00     .......x........
    41f0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4200:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4210:	00 00 00 00 00 00 00 00 00 00 0a c0 01 00 00 c0     ................
    4220:	01 00 00 f8 ff 1f 00 fc ff 1f 00 fe ff 1f 00 fe     ................
    4230:	ff 1f 00 ce 01 00 00 ce 01 00 00 ce 01 00 00 0e     ................
    4240:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4250:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4260:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4270:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4280:	00 00 00 0f 00 00 00 00 00 fc c1 00 00 ff c7 01     ................
    4290:	80 ff 8f 01 80 ff 9f 03 c0 07 9f 03 c0 01 9c 03     ................
    42a0:	c0 01 9c 03 c0 01 9c 03 80 01 8e 03 00 07 c7 03     ................
    42b0:	c0 ff ff 03 c0 ff ff 01 c0 ff ff 00 c0 ff 7f 00     ................
    42c0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    42d0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    42e0:	00 00 00 00 00 00 00 00 00 00 00 00 0f 00 00 00     ................
    42f0:	00 00 00 00 00 fe ff 1f 00 fe ff 1f 00 fe ff 1f     ................
    4300:	00 fe ff 1f 00 80 03 00 00 80 01 00 00 c0 01 00     ................
    4310:	00 c0 01 00 00 c0 03 00 00 c0 ff 1f 00 c0 ff 1f     ................
    4320:	00 80 ff 1f 00 00 ff 1f 00 00 00 00 00 00 00 00     ................
    4330:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4340:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4350:	00 00 00 00 00 06 00 00 00 00 00 00 00 00 ce ff     ................
    4360:	1f 00 ce ff 1f 00 ce ff 1f 00 ce ff 1f 00 00 00     ................
    4370:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4380:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4390:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    43a0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    43b0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 00     ................
    43c0:	00 80 03 00 00 80 03 ce ff ff 03 ce ff ff 03 ce     ................
    43d0:	ff ff 01 ce ff ff 00 00 00 00 00 00 00 00 00 00     ................
    43e0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    43f0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4400:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4410:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4420:	00 00 00 00 00 00 00 0e 00 00 00 00 00 00 00 00     ................
    4430:	fe ff 1f 00 fe ff 1f 00 fe ff 1f 00 fe ff 1f 00     ................
    4440:	00 f0 00 00 00 7c 00 00 00 fe 01 00 80 ff 07 00     .....|..........
    4450:	c0 e7 1f 00 c0 83 1f 00 c0 00 1e 00 40 00 18 00     ............@...
    4460:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4470:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4480:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4490:	06 00 00 00 00 00 00 00 00 fe ff 1f 00 fe ff 1f     ................
    44a0:	00 fe ff 1f 00 fe ff 1f 00 00 00 00 00 00 00 00     ................
    44b0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    44c0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    44d0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    44e0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    44f0:	00 00 00 00 00 00 00 00 00 18 00 00 00 00 00 00     ................
    4500:	00 00 c0 ff 1f 00 c0 ff 1f 00 c0 ff 1f 00 c0 ff     ................
    4510:	1f 00 80 03 00 00 80 01 00 00 c0 01 00 00 c0 01     ................
    4520:	00 00 c0 03 00 00 c0 ff 1f 00 c0 ff 1f 00 80 ff     ................
    4530:	1f 00 00 ff 1f 00 80 07 00 00 80 01 00 00 c0 01     ................
    4540:	00 00 c0 01 00 00 c0 03 00 00 c0 ff 1f 00 c0 ff     ................
    4550:	1f 00 80 ff 1f 00 00 ff 1f 00 00 00 00 00 00 00     ................
    4560:	00 00 0f 00 00 00 00 00 00 00 00 c0 ff 1f 00 c0     ................
    4570:	ff 1f 00 c0 ff 1f 00 c0 ff 1f 00 00 03 00 00 80     ................
    4580:	01 00 00 c0 01 00 00 c0 01 00 00 c0 03 00 00 c0     ................
    4590:	ff 1f 00 c0 ff 1f 00 80 ff 1f 00 00 ff 1f 00 00     ................
    45a0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    45b0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    45c0:	00 00 00 00 00 00 00 00 00 00 00 10 00 00 00 00     ................
    45d0:	00 f8 00 00 00 fe 03 00 00 ff 07 00 80 ff 0f 00     ................
    45e0:	80 07 0f 00 c0 03 1e 00 c0 01 1c 00 c0 01 1c 00     ................
    45f0:	c0 01 1c 00 c0 03 1e 00 80 07 0f 00 80 ff 0f 00     ................
    4600:	00 ff 07 00 00 fe 03 00 00 f8 00 00 00 00 00 00     ................
    4610:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4620:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4630:	00 00 00 00 10 00 00 00 00 00 00 00 00 c0 ff ff     ................
    4640:	03 c0 ff ff 03 c0 ff ff 03 c0 ff ff 03 80 07 07     ................
    4650:	00 80 01 0e 00 c0 01 1c 00 c0 01 1c 00 c0 01 1c     ................
    4660:	00 c0 07 1f 00 c0 ff 0f 00 80 ff 0f 00 00 ff 07     ................
    4670:	00 00 fc 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4680:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4690:	00 00 00 00 00 00 00 00 00 00 00 00 00 0f 00 00     ................
    46a0:	00 00 00 fc 01 00 00 ff 07 00 80 ff 0f 00 80 ff     ................
    46b0:	0f 00 c0 07 1f 00 c0 01 1c 00 c0 01 1c 00 c0 01     ................
    46c0:	1c 00 80 01 0e 00 80 07 0f 00 c0 ff ff 03 c0 ff     ................
    46d0:	ff 03 c0 ff ff 03 c0 ff ff 03 00 00 00 00 00 00     ................
    46e0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    46f0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4700:	00 00 00 00 00 00 0b 00 00 00 00 00 00 00 00 c0     ................
    4710:	ff 1f 00 c0 ff 1f 00 c0 ff 1f 00 c0 ff 1f 00 80     ................
    4720:	07 00 00 c0 01 00 00 c0 01 00 00 c0 01 00 00 c0     ................
    4730:	01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4740:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4750:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4760:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0e     ................
    4770:	00 00 00 00 00 0f 04 00 80 1f 0c 00 80 3f 0e 00     .............?..
    4780:	c0 3f 1e 00 c0 79 1c 00 c0 79 1c 00 c0 71 1c 00     .?...y...y...q..
    4790:	c0 f1 1c 00 c0 f1 1c 00 c0 e3 1f 00 80 e3 0f 00     ................
    47a0:	80 c1 0f 00 00 81 03 00 00 00 00 00 00 00 00 00     ................
    47b0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    47c0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    47d0:	00 00 00 00 00 00 00 00 09 c0 01 00 00 c0 01 00     ................
    47e0:	00 f8 ff 07 00 fc ff 0f 00 fc ff 1f 00 fe ff 1f     ................
    47f0:	00 c0 01 1c 00 c0 01 1c 00 c0 01 1c 00 00 00 00     ................
    4800:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4810:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4820:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4830:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4840:	00 0f 00 00 00 00 00 00 00 00 c0 ff 07 00 c0 ff     ................
    4850:	0f 00 c0 ff 1f 00 c0 ff 1f 00 00 00 1e 00 00 00     ................
    4860:	1c 00 00 00 1c 00 00 00 0c 00 00 00 0e 00 c0 ff     ................
    4870:	1f 00 c0 ff 1f 00 c0 ff 1f 00 c0 ff 1f 00 00 00     ................
    4880:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4890:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    48a0:	00 00 00 00 00 00 00 00 00 00 0e 00 00 00 00 c0     ................
    48b0:	01 00 00 c0 0f 00 00 c0 7f 00 00 c0 ff 03 00 00     ................
    48c0:	fc 1f 00 00 c0 1f 00 00 00 1e 00 00 80 1f 00 00     ................
    48d0:	fc 1f 00 c0 ff 03 00 c0 7f 00 00 c0 0f 00 00 c0     ................
    48e0:	01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    48f0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4900:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4910:	00 00 00 15 c0 00 00 00 c0 07 00 00 c0 3f 00 00     .............?..
    4920:	c0 ff 01 00 00 fe 1f 00 00 f0 1f 00 00 00 1f 00     ................
    4930:	00 f0 1f 00 80 ff 0f 00 c0 ff 00 00 c0 07 00 00     ................
    4940:	c0 ff 00 00 80 ff 0f 00 00 f8 1f 00 00 00 1f 00     ................
    4950:	00 f0 1f 00 00 fe 1f 00 c0 ff 01 00 c0 3f 00 00     .............?..
    4960:	c0 07 00 00 c0 00 00 00 00 00 00 00 00 00 00 00     ................
    4970:	00 00 00 00 00 00 00 00 00 00 00 00 0e 00 00 00     ................
    4980:	00 c0 00 18 00 c0 01 1c 00 c0 07 1f 00 c0 8f 1f     ................
    4990:	00 00 ff 07 00 00 fe 03 00 00 f8 00 00 00 fe 03     ................
    49a0:	00 00 ff 07 00 c0 8f 1f 00 c0 03 1f 00 c0 01 1c     ................
    49b0:	00 c0 00 18 00 00 00 00 00 00 00 00 00 00 00 00     ................
    49c0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    49d0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    49e0:	00 00 00 00 00 0f c0 00 00 00 c0 07 80 03 c0 1f     ................
    49f0:	80 03 c0 ff 80 03 00 ff c3 03 00 f8 ff 03 00 80     ................
    4a00:	ff 01 00 00 fc 01 00 80 7f 00 00 f8 1f 00 00 ff     ................
    4a10:	03 00 c0 ff 00 00 c0 1f 00 00 c0 03 00 00 c0 00     ................
    4a20:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4a30:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4a40:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 0d 00     ................
    4a50:	00 00 00 c0 01 1e 00 c0 01 1f 00 c0 81 1f 00 c0     ................
    4a60:	c1 1f 00 c0 e1 1d 00 c0 f1 1c 00 c0 79 1c 00 c0     ............y...
    4a70:	3d 1c 00 c0 1f 1c 00 c0 0f 1c 00 c0 07 1c 00 c0     =...............
    4a80:	03 1c 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4a90:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4aa0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4ab0:	00 00 00 00 00 00 00 0a 00 00 00 00 00 70 00 00     .............p..
    4ac0:	00 70 00 00 00 f8 00 00 f8 ff ff 00 fc df ff 01     .p..............
    4ad0:	fe 8f ff 03 0e 00 80 03 0e 00 80 03 0e 00 80 03     ................
    4ae0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4af0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4b00:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4b10:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4b20:	05 00 00 00 00 00 00 00 00 fe ff ff 03 fe ff ff     ................
    4b30:	03 fe ff ff 03 00 00 00 00 00 00 00 00 00 00 00     ................
    4b40:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4b50:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4b60:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4b70:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4b80:	00 00 00 00 00 00 00 00 00 0a 00 00 00 00 0e 00     ................
    4b90:	80 03 0e 00 80 03 0e 00 80 03 fe 8f ff 03 fc df     ................
    4ba0:	ff 01 f8 ff ff 00 00 f8 00 00 00 70 00 00 00 70     ...........p...p
    4bb0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4bc0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4bd0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4be0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4bf0:	00 00 0a 00 00 00 00 f8 01 00 00 fc 03 00 00 fe     ................
    4c00:	07 00 00 06 06 00 00 06 06 00 00 06 06 00 00 fe     ................
    4c10:	07 00 00 fc 03 00 00 f8 01 00 00 00 00 00 00 00     ................
    4c20:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4c30:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4c40:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4c50:	00 00 00 00 00 00 00 00 00 00 00 08 00 00 00 00     ................
    4c60:	fc ff 3f 00 fc ff 3f 00 04 00 20 00 04 00 20 00     ..?...?... ... .
    4c70:	04 00 20 00 fc ff 3f 00 fc ff 3f 00 00 00 00 00     .. ...?...?.....
    4c80:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4c90:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4ca0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4cb0:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4cc0:	00 00 00 00                                         ....

00004cc4 <Neu42x35>:
    4cc4:	d8 2b 24 05 16 00 00 00 00 00 00 00 00 00 00 00     .+$.............
    4cd4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4ce4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4cf4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4d04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4d14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4d24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4d34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4d44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4d54:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4d64:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4d74:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4d84:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4d94:	00 00 00 00 00 00 00 00 00 00 00 00 0b 00 00 00     ................
    4da4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4db4:	00 f0 7f 00 1f 00 f0 ff 1f 1f 00 f0 ff 1f 1f 00     ................
    4dc4:	f0 ff 1f 1f 00 f0 ff 1f 1f 00 f0 ff 1f 1f 00 f0     ................
    4dd4:	7f 00 1f 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4de4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4df4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4e04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4e14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4e24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4e34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4e44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4e54:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4e64:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4e74:	00 00 00 00 12 00 00 00 00 00 00 00 00 00 00 00     ................
    4e84:	00 00 00 00 7c 00 00 00 00 fc 0f 00 00 00 fc 0f     ....|...........
    4e94:	00 00 00 fc 0f 00 00 00 fc 0f 00 00 00 7c 00 00     .............|..
    4ea4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4eb4:	00 7c 00 00 00 00 fc 0f 00 00 00 fc 0f 00 00 00     .|..............
    4ec4:	fc 0f 00 00 00 fc 0f 00 00 00 7c 00 00 00 00 00     ..........|.....
    4ed4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4ee4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4ef4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4f04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4f14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4f24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4f34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4f44:	00 00 00 00 00 00 00 00 00 00 00 00 1c 00 00 00     ................
    4f54:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 00     ..............x.
    4f64:	00 00 00 78 00 00 00 3c 78 00 00 00 3c 78 18 00     ...x...<x...<x..
    4f74:	00 3c f8 1f 00 00 3c f8 1f 00 00 fc ff 1f 00 00     .<....<.........
    4f84:	fc ff 07 00 c0 ff 7f 00 00 f0 ff 7f 00 00 f0 7f     ................
    4f94:	78 00 00 f0 3f 78 00 00 70 3c 78 18 00 00 3c f8     x...?x..p<x...<.
    4fa4:	1f 00 00 3c f8 1f 00 00 fc ff 1f 00 00 fc ff 07     ...<............
    4fb4:	00 c0 ff 7f 00 00 f0 ff 7f 00 00 f0 7f 78 00 00     .............x..
    4fc4:	f0 3f 78 00 00 30 3c 78 00 00 00 3c 78 00 00 00     .?x..0<x...<x...
    4fd4:	3c 00 00 00 00 3c 00 00 00 00 00 00 00 00 00 00     <....<..........
    4fe4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    4ff4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5004:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5014:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5024:	00 00 00 00 17 00 00 00 00 00 00 00 00 00 00 00     ................
    5034:	7c c0 0f 00 00 fe c1 0f 00 00 ff 83 0f 00 80 ff     |...............
    5044:	83 0f 00 80 ff 87 1f 00 80 ff 07 1f 00 c0 ff 07     ................
    5054:	1f 00 c0 cf 07 1f 00 c0 c7 0f 1f 00 fc ff ff ff     ................
    5064:	07 fc ff ff ff 07 fc ff ff ff 07 c0 87 0f 1f 00     ................
    5074:	c0 87 9f 1f 00 c0 87 ff 1f 00 c0 07 ff 0f 00 80     ................
    5084:	0f ff 0f 00 80 0f ff 07 00 80 0f fe 07 00 00 00     ................
    5094:	fc 03 00 00 00 f8 00 00 00 00 00 00 00 00 00 00     ................
    50a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    50b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    50c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    50d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    50e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    50f4:	00 00 00 00 00 00 00 00 00 00 00 00 2b 00 00 00     ............+...
    5104:	00 00 00 00 00 00 00 00 7f 00 00 00 c0 ff 01 00     ................
    5114:	00 e0 ff 03 00 00 f0 ff 07 00 00 f8 ff 0f 00 00     ................
    5124:	f8 80 0f 00 00 78 00 0f 00 00 78 00 0f 00 00 78     .....x....x....x
    5134:	00 0f 00 00 f8 80 0f 00 00 f8 ff 0f 00 00 f0 ff     ................
    5144:	07 10 00 f0 ff 03 1c 00 c0 ff 01 1e 00 00 7f 80     ................
    5154:	1f 00 00 00 e0 1f 00 00 00 f0 07 00 00 00 fc 01     ................
    5164:	00 00 00 ff 00 00 00 c0 3f 00 00 00 e0 0f 00 00     ........?.......
    5174:	00 f8 07 00 00 00 fe 01 00 00 00 7f 00 00 00 c0     ................
    5184:	1f 00 00 00 f0 0f 00 00 00 f0 03 fe 00 00 f0 80     ................
    5194:	ff 03 00 70 c0 ff 07 00 10 e0 ff 0f 00 00 f0 ff     ...p............
    51a4:	1f 00 00 f0 01 1f 00 00 f0 00 1e 00 00 f0 00 1e     ................
    51b4:	00 00 f0 00 1e 00 00 f0 01 1f 00 00 f0 ff 1f 00     ................
    51c4:	00 e0 ff 0f 00 00 e0 ff 07 00 00 80 ff 03 00 00     ................
    51d4:	00 fe 00 00 1f 00 00 00 00 00 00 00 00 00 00 00     ................
    51e4:	00 f8 00 00 80 07 fe 03 00 e0 1f ff 07 00 e0 bf     ................
    51f4:	ff 07 00 f0 ff ff 0f 00 f0 ff ff 0f 00 f8 ff ff     ................
    5204:	1f 00 f8 ff 83 1f 00 f8 f8 03 1f 00 78 f0 07 1e     ............x...
    5214:	00 78 e0 0f 1e 00 f8 f0 1f 1e 00 f8 ff 3f 1e 00     .x...........?..
    5224:	f8 7f 3f 1e 00 f0 7f 7e 0f 00 f0 3f fe 0f 00 f0     ..?....~...?....
    5234:	3f fc 0f 00 e0 1f f8 07 00 80 c7 ff 07 00 00 c0     ?...............
    5244:	ff 0f 00 00 c0 ff 1f 00 00 c0 ff 1f 00 00 c0 ff     ................
    5254:	1f 00 00 c0 3f 1f 00 00 c0 07 1e 00 00 00 00 1c     ....?...........
    5264:	00 00 00 00 18 00 00 00 00 18 00 00 00 00 10 00     ................
    5274:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5284:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5294:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    52a4:	00 00 00 00 00 00 00 00 00 00 00 00 09 00 00 00     ................
    52b4:	00 00 00 00 00 00 00 00 00 00 00 00 7c 00 00 00     ............|...
    52c4:	00 fc 0f 00 00 00 fc 0f 00 00 00 fc 0f 00 00 00     ................
    52d4:	fc 0f 00 00 00 7c 00 00 00 00 00 00 00 00 00 00     .....|..........
    52e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    52f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5304:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5314:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5324:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5334:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5344:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5354:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5364:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5374:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5384:	00 00 00 00 10 00 00 00 00 00 00 00 00 00 00 00     ................
    5394:	00 00 00 00 00 c0 ff 00 00 00 fc ff 0f 00 00 ff     ................
    53a4:	ff 3f 00 c0 ff ff ff 00 e0 ff ff ff 01 f8 ff ff     .?..............
    53b4:	ff 07 fc 3f 00 ff 0f fc 07 00 f8 0f fc 01 00 e0     ...?............
    53c4:	0f 7c 00 00 80 0f 1c 00 00 00 0e 0c 00 00 00 0c     .|..............
    53d4:	04 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00     ................
    53e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    53f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5404:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5414:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5424:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5434:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5444:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5454:	00 00 00 00 00 00 00 00 00 00 00 00 10 00 00 00     ................
    5464:	00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00     ................
    5474:	08 0c 00 00 00 0c 1c 00 00 00 0e 7c 00 00 80 0f     ...........|....
    5484:	fc 01 00 e0 0f fc 07 00 f8 0f fc 3f 00 ff 0f f8     ...........?....
    5494:	ff ff ff 07 e0 ff ff ff 01 c0 ff ff ff 00 00 ff     ................
    54a4:	ff 3f 00 00 fc ff 0f 00 00 c0 ff 00 00 00 00 00     .?..............
    54b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    54c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    54d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    54e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    54f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5504:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5514:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5524:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5534:	00 00 00 00 16 00 00 00 00 00 00 00 00 00 00 00     ................
    5544:	00 00 00 00 00 00 00 00 00 40 40 00 00 00 e0 e0     .........@@.....
    5554:	00 00 00 f0 e0 01 00 00 e0 f1 00 00 00 c0 7b 00     ..............{.
    5564:	00 00 80 7b 00 00 00 80 3f 00 00 00 fc ff 07 00     ...{....?.......
    5574:	00 fc ff 07 00 00 fc ff 07 00 00 fc ff 07 00 00     ................
    5584:	80 3f 00 00 00 80 3b 00 00 00 c0 7b 00 00 00 e0     .?....;....{....
    5594:	f1 00 00 00 f0 e0 01 00 00 e0 e0 00 00 00 40 40     ..............@@
    55a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    55b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    55c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    55d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    55e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    55f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5604:	00 00 00 00 00 00 00 00 00 00 00 00 1b 00 00 00     ................
    5614:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5624:	00 00 80 0f 00 00 00 80 0f 00 00 00 80 0f 00 00     ................
    5634:	00 80 0f 00 00 00 80 0f 00 00 00 80 0f 00 00 00     ................
    5644:	80 0f 00 00 00 80 0f 00 00 00 80 0f 00 00 c0 ff     ................
    5654:	ff 1f 00 c0 ff ff 1f 00 c0 ff ff 1f 00 c0 ff ff     ................
    5664:	1f 00 c0 ff ff 1f 00 00 80 0f 00 00 00 80 0f 00     ................
    5674:	00 00 80 0f 00 00 00 80 0f 00 00 00 80 0f 00 00     ................
    5684:	00 80 0f 00 00 00 80 0f 00 00 00 80 0f 00 00 00     ................
    5694:	80 0f 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    56a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    56b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    56c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    56d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    56e4:	00 00 00 00 0b 00 00 00 00 00 00 00 00 00 06 00     ................
    56f4:	00 00 e0 07 00 00 00 fe 07 00 00 c0 ff 07 00 00     ................
    5704:	c0 ff 03 00 00 c0 7f 00 00 00 c0 1f 00 00 00 c0     ................
    5714:	07 00 00 00 c0 01 00 00 00 40 00 00 00 00 00 00     .........@......
    5724:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5734:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5744:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5754:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5764:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5774:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5784:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5794:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    57a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    57b4:	00 00 00 00 00 00 00 00 00 00 00 00 0f 00 00 00     ................
    57c4:	00 00 00 00 00 00 00 00 80 0f 00 00 00 80 0f 00     ................
    57d4:	00 00 80 0f 00 00 00 80 0f 00 00 00 80 0f 00 00     ................
    57e4:	00 80 0f 00 00 00 80 0f 00 00 00 80 0f 00 00 00     ................
    57f4:	80 0f 00 00 00 80 0f 00 00 00 80 0f 00 00 00 80     ................
    5804:	0f 00 00 00 80 0f 00 00 00 00 00 00 00 00 00 00     ................
    5814:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5824:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5834:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5844:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5854:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5864:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5874:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5884:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5894:	00 00 00 00 09 00 00 00 00 00 00 00 00 00 00 00     ................
    58a4:	00 00 00 00 00 00 c0 1f 00 00 00 c0 1f 00 00 00     ................
    58b4:	c0 1f 00 00 00 c0 1f 00 00 00 c0 1f 00 00 00 c0     ................
    58c4:	1f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    58d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    58e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    58f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5904:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5914:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5924:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5934:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5944:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5954:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5964:	00 00 00 00 00 00 00 00 00 00 00 00 15 00 00 00     ................
    5974:	00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 80     ................
    5984:	07 00 00 00 e0 07 00 00 00 f8 07 00 00 00 ff 07     ................
    5994:	00 00 c0 ff 07 00 00 f8 ff 00 00 00 fe 3f 00 00     .............?..
    59a4:	c0 ff 07 00 00 f0 ff 01 00 00 fc 7f 00 00 80 ff     ................
    59b4:	0f 00 00 e0 ff 03 00 00 fc 7f 00 00 00 fc 1f 00     ................
    59c4:	00 00 fc 03 00 00 00 fc 00 00 00 00 3c 00 00 00     ............<...
    59d4:	00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    59e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    59f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5a04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5a14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5a24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5a34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5a44:	00 00 00 00 17 00 00 00 00 00 00 00 00 00 00 00     ................
    5a54:	f8 1f 00 00 00 ff ff 00 00 c0 ff ff 03 00 e0 ff     ................
    5a64:	ff 07 00 f0 ff ff 0f 00 f0 ff ff 0f 00 f0 ff ff     ................
    5a74:	0f 00 f8 07 e0 1f 00 f8 01 80 1f 00 f8 00 00 1f     ................
    5a84:	00 f8 00 00 1f 00 f8 00 00 1f 00 f8 01 80 1f 00     ................
    5a94:	f8 07 e0 1f 00 f0 ff ff 0f 00 f0 ff ff 0f 00 f0     ................
    5aa4:	ff ff 0f 00 e0 ff ff 07 00 c0 ff ff 03 00 00 ff     ................
    5ab4:	ff 00 00 00 f8 1f 00 00 00 00 00 00 00 00 00 00     ................
    5ac4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5ad4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5ae4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5af4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5b04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5b14:	00 00 00 00 00 00 00 00 00 00 00 00 16 00 00 00     ................
    5b24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5b34:	00 00 00 00 00 00 80 0f 00 1f 00 80 0f 00 1f 00     ................
    5b44:	80 0f 00 1f 00 80 0f 00 1f 00 c0 0f 00 1f 00 e0     ................
    5b54:	ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff     ................
    5b64:	ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff     ................
    5b74:	1f 00 00 00 00 1f 00 00 00 00 1f 00 00 00 00 1f     ................
    5b84:	00 00 00 00 1f 00 00 00 00 1f 00 00 00 00 00 00     ................
    5b94:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5ba4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5bb4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5bc4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5bd4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5be4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5bf4:	00 00 00 00 17 00 00 00 00 00 00 00 00 00 00 00     ................
    5c04:	00 00 00 00 00 00 00 1f 00 f0 03 00 1f 00 f0 01     ................
    5c14:	80 1f 00 f0 01 c0 1f 00 f0 01 e0 1f 00 f8 00 f0     ................
    5c24:	1f 00 f8 00 f0 1f 00 f8 00 f8 1f 00 f8 00 fc 1f     ................
    5c34:	00 f8 00 7e 1f 00 f8 81 7f 1f 00 f8 c3 3f 1f 00     ...~.........?..
    5c44:	f8 ff 1f 1f 00 f0 ff 0f 1f 00 f0 ff 07 1f 00 f0     ................
    5c54:	ff 03 1f 00 e0 ff 01 1f 00 c0 ff 00 1f 00 00 3f     ...............?
    5c64:	00 1f 00 00 00 00 1f 00 00 00 00 00 00 00 00 00     ................
    5c74:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5c84:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5c94:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5ca4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5cb4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5cc4:	00 00 00 00 00 00 00 00 00 00 00 00 17 00 00 00     ................
    5cd4:	00 00 00 00 00 00 00 00 00 c0 0f 00 f0 03 c0 0f     ................
    5ce4:	00 f0 03 80 0f 00 f0 01 80 0f 00 f0 01 80 1f 00     ................
    5cf4:	f8 00 00 1f 00 f8 e0 03 1f 00 f8 e0 03 1f 00 f8     ................
    5d04:	e0 03 1f 00 f8 e0 03 1f 00 f8 e0 03 1f 00 f8 e0     ................
    5d14:	03 1f 00 f8 f1 83 1f 00 f8 ff c7 1f 00 f8 ff ff     ................
    5d24:	0f 00 f0 ff ff 0f 00 f0 7f ff 0f 00 e0 3f ff 07     .............?..
    5d34:	00 e0 1f ff 03 00 80 0f fe 01 00 00 00 fc 00 00     ................
    5d44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5d54:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5d64:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5d74:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5d84:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5d94:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5da4:	00 00 00 00 17 00 00 00 00 00 00 00 7e 00 00 00     ............~...
    5db4:	00 7f 00 00 00 80 7f 00 00 00 c0 7f 00 00 00 f0     ................
    5dc4:	7f 00 00 00 f8 7d 00 00 00 fc 7c 00 00 00 7e 7c     .....}....|...~|
    5dd4:	00 00 00 3f 7c 00 00 c0 1f 7c 00 00 e0 0f 7c 00     ...?|....|....|.
    5de4:	00 f0 03 7c 00 00 f0 ff ff 1f 00 f0 ff ff 1f 00     ...|............
    5df4:	f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0     ................
    5e04:	ff ff 1f 00 f0 ff ff 1f 00 00 00 7c 00 00 00 00     ...........|....
    5e14:	7c 00 00 00 00 7c 00 00 00 00 00 00 00 00 00 00     |....|..........
    5e24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5e34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5e44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5e54:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5e64:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5e74:	00 00 00 00 00 00 00 00 00 00 00 00 17 00 00 00     ................
    5e84:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 0f     ................
    5e94:	00 f0 ff c7 0f 00 f0 ff 87 0f 00 f0 ff 83 1f 00     ................
    5ea4:	f0 ff 03 1f 00 f0 ff 03 1f 00 f0 ff 03 1f 00 f0     ................
    5eb4:	ff 03 1f 00 f0 e1 03 1f 00 f0 e1 03 1f 00 f0 e1     ................
    5ec4:	03 1f 00 f0 e1 87 1f 00 f0 e1 c7 1f 00 f0 e1 ff     ................
    5ed4:	0f 00 f0 e1 ff 0f 00 f0 c1 ff 0f 00 f0 c1 ff 07     ................
    5ee4:	00 f0 81 ff 03 00 f0 01 ff 01 00 00 00 7e 00 00     .............~..
    5ef4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5f04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5f14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5f24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5f34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5f44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5f54:	00 00 00 00 17 00 00 00 00 00 00 00 00 00 00 00     ................
    5f64:	e0 3f 00 00 00 fc ff 00 00 00 ff ff 03 00 80 ff     .?..............
    5f74:	ff 07 00 c0 ff ff 07 00 e0 ff ff 0f 00 e0 ff ff     ................
    5f84:	0f 00 f0 ef c1 1f 00 f0 e3 81 1f 00 f0 e1 01 1f     ................
    5f94:	00 f8 f1 01 1f 00 f8 f0 01 1f 00 f8 f0 03 1f 00     ................
    5fa4:	f8 f0 c3 1f 00 f8 f0 ff 1f 00 f8 f0 ff 0f 00 f8     ................
    5fb4:	e0 ff 0f 00 f8 e1 ff 07 00 f8 c1 ff 03 00 00 80     ................
    5fc4:	ff 01 00 00 00 7e 00 00 00 00 00 00 00 00 00 00     .....~..........
    5fd4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5fe4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    5ff4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6004:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6014:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6024:	00 00 00 00 00 00 00 00 00 00 00 00 17 00 00 00     ................
    6034:	00 00 00 00 00 00 00 00 00 00 00 00 f0 01 00 00     ................
    6044:	00 f0 01 00 10 00 f0 01 00 1c 00 f0 01 00 1e 00     ................
    6054:	f0 01 80 1f 00 f0 01 e0 1f 00 f0 01 f8 1f 00 f0     ................
    6064:	01 fe 1f 00 f0 01 ff 1f 00 f0 c1 ff 0f 00 f0 f1     ................
    6074:	ff 07 00 f0 fd ff 01 00 f0 ff 7f 00 00 f0 ff 1f     ................
    6084:	00 00 f0 ff 07 00 00 f0 ff 01 00 00 f0 ff 00 00     ................
    6094:	00 f0 3f 00 00 00 f0 0f 00 00 00 f0 03 00 00 00     ..?.............
    60a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    60b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    60c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    60d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    60e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    60f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6104:	00 00 00 00 17 00 00 00 00 00 00 00 00 00 00 00     ................
    6114:	00 f8 00 00 80 0f fc 03 00 c0 3f fe 07 00 e0 7f     ..........?.....
    6124:	fe 0f 00 f0 ff ff 0f 00 f0 ff ff 0f 00 f0 ff ff     ................
    6134:	1f 00 f8 ff c3 1f 00 f8 f9 81 1f 00 f8 f0 03 1f     ................
    6144:	00 f8 f0 03 1f 00 f8 e0 07 1f 00 f8 e1 07 1f 00     ................
    6154:	f8 ff 8f 1f 00 f8 ff ff 1f 00 f0 ff ff 0f 00 f0     ................
    6164:	ff ff 0f 00 e0 bf ff 07 00 c0 1f ff 07 00 80 0f     ................
    6174:	fe 03 00 00 00 f8 00 00 00 00 00 00 00 00 00 00     ................
    6184:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6194:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    61a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    61b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    61c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    61d4:	00 00 00 00 00 00 00 00 00 00 00 00 17 00 00 00     ................
    61e4:	00 00 00 00 00 00 00 00 7e 00 00 00 80 ff 01 00     ........~.......
    61f4:	00 c0 ff 83 1f 00 e0 ff 87 1f 00 f0 ff 07 1f 00     ................
    6204:	f0 ff 0f 1f 00 f0 ff 0f 1f 00 f8 c3 0f 1f 00 f8     ................
    6214:	c1 0f 1f 00 f8 80 0f 1f 00 f8 80 8f 1f 00 f8 80     ................
    6224:	87 0f 00 f8 81 c7 0f 00 f8 83 f7 0f 00 f0 ff ff     ................
    6234:	07 00 f0 ff ff 07 00 f0 ff ff 03 00 e0 ff ff 01     ................
    6244:	00 c0 ff ff 00 00 00 ff 3f 00 00 00 fc 07 00 00     ........?.......
    6254:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6264:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6274:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6284:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6294:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    62a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    62b4:	00 00 00 00 0a 00 00 00 00 00 00 00 00 00 00 00     ................
    62c4:	00 00 00 00 00 00 00 00 00 00 fc c1 1f 00 00 fc     ................
    62d4:	c1 1f 00 00 fc c1 1f 00 00 fc c1 1f 00 00 fc c1     ................
    62e4:	1f 00 00 fc c1 1f 00 00 00 00 00 00 00 00 00 00     ................
    62f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6304:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6314:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6324:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6334:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6344:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6354:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6364:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6374:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6384:	00 00 00 00 00 00 00 00 00 00 00 00 0b 00 00 00     ................
    6394:	00 00 00 00 00 00 06 00 00 00 e0 07 00 00 00 fe     ................
    63a4:	07 00 fc c1 ff 07 00 fc c1 ff 03 00 fc c1 7f 00     ................
    63b4:	00 fc c1 1f 00 00 fc c1 07 00 00 fc c1 01 00 00     ................
    63c4:	00 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00     .@..............
    63d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    63e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    63f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6404:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6414:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6424:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6434:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6444:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6454:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6464:	00 00 00 00 1a 00 00 00 00 00 00 00 00 00 00 00     ................
    6474:	00 00 00 00 00 80 0f 00 00 00 80 0f 00 00 00 80     ................
    6484:	0f 00 00 00 c0 1f 00 00 00 c0 1f 00 00 00 e0 3f     ...............?
    6494:	00 00 00 e0 3f 00 00 00 f0 7f 00 00 00 f0 7d 00     ....?.........}.
    64a4:	00 00 f0 7d 00 00 00 f8 fd 00 00 00 f8 f8 00 00     ...}............
    64b4:	00 fc f8 01 00 00 7c f0 01 00 00 7c f0 01 00 00     ......|....|....
    64c4:	3e e0 03 00 00 3e e0 03 00 00 3f e0 07 00 00 1f     >....>....?.....
    64d4:	c0 07 00 80 1f c0 0f 00 80 0f 80 0f 00 80 0f 80     ................
    64e4:	0f 00 c0 0f 80 1f 00 00 00 00 00 00 00 00 00 00     ................
    64f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6504:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6514:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6524:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6534:	00 00 00 00 00 00 00 00 00 00 00 00 1a 00 00 00     ................
    6544:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6554:	00 00 f8 f0 01 00 00 f8 f0 01 00 00 f8 f0 01 00     ................
    6564:	00 f8 f0 01 00 00 f8 f0 01 00 00 f8 f0 01 00 00     ................
    6574:	f8 f0 01 00 00 f8 f0 01 00 00 f8 f0 01 00 00 f8     ................
    6584:	f0 01 00 00 f8 f0 01 00 00 f8 f0 01 00 00 f8 f0     ................
    6594:	01 00 00 f8 f0 01 00 00 f8 f0 01 00 00 f8 f0 01     ................
    65a4:	00 00 f8 f0 01 00 00 f8 f0 01 00 00 f8 f0 01 00     ................
    65b4:	00 f8 f0 01 00 00 f8 f0 01 00 00 f8 f0 01 00 00     ................
    65c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    65d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    65e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    65f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6604:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6614:	00 00 00 00 1b 00 00 00 00 00 00 00 00 00 00 00     ................
    6624:	00 00 00 00 00 00 00 00 00 c0 0f 80 1f 00 80 0f     ................
    6634:	80 0f 00 80 0f 80 0f 00 80 1f c0 0f 00 00 1f c0     ................
    6644:	07 00 00 3f e0 07 00 00 3e e0 03 00 00 3e e0 03     ...?....>....>..
    6654:	00 00 7c f0 01 00 00 7c f0 01 00 00 fc f8 01 00     ..|....|........
    6664:	00 f8 f8 00 00 00 f8 fd 00 00 00 f0 7d 00 00 00     ............}...
    6674:	f0 7d 00 00 00 f0 7f 00 00 00 e0 3f 00 00 00 e0     .}.........?....
    6684:	3f 00 00 00 c0 1f 00 00 00 c0 1f 00 00 00 80 0f     ?...............
    6694:	00 00 00 80 0f 00 00 00 80 0f 00 00 00 00 00 00     ................
    66a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    66b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    66c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    66d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    66e4:	00 00 00 00 00 00 00 00 00 00 00 00 14 00 00 00     ................
    66f4:	00 00 00 00 00 00 00 00 00 00 00 00 f0 03 00 00     ................
    6704:	00 f0 01 00 00 00 f0 01 00 00 00 f8 00 00 00 00     ................
    6714:	f8 00 3f 1f 00 f8 00 3f 1f 00 f8 80 3f 1f 00 f8     ..?....?....?...
    6724:	80 3f 1f 00 f8 c0 3f 1f 00 f8 e1 3f 1f 00 f8 ff     .?....?....?....
    6734:	03 1f 00 f8 ff 01 00 00 f0 ff 01 00 00 f0 ff 00     ................
    6744:	00 00 e0 ff 00 00 00 c0 7f 00 00 00 80 1f 00 00     ................
    6754:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6764:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6774:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6784:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6794:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    67a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    67b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    67c4:	00 00 00 00 20 00 00 00 00 00 00 00 00 00 00 00     .... ...........
    67d4:	c0 3f 00 00 00 f8 ff 01 00 00 fc ff 07 00 00 ff     .?..............
    67e4:	ff 0f 00 80 3f c0 1f 00 c0 0f 00 3f 00 c0 03 00     ....?......?....
    67f4:	7c 00 e0 81 3f 78 00 f0 e0 ff f0 00 f0 f8 ff e1     |...?x..........
    6804:	00 70 fc ff e3 00 78 7c c0 e7 01 38 1e 80 c7 01     .p....x|...8....
    6814:	38 0e 00 c7 01 38 0e 00 c7 01 38 0e 00 c7 01 38     8....8....8....8
    6824:	0e 00 c7 01 38 1c 80 c3 01 38 fe ff c3 01 70 fe     ....8....8....p.
    6834:	ff c7 01 70 fe ff e7 01 f0 fe ff e7 00 e0 01 00     ...p............
    6844:	07 00 e0 03 00 07 00 c0 07 00 07 00 80 3f c0 07     .............?..
    6854:	00 00 ff ff 07 00 00 fe ff 07 00 00 f8 ff 01 00     ................
    6864:	00 c0 3f 00 00 00 00 00 00 00 00 00 00 00 00 00     ..?.............
    6874:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6884:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6894:	00 00 00 00 00 00 00 00 00 00 00 00 1b 00 00 00     ................
    68a4:	10 00 00 00 00 1e 00 00 00 80 1f 00 00 00 f0 1f     ................
    68b4:	00 00 00 fe 1f 00 00 80 ff 1f 00 00 f0 ff 1f 00     ................
    68c4:	00 fc ff 03 00 80 ff ff 00 00 f0 ff ff 00 00 f0     ................
    68d4:	ff fb 00 00 f0 7f f8 00 00 f0 0f f8 00 00 f0 0f     ................
    68e4:	f8 00 00 f0 7f f8 00 00 f0 ff fb 00 00 f0 ff ff     ................
    68f4:	00 00 f0 ff ff 00 00 80 ff ff 03 00 00 fc ff 1f     ................
    6904:	00 00 f0 ff 1f 00 00 80 ff 1f 00 00 00 fe 1f 00     ................
    6914:	00 00 f0 1f 00 00 00 80 1f 00 00 00 00 1e 00 00     ................
    6924:	00 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6934:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6944:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6954:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6964:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6974:	00 00 00 00 19 00 00 00 00 00 00 00 00 00 00 00     ................
    6984:	00 00 00 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff     ................
    6994:	ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff     ................
    69a4:	1f 00 f0 ff ff 1f 00 f0 c1 03 1f 00 f0 c1 03 1f     ................
    69b4:	00 f0 c1 03 1f 00 f0 c1 03 1f 00 f0 c1 03 1f 00     ................
    69c4:	f0 e3 03 1f 00 f0 ff 83 1f 00 f0 ff 87 1f 00 f0     ................
    69d4:	ff ff 1f 00 e0 ff ff 0f 00 e0 7f ff 0f 00 c0 3f     ...............?
    69e4:	ff 07 00 80 0f fe 07 00 00 00 fe 03 00 00 00 f8     ................
    69f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6a04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6a14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6a24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6a34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6a44:	00 00 00 00 00 00 00 00 00 00 00 00 17 00 00 00     ................
    6a54:	00 00 00 00 00 00 00 00 f0 0f 00 00 00 fe 7f 00     ................
    6a64:	00 00 ff ff 01 00 c0 ff ff 03 00 e0 ff ff 07 00     ................
    6a74:	e0 ff ff 07 00 f0 ff ff 0f 00 f0 1f f0 0f 00 f0     ................
    6a84:	07 c0 1f 00 f8 01 80 1f 00 f8 01 80 1f 00 f8 00     ................
    6a94:	00 1f 00 f8 00 00 1f 00 f8 00 00 1f 00 f8 00 00     ................
    6aa4:	1f 00 f8 00 00 1f 00 f8 01 80 1f 00 f0 01 80 0f     ................
    6ab4:	00 f0 03 c0 0f 00 f0 03 c0 0f 00 e0 07 e0 07 00     ................
    6ac4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6ad4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6ae4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6af4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6b04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6b14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6b24:	00 00 00 00 1b 00 00 00 00 00 00 00 00 00 00 00     ................
    6b34:	00 00 00 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff     ................
    6b44:	ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff     ................
    6b54:	1f 00 f0 ff ff 1f 00 f0 01 00 1f 00 f0 01 00 1f     ................
    6b64:	00 f0 01 00 1f 00 f0 01 00 1f 00 f0 01 00 1f 00     ................
    6b74:	f0 01 00 1f 00 f0 03 80 1f 00 e0 03 80 1f 00 e0     ................
    6b84:	07 c0 0f 00 e0 1f f0 0f 00 c0 ff ff 07 00 c0 ff     ................
    6b94:	ff 07 00 80 ff ff 03 00 00 ff ff 01 00 00 fe ff     ................
    6ba4:	00 00 00 fc 7f 00 00 00 e0 0f 00 00 00 00 00 00     ................
    6bb4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6bc4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6bd4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6be4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6bf4:	00 00 00 00 00 00 00 00 00 00 00 00 16 00 00 00     ................
    6c04:	00 00 00 00 00 00 00 00 00 00 00 00 f0 ff ff 1f     ................
    6c14:	00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00     ................
    6c24:	f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0     ................
    6c34:	e1 03 1f 00 f0 e1 03 1f 00 f0 e1 03 1f 00 f0 e1     ................
    6c44:	03 1f 00 f0 e1 03 1f 00 f0 e1 03 1f 00 f0 e1 03     ................
    6c54:	1f 00 f0 e1 03 1f 00 f0 e1 03 1f 00 f0 e1 03 1f     ................
    6c64:	00 f0 e1 03 1f 00 f0 01 00 1f 00 00 00 00 00 00     ................
    6c74:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6c84:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6c94:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6ca4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6cb4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6cc4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6cd4:	00 00 00 00 16 00 00 00 00 00 00 00 00 00 00 00     ................
    6ce4:	00 00 00 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff     ................
    6cf4:	ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff     ................
    6d04:	1f 00 f0 ff ff 1f 00 f0 e1 03 00 00 f0 e1 03 00     ................
    6d14:	00 f0 e1 03 00 00 f0 e1 03 00 00 f0 e1 03 00 00     ................
    6d24:	f0 e1 03 00 00 f0 e1 03 00 00 f0 e1 03 00 00 f0     ................
    6d34:	e1 03 00 00 f0 e1 03 00 00 f0 e1 03 00 00 f0 01     ................
    6d44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6d54:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6d64:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6d74:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6d84:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6d94:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6da4:	00 00 00 00 00 00 00 00 00 00 00 00 19 00 00 00     ................
    6db4:	00 00 00 00 00 00 00 00 f0 0f 00 00 00 fe 7f 00     ................
    6dc4:	00 00 ff ff 00 00 80 ff ff 03 00 c0 ff ff 03 00     ................
    6dd4:	e0 ff ff 07 00 f0 ff ff 0f 00 f0 1f f8 0f 00 f0     ................
    6de4:	07 e0 0f 00 f8 03 c0 1f 00 f8 01 80 1f 00 f8 01     ................
    6df4:	00 1f 00 f8 80 0f 1f 00 f8 80 0f 1f 00 f8 80 0f     ................
    6e04:	1f 00 f8 80 0f 1f 00 f8 80 ff 1f 00 f8 80 ff 1f     ................
    6e14:	00 f0 81 ff 0f 00 f0 81 ff 0f 00 f0 83 ff 0f 00     ................
    6e24:	e0 83 ff 0f 00 e0 87 ff 07 00 00 00 00 00 00 00     ................
    6e34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6e44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6e54:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6e64:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6e74:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6e84:	00 00 00 00 1a 00 00 00 00 00 00 00 00 00 00 00     ................
    6e94:	00 00 00 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff     ................
    6ea4:	ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff     ................
    6eb4:	1f 00 f0 ff ff 1f 00 00 e0 03 00 00 00 e0 03 00     ................
    6ec4:	00 00 e0 03 00 00 00 e0 03 00 00 00 e0 03 00 00     ................
    6ed4:	00 e0 03 00 00 00 e0 03 00 00 00 e0 03 00 00 00     ................
    6ee4:	e0 03 00 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff     ................
    6ef4:	ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff     ................
    6f04:	1f 00 f0 ff ff 1f 00 00 00 00 00 00 00 00 00 00     ................
    6f14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6f24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6f34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6f44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6f54:	00 00 00 00 00 00 00 00 00 00 00 00 11 00 00 00     ................
    6f64:	00 00 00 00 00 00 00 f0 01 00 1f 00 f0 01 00 1f     ................
    6f74:	00 f0 01 00 1f 00 f0 01 00 1f 00 f0 ff ff 1f 00     ................
    6f84:	f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0     ................
    6f94:	ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 01     ................
    6fa4:	00 1f 00 f0 01 00 1f 00 f0 01 00 1f 00 f0 01 00     ................
    6fb4:	1f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6fc4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6fd4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6fe4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    6ff4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7004:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7014:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7024:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7034:	00 00 00 00 10 00 00 00 00 00 00 00 80 1f 00 00     ................
    7044:	00 80 1f 00 00 00 00 1f 00 f0 01 00 1f 00 f0 01     ................
    7054:	00 1f 00 f0 01 00 1f 00 f0 01 00 1f 00 f0 01 c0     ................
    7064:	1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff 0f     ................
    7074:	00 f0 ff ff 0f 00 f0 ff ff 07 00 f0 ff ff 03 00     ................
    7084:	f0 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7094:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    70a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    70b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    70c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    70d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    70e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    70f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7104:	00 00 00 00 00 00 00 00 00 00 00 00 1b 00 00 00     ................
    7114:	00 00 00 00 00 00 00 00 00 00 00 00 f0 ff ff 1f     ................
    7124:	00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00     ................
    7134:	f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 00     ................
    7144:	c0 0f 00 00 00 e0 07 00 00 00 f0 1f 00 00 00 f8     ................
    7154:	3f 00 00 00 fe 7f 00 00 00 ff ff 01 00 80 ff ff     ?...............
    7164:	03 00 c0 7f fe 07 00 e0 3f fc 1f 00 f0 0f f8 1f     ........?.......
    7174:	00 f0 07 e0 1f 00 f0 03 c0 1f 00 f0 01 80 1f 00     ................
    7184:	f0 00 00 1f 00 70 00 00 1c 00 30 00 00 18 00 10     .....p....0.....
    7194:	00 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    71a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    71b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    71c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    71d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    71e4:	00 00 00 00 15 00 00 00 00 00 00 00 00 00 00 00     ................
    71f4:	00 00 00 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff     ................
    7204:	ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff     ................
    7214:	1f 00 f0 ff ff 1f 00 00 00 00 1f 00 00 00 00 1f     ................
    7224:	00 00 00 00 1f 00 00 00 00 1f 00 00 00 00 1f 00     ................
    7234:	00 00 00 1f 00 00 00 00 1f 00 00 00 00 1f 00 00     ................
    7244:	00 00 1f 00 00 00 00 1f 00 00 00 00 1f 00 00 00     ................
    7254:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7264:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7274:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7284:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7294:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    72a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    72b4:	00 00 00 00 00 00 00 00 00 00 00 00 1e 00 00 00     ................
    72c4:	00 00 00 00 00 00 00 00 00 00 00 00 f0 ff ff 1f     ................
    72d4:	00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00     ................
    72e4:	f0 ff ff 1f 00 f0 ff ff 1f 00 f0 1f 00 00 00 f0     ................
    72f4:	ff 00 00 00 c0 ff 03 00 00 00 ff 0f 00 00 00 f8     ................
    7304:	3f 00 00 00 e0 7f 00 00 00 80 7f 00 00 00 00 7f     ?...............
    7314:	00 00 00 c0 7f 00 00 00 f8 3f 00 00 00 fe 0f 00     .........?......
    7324:	00 80 ff 03 00 00 e0 ff 00 00 00 f0 1f 00 00 00     ................
    7334:	f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0     ................
    7344:	ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff     ................
    7354:	ff 1f 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7364:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7374:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7384:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7394:	00 00 00 00 1b 00 00 00 00 00 00 00 00 00 00 00     ................
    73a4:	00 00 00 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff     ................
    73b4:	ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff     ................
    73c4:	1f 00 f0 1f 00 00 00 f0 3f 00 00 00 e0 ff 00 00     ........?.......
    73d4:	00 c0 ff 01 00 00 00 ff 03 00 00 00 fe 0f 00 00     ................
    73e4:	00 fc 1f 00 00 00 f0 7f 00 00 00 e0 ff 00 00 00     ................
    73f4:	80 ff 03 00 00 00 ff 07 00 00 00 fc 1f 00 f0 ff     ................
    7404:	ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff     ................
    7414:	1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 00 00 00 00     ................
    7424:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7434:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7444:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7454:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7464:	00 00 00 00 00 00 00 00 00 00 00 00 1c 00 00 00     ................
    7474:	00 00 00 00 00 00 00 00 f0 0f 00 00 00 fe 7f 00     ................
    7484:	00 00 ff ff 00 00 c0 ff ff 03 00 c0 ff ff 03 00     ................
    7494:	e0 ff ff 07 00 f0 ff ff 0f 00 f0 0f f0 0f 00 f0     ................
    74a4:	03 c0 0f 00 f8 01 80 1f 00 f8 01 80 1f 00 f8 00     ................
    74b4:	00 1f 00 f8 00 00 1f 00 f8 00 00 1f 00 f8 00 00     ................
    74c4:	1f 00 f8 01 80 1f 00 f8 01 80 1f 00 f0 03 c0 0f     ................
    74d4:	00 f0 0f f0 0f 00 f0 ff ff 0f 00 e0 ff ff 07 00     ................
    74e4:	c0 ff ff 03 00 c0 ff ff 03 00 00 ff ff 00 00 00     ................
    74f4:	fe 7f 00 00 00 f0 0f 00 00 00 00 00 00 00 00 00     ................
    7504:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7514:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7524:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7534:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7544:	00 00 00 00 19 00 00 00 00 00 00 00 00 00 00 00     ................
    7554:	00 00 00 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff     ................
    7564:	ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff     ................
    7574:	1f 00 f0 ff ff 1f 00 f0 01 1f 00 00 f0 01 1f 00     ................
    7584:	00 f0 01 1f 00 00 f0 01 1f 00 00 f0 01 1f 00 00     ................
    7594:	f0 01 1f 00 00 f0 83 1f 00 00 f0 c7 1f 00 00 f0     ................
    75a4:	ff 0f 00 00 e0 ff 0f 00 00 e0 ff 0f 00 00 c0 ff     ................
    75b4:	07 00 00 c0 ff 03 00 00 80 ff 01 00 00 00 7e 00     ..............~.
    75c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    75d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    75e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    75f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7604:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7614:	00 00 00 00 00 00 00 00 00 00 00 00 1c 00 00 00     ................
    7624:	00 00 00 00 00 00 00 00 f0 0f 00 00 00 fe 7f 00     ................
    7634:	00 00 ff ff 00 00 c0 ff ff 03 00 c0 ff ff 03 00     ................
    7644:	e0 ff ff 07 00 f0 ff ff 0f 00 f0 0f f0 0f 00 f0     ................
    7654:	03 c0 0f 00 f8 01 80 1f 00 f8 01 80 1f 00 f8 00     ................
    7664:	00 1f 00 f8 00 00 ff 00 f8 00 00 ff 01 f8 00 00     ................
    7674:	ff 03 f8 01 80 ff 07 f8 01 80 ff 0f f0 03 c0 ff     ................
    7684:	0f f0 0f f0 8f 0f f0 ff ff 0f 0f e0 ff ff 07 0f     ................
    7694:	c0 ff ff 03 0f c0 ff ff 03 0f 00 ff ff 80 0f 00     ................
    76a4:	fe 7f 80 0f 00 f0 0f 00 00 00 00 00 00 00 00 00     ................
    76b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    76c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    76d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    76e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    76f4:	00 00 00 00 1b 00 00 00 00 00 00 00 00 00 00 00     ................
    7704:	00 00 00 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff     ................
    7714:	ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff     ................
    7724:	1f 00 f0 ff ff 1f 00 f0 81 0f 00 00 f0 81 0f 00     ................
    7734:	00 f0 81 3f 00 00 f0 81 7f 00 00 f0 81 ff 00 00     ...?............
    7744:	f0 c1 ff 03 00 f0 c3 ff 07 00 f0 ff ff 0f 00 f0     ................
    7754:	ff ff 1f 00 e0 ff fb 1f 00 e0 ff e1 1f 00 c0 ff     ................
    7764:	c1 1f 00 80 ff 80 1f 00 00 3f 00 1e 00 00 00 00     .........?......
    7774:	1c 00 00 00 00 18 00 00 00 00 10 00 00 00 00 00     ................
    7784:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7794:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    77a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    77b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    77c4:	00 00 00 00 00 00 00 00 00 00 00 00 18 00 00 00     ................
    77d4:	00 00 00 00 00 00 00 00 3f e0 07 00 80 7f c0 0f     ........?.......
    77e4:	00 c0 ff c0 0f 00 e0 ff 81 0f 00 f0 ff 83 0f 00     ................
    77f4:	f0 ff 83 1f 00 f0 ff 03 1f 00 f8 f9 07 1f 00 f8     ................
    7804:	f0 07 1f 00 f8 f0 07 1f 00 f8 e0 07 1f 00 f8 e0     ................
    7814:	07 1f 00 f8 e0 0f 1f 00 f8 e0 0f 1f 00 f8 e0 9f     ................
    7824:	1f 00 f8 c1 ff 0f 00 f8 c1 ff 0f 00 f0 c1 ff 07     ................
    7834:	00 f0 83 ff 07 00 f0 83 ff 03 00 e0 07 ff 01 00     ................
    7844:	00 00 7c 00 00 00 00 00 00 00 00 00 00 00 00 00     ..|.............
    7854:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7864:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7874:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7884:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7894:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    78a4:	00 00 00 00 18 00 00 00 00 00 f0 01 00 00 00 f0     ................
    78b4:	01 00 00 00 f0 01 00 00 00 f0 01 00 00 00 f0 01     ................
    78c4:	00 00 00 f0 01 00 00 00 f0 01 00 00 00 f0 01 00     ................
    78d4:	00 00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f     ................
    78e4:	00 f0 ff ff 1f 00 f0 ff ff 1f 00 f0 ff ff 1f 00     ................
    78f4:	f0 ff ff 1f 00 f0 01 00 00 00 f0 01 00 00 00 f0     ................
    7904:	01 00 00 00 f0 01 00 00 00 f0 01 00 00 00 f0 01     ................
    7914:	00 00 00 f0 01 00 00 00 f0 01 00 00 00 00 00 00     ................
    7924:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7934:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7944:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7954:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7964:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7974:	00 00 00 00 00 00 00 00 00 00 00 00 19 00 00 00     ................
    7984:	00 00 00 00 00 00 00 00 00 00 00 00 f0 ff 7f 00     ................
    7994:	00 f0 ff ff 01 00 f0 ff ff 03 00 f0 ff ff 07 00     ................
    79a4:	f0 ff ff 0f 00 f0 ff ff 0f 00 f0 ff ff 0f 00 00     ................
    79b4:	00 c0 1f 00 00 00 80 1f 00 00 00 00 1f 00 00 00     ................
    79c4:	00 1f 00 00 00 00 1f 00 00 00 00 1f 00 00 00 80     ................
    79d4:	1f 00 00 00 c0 1f 00 f0 ff ff 0f 00 f0 ff ff 0f     ................
    79e4:	00 f0 ff ff 0f 00 f0 ff ff 07 00 f0 ff ff 03 00     ................
    79f4:	f0 ff ff 01 00 f0 ff 7f 00 00 00 00 00 00 00 00     ................
    7a04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7a14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7a24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7a34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7a44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7a54:	00 00 00 00 1b 10 00 00 00 00 f0 00 00 00 00 f0     ................
    7a64:	03 00 00 00 f0 1f 00 00 00 f0 ff 00 00 00 f0 ff     ................
    7a74:	03 00 00 f0 ff 1f 00 00 f0 ff 7f 00 00 80 ff ff     ................
    7a84:	03 00 00 fe ff 1f 00 00 f0 ff 1f 00 00 80 ff 1f     ................
    7a94:	00 00 00 fc 1f 00 00 00 f0 1f 00 00 00 e0 1f 00     ................
    7aa4:	00 00 fc 1f 00 00 80 ff 1f 00 00 f0 ff 1f 00 00     ................
    7ab4:	fc ff 03 00 80 ff 7f 00 00 f0 ff 1f 00 00 f0 ff     ................
    7ac4:	03 00 00 f0 ff 00 00 00 f0 1f 00 00 00 f0 03 00     ................
    7ad4:	00 00 f0 00 00 00 00 10 00 00 00 00 00 00 00 00     ................
    7ae4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7af4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7b04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7b14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7b24:	00 00 00 00 00 00 00 00 00 00 00 00 27 00 00 00     ............'...
    7b34:	00 00 30 00 00 00 00 f0 01 00 00 00 f0 1f 00 00     ..0.............
    7b44:	00 f0 ff 01 00 00 f0 ff 0f 00 00 f0 ff ff 00 00     ................
    7b54:	f0 ff ff 07 00 e0 ff ff 1f 00 00 fe ff 1f 00 00     ................
    7b64:	c0 ff 1f 00 00 00 fc 1f 00 00 00 f0 1f 00 00 00     ................
    7b74:	fe 1f 00 00 c0 ff 1f 00 00 fc ff 0f 00 80 ff ff     ................
    7b84:	01 00 f0 ff 1f 00 00 f0 ff 03 00 00 f0 3f 00 00     .............?..
    7b94:	00 f0 7f 00 00 00 f0 ff 03 00 00 f0 ff 3f 00 00     .............?..
    7ba4:	c0 ff ff 01 00 00 fc ff 0f 00 00 c0 ff 1f 00 00     ................
    7bb4:	00 fe 1f 00 00 00 e0 1f 00 00 00 fe 1f 00 00 e0     ................
    7bc4:	ff 1f 00 00 fe ff 1f 00 e0 ff ff 1f 00 f0 ff ff     ................
    7bd4:	07 00 f0 ff ff 00 00 f0 ff 0f 00 00 f0 ff 01 00     ................
    7be4:	00 f0 1f 00 00 00 f0 01 00 00 00 30 00 00 00 00     ...........0....
    7bf4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7c04:	00 00 00 00 1b 10 00 00 10 00 30 00 00 18 00 70     ..........0....p
    7c14:	00 00 1c 00 f0 01 00 1f 00 f0 03 80 1f 00 f0 07     ................
    7c24:	c0 1f 00 f0 1f f0 1f 00 f0 3f f8 1f 00 e0 7f fc     .........?......
    7c34:	0f 00 80 ff ff 03 00 00 ff ff 01 00 00 fe ff 00     ................
    7c44:	00 00 f8 3f 00 00 00 f0 1f 00 00 00 f8 3f 00 00     ...?.........?..
    7c54:	00 fe 7f 00 00 00 ff ff 01 00 80 ff ff 03 00 e0     ................
    7c64:	7f fc 0f 00 f0 3f f8 1f 00 f0 0f f0 1f 00 f0 07     .....?..........
    7c74:	c0 1f 00 f0 03 80 1f 00 f0 01 00 1f 00 70 00 00     .............p..
    7c84:	1c 00 30 00 00 18 00 10 00 00 10 00 00 00 00 00     ..0.............
    7c94:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7ca4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7cb4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7cc4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7cd4:	00 00 00 00 00 00 00 00 00 00 00 00 1a 00 00 00     ................
    7ce4:	00 00 10 00 00 00 00 70 00 00 00 00 f0 00 00 00     .......p........
    7cf4:	00 f0 03 00 00 00 f0 0f 00 00 00 f0 3f 00 00 00     ............?...
    7d04:	f0 7f 00 00 00 f0 ff 01 00 00 e0 ff 07 00 00 80     ................
    7d14:	ff ff 1f 00 00 fe ff 1f 00 00 fc ff 1f 00 00 f0     ................
    7d24:	ff 1f 00 00 e0 ff 1f 00 00 f8 ff 1f 00 00 fe ff     ................
    7d34:	1f 00 80 ff 03 00 00 e0 ff 01 00 00 f0 7f 00 00     ................
    7d44:	00 f0 1f 00 00 00 f0 0f 00 00 00 f0 03 00 00 00     ................
    7d54:	f0 00 00 00 00 70 00 00 00 00 10 00 00 00 00 00     .....p..........
    7d64:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7d74:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7d84:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7d94:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7da4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7db4:	00 00 00 00 17 00 00 00 00 00 00 00 00 00 00 00     ................
    7dc4:	00 80 1f 00 f0 01 c0 1f 00 f0 01 e0 1f 00 f0 01     ................
    7dd4:	f8 1f 00 f0 01 fc 1f 00 f0 01 fe 1f 00 f0 81 ff     ................
    7de4:	1f 00 f0 c1 ff 1f 00 f0 e1 ff 1f 00 f0 f9 7f 1f     ................
    7df4:	00 f0 fd 3f 1f 00 f0 ff 0f 1f 00 f0 ff 07 1f 00     ...?............
    7e04:	f0 ff 03 1f 00 f0 ff 00 1f 00 f0 7f 00 1f 00 f0     ................
    7e14:	3f 00 1f 00 f0 0f 00 1f 00 f0 07 00 1f 00 f0 03     ?...............
    7e24:	00 1f 00 00 00 00 1f 00 00 00 00 00 00 00 00 00     ................
    7e34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7e44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7e54:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7e64:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7e74:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7e84:	00 00 00 00 00 00 00 00 00 00 00 00 0f 00 00 00     ................
    7e94:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7ea4:	00 fc ff ff ff 0f fc ff ff ff 0f fc ff ff ff 0f     ................
    7eb4:	fc ff ff ff 0f fc ff ff ff 0f 3c 00 00 00 0f 3c     ..........<....<
    7ec4:	00 00 00 0f 3c 00 00 00 0f 3c 00 00 00 0f 3c 00     ....<....<....<.
    7ed4:	00 00 0f 3c 00 00 00 0f 00 00 00 00 00 00 00 00     ...<............
    7ee4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7ef4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7f04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7f14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7f24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7f34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7f44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7f54:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7f64:	00 00 00 00 16 00 00 00 00 00 00 00 00 00 00 00     ................
    7f74:	00 00 00 00 04 00 00 00 00 3c 00 00 00 00 fc 00     .........<......
    7f84:	00 00 00 fc 03 00 00 00 fc 1f 00 00 00 fc 7f 00     ................
    7f94:	00 00 e0 ff 03 00 00 80 ff 0f 00 00 00 fc 7f 00     ................
    7fa4:	00 00 f0 ff 01 00 00 c0 ff 07 00 00 00 fe 3f 00     ..............?.
    7fb4:	00 00 f8 ff 00 00 00 c0 ff 07 00 00 00 ff 07 00     ................
    7fc4:	00 00 f8 07 00 00 00 e0 07 00 00 00 80 07 00 00     ................
    7fd4:	00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7fe4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    7ff4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8004:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8014:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8024:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8034:	00 00 00 00 00 00 00 00 00 00 00 00 0e 00 00 00     ................
    8044:	00 00 00 00 00 00 00 00 00 00 00 00 3c 00 00 00     ............<...
    8054:	0f 3c 00 00 00 0f 3c 00 00 00 0f 3c 00 00 00 0f     .<....<....<....
    8064:	3c 00 00 00 0f 3c 00 00 00 0f fc ff ff ff 0f fc     <....<..........
    8074:	ff ff ff 0f fc ff ff ff 0f fc ff ff ff 0f fc ff     ................
    8084:	ff ff 0f 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8094:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    80a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    80b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    80c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    80d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    80e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    80f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8104:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8114:	00 00 00 00 1b 00 00 00 00 00 00 00 00 00 00 00     ................
    8124:	00 00 00 00 00 00 04 00 00 00 00 06 00 00 00 80     ................
    8134:	07 00 00 00 c0 07 00 00 00 f0 07 00 00 00 fc 07     ................
    8144:	00 00 00 fe 01 00 00 80 ff 00 00 00 c0 3f 00 00     .............?..
    8154:	00 f0 1f 00 00 00 f0 07 00 00 00 f0 01 00 00 00     ................
    8164:	f0 03 00 00 00 f0 0f 00 00 00 e0 1f 00 00 00 c0     ................
    8174:	7f 00 00 00 00 ff 00 00 00 00 fe 03 00 00 00 f8     ................
    8184:	07 00 00 00 f0 07 00 00 00 c0 07 00 00 00 80 07     ................
    8194:	00 00 00 00 06 00 00 00 00 04 00 00 00 00 00 00     ................
    81a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    81b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    81c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    81d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    81e4:	00 00 00 00 00 00 00 00 00 00 00 00 19 00 00 00     ................
    81f4:	80 07 00 00 00 80 07 00 00 00 80 07 00 00 00 80     ................
    8204:	07 00 00 00 80 07 00 00 00 80 07 00 00 00 80 07     ................
    8214:	00 00 00 80 07 00 00 00 80 07 00 00 00 80 07 00     ................
    8224:	00 00 80 07 00 00 00 80 07 00 00 00 80 07 00 00     ................
    8234:	00 80 07 00 00 00 80 07 00 00 00 80 07 00 00 00     ................
    8244:	80 07 00 00 00 80 07 00 00 00 80 07 00 00 00 80     ................
    8254:	07 00 00 00 80 07 00 00 00 80 07 00 00 00 80 07     ................
    8264:	00 00 00 80 07 00 00 00 80 07 00 00 00 00 00 00     ................
    8274:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8284:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8294:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    82a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    82b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    82c4:	00 00 00 00 10 00 00 00 00 00 00 00 00 00 00 00     ................
    82d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    82e4:	00 00 00 01 00 00 00 00 03 00 00 00 00 07 00 00     ................
    82f4:	00 00 0f 00 00 00 00 1f 00 00 00 00 7f 00 00 00     ................
    8304:	00 7e 00 00 00 00 78 00 00 00 00 70 00 00 00 00     .~....x....p....
    8314:	40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     @...............
    8324:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8334:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8344:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8354:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8364:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8374:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8384:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8394:	00 00 00 00 00 00 00 00 00 00 00 00 14 00 00 00     ................
    83a4:	00 00 00 00 00 00 00 00 00 f0 03 00 00 00 f8 07     ................
    83b4:	00 00 3c fc 0f 00 00 3c fe 1f 00 00 1e fe 1f 00     ..<....<........
    83c4:	00 1e fe 1f 00 00 1e 1e 1f 00 00 1e 1f 1e 00 00     ................
    83d4:	1e 0f 1e 00 00 1e 0f 1e 00 00 1e 0f 0e 00 00 3e     ...............>
    83e4:	0f 07 00 00 fe ff 1f 00 00 fc ff 1f 00 00 fc ff     ................
    83f4:	1f 00 00 fc ff 1f 00 00 f8 ff 1f 00 00 e0 ff 1f     ................
    8404:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8414:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8424:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8434:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8444:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8454:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8464:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8474:	00 00 00 00 16 00 00 00 00 00 00 00 00 00 00 00     ................
    8484:	00 00 00 00 fc ff ff 1f 00 fc ff ff 1f 00 fc ff     ................
    8494:	ff 1f 00 fc ff ff 1f 00 fc ff ff 1f 00 fc ff ff     ................
    84a4:	1f 00 00 38 00 0e 00 00 1c 00 1e 00 00 1c 00 1e     ...8............
    84b4:	00 00 1e 00 1e 00 00 1e 00 1e 00 00 3e 00 1f 00     ............>...
    84c4:	00 7e c0 1f 00 00 fe ff 1f 00 00 fe ff 0f 00 00     .~..............
    84d4:	fc ff 07 00 00 f8 ff 03 00 00 f0 ff 01 00 00 80     ................
    84e4:	7f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    84f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8504:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8514:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8524:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8534:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8544:	00 00 00 00 00 00 00 00 00 00 00 00 14 00 00 00     ................
    8554:	00 00 00 00 00 00 00 00 00 7f 00 00 00 e0 ff 01     ................
    8564:	00 00 f0 ff 03 00 00 f8 ff 07 00 00 f8 ff 07 00     ................
    8574:	00 fc ff 0f 00 00 fc c0 0f 00 00 3e 00 1f 00 00     ...........>....
    8584:	3e 00 1f 00 00 1e 00 1e 00 00 1e 00 1e 00 00 1e     >...............
    8594:	00 1e 00 00 1e 00 1e 00 00 1e 00 1e 00 00 3e 00     ..............>.
    85a4:	1f 00 00 3c 00 0f 00 00 7c 80 0f 00 00 fc c0 0f     ...<....|.......
    85b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    85c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    85d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    85e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    85f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8604:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8614:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8624:	00 00 00 00 15 00 00 00 00 00 00 00 00 00 00 00     ................
    8634:	80 7f 00 00 00 e0 ff 03 00 00 f0 ff 07 00 00 f8     ................
    8644:	ff 0f 00 00 fc ff 0f 00 00 fc ff 1f 00 00 fe 80     ................
    8654:	1f 00 00 3e 00 1f 00 00 1e 00 1e 00 00 1e 00 1e     ...>............
    8664:	00 00 1e 00 1e 00 00 1c 00 0e 00 00 1c 00 07 00     ................
    8674:	fc ff ff 1f 00 fc ff ff 1f 00 fc ff ff 1f 00 fc     ................
    8684:	ff ff 1f 00 fc ff ff 1f 00 fc ff ff 1f 00 00 00     ................
    8694:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    86a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    86b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    86c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    86d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    86e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    86f4:	00 00 00 00 00 00 00 00 00 00 00 00 15 00 00 00     ................
    8704:	00 00 00 00 00 00 00 00 00 7f 00 00 00 e0 ff 01     ................
    8714:	00 00 f0 ff 03 00 00 f8 ff 07 00 00 fc ff 0f 00     ................
    8724:	00 fc ff 0f 00 00 7c 9e 0f 00 00 3e 1e 1f 00 00     ......|....>....
    8734:	1e 1e 1f 00 00 1e 1e 1e 00 00 1e 1e 1e 00 00 1e     ................
    8744:	1e 1e 00 00 7e 1e 1e 00 00 fe 1f 1e 00 00 fc 1f     ....~...........
    8754:	1e 00 00 fc 1f 1f 00 00 f8 1f 0f 00 00 f0 9f 0f     ................
    8764:	00 00 80 df 0f 00 00 00 00 00 00 00 00 00 00 00     ................
    8774:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8784:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8794:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    87a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    87b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    87c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    87d4:	00 00 00 00 10 00 3c 00 00 00 00 3c 00 00 00 00     ......<....<....
    87e4:	3c 00 00 00 c0 ff ff 1f 00 f0 ff ff 1f 00 f8 ff     <...............
    87f4:	ff 1f 00 f8 ff ff 1f 00 fc ff ff 1f 00 fc ff ff     ................
    8804:	1f 00 7c 3c 00 00 00 3c 3c 00 00 00 3c 3c 00 00     ..|<...<<...<<..
    8814:	00 3c 3c 00 00 00 3c 3c 00 00 00 3c 00 00 00 00     .<<...<<...<....
    8824:	3c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     <...............
    8834:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8844:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8854:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8864:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8874:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8884:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8894:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    88a4:	00 00 00 00 00 00 00 00 00 00 00 00 15 00 00 00     ................
    88b4:	00 00 00 00 00 00 00 00 80 7f 00 00 00 e0 ff 03     ................
    88c4:	00 00 f8 ff 87 07 00 f8 ff 8f 0f 00 fc ff 0f 0f     ................
    88d4:	00 fe ff 1f 0f 00 fe 80 1f 0f 00 3e 00 1f 0f 00     ...........>....
    88e4:	1e 00 1e 0f 00 1e 00 1e 0f 00 1e 00 1e 0f 00 1c     ................
    88f4:	00 8e 0f 00 1c 00 c7 0f 00 fc ff ff 07 00 fc ff     ................
    8904:	ff 07 00 fc ff ff 07 00 fc ff ff 03 00 fc ff ff     ................
    8914:	01 00 fc ff 7f 00 00 00 00 00 00 00 00 00 00 00     ................
    8924:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8934:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8944:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8954:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8964:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8974:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8984:	00 00 00 00 16 00 00 00 00 00 00 00 00 00 00 00     ................
    8994:	00 00 00 00 fc ff ff 1f 00 fc ff ff 1f 00 fc ff     ................
    89a4:	ff 1f 00 fc ff ff 1f 00 fc ff ff 1f 00 fc ff ff     ................
    89b4:	1f 00 00 78 00 00 00 00 38 00 00 00 00 3c 00 00     ...x....8....<..
    89c4:	00 00 3c 00 00 00 00 3e 00 00 00 00 3e 00 00 00     ..<....>....>...
    89d4:	00 7e 00 00 00 00 fe ff 1f 00 00 fe ff 1f 00 00     .~..............
    89e4:	fc ff 1f 00 00 fc ff 1f 00 00 f8 ff 1f 00 00 e0     ................
    89f4:	ff 1f 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8a04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8a14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8a24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8a34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8a44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8a54:	00 00 00 00 00 00 00 00 00 00 00 00 09 00 00 00     ................
    8a64:	00 00 00 00 00 00 00 00 00 00 00 00 7c fc ff 1f     ............|...
    8a74:	00 7c fc ff 1f 00 7c fc ff 1f 00 7c fc ff 1f 00     .|....|....|....
    8a84:	7c fc ff 1f 00 7c fc ff 1f 00 00 00 00 00 00 00     |....|..........
    8a94:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8aa4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8ab4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8ac4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8ad4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8ae4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8af4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8b04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8b14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8b24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8b34:	00 00 00 00 0b 00 00 00 00 0f 00 3c 00 00 0f 00     ...........<....
    8b44:	3c 00 00 0f 00 3c 00 00 0f 00 3c 00 80 0f 7c fc     <....<....<...|.
    8b54:	ff ff 0f 7c fc ff ff 0f 7c fc ff ff 07 7c fc ff     ...|....|....|..
    8b64:	ff 07 7c fc ff ff 03 7c fc ff ff 00 00 00 00 00     ..|....|........
    8b74:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8b84:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8b94:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8ba4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8bb4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8bc4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8bd4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8be4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8bf4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8c04:	00 00 00 00 00 00 00 00 00 00 00 00 17 00 00 00     ................
    8c14:	00 00 00 00 00 00 00 00 00 00 00 00 fc ff ff 1f     ................
    8c24:	00 fc ff ff 1f 00 fc ff ff 1f 00 fc ff ff 1f 00     ................
    8c34:	fc ff ff 1f 00 fc ff ff 1f 00 00 00 3c 00 00 00     ............<...
    8c44:	00 1e 00 00 00 00 3f 00 00 00 80 ff 00 00 00 e0     ......?.........
    8c54:	ff 01 00 00 f0 ff 07 00 00 f8 ff 1f 00 00 fc f9     ................
    8c64:	1f 00 00 fc e0 1f 00 00 7c c0 1f 00 00 3c 00 1f     ........|....<..
    8c74:	00 00 1c 00 1e 00 00 0c 00 18 00 00 04 00 10 00     ................
    8c84:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8c94:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8ca4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8cb4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8cc4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8cd4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8ce4:	00 00 00 00 09 00 00 00 00 00 00 00 00 00 00 00     ................
    8cf4:	00 00 00 00 fc ff ff 1f 00 fc ff ff 1f 00 fc ff     ................
    8d04:	ff 1f 00 fc ff ff 1f 00 fc ff ff 1f 00 fc ff ff     ................
    8d14:	1f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8d24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8d34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8d44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8d54:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8d64:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8d74:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8d84:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8d94:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8da4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8db4:	00 00 00 00 00 00 00 00 00 00 00 00 22 00 00 00     ............"...
    8dc4:	00 00 00 00 00 00 00 00 fc ff 1f 00 00 fc ff 1f     ................
    8dd4:	00 00 fc ff 1f 00 00 fc ff 1f 00 00 fc ff 1f 00     ................
    8de4:	00 fc ff 1f 00 00 78 00 00 00 00 38 00 00 00 00     ......x....8....
    8df4:	3c 00 00 00 00 3c 00 00 00 00 3e 00 00 00 00 3e     <....<....>....>
    8e04:	00 00 00 00 7e 00 00 00 00 fe ff 1f 00 00 fe ff     ....~...........
    8e14:	1f 00 00 fc ff 1f 00 00 fc ff 1f 00 00 f8 ff 1f     ................
    8e24:	00 00 f0 ff 1f 00 00 78 00 00 00 00 38 00 00 00     .......x....8...
    8e34:	00 3c 00 00 00 00 3c 00 00 00 00 3e 00 00 00 00     .<....<....>....
    8e44:	3e 00 00 00 00 7e 00 00 00 00 fe ff 1f 00 00 fe     >....~..........
    8e54:	ff 1f 00 00 fc ff 1f 00 00 fc ff 1f 00 00 f8 ff     ................
    8e64:	1f 00 00 e0 ff 1f 00 00 00 00 00 00 00 00 00 00     ................
    8e74:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8e84:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8e94:	00 00 00 00 16 00 00 00 00 00 00 00 00 00 00 00     ................
    8ea4:	00 00 00 00 00 fc ff 1f 00 00 fc ff 1f 00 00 fc     ................
    8eb4:	ff 1f 00 00 fc ff 1f 00 00 fc ff 1f 00 00 fc ff     ................
    8ec4:	1f 00 00 78 00 00 00 00 38 00 00 00 00 3c 00 00     ...x....8....<..
    8ed4:	00 00 3c 00 00 00 00 3e 00 00 00 00 3e 00 00 00     ..<....>....>...
    8ee4:	00 7e 00 00 00 00 fe ff 1f 00 00 fe ff 1f 00 00     .~..............
    8ef4:	fc ff 1f 00 00 fc ff 1f 00 00 f8 ff 1f 00 00 e0     ................
    8f04:	ff 1f 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8f14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8f24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8f34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8f44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8f54:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8f64:	00 00 00 00 00 00 00 00 00 00 00 00 16 00 00 00     ................
    8f74:	00 00 00 00 00 00 00 00 80 7f 00 00 00 e0 ff 01     ................
    8f84:	00 00 f0 ff 03 00 00 f8 ff 07 00 00 fc ff 0f 00     ................
    8f94:	00 fc ff 0f 00 00 fe 80 1f 00 00 3e 00 1f 00 00     ...........>....
    8fa4:	1e 00 1e 00 00 1e 00 1e 00 00 1e 00 1e 00 00 1e     ................
    8fb4:	00 1e 00 00 3e 00 1f 00 00 7e 80 1f 00 00 fc ff     ....>....~......
    8fc4:	0f 00 00 fc ff 0f 00 00 f8 ff 07 00 00 f0 ff 03     ................
    8fd4:	00 00 e0 ff 01 00 00 80 7f 00 00 00 00 00 00 00     ................
    8fe4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    8ff4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9004:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9014:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9024:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9034:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9044:	00 00 00 00 16 00 00 00 00 00 00 00 00 00 00 00     ................
    9054:	00 00 00 00 00 fc ff ff 0f 00 fc ff ff 0f 00 fc     ................
    9064:	ff ff 0f 00 fc ff ff 0f 00 fc ff ff 0f 00 fc ff     ................
    9074:	ff 0f 00 30 00 0e 00 00 18 00 0e 00 00 1c 00 1e     ...0............
    9084:	00 00 1e 00 1e 00 00 1e 00 1e 00 00 3e 00 1f 00     ............>...
    9094:	00 7e c0 1f 00 00 fe ff 0f 00 00 fe ff 0f 00 00     .~..............
    90a4:	fc ff 07 00 00 f8 ff 03 00 00 f0 ff 01 00 00 80     ................
    90b4:	7f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    90c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    90d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    90e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    90f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9104:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9114:	00 00 00 00 00 00 00 00 00 00 00 00 15 00 00 00     ................
    9124:	00 00 00 00 00 00 00 00 80 7f 00 00 00 e0 ff 03     ................
    9134:	00 00 f0 ff 07 00 00 f8 ff 0f 00 00 fc ff 0f 00     ................
    9144:	00 fc ff 1f 00 00 fe 80 1f 00 00 3e 00 1f 00 00     ...........>....
    9154:	1e 00 1e 00 00 1e 00 1e 00 00 1e 00 0e 00 00 1c     ................
    9164:	00 0e 00 00 18 00 07 00 00 fc ff ff 0f 00 fc ff     ................
    9174:	ff 0f 00 fc ff ff 0f 00 fc ff ff 0f 00 fc ff ff     ................
    9184:	0f 00 fc ff ff 0f 00 00 00 00 00 00 00 00 00 00     ................
    9194:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    91a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    91b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    91c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    91d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    91e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    91f4:	00 00 00 00 10 00 00 00 00 00 00 00 00 00 00 00     ................
    9204:	00 00 00 00 00 fc ff 1f 00 00 fc ff 1f 00 00 fc     ................
    9214:	ff 1f 00 00 fc ff 1f 00 00 fc ff 1f 00 00 fc ff     ................
    9224:	1f 00 00 f0 00 00 00 00 70 00 00 00 00 78 00 00     ........p....x..
    9234:	00 00 7c 00 00 00 00 7c 00 00 00 00 7c 00 00 00     ..|....|....|...
    9244:	00 7c 00 00 00 00 00 00 00 00 00 00 00 00 00 00     .|..............
    9254:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9264:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9274:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9284:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9294:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    92a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    92b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    92c4:	00 00 00 00 00 00 00 00 00 00 00 00 14 00 00 00     ................
    92d4:	00 00 00 00 00 00 00 00 e0 c3 0f 00 00 f0 87 0f     ................
    92e4:	00 00 f8 8f 0f 00 00 fc 0f 1f 00 00 fc 1f 1f 00     ................
    92f4:	00 fc 1f 1e 00 00 3e 1f 1e 00 00 1e 1f 1e 00 00     ......>.........
    9304:	1e 3f 1e 00 00 1e 3f 1e 00 00 1e 3e 1e 00 00 1e     .?....?....>....
    9314:	3e 1f 00 00 1e fe 0f 00 00 3e fe 0f 00 00 3c fc     >........>....<.
    9324:	0f 00 00 3c fc 07 00 00 7c f8 03 00 00 00 f0 01     ...<....|.......
    9334:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9344:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9354:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9364:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9374:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9384:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9394:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    93a4:	00 00 00 00 0f 00 3c 00 00 00 00 3c 00 00 00 00     ......<....<....
    93b4:	3c 00 00 00 e0 ff ff 03 00 e0 ff ff 07 00 e0 ff     <...............
    93c4:	ff 0f 00 e0 ff ff 0f 00 e0 ff ff 1f 00 e0 ff ff     ................
    93d4:	1f 00 00 3c 00 1f 00 00 3c 00 1e 00 00 3c 00 1e     ...<....<....<..
    93e4:	00 00 3c 00 1e 00 00 3c 00 1e 00 00 3c 00 1f 00     ..<....<....<...
    93f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9404:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9414:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9424:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9434:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9444:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9454:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9464:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9474:	00 00 00 00 00 00 00 00 00 00 00 00 16 00 00 00     ................
    9484:	00 00 00 00 00 00 00 00 00 00 00 00 00 fc ff 01     ................
    9494:	00 00 fc ff 07 00 00 fc ff 0f 00 00 fc ff 0f 00     ................
    94a4:	00 fc ff 1f 00 00 fc ff 1f 00 00 00 80 1f 00 00     ................
    94b4:	00 00 1f 00 00 00 00 1f 00 00 00 00 1f 00 00 00     ................
    94c4:	00 0f 00 00 00 00 07 00 00 00 80 07 00 00 fc ff     ................
    94d4:	1f 00 00 fc ff 1f 00 00 fc ff 1f 00 00 fc ff 1f     ................
    94e4:	00 00 fc ff 1f 00 00 fc ff 1f 00 00 00 00 00 00     ................
    94f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9504:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9514:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9524:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9534:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9544:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9554:	00 00 00 00 16 00 00 00 00 00 00 04 00 00 00 00     ................
    9564:	3c 00 00 00 00 fc 01 00 00 00 fc 07 00 00 00 fc     <...............
    9574:	3f 00 00 00 fc ff 01 00 00 fc ff 07 00 00 e0 ff     ?...............
    9584:	1f 00 00 00 ff 1f 00 00 00 f8 1f 00 00 00 c0 1f     ................
    9594:	00 00 00 f0 1f 00 00 00 fe 1f 00 00 e0 ff 1f 00     ................
    95a4:	00 fc ff 07 00 00 fc ff 01 00 00 fc 3f 00 00 00     ............?...
    95b4:	fc 07 00 00 00 fc 01 00 00 00 3c 00 00 00 00 04     ..........<.....
    95c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    95d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    95e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    95f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9604:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9614:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9624:	00 00 00 00 00 00 00 00 00 00 00 00 21 00 00 00     ............!...
    9634:	00 00 00 0c 00 00 00 00 7c 00 00 00 00 fc 03 00     ........|.......
    9644:	00 00 fc 3f 00 00 00 fc ff 01 00 00 fc ff 0f 00     ...?............
    9654:	00 f8 ff 1f 00 00 80 ff 1f 00 00 00 f8 1f 00 00     ................
    9664:	00 80 1f 00 00 00 f0 1f 00 00 00 fe 1f 00 00 e0     ................
    9674:	ff 0f 00 00 fc ff 01 00 00 fc 1f 00 00 00 fc 03     ................
    9684:	00 00 00 fc 03 00 00 00 fc 1f 00 00 00 fc ff 01     ................
    9694:	00 00 f0 ff 0f 00 00 00 ff 1f 00 00 00 f8 1f 00     ................
    96a4:	00 00 80 1f 00 00 00 f8 1f 00 00 80 ff 1f 00 00     ................
    96b4:	f8 ff 1f 00 00 fc ff 0f 00 00 fc ff 01 00 00 fc     ................
    96c4:	1f 00 00 00 fc 03 00 00 00 7c 00 00 00 00 0c 00     .........|......
    96d4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    96e4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    96f4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9704:	00 00 00 00 17 00 04 00 10 00 00 0c 00 18 00 00     ................
    9714:	1c 00 1c 00 00 3c 00 1e 00 00 7c 00 1f 00 00 fc     .....<....|.....
    9724:	80 1f 00 00 fc e3 1f 00 00 f8 f7 0f 00 00 e0 ff     ................
    9734:	07 00 00 c0 ff 01 00 00 80 ff 00 00 00 00 7f 00     ................
    9744:	00 00 80 ff 00 00 00 c0 ff 01 00 00 e0 ff 03 00     ................
    9754:	00 f8 f7 0f 00 00 fc e3 1f 00 00 fc 80 1f 00 00     ................
    9764:	7c 00 1f 00 00 3c 00 1e 00 00 1c 00 1c 00 00 0c     |....<..........
    9774:	00 18 00 00 04 00 10 00 00 00 00 00 00 00 00 00     ................
    9784:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9794:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    97a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    97b4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    97c4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    97d4:	00 00 00 00 00 00 00 00 00 00 00 00 16 00 00 00     ................
    97e4:	00 00 00 04 00 00 00 00 3c 00 00 00 00 fc 01 00     ........<.......
    97f4:	00 00 fc 07 00 00 00 fc 3f 00 08 00 fc ff 01 0f     ........?.......
    9804:	00 fc ff c7 0f 00 e0 ff ff 0f 00 00 ff ff 0f 00     ................
    9814:	00 f8 ff 0f 00 00 e0 ff 0f 00 00 f8 ff 03 00 00     ................
    9824:	ff 7f 00 00 e0 ff 1f 00 00 fc ff 03 00 00 fc ff     ................
    9834:	00 00 00 fc 1f 00 00 00 fc 07 00 00 00 fc 00 00     ................
    9844:	00 00 3c 00 00 00 00 04 00 00 00 00 00 00 00 00     ..<.............
    9854:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9864:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9874:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9884:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9894:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    98a4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    98b4:	00 00 00 00 13 00 00 00 00 00 00 3c 00 1e 00 00     ...........<....
    98c4:	3c 00 1f 00 00 3c 80 1f 00 00 3c c0 1f 00 00 3c     <....<....<....<
    98d4:	e0 1f 00 00 3c f0 1f 00 00 3c f8 1f 00 00 3c fc     ....<....<....<.
    98e4:	1e 00 00 3c 7e 1e 00 00 3c 3f 1e 00 00 bc 1f 1e     ...<~...<?......
    98f4:	00 00 fc 0f 1e 00 00 fc 07 1e 00 00 fc 03 1e 00     ................
    9904:	00 fc 01 1e 00 00 fc 00 1e 00 00 7c 00 1e 00 00     ...........|....
    9914:	3c 00 1e 00 00 00 00 00 00 00 00 00 00 00 00 00     <...............
    9924:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9934:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9944:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9954:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9964:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9974:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9984:	00 00 00 00 00 00 00 00 00 00 00 00 16 00 00 00     ................
    9994:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 1e 00     ................
    99a4:	00 00 00 1e 00 00 00 00 1e 00 00 00 00 1e 00 00     ................
    99b4:	00 00 3f 00 00 00 00 3f 00 00 00 80 7f 00 00 c0     ..?....?........
    99c4:	ff ff ff 00 f0 ff f3 ff 03 f8 ff f3 ff 07 f8 ff     ................
    99d4:	e1 ff 07 fc ff c0 ff 0f fc 7f 80 ff 0f fc 00 00     ................
    99e4:	c0 0f 3c 00 00 00 0f 3c 00 00 00 0f 3c 00 00 00     ..<....<....<...
    99f4:	0f 3c 00 00 00 0f 3c 00 00 00 0f 00 00 00 00 00     .<....<.........
    9a04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9a14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9a24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9a34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9a44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9a54:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9a64:	00 00 00 00 0c 00 00 00 00 00 00 00 00 00 00 00     ................
    9a74:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9a84:	00 00 00 00 00 00 00 00 fc ff ff ff 0f fc ff ff     ................
    9a94:	ff 0f fc ff ff ff 0f fc ff ff ff 0f fc ff ff ff     ................
    9aa4:	0f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9ab4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9ac4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9ad4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9ae4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9af4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9b04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9b14:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9b24:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9b34:	00 00 00 00 00 00 00 00 00 00 00 00 16 00 00 00     ................
    9b44:	00 00 00 00 00 00 00 00 00 00 00 00 3c 00 00 00     ............<...
    9b54:	0f 3c 00 00 00 0f 3c 00 00 00 0f 3c 00 00 00 0f     .<....<....<....
    9b64:	3c 00 00 00 0f fc 00 00 c0 0f fc 7f 80 ff 0f fc     <...............
    9b74:	ff c0 ff 0f f8 ff e1 ff 07 f8 ff f3 ff 07 f0 ff     ................
    9b84:	f3 ff 03 c0 ff ff ff 00 00 c0 7f 00 00 00 00 3f     ...............?
    9b94:	00 00 00 00 3f 00 00 00 00 1e 00 00 00 00 1e 00     ....?...........
    9ba4:	00 00 00 1e 00 00 00 00 1e 00 00 00 00 00 00 00     ................
    9bb4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9bc4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9bd4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9be4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9bf4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9c04:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9c14:	00 00 00 00 11 00 00 00 00 00 00 00 00 00 00 00     ................
    9c24:	7f 00 00 00 c0 ff 01 00 00 e0 ff 03 00 00 f0 ff     ................
    9c34:	07 00 00 f8 ff 0f 00 00 f8 80 0f 00 00 78 00 0f     .............x..
    9c44:	00 00 78 00 0f 00 00 78 00 0f 00 00 f8 80 0f 00     ..x....x........
    9c54:	00 f8 ff 0f 00 00 f0 ff 07 00 00 f0 ff 03 00 00     ................
    9c64:	c0 ff 01 00 00 00 7f 00 00 00 00 00 00 00 00 00     ................
    9c74:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9c84:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9c94:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9ca4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9cb4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9cc4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9cd4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9ce4:	00 00 00 00 00 00 00 00 00 00 00 00 0b 00 00 00     ................
    9cf4:	00 00 fe ff ff 1f 00 fe ff ff 1f 00 fe ff ff 1f     ................
    9d04:	00 06 00 00 18 00 06 00 00 18 00 06 00 00 18 00     ................
    9d14:	06 00 00 18 00 fe ff ff 1f 00 fe ff ff 1f 00 fe     ................
    9d24:	ff ff 1f 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9d34:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9d44:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9d54:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9d64:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9d74:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9d84:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9d94:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9da4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9db4:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    9dc4:	00 00 00 00                                         ....

00009dc8 <logo>:
    9dc8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    9dd8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    9de8:	ff ff ff ff ff ff ff ff df ff 96 b5 eb 5a ff ff     .............Z..
    9df8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    9e08:	ff ff ff ff ff ff ff ff da d6 65 29 ff ff df ff     ..........e)....
    9e18:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    9e28:	ff ff de f7 7d ef f7 bd 38 c6 59 ce 38 c6 59 ce     ....}...8.Y.8.Y.
    9e38:	59 ce 59 ce 59 ce 59 ce 59 ce 38 c6 17 be ff ff     Y.Y.Y.Y.Y.8.....
    9e48:	79 ce 59 ce 38 ce 38 ce 59 ce 59 ce 59 ce 59 ce     y.Y.8.8.Y.Y.Y.Y.
    9e58:	59 ce 59 ce 59 ce 59 ce 59 ce 59 ce 59 ce 59 ce     Y.Y.Y.Y.Y.Y.Y.Y.
    9e68:	59 ce 59 ce 59 ce 59 ce 59 ce 59 ce 59 ce 59 ce     Y.Y.Y.Y.Y.Y.Y.Y.
    9e78:	38 c6 ff ff 9e f7 18 c6 58 c6 59 ce 59 ce 58 c6     8.......X.Y.Y.X.
    9e88:	59 ce 59 ce 59 ce 59 ce 59 ce ff ff df ff 38 c6     Y.Y.Y.Y.Y.....8.
    9e98:	38 c6 38 ce 59 ce 59 ce 59 ce 59 ce 59 ce 59 ce     8.8.Y.Y.Y.Y.Y.Y.
    9ea8:	18 be 5d ef ff ff de f7 ff ff ff ff df ff ff ff     ..].............
    9eb8:	75 ad 2c 6b 08 42 a7 39 a6 39 69 52 8e 73 f7 c5     u.,k.B.9.9iR.s..
    9ec8:	ff ff df ff ff ff de f7 ff ff ff ff ff ff ff ff     ................
    9ed8:	de ff df ff ff ff 72 94 69 52 a7 39 a7 39 69 52     ......r.iR.9.9iR
    9ee8:	10 84 7d ef ff ff de f7 ff ff ff ff ff ff ff ff     ..}.............
    9ef8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    9f08:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    9f18:	ff ff ff ff ff ff 6d 6b c3 18 ba d6 ff ff ff ff     ......mk........
    9f28:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    9f38:	ff ff ff ff 34 a5 c3 18 f3 9c ff ff ff ff ff ff     ....4...........
    9f48:	ff ff ff ff ff ff ff ff ff ff ff ff df ff df ff     ................
    9f58:	5d ef 8a 52 a2 10 a2 10 c3 18 c3 18 c3 18 c3 18     ]..R............
    9f68:	c3 18 c3 18 e4 20 62 10 69 4a de f7 51 8c 82 18     ..... b.iJ..Q...
    9f78:	a3 18 c3 20 c3 18 c3 18 c3 18 c3 18 82 18 82 10     ... ............
    9f88:	82 10 82 18 82 10 82 10 82 10 82 10 82 18 82 10     ................
    9f98:	82 18 82 18 a3 18 c3 18 c3 18 c3 18 82 10 db de     ................
    9fa8:	5c e7 8a 52 61 08 e3 18 c3 18 c3 18 c3 18 c3 18     \..Ra...........
    9fb8:	c3 18 82 10 08 42 ff ff ff ff 0c 63 c3 20 a3 18     .....B.....c. ..
    9fc8:	e3 20 c3 18 c3 18 c3 18 c3 18 a3 18 45 29 79 ce     . ..........E)y.
    9fd8:	ff ff df ff df ff de f7 db de 25 29 e4 20 04 21     ..........%). .!
    9fe8:	e4 20 04 21 e4 20 e4 20 a3 18 c3 18 45 29 96 b5     . .!. . ....E)..
    9ff8:	ff ff de f7 ff ff ff ff ff ff ff ff df ff 7d f7     ..............}.
    a008:	a7 39 e3 20 e4 20 e3 20 e3 20 e3 20 c3 18 62 10     .9. . . . . ..b.
    a018:	f3 9c ff ff ff ff ff ff ff ff df ff df ff df ff     ................
    a028:	df ff ff ff ff ff ff ff ff f7 ff f7 ff f7 fe f7     ................
    a038:	fe ff fe ff fe ff de f7 ff ff ff ff ff ff ff ff     ................
    a048:	ff ff 49 4a c3 18 ab 5a ff ff ff ff ff ff df ff     ..IJ...Z........
    a058:	ff ff ff ff ff ff ff ff df ff ff ff ff ff ff ff     ................
    a068:	8e 73 04 21 24 21 de f7 df ff ff ff df ff ff ff     .s.!$!..........
    a078:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    a088:	df ff 6d 6b e4 20 04 21 e4 20 04 21 04 21 e4 20     ..mk. .!. .!.!. 
    a098:	c7 39 7d ef df ff df ff ff ff 4d 6b e3 18 e3 18     .9}.......Mk....
    a0a8:	04 21 e3 18 24 21 e3 18 f3 9c 79 ce 79 ce 59 ce     .!..$!....y.y.Y.
    a0b8:	79 ce 79 ce 79 ce 79 ce 59 ce 9a d6 59 ce d7 bd     y.y.y.y.Y...Y...
    a0c8:	d3 9c aa 52 a3 18 e4 20 e3 18 51 8c de f7 ff ff     ...R... ..Q.....
    a0d8:	7d ef a7 39 04 21 24 21 e3 18 e4 20 e3 18 f3 9c     }..9.!$!... ....
    a0e8:	ff ff ff ff ff ff ff ff df ff 8a 52 04 21 e4 20     ...........R.!. 
    a0f8:	c3 20 c3 20 e3 20 8e 73 ff ff ff ff ff ff ff ff     . . . .s........
    a108:	df ff ba d6 c3 18 04 21 24 21 e4 20 24 21 a3 18     .......!$!. $!..
    a118:	0c 63 75 ad d7 bd 34 a5 4d 6b c3 18 aa 52 9d ef     .cu...4.Mk...R..
    a128:	df ff ff ff de f7 df ff ff ff 71 94 c3 20 04 21     ..........q.. .!
    a138:	04 21 04 21 e4 20 cf 7b 58 c6 d6 b5 28 42 cf 7b     .!.!. .{X...(B.{
    a148:	ff ff ff ff df ff df ff ff ff ff ff ff f7 ff ff     ................
    a158:	df ff 9f ff ff f7 ff f7 ff ef ff ef ff f7 df ff     ................
    a168:	bf ff bf ff ff ff ff ff ff ff ff ff ff ff c3 18     ................
    a178:	24 21 82 10 99 ce df ff ff ff ff ff ff ff ff ff     $!..............
    a188:	ff ff ff ff df ff ff ff de f7 ff ff 28 42 e3 18     ............(B..
    a198:	a3 18 92 94 ff ff ff ff be f7 df ff ff ff ff ff     ................
    a1a8:	ff ff ff ff ff ff ff ff ff ff ff ff de f7 ff ff     ................
    a1b8:	69 4a 04 21 04 21 04 21 04 21 e4 20 14 a5 df ff     iJ.!.!.!.!. ....
    a1c8:	df ff ff ff df ff ff ff 69 4a 04 21 04 21 e3 18     ........iJ.!.!..
    a1d8:	e4 20 24 21 82 10 9a d6 ff ff de f7 ff ff ff ff     . $!............
    a1e8:	ff ff ff ff ff ff ff ff ff ff ff ff be f7 ff ff     ................
    a1f8:	3c e7 e7 39 c3 18 65 29 ff ff de f7 df ff 58 c6     <..9..e)......X.
    a208:	c3 18 04 21 24 21 04 21 a2 10 de f7 ff ff ff ff     ...!$!.!........
    a218:	ff ff ff ff be ff 7d ef c3 20 04 29 24 29 04 21     ......}.. .)$).!
    a228:	a3 18 59 ce ff ff ff ff ff ff ff ff be f7 25 29     ..Y...........%)
    a238:	04 21 e3 18 e4 20 25 29 c3 18 b6 b5 ff ff ff ff     .!... %)........
    a248:	ff ff de f7 ff ff 9d ef 0c 63 86 31 be f7 be f7     .........c.1....
    a258:	df ff df ff ff ff 49 4a c3 20 e4 20 04 21 e3 20     ......IJ. . .!. 
    a268:	4d 6b ff ff df ff de f7 ff ff b2 94 ff ff ff ff     Mk..............
    a278:	df ff ff ff ff f7 ff f7 df ff bf ff ff ff ff ef     ................
    a288:	fe f7 fe ff fe ff df ff bf ff df f7 ff f7 ff ef     ................
    a298:	ff ff ff ff ff ff ff ff db de a3 18 c3 18 45 29     ..............E)
    a2a8:	69 4a ff ff df ff be f7 ff ff ff ff ff ff ff ff     iJ..............
    a2b8:	ff ff ff ff df ff ff ff a3 18 e4 20 24 21 04 21     ........... $!.!
    a2c8:	df ff df ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    a2d8:	ff ff ff ff ff ff ff ff df ff ff ff 34 a5 c3 18     ............4...
    a2e8:	e4 20 04 21 04 21 e3 20 76 b5 ff ff be ff ff ff     . .!.!. v.......
    a2f8:	ff ff be f7 df ff c7 39 c3 18 45 29 e3 18 e3 18     .......9..E)....
    a308:	24 21 82 10 1c e7 ff ff ff ff ff ff ff ff ff ff     $!..............
    a318:	df ff ff ff ff ff de f7 ff ff be f7 ff ff ff ff     ................
    a328:	c7 39 a2 10 ba d6 ff ff be f7 ff ff 65 29 e4 20     .9..........e). 
    a338:	c3 18 e3 18 61 08 9e f7 ff ff ff ff ff ff ff ff     ....a...........
    a348:	ff ff ff ff 29 4a e4 20 c3 18 c3 20 e4 20 d7 bd     ....)J. ... . ..
    a358:	ff ff ff ff ff ff ff ff 92 94 24 21 04 21 e3 18     ..........$!.!..
    a368:	e4 20 c3 18 71 8c ff ff df ff ff ff ff ff ff ff     . ..q...........
    a378:	df ff de f7 ff ff 55 ad 65 29 df ff de f7 ff ff     ......U.e)......
    a388:	ff ff e8 41 25 29 04 21 04 29 04 21 55 ad ff ff     ...A%).!.).!U...
    a398:	df ff ff ff ff ff be f7 ff ff ff ff fe ff fe ff     ................
    a3a8:	ff f7 ff f7 df ff df ff de ff fe f7 fc ff 9b ff     ................
    a3b8:	99 f6 f7 dd f8 dd bb ee 7e ff be ff ff ff ff ff     ........~.......
    a3c8:	ff ff ff ff 75 ad c3 18 04 21 c3 18 a3 18 59 ce     ....u....!....Y.
    a3d8:	df ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    a3e8:	ff ff ba d6 c3 18 04 21 e3 18 04 21 51 8c ff ff     .......!...!Q...
    a3f8:	df ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    a408:	ff ff ff ff df ff de f7 ba d6 c3 18 04 21 04 21     .............!.!
    a418:	04 21 04 21 af 7b ff ff df ff df ff de f7 be f7     .!.!.{..........
    a428:	ff ff be f7 e7 39 c3 18 04 21 04 21 04 21 24 21     .....9...!.!.!$!
    a438:	04 21 3c e7 ff ff ff ff ff ff ff ff ff ff ff ff     .!<.............
    a448:	ff ff ff ff ff ff de f7 ff ff df ff be f7 45 29     ..............E)
    a458:	ef 7b ff ff df ff ff ff 28 42 04 21 24 21 04 21     .{......(B.!$!.!
    a468:	e3 18 f7 bd ff ff ff ff ff ff ff ff df ff de ff     ................
    a478:	cf 7b 04 29 e4 20 04 29 e3 20 b2 9c ff ff ff ff     .{.). .). ......
    a488:	ff ff ff ff 28 42 e4 20 e4 20 04 21 04 21 e4 20     ....(B. . .!.!. 
    a498:	be f7 df ff ff ff df ff df ff ff ff de f7 df ff     ................
    a4a8:	df ff df ff f3 9c 2c 63 ff ff de f7 ff ff cb 62     ......,c.......b
    a4b8:	a3 18 24 29 e4 20 c3 20 34 ad be ff be f7 df ff     ..$). . 4.......
    a4c8:	de f7 de f7 ff ff ff ff fe f7 df ff df ff df ff     ................
    a4d8:	fe f7 bd ff 33 e5 4c e3 89 d1 2b ca 72 d4 18 e6     ....3.L...+.r...
    a4e8:	1b f7 bd ff ff ff de f7 ff ff df ff ff ff ff ff     ................
    a4f8:	ae 73 e4 20 e3 18 04 21 e3 18 8a 52 ff ff ff ff     .s. ...!...R....
    a508:	ff ff ff ff ff ff ff ff ff ff de f7 df ff 55 ad     ..............U.
    a518:	e3 18 04 21 04 21 04 21 e4 20 be f7 df ff df ff     ...!.!.!. ......
    a528:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    a538:	ff ff ff ff ff ff a2 10 04 21 04 21 04 21 04 21     .........!.!.!.!
    a548:	8a 52 ff ff be f7 df ff ff ff ff ff ff ff ff ff     .R..............
    a558:	7d ef 45 29 24 21 04 21 04 21 04 21 c3 18 c7 39     }.E)$!.!.!.!...9
    a568:	9d ef de f7 de f7 be f7 ff ff ff ff ff ff ff ff     ................
    a578:	ff ff ff ff ff ff ff ff df ff 59 ce e3 18 df ff     ..........Y.....
    a588:	ff ff ff ff 8e 73 04 21 e4 20 e4 20 04 21 d3 9c     .....s.!. . .!..
    a598:	ff ff df ff df ff ff ff df ff df ff d3 9c e4 20     ............... 
    a5a8:	c3 20 c3 20 e3 20 2d 6b ff ff ff ff ff ff ff ff     . . . -k........
    a5b8:	04 21 24 21 e3 18 e4 20 e4 20 aa 52 ff ff ff ff     .!$!... . .R....
    a5c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    a5d8:	ff ff ff ff ff ff ff ff df ff 71 94 04 21 04 21     ..........q..!.!
    a5e8:	e4 20 e3 20 10 84 df ff ff ff ff ff ff ff ff ff     . . ............
    a5f8:	ff ff ff ff df f7 ff f7 ff ff 7e ff 31 e4 87 c1     ..........~.1...
    a608:	a5 c9 46 da 39 f6 bf ff 9e ff be ff df ff df ff     ..F.9...........
    a618:	df ff bf ff df ff ff ff ff ff ff ff 28 42 04 21     ............(B.!
    a628:	e3 18 04 21 e3 18 c3 18 38 c6 df ff ff ff ff ff     ...!....8.......
    a638:	ff ff ff ff df ff ff ff ff ff 6d 6b 04 21 04 21     ..........mk.!.!
    a648:	04 21 04 21 e3 18 10 84 ff ff de f7 ff ff ff ff     .!.!............
    a658:	ff ff ff ff ff ff ff ff ff ff ff ff df ff ff ff     ................
    a668:	ff ff e7 39 e4 20 04 21 04 21 04 21 45 29 ff ff     ...9. .!.!.!E)..
    a678:	ff ff df ff ff ff ff ff ff ff ff ff de f7 5c e7     ..............\.
    a688:	e3 18 04 21 e4 20 e3 18 04 21 c3 18 a6 31 be f7     ...!. ...!...1..
    a698:	be f7 ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    a6a8:	ff ff ff ff 9e f7 ff ff 92 94 7d ef df ff ff ff     ..........}.....
    a6b8:	14 a5 e3 18 e4 20 04 21 e3 18 0c 63 ff ff ff ff     ..... .!...c....
    a6c8:	df ff df ff ff ff ff ff 79 ce c3 20 e3 20 e3 20     ........y.. . . 
    a6d8:	04 29 c7 41 ff ff df ff df ff ff ff a3 18 04 21     .).A...........!
    a6e8:	04 21 04 21 e4 20 6d 6b ff ff be f7 ff ff ff ff     .!.!. mk........
    a6f8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    a708:	ff ff ff ff ff ff d7 bd e4 20 04 21 e4 20 e3 20     ......... .!. . 
    a718:	69 52 ff ff ff ff ff ff ff ff ff ff ff ff ff ff     iR..............
    a728:	df f7 de f7 b9 f6 48 ca 25 e9 46 e9 2c db 5a ff     ......H.%.F.,.Z.
    a738:	ff ef ff f7 df f7 df ff ff ff ff f7 ff ef ff ef     ................
    a748:	ff ff ff ff ff ff ff ff c3 18 04 21 e4 20 04 21     ...........!. .!
    a758:	e4 20 24 21 28 42 ff ff ff ff ff ff ff ff ff ff     . $!(B..........
    a768:	ff ff df ff ff ff 29 4a 04 21 04 21 04 21 04 21     ......)J.!.!.!.!
    a778:	e3 18 04 21 be f7 df ff ff ff ff ff ff ff ff ff     ...!............
    a788:	ff ff ff ff ff ff ff ff df ff df ff ff ff 0c 63     ...............c
    a798:	04 21 04 21 04 21 04 21 82 10 7d f7 df ff ff ff     .!.!.!.!..}.....
    a7a8:	ff ff ff ff ff ff ff ff df ff ff ff fb de e4 20     ............... 
    a7b8:	04 21 24 21 e3 18 04 21 04 21 49 4a ff ff df ff     .!$!...!.!IJ....
    a7c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    a7d8:	de f7 df ff ff ff de f7 ff ff de f7 79 ce a3 18     ............y...
    a7e8:	04 21 e4 20 04 21 e7 39 ff ff ff ff ff ff df ff     .!. .!.9........
    a7f8:	ff ff df ff 9d f7 82 18 e4 20 e4 20 24 29 a3 18     ......... . $)..
    a808:	ff ff ff ff df ff ff ff 65 29 04 21 04 21 e4 20     ........e).!.!. 
    a818:	e3 18 6d 6b ff ff be f7 ff ff ff ff ff ff ff ff     ..mk............
    a828:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    a838:	df ff 1c e7 82 10 04 21 e4 20 e4 20 45 29 ff ff     .......!. . E)..
    a848:	ff ff ff ff ff ff ff ff ff ff ff ff ff f7 da fe     ................
    a858:	26 d2 83 f1 a4 e9 68 d2 3d ff bf f7 df f7 be f7     &.....h.=.......
    a868:	de ff de ff de ff de ff de ff be ff df ff ff ff     ................
    a878:	ff ff fb de c3 18 e3 18 04 21 24 21 04 21 e3 18     .........!$!.!..
    a888:	a2 10 18 c6 ff ff ff ff ff ff ff ff de f7 ff ff     ................
    a898:	ff ff e3 18 04 21 04 21 04 21 04 21 e3 18 04 21     .....!.!.!.!...!
    a8a8:	8e 73 ff ff ff ff ff ff ff ff ff ff ff ff ff ff     .s..............
    a8b8:	ff ff ff ff ff ff df ff ff ff 92 94 e4 20 e4 20     ............. . 
    a8c8:	04 21 e4 20 c3 18 59 ce df ff df ff ff ff ff ff     .!. ..Y.........
    a8d8:	ff ff ff ff de f7 df ff de f7 59 ce 82 10 04 21     ..........Y....!
    a8e8:	04 21 24 21 04 21 e4 20 eb 5a ff ff ff ff ff ff     .!$!.!. .Z......
    a8f8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff de f7     ................
    a908:	de f7 ff ff ff ff de f7 be f7 a3 18 e4 20 04 21     ............. .!
    a918:	04 21 82 10 ff ff ff ff ff ff ff ff df ff df ff     .!..............
    a928:	ff ff 65 31 e4 20 c3 20 e4 20 a3 18 da d6 ff ff     ..e1. . . ......
    a938:	df ff ff ff aa 52 04 21 e4 20 e3 18 e4 20 aa 52     .....R.!. ... .R
    a948:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    a958:	ff ff ff ff ff ff ff ff ff ff ff ff df ff ff ff     ................
    a968:	c3 20 24 29 04 21 c3 20 a3 18 7d ef ff ff ff ff     . $).!. ..}.....
    a978:	ff ff ff ff ff ff ff ff de ff 2c e2 87 e9 64 e9     ..........,...d.
    a988:	85 d1 77 e6 ff f7 df ff ff ff ff ff ff ff ff ff     ..w.............
    a998:	ff ff ff ff ff ff ff ff ff ff df ff de ff 55 ad     ..............U.
    a9a8:	e3 20 04 21 e4 20 e4 20 c3 18 ae 73 a7 39 08 42     . .!. . ...s.9.B
    a9b8:	ff ff ff ff ff ff ff ff df ff ff ff ba de a3 18     ................
    a9c8:	04 21 e4 20 e4 20 04 21 08 42 6d 6b c3 18 5d ef     .!. . .!.Bmk..].
    a9d8:	df ff ff ff ff ff df ff ff ff ff ff ff ff ff ff     ................
    a9e8:	de f7 df ff df ff f7 bd e4 20 04 21 e4 20 04 21     ......... .!. .!
    a9f8:	e3 20 f3 9c df ff df ff ff ff ff ff ff ff ff ff     . ..............
    aa08:	ff ff ff ff ff ff ff ff 96 b5 a2 10 e3 18 04 21     ...............!
    aa18:	04 21 c3 18 a2 10 cf 7b ff ff ff ff df ff ff ff     .!.....{........
    aa28:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    aa38:	df ff ff ff ff ff 66 31 04 21 e4 20 e4 20 a3 18     ......f1.!. . ..
    aa48:	fb de df ff df ff ff ff ff ff ff ff ff ff ab 5a     ...............Z
    aa58:	04 21 04 21 04 21 c3 20 96 b5 df ff df ff ff ff     .!.!.!. ........
    aa68:	d3 9c c3 18 e3 18 e4 20 04 21 45 29 75 ad 34 a5     ....... .!E)u.4.
    aa78:	54 a5 34 a5 34 a5 54 a5 55 ad 54 a5 55 ad 34 a5     T.4.4.T.U.T.U.4.
    aa88:	55 ad 55 ad d7 bd ff ff df ff ff ff 49 4a c3 20     U.U.........IJ. 
    aa98:	e4 20 04 21 e3 20 18 c6 ff ff ff ff ff ff ff ff     . .!. ..........
    aaa8:	ff ff ff ff f7 ed 47 c9 66 e9 a5 f1 48 da bc ff     ......G.f...H...
    aab8:	ff ff df ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    aac8:	ff ff ff ff df ff df ff ff ff ae 7b e4 20 04 21     ...........{. .!
    aad8:	04 21 04 21 04 21 13 9d 34 a5 82 10 b6 b5 de f7     .!.!.!..4.......
    aae8:	df ff ff ff df ff ff ff 75 ad c3 20 e4 20 04 21     ........u.. . .!
    aaf8:	04 21 04 21 eb 5a 3c e7 a3 18 6d 6b ff ff ff ff     .!.!.Z<...mk....
    ab08:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff df ff     ................
    ab18:	ff ff 5c e7 82 10 04 29 e4 20 e4 20 e4 20 6d 73     ..\....). . . ms
    ab28:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ab38:	ff ff ff ff ff ff f3 9c c3 18 c3 18 e3 18 04 21     ...............!
    ab48:	24 21 c3 18 51 8c ff ff ff ff ff ff ff ff ff ff     $!..Q...........
    ab58:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ab68:	ff ff cb 5a e4 20 04 21 04 21 c3 20 96 b5 df ff     ...Z. .!.!. ....
    ab78:	ff ff df ff ff ff df ff ff ff f0 83 e4 20 04 21     ............. .!
    ab88:	04 21 e4 20 10 84 ff ff ff ff ff ff 5d ef e4 20     .!. ........].. 
    ab98:	e4 20 04 21 c3 18 04 21 0c 63 0c 63 2c 63 2c 63     . .!...!.c.c,c,c
    aba8:	2c 63 2c 63 4d 6b c7 39 e4 20 e4 20 e4 20 24 21     ,c,cMk.9. . . $!
    abb8:	cb 5a ff ff ff ff ff ff 2d 6b e4 20 04 29 04 21     .Z......-k. .).!
    abc8:	e4 20 d3 9c ff ff ff ff ff ff ff ff ff ff ff ff     . ..............
    abd8:	ce db c8 e1 45 e1 85 e9 6d e3 fe ff df ff df f7     ....E...m.......
    abe8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    abf8:	ff ff de ff ff ff 69 52 e4 20 04 21 04 21 e4 20     ......iR. .!.!. 
    ac08:	61 08 79 ce ff ff 45 29 08 42 ff ff ff ff de f7     a.y...E).B......
    ac18:	ff ff ff ff 8e 73 e4 20 e4 20 04 21 04 21 e4 20     .....s. . .!.!. 
    ac28:	71 8c ff ff 2d 6b 82 10 3c e7 ff ff df ff df ff     q...-k..<.......
    ac38:	ff ff ff ff ff ff ff ff ff ff df ff ff ff ff ff     ................
    ac48:	04 21 04 21 e4 20 e4 20 e4 20 28 4a ff ff ff ff     .!.!. . . (J....
    ac58:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ac68:	ff ff ff ff 51 8c c3 18 04 21 e3 18 a3 18 c3 18     ....Q....!......
    ac78:	c3 18 f3 9c ff ff df ff ff ff ff ff ff ff ff ff     ................
    ac88:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ef 7b     ...............{
    ac98:	e4 20 04 21 04 21 e4 20 6e 73 ff ff df ff df ff     . .!.!. ns......
    aca8:	ff ff df ff ff ff 34 a5 e4 20 04 21 04 21 04 21     ......4.. .!.!.!
    acb8:	cb 5a ff ff ff ff ff ff ff ff cf 7b 82 10 e4 20     .Z.........{... 
    acc8:	e4 20 a3 18 38 c6 ff ff ff ff ff ff ff ff ff ff     . ..8...........
    acd8:	ff ff 92 94 e4 20 04 21 e3 18 c3 18 ae 73 ff ff     ..... .!.....s..
    ace8:	ff ff df ff d3 9c e4 20 e3 20 04 21 04 21 6d 73     ....... . .!.!ms
    acf8:	ff ff ff ff ff ff ff ff ff ff ff ff 68 e2 86 e9     ............h...
    ad08:	65 e9 66 e9 2f dc fe ff df ff ff ff ff ff ff ff     e.f./...........
    ad18:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff df ff     ................
    ad28:	ff ff e4 20 e4 20 04 21 04 21 04 21 c3 18 de f7     ... . .!.!.!....
    ad38:	ff ff 34 a5 a2 10 b6 b5 df ff ff ff ff ff ff ff     ..4.............
    ad48:	49 4a e4 20 04 21 e4 20 e4 20 c3 20 38 c6 be f7     IJ. .!. . . 8...
    ad58:	3c e7 e3 18 0c 63 ff ff ff ff df ff ff ff ff ff     <....c..........
    ad68:	ff ff ff ff ff ff de f7 ff ff ff ff 49 4a e4 20     ............IJ. 
    ad78:	04 21 e4 20 04 21 e4 20 ff ff df ff ff ff ff ff     .!. .!. ........
    ad88:	ff ff ff ff ff ff ff ff ff ff ff ff de f7 ff ff     ................
    ad98:	ff ff ae 73 e4 20 04 21 24 21 04 21 04 21 62 10     ...s. .!$!.!.!b.
    ada8:	54 a5 ff ff ff ff ff ff ff ff ff ff ff ff ff ff     T...............
    adb8:	ff ff ff ff de f7 be f7 ff ff 75 ad c3 20 e4 20     ..........u.. . 
    adc8:	04 21 04 21 a3 18 55 ad ff ff df ff df ff df ff     .!.!..U.........
    add8:	ff ff 30 8c e4 20 04 21 04 21 e4 20 8a 52 ff ff     ..0.. .!.!. .R..
    ade8:	ff ff ff ff be f7 de f7 86 31 04 21 a3 18 25 29     .........1.!..%)
    adf8:	aa 52 ff ff ff ff ff ff ff ff ff ff be f7 ef 7b     .R.............{
    ae08:	25 29 e3 18 04 21 c3 18 b6 b5 ff ff df ff be ff     %)...!..........
    ae18:	38 c6 c3 18 04 21 25 29 c3 20 28 4a ff ff ff ff     8....!%). (J....
    ae28:	ff ff ff ff ff ff ff ff a5 e9 45 e9 85 e1 66 e9     ..........E...f.
    ae38:	ef e3 fe ff df ff ff ff ff ff ff ff ff ff ff ff     ................
    ae48:	ff ff ff ff ff ff ff ff df ff df ff 1b e7 a3 18     ................
    ae58:	04 21 04 21 04 21 04 21 e7 39 ff ff ff ff ff ff     .!.!.!.!.9......
    ae68:	45 29 c7 39 ff ff de f7 df ff ff ff 04 21 c3 20     E).9.........!. 
    ae78:	04 21 04 21 04 21 82 18 7d ef ff ff ff ff ae 73     .!.!.!..}......s
    ae88:	a3 18 da d6 df ff df ff ff ff ff ff ff ff ff ff     ................
    ae98:	ff ff ff ff ff ff ff ff 6d 73 04 21 04 21 e4 20     ........ms.!.!. 
    aea8:	e4 20 c3 18 1c e7 ff ff ff ff ff ff ff ff ff ff     . ..............
    aeb8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    aec8:	ec 62 c3 18 e3 18 04 21 e3 18 24 21 a3 18 d6 b5     .b.....!..$!....
    aed8:	ff ff de f7 df ff de f7 ff ff ff ff ff ff ff ff     ................
    aee8:	df ff ff ff be f7 38 c6 a3 18 e4 20 e4 20 e4 20     ......8.... . . 
    aef8:	e7 41 08 4a 92 94 ff ff ff ff df ff 5d ef 86 31     .A.J........]..1
    af08:	e4 20 04 21 e4 20 c3 20 4d 6b ff ff df ff ff ff     . .!. . Mk......
    af18:	ff ff df ff 1c e7 65 29 04 21 04 21 82 10 db de     ......e).!.!....
    af28:	df ff df ff df ff ff ff ff ff 8a 52 e4 20 e4 20     ...........R. . 
    af38:	24 21 45 29 be f7 de f7 be f7 df ff 9e f7 62 10     $!E)..........b.
    af48:	04 21 e4 20 e4 20 04 21 ff ff ff ff de f7 ff ff     .!. . .!........
    af58:	de f7 ff ff 85 e1 65 f1 85 d9 85 e9 0c e3 fe ff     ......e.........
    af68:	ff ff be f7 ff ff ff ff ff ff ff ff ff ff ff ff     ................
    af78:	ff ff ff ff ff ff de ff 96 b5 e4 20 e4 20 04 21     ........... . .!
    af88:	04 21 04 21 4d 6b df ff ff ff ff ff 75 ad 61 08     .!.!Mk......u.a.
    af98:	96 b5 df ff ff ff db de 82 18 e4 20 04 21 e4 20     ........... .!. 
    afa8:	24 29 25 29 ff ff ff ff ff ff 7d ef c3 18 cb 5a     $)%)......}....Z
    afb8:	ff ff df ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    afc8:	ff ff ff ff 34 ad e4 20 c3 20 04 21 e3 20 a2 18     ....4.. . .!. ..
    afd8:	d7 bd de ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    afe8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff 49 4a     ..............IJ
    aff8:	24 21 04 21 e4 20 24 21 e3 18 e3 18 9a d6 df ff     $!.!. $!........
    b008:	df ff be f7 ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b018:	ff ff 51 8c e3 20 e4 20 e4 20 e4 20 a3 18 be f7     ..Q.. . . . ....
    b028:	86 31 04 21 4d 6b 8e 73 25 29 c3 20 04 21 c3 20     .1.!Mk.s%). .!. 
    b038:	e4 20 82 18 d7 bd de f7 ff ff ff ff ff ff ff ff     . ..............
    b048:	be f7 1c e7 86 31 04 21 04 21 a6 31 be f7 ff ff     .....1.!.!.1....
    b058:	de f7 df ff db de c3 18 04 21 24 21 61 08 f7 bd     .........!$!a...
    b068:	ff ff de f7 ff ff ff ff ff ff 86 31 e4 20 04 21     ...........1. .!
    b078:	e4 20 a3 18 7d ef ff ff ff ff ff ff ff ff ff ff     . ..}...........
    b088:	07 ea 66 f1 84 d9 85 e9 08 da bd ff ff f7 be f7     ..f.............
    b098:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b0a8:	df ff ff ff ef 83 c3 20 e4 20 04 21 04 21 e4 20     ....... . .!.!. 
    b0b8:	f3 9c de f7 ff ff df ff ff ff e7 39 86 31 ff ff     ...........9.1..
    b0c8:	df ff 75 ad e4 20 e4 20 e4 20 e4 20 04 21 ab 5a     ..u.. . . . .!.Z
    b0d8:	ff ff df ff df ff ff ff 10 84 82 10 9a d6 df ff     ................
    b0e8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b0f8:	59 ce a3 18 e3 20 e3 20 04 21 e4 20 92 94 ff ff     Y.... . .!. ....
    b108:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b118:	ff ff ff ff ff ff ff ff de f7 ff ff c7 39 e3 18     .............9..
    b128:	04 21 04 21 e4 20 24 21 24 21 db de ff ff df ff     .!.!. $!$!......
    b138:	ff ff ff ff ff ff ff ff de f7 34 a5 8a 52 a2 10     ..........4..R..
    b148:	e4 20 e4 20 04 21 04 21 a3 18 79 ce df ff ab 5a     . . .!.!..y....Z
    b158:	a3 18 e3 20 04 21 e4 20 04 21 45 29 61 10 8e 73     ... .!. .!E)a..s
    b168:	ff ff ff ff ff ff ff ff df ff be f7 ff ff de f7     ................
    b178:	ff ff cf 7b a3 18 04 21 a6 31 b6 b5 7d ef 38 c6     ...{...!.1..}.8.
    b188:	86 31 04 21 04 21 a3 18 96 b5 ff ff de f7 ff ff     .1.!.!..........
    b198:	08 4a c3 18 25 29 e4 20 e4 20 e4 20 e4 20 c3 20     .J..%). . . . . 
    b1a8:	e4 20 e3 18 c3 18 e4 20 e4 20 a6 31 89 f2 26 e9     . ..... . .1..&.
    b1b8:	c5 d9 84 e9 66 d9 da f6 ff f7 de ff ff ff ff ff     ....f...........
    b1c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b1d8:	8a 52 e4 20 e4 20 e4 20 e4 20 c3 18 9a d6 df ff     .R. . . . ......
    b1e8:	ff ff ff ff df ff 55 ad c3 18 34 a5 df ff cf 7b     ......U...4....{
    b1f8:	04 29 e4 20 e4 20 04 29 e4 20 30 8c ff ff de f7     .). . .). 0.....
    b208:	ff ff ff ff be f7 c3 18 cb 5a ff ff ff ff ff ff     .........Z......
    b218:	ff ff ff ff ff ff ff ff ff ff ff ff be f7 82 18     ................
    b228:	04 21 e4 20 e4 20 e4 20 0c 6b ff ff ff ff ff ff     .!. . . .k......
    b238:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b248:	ff ff ff ff ff ff be f7 de f7 86 31 04 21 04 21     ...........1.!.!
    b258:	04 21 e4 20 04 21 65 29 3c e7 df ff ff ff ff ff     .!. .!e)<.......
    b268:	ff ff ff ff ff ff 55 ad 51 8c 8e 73 cb 5a 29 4a     ......U.Q..s.Z)J
    b278:	65 31 c3 18 62 10 f3 a4 9e f7 ff ff 18 c6 aa 5a     e1..b..........Z
    b288:	c3 18 82 18 82 10 24 29 d3 9c be f7 df ff df ff     ......$)........
    b298:	ff ff ff ff ff ff df ff df ff ff ff 9d ef ff ff     ................
    b2a8:	9d ef 71 8c 08 42 82 10 41 08 61 08 a2 10 a6 31     ..q..B..A.a....1
    b2b8:	10 84 5d ef ff ff df ff df ff ff ff 5d ef 8e 73     ..].........]..s
    b2c8:	82 18 04 21 04 21 c3 20 04 29 04 21 ab 5a 54 a5     ...!.!. .).!.ZT.
    b2d8:	55 ad 34 a5 34 a5 d3 9c 70 dc 86 e1 44 e9 86 e9     U.4.4...p...D...
    b2e8:	27 e1 f0 e3 df ff 9f ff ff ff fe ff fd ff fd f7     '...............
    b2f8:	ff f7 ff ff ff ff fe ff de ff ff ff e4 20 04 29     ............. .)
    b308:	04 29 04 21 04 21 82 18 be f7 ff ff df ff ff ff     .).!.!..........
    b318:	df ff ff ff 65 29 86 31 ff ff 49 52 e4 20 e4 20     ....e).1..IR. . 
    b328:	04 29 e4 20 c3 20 d7 bd ff ff ff ff ff ff ff ff     .). . ..........
    b338:	ff ff 51 8c 82 10 79 ce ff ff de f7 df ff de f7     ..Q...y.........
    b348:	ff ff ff ff ff ff ff ff ff ff 45 31 c3 20 e4 20     ..........E1. . 
    b358:	e3 20 e4 20 86 39 ff ff ff ff ff ff ff ff ff ff     . . .9..........
    b368:	ff ff be f7 df ff ff ff ff ff ff ff ff ff ff ff     ................
    b378:	df ff ff ff ff ff 3c e7 25 29 e4 20 c3 20 e4 20     ......<.%). . . 
    b388:	e4 20 e4 20 a7 39 9e f7 ff ff df ff be f7 be f7     . . .9..........
    b398:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b3a8:	3c e7 7d ef ff ff ff ff ff ff ff ff ff ff 7d ef     <.}...........}.
    b3b8:	7d ef ff ff ff ff ff ff ff ff ff ff ff ff ff ff     }...............
    b3c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b3d8:	ff ff ff ff 7d ef 3c e7 be f7 ff ff ff ff df ff     ....}.<.........
    b3e8:	ff ff ff ff ff ff ff ff de f7 ff ff f7 bd 45 29     ..............E)
    b3f8:	e3 18 04 21 04 21 e4 20 0c 63 ff ff df ff ff ff     ...!.!. .c......
    b408:	ff ff ff ff 58 fe 65 c9 85 e9 85 d9 87 e1 08 ca     ....X.e.........
    b418:	3c ff df f7 ff ff ff ff fe ff fe ff ff ff ff ff     <...............
    b428:	ff ff fe ff ff ff 1c e7 82 18 04 21 e4 20 e4 20     ...........!. . 
    b438:	e4 20 a7 39 ff ff ff ff de f7 ff ff ff ff de f7     . .9............
    b448:	f7 bd 82 10 75 b5 04 21 e4 20 25 29 04 21 e3 20     ....u..!. %).!. 
    b458:	62 10 5d ef ff ff ff ff ff ff ff ff ff ff 9e f7     b.].............
    b468:	25 29 69 4a ff ff ff ff ff ff de f7 ff ff ff ff     %)iJ............
    b478:	ff ff ff ff ff ff ab 5a 24 29 04 21 e4 20 e4 20     .......Z$).!. . 
    b488:	c3 18 de ff ff ff ff ff ff ff ff ff df ff ff ff     ................
    b498:	de f7 df ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b4a8:	df ff ff ff 3c e7 04 21 e3 20 e3 20 04 21 c3 18     ....<..!. . .!..
    b4b8:	c3 18 e8 41 df ff be f7 ff ff ff ff ff ff ff ff     ...A............
    b4c8:	ff ff ff ff ff ff ff ff ff ff ff ff df ff ff ff     ................
    b4d8:	df ff ff ff ff ff de f7 de f7 df ff ff ff df ff     ................
    b4e8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b4f8:	ff ff ff ff ff ff ff ff ff ff ff ff de f7 df ff     ................
    b508:	df ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b518:	ff ff ff ff df ff de f7 ff ff 1c e7 e7 39 c3 18     .............9..
    b528:	c3 18 04 21 a6 31 ff ff df ff df ff ff ff ff ff     ...!.1..........
    b538:	7c ff 69 ca 65 e1 a5 e1 85 e1 66 d9 b3 ec ff f7     |.i.e.....f.....
    b548:	ff f7 ff ff df ff bf ff df ff ff ff ff ff fe ff     ................
    b558:	ff ff 96 b5 e4 20 04 21 04 21 e4 20 e3 20 4d 6b     ..... .!.!. . Mk
    b568:	ff ff ff ff ff ff ff ff de f7 ff ff ff ff e7 39     ...............9
    b578:	45 29 04 29 e4 20 e4 20 04 21 e4 20 25 29 ff ff     E).). . .!. %)..
    b588:	ff ff ff ff ff ff ff ff ff ff de f7 92 94 82 10     ................
    b598:	38 c6 df ff de f7 ff ff ff ff ff ff ff ff ff ff     8...............
    b5a8:	ff ff 10 84 c3 20 04 21 24 29 04 21 a2 18 ba d6     ..... .!$).!....
    b5b8:	ff ff ff ff ff ff ff ff 7d ef e4 20 ff ff df ff     ........}.. ....
    b5c8:	ff ff ff ff ff ff ff ff ff ff df ff ff ff df ff     ................
    b5d8:	df ff ba d6 e4 20 e4 20 04 21 e4 20 c3 20 e4 20     ..... . .!. . . 
    b5e8:	69 4a de f7 de f7 de f7 ff ff ff ff ff ff ff ff     iJ..............
    b5f8:	de f7 df ff ff ff ff ff ff ff ff ff de f7 ff ff     ................
    b608:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff de f7     ................
    b618:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b628:	ff ff ff ff ff ff ff ff df ff de f7 ff ff ff ff     ................
    b638:	de f7 ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b648:	df ff df ff ff ff df ff ff ff aa 52 e4 20 e3 18     ...........R. ..
    b658:	c3 18 df ff ff ff ff ff ff ff ff ff ff ff b3 dc     ................
    b668:	66 e1 64 e9 c4 e9 85 e9 a7 c9 3b ff ff f7 ff f7     f.d.......;.....
    b678:	ff ff bf ff df ff ff f7 ff f7 fe ff ff ff f0 83     ................
    b688:	e4 20 04 29 c3 18 e3 20 04 21 d3 9c ff ff ff ff     . .)... .!......
    b698:	df ff ff ff de f7 de f7 de f7 d7 bd c3 18 04 21     ...............!
    b6a8:	c3 20 e3 20 e4 20 04 29 8a 52 ff ff ff ff ff ff     . . . .).R......
    b6b8:	ff ff ff ff df ff be f7 df ff e4 20 c7 39 ff ff     ........... .9..
    b6c8:	df ff de f7 ff ff ff ff ff ff ff ff df ff 75 b5     ..............u.
    b6d8:	e4 20 e3 20 e4 20 a3 18 e4 20 75 ad ff ff ff ff     . . . ... u.....
    b6e8:	ff ff ff ff ff ff 49 4a 92 94 df ff ff ff ff ff     ......IJ........
    b6f8:	ff ff ff ff be f7 ff ff ff ff df ff df ff ff ff     ................
    b708:	d7 bd c3 18 e4 20 c3 20 04 21 04 21 e3 18 4d 6b     ..... . .!.!..Mk
    b718:	ff ff de f7 ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b728:	ff ff ff ff de f7 ff ff ff ff df ff ff ff ff ff     ................
    b738:	df ff de f7 ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b748:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b758:	ff ff ff ff ff ff df ff ff ff df ff ff ff df ff     ................
    b768:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b778:	ff ff ff ff de f7 ff ff 6d 6b c3 18 a2 10 ba d6     ........mk......
    b788:	df ff ff ff ff ff ff ff df ff 1c ff a7 d1 25 f9     ..............%.
    b798:	a4 e9 64 e1 66 d9 ce e3 ff ff ff f7 df f7 bf ff     ..d.f...........
    b7a8:	df ff de f7 ff f7 fe ff ff ff 69 52 c3 20 e3 20     ..........iR. . 
    b7b8:	e4 20 e4 20 c3 20 79 ce ff ff ff ff ff ff ff ff     . . . y.........
    b7c8:	ff ff df ff ff ff ff ff 28 4a 24 29 c3 20 c3 20     ........(J$). . 
    b7d8:	c3 20 04 21 51 8c df ff ff ff ff ff df ff ff ff     . .!Q...........
    b7e8:	df ff ff ff ff ff 8e 73 c3 18 b2 94 ff ff be f7     .......s........
    b7f8:	be f7 ff ff be f7 ff ff df ff fb de c3 18 e4 20     ............... 
    b808:	e4 20 c3 18 e3 20 cf 7b ff ff df ff ff ff ff ff     . ... .{........
    b818:	ff ff d3 9c c3 18 3c e7 df ff ff ff df ff df ff     ......<.........
    b828:	ff ff ff ff ff ff ff ff df ff ff ff ff ff 34 ad     ..............4.
    b838:	c3 18 04 21 c3 18 e4 20 04 21 a2 10 ef 7b be f7     ...!... .!...{..
    b848:	df ff df ff ff ff de f7 ff ff ff ff ff ff ff ff     ................
    b858:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b868:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b878:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b888:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b898:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b8a8:	df ff df ff ff ff 8e 73 c3 18 75 ad de f7 df ff     .......s..u.....
    b8b8:	ff ff ff ff ff ff be ff 31 ec 46 e9 64 e9 85 e1     ........1.F.d...
    b8c8:	86 e1 24 d9 17 ee dd ff ff f7 df f7 df ff fe f7     ..$.............
    b8d8:	fe f7 de ff 9e f7 82 18 24 29 24 29 25 29 04 21     ........$)$)%).!
    b8e8:	82 10 db de ff ff de f7 df ff df ff be f7 df ff     ................
    b8f8:	ff ff ff ff ec 62 e3 20 c3 20 e4 20 24 29 e4 20     .....b. . . $). 
    b908:	76 b5 df ff de f7 ff ff de f7 df ff ff ff be f7     v...............
    b918:	de f7 f7 bd 24 21 82 10 99 ce be f7 ff ff ff ff     ....$!..........
    b928:	ff ff ff ff df ff 3c e7 62 10 24 29 e3 20 e4 20     ......<.b.$). . 
    b938:	04 21 45 29 ff ff 9e f7 ff ff de f7 ff ff 3c e7     .!E)..........<.
    b948:	e3 18 86 31 7d ef be f7 de f7 ff ff ff ff ff ff     ...1}...........
    b958:	ff ff ff ff df ff df ff df ff ff ff d3 9c 62 10     ..............b.
    b968:	04 21 e4 20 e4 20 24 21 62 10 b2 94 ff ff be f7     .!. . $!b.......
    b978:	ff ff de f7 ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b988:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b998:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b9a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b9b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b9c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    b9d8:	ff ff ff ff ae 73 cf 7b ff ff ff ff ff ff ff ff     .....s.{........
    b9e8:	df f7 df f7 7d ff 08 ca 85 e1 86 e1 65 e1 85 e9     ....}.......e...
    b9f8:	08 ca fa fe fe f7 ff f7 ff ff ff ff fe f7 df ff     ................
    ba08:	f3 9c e4 20 04 21 c3 18 c3 18 e4 20 e4 20 f3 a4     ... .!..... . ..
    ba18:	ff ff de f7 ff ff ff ff ff ff df ff de f7 fb de     ................
    ba28:	82 18 e4 20 04 21 e4 20 04 21 a3 18 10 84 ff ff     ... .!. .!......
    ba38:	ff ff df ff ff ff ff ff ff ff be f7 ff ff b6 b5     ................
    ba48:	c3 18 24 21 04 21 79 ce ff ff ff ff df ff ff ff     ..$!.!y.........
    ba58:	ff ff 55 ad a3 18 04 21 04 21 e4 20 24 29 c3 18     ..U....!.!. $)..
    ba68:	71 8c ff ff de f7 ff ff df ff ff ff a6 31 e3 18     q............1..
    ba78:	04 21 55 ad 9e f7 ff ff ff ff ff ff ff ff ff ff     .!U.............
    ba88:	ff ff ff ff ff ff ff ff ff ff f3 a4 a2 18 04 21     ...............!
    ba98:	e4 20 e3 18 45 29 82 10 13 9d ff ff de f7 ff ff     . ..E)..........
    baa8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bab8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bac8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bad8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bae8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    baf8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff df ff     ................
    bb08:	ff ff ff ff de f7 ff ff ff ff ff ff df ff ff ef     ................
    bb18:	dd f7 b4 f5 86 d9 46 e9 a7 e9 84 d9 46 f1 eb ba     ......F.....F...
    bb28:	fd ff ff f7 de ff de ff 99 d6 31 94 04 21 c3 18     ..........1..!..
    bb38:	e3 20 e4 20 24 29 04 21 e4 20 e4 20 f3 9c be f7     . . $).!. . ....
    bb48:	df ff ff ff ff ff ba d6 92 94 25 29 e4 20 04 21     ..........%). .!
    bb58:	c3 20 04 29 04 21 04 21 04 21 af 7b 7d ef ff ff     . .).!.!.!.{}...
    bb68:	de f7 ff ff df ff de f7 75 ad 65 29 04 21 e3 18     ........u.e).!..
    bb78:	24 21 e3 18 ce 73 79 ce ff ff 38 c6 4d 6b e3 20     $!...sy...8.Mk. 
    bb88:	04 29 c3 18 04 21 e4 20 e3 20 e4 20 c3 18 28 42     .)...!. . . ..(B
    bb98:	14 a5 9e f7 df ff ff ff 30 84 e4 20 24 21 a3 18     ........0.. $!..
    bba8:	a2 10 45 29 45 29 45 29 45 29 45 29 65 31 65 31     ..E)E)E)E)E)e1e1
    bbb8:	45 29 66 31 04 29 a7 39 c3 18 04 21 e4 20 04 21     E)f1.).9...!. .!
    bbc8:	e3 18 04 21 a3 18 96 b5 ff ff ff ff ff ff ff ff     ...!............
    bbd8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bbe8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bbf8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bc08:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bc18:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bc28:	ff ff ff ff df ff ff ff ff ff df ff df ff be f7     ................
    bc38:	ff ff ff ff ff ff ff ff fc ff fe ff ff ff ff ff     ................
    bc48:	ef d3 45 e1 45 f1 c5 d1 24 f9 46 e1 ef e3 be ff     ..E.E...$.F.....
    bc58:	df ef ff ff 0c 63 ac 4b 0d 7b 2d 73 2c 73 4c 6b     .....c.K.{-s,sLk
    bc68:	4c 6b 4c 6b 4c 6b 4c 6b cb 5a 79 ce df ff ff ff     LkLkLkLk.Zy.....
    bc78:	ff ff 71 8c 2d 6b 4d 6b 4d 6b 4d 6b 4d 6b 4d 6b     ..q.-kMkMkMkMkMk
    bc88:	4d 6b 4d 6b 4d 6b 2d 6b 75 ad df ff ff ff de f7     MkMkMk-ku.......
    bc98:	df ff be f7 eb 5a 8d 73 2e 6b 2f 6b 2d 6b 48 72     .....Z.s.k/k-kHr
    bca8:	a7 81 cc 7a ff f7 0e 84 2f 6b 2e 6b 4d 63 4d 6b     ...z..../k.kMcMk
    bcb8:	2c 73 0d 7b 0d 73 4e 6b 4d 6b 6d 6b ec 62 b6 b5     ,s.{.sNkMkmk.b..
    bcc8:	ff ff df ff 9a d6 cb 5a 4d 6b 4d 6b 4d 6b 4d 6b     .......ZMkMkMkMk
    bcd8:	4d 6b 4d 6b 4d 6b 4d 6b 4d 6b 4d 6b 4d 6b 4d 6b     MkMkMkMkMkMkMkMk
    bce8:	4d 6b 4d 6b 4d 6b 4d 6b 4d 6b 4d 6b 4d 6b 4d 6b     MkMkMkMkMkMkMkMk
    bcf8:	0c 63 30 84 ff ff de f7 ff ff ff ff ff ff ff ff     .c0.............
    bd08:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bd18:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bd28:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bd38:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bd48:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bd58:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bd68:	ff ff ff ff fe ff fe ff ff ff fe ff 5b ff 89 d2     ............[...
    bd78:	a6 e9 45 e9 c4 d9 65 e9 26 d9 52 f4 df ff de ef     ..E...e.&.R.....
    bd88:	ff f7 ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bd98:	ff ff ff ff ff ff ff ff de f7 ff ff de f7 ff ff     ................
    bda8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bdb8:	ff ff ff ff ff ff df ff ff ff df ff ff ff ff ff     ................
    bdc8:	ff ff ff ff ff f7 ff ff ff ff 9c ff 8b b2 bc fe     ................
    bdd8:	de ff fe f7 ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bde8:	ff ff ff ff df ff ff ff ff ff de f7 ff ff de f7     ................
    bdf8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    be08:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    be18:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    be28:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    be38:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    be48:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    be58:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    be68:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    be78:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    be88:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    be98:	ff ff ff ff fe ff fe f7 fe f7 98 f6 c7 c1 06 f9     ................
    bea8:	e4 d1 64 e9 47 f9 27 d9 31 e4 fe ff ff ef df f7     ..d.G.'.1.......
    beb8:	fe ff fe ff ff f7 ff f7 ff f7 ff ff ff ff ff ff     ................
    bec8:	ff ff ff ff ff ff de f7 ff ff ff ff df ff ff ff     ................
    bed8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bee8:	be f7 df ff ff ff ff ff df ff df ff ff ff ff ff     ................
    bef8:	ff f7 be ff fe ef de f7 36 f5 2a c2 5b ff fe f7     ........6.*.[...
    bf08:	ff ff ff ff df ff df ff df ff ff ff ff f7 ff f7     ................
    bf18:	ff ff ff ff df ff ff ff de f7 ff ff ff ff ff ff     ................
    bf28:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bf38:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bf48:	ff ff ff ff ff ff ff ff ff ff ff ff df ff de f7     ................
    bf58:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bf68:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bf78:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bf88:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bf98:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bfa8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bfb8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    bfc8:	fe ff fe ff ff ef fe ff 75 f5 67 d1 44 e1 a5 e9     ........u.g.D...
    bfd8:	84 e1 a6 e1 a7 d1 32 ec df ff ff ef ff ff ff f7     ......2.........
    bfe8:	ff f7 df ff df ff df ff ff ff ff f7 df ff ff ff     ................
    bff8:	de f7 df ff ff ff df ff ff ff df ff ff ff ff ff     ................
    c008:	ff ff ff ff ff ff ff ff ff ff ff ff df ff df ff     ................
    c018:	ff ff be f7 de f7 df ff be f7 df ff de f7 dd ff     ................
    c028:	de f7 ff f7 7d ff 49 ca 0f dc dd ff ff f7 ff f7     ....}.I.........
    c038:	df ff df ff df ff ff f7 ff f7 ff f7 df ff df ff     ................
    c048:	df ff ff ff df ff de f7 ff ff df ff ff ff ff ff     ................
    c058:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c068:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c078:	ff ff ff ff be f7 ff ff df ff ff ff ff ff ff ff     ................
    c088:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c098:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c0a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c0b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c0c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c0d8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c0e8:	ff ff ff ff ff ff ff ff ff ff ff f7 fe ff df ff     ................
    c0f8:	ff ff ff f7 fe ff d2 dc 46 e9 86 e9 84 d9 c5 d9     ........F.......
    c108:	86 e1 27 d9 f1 e3 9e ff ff f7 ff ef ff f7 df f7     ..'.............
    c118:	df ff df ff fe ff fe f7 ff ff ff ff ff ff ff ff     ................
    c128:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c138:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c148:	ff ff ff ff ff ff ff ff fe ff fd ff fe ff ff f7     ................
    c158:	fe f7 91 e4 a7 d1 96 f5 dd ff fe f7 fe f7 df ff     ................
    c168:	ff ff ff f7 ff f7 df ff ff ff ff ff ff ff ff ff     ................
    c178:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c188:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c198:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c1a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c1b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c1c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c1d8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c1e8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c1f8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c208:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c218:	ff ff ff ff ff ff ff ff ff ff df ff df ff ff f7     ................
    c228:	fe f7 ff ff 30 ec 46 d1 87 f9 64 e1 84 d9 a7 e9     ....0.F...d.....
    c238:	46 d1 0d eb dd f7 fe f7 ff ef ff f7 ff ff df ff     F...............
    c248:	fe ff fd f7 ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c258:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c268:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c278:	ff ff ff ff de ff fe f7 df ff df ff fe df 1a ff     ................
    c288:	87 d1 08 da 9d ff dd ff fe ef df ff ff ff ff f7     ................
    c298:	ff ff df ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c2a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c2b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c2c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c2d8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c2e8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c2f8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c308:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c318:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c328:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c338:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c348:	ff ff ff ff ff ff ff ff fe ff fe f7 ff f7 bf f7     ................
    c358:	bd ff 52 ec 26 d1 66 e9 a5 e1 44 d9 86 e9 46 e9     ..R.&.f...D...F.
    c368:	aa b2 99 fe dd ff ff f7 ff f7 ff ff ff ff fe ff     ................
    c378:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c388:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c398:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c3a8:	fe ff ff ff df ff ff ff ff ef df ff ab d2 44 e9     ..............D.
    c3b8:	14 e5 dd ff fe f7 ff f7 ff ff ff f7 ff f7 ff ff     ................
    c3c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c3d8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c3e8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c3f8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c408:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c418:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c428:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c438:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c448:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c458:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c468:	ff ff ff ff ff ff ff ff ff ff ff ff fe ff df ff     ................
    c478:	df ff ff f7 fd ef dd ef ff ff 9f ff de e7 bd ff     ................
    c488:	30 ec 66 d9 24 f1 84 e9 a4 e1 84 d9 27 f1 c7 c1     0.f.$.......'...
    c498:	b6 e5 ff ff ff f7 ff ff ff ff ff ff ff ff ff ff     ................
    c4a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c4b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c4c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff f7 df ff     ................
    c4d8:	ff f7 ff f7 df ff bf ff 51 dc 23 f9 4b ba 5c ff     ........Q.#.K.\.
    c4e8:	dd f7 ff f7 ff ff ff f7 ff ef ff f7 ff ff ff ff     ................
    c4f8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c508:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c518:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c528:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c538:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c548:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c558:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c568:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c578:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c588:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c598:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c5a8:	ff ff ff ff ff ff ff ff bf ff ff f7 ff ff 92 dc     ................
    c5b8:	67 d1 06 f1 86 e9 25 d2 64 e1 65 f1 05 d9 af e3     g.....%.d.e.....
    c5c8:	9c ff fd f7 fe f7 be ff ff ff de ff de ff fd ff     ................
    c5d8:	fe ff ff ff ff f7 ff f7 ff ff ff ff ff ff ff ff     ................
    c5e8:	ff ff ff ff ff f7 ff f7 ff ff ff ff ff ff ff ff     ................
    c5f8:	ff ff ff ff ff ff ff ff ff f7 fe f7 fd ff fe ff     ................
    c608:	ff ef de f7 95 ed 46 d9 a5 e1 73 f4 fe ef fe e7     ......F...s.....
    c618:	fe ff ff f7 df ff fe ff ff ff ff ff ff ff ff ff     ................
    c628:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c638:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c648:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c658:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c668:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c678:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c688:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c698:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c6a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c6b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c6c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c6d8:	ff ff ff ff ff ff ff ff fe f7 de ff 55 f5 86 c1     ............U...
    c6e8:	66 e9 24 f1 a7 e9 45 e9 65 f1 45 d9 27 ca f6 f5     f.$...E.e.E.'...
    c6f8:	fe ff ff e7 ff f7 ff f7 ff ff ff ff ff ff ff ff     ................
    c708:	ff ff ff f7 ff f7 ff f7 ff f7 ff f7 ff f7 ff ff     ................
    c718:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c728:	ff ff ff ff ff ff ff f7 fe ff df ff ff ff ff f7     ................
    c738:	95 ed 66 e9 85 d9 6b da ff ff fe ef fe ff ff f7     ..f...k.........
    c748:	df ff fe ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c758:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c768:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c778:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c788:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c798:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c7a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c7b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c7c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c7d8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c7e8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c7f8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c808:	dd ff fe ff ff ff ff f7 de ff 58 f6 e8 c9 47 f1     ..........X...G.
    c818:	65 e1 85 e1 84 e1 44 e9 45 f1 66 d1 ae cb 3b ff     e.....D.E.f...;.
    c828:	ff f7 df f7 df ff df ff df ff ff ff fe ff fe f7     ................
    c838:	df ff ff ff ff f7 ff f7 ff f7 ff ff ff ff de ff     ................
    c848:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c858:	df ff ff f7 ff ff bf ff df ff ff f7 34 e5 46 f1     ............4.F.
    c868:	85 e9 66 c1 1b ff fe f7 ff ff ff ff df ff fe ff     ..f.............
    c878:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c888:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c898:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c8a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c8b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c8c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c8d8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c8e8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c8f8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c908:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c918:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c928:	ff ff ff ff ff ff ff ff ff ff ff ff dd f7 de ff     ................
    c938:	bf ff ff ff ff ef dd ff 3b ff cc c2 84 e9 84 d9     ........;.......
    c948:	a5 d9 a6 e1 66 e9 46 e9 66 e1 a6 d9 f4 e4 5d ff     ....f.F.f.....].
    c958:	be ff df ff ff f7 ff f7 ff ff fe ff bf ff bf ff     ................
    c968:	df ff df ff ff ff fe ff fe ff fe ff ff ff ff ff     ................
    c978:	ff ff ff ff ff ff ff ff ff ff ff ff df ff ff f7     ................
    c988:	ff ff df ff ff f7 de ff 50 dc 25 e9 65 e9 87 d9     ........P.%.e...
    c998:	34 e5 fe ff ff ff ff ff ff ff fe ff ff ff ff ff     4...............
    c9a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c9b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c9c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c9d8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c9e8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    c9f8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ca08:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ca18:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ca28:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ca38:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ca48:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ca58:	ff ff ff ff ff ff ff ff ff ff df ff df ff ff ff     ................
    ca68:	fe f7 fe f7 fe ff ff ff 0e f4 85 c9 87 e1 66 e9     ..............f.
    ca78:	66 e9 85 e1 65 e9 65 f9 67 e1 e8 d1 34 ed bd ff     f...e.e.g...4...
    ca88:	ff f7 ff f7 be f7 df ff ff f7 ff ff df ff be ff     ................
    ca98:	df ff fe ff fe ff fe f7 ff ff ff ff ff ff ff ff     ................
    caa8:	ff ff ff ff ff ff ff ff df ff df ff ff f7 ff e7     ................
    cab8:	df f7 5d ff 29 ca 45 e9 45 e9 66 e1 cf e3 de f7     ..].).E.E.f.....
    cac8:	ff f7 df ff ff ff fe ff ff ff ff ff ff ff ff ff     ................
    cad8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cae8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    caf8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cb08:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cb18:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cb28:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cb38:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cb48:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cb58:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cb68:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cb78:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cb88:	ff ff ff ff ff ff ff ff ff ff fe ff fe ff fe ff     ................
    cb98:	ff ff ff ff fd f7 38 f6 08 da 46 e9 45 e9 65 e1     ......8...F.E.e.
    cba8:	65 d9 a7 e9 24 f1 66 e9 46 d9 09 ca d4 ec 7d ff     e...$.f.F.....}.
    cbb8:	ff ff fe ef fe ef fe f7 fe f7 ff ff ff ff ff ff     ................
    cbc8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cbd8:	ff ff ff ff ff ff df ff ff f7 fe ef dd ff d3 f4     ................
    cbe8:	46 d1 a6 e9 85 e9 65 e9 eb e2 fe ff ff f7 df ff     F.....e.........
    cbf8:	ff ff fe ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cc08:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cc18:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cc28:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cc38:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cc48:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cc58:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cc68:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cc78:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cc88:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cc98:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cca8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ccb8:	df ff ff ff ff ff ff ff df ff df ff fe ff fe ff     ................
    ccc8:	ff df de ef 7c ff ad db c7 d1 86 e1 a7 e9 67 e1     ....|.........g.
    ccd8:	c6 d9 86 e9 66 f9 47 f9 46 e1 c7 c1 70 d4 d9 fe     ....f.G.F...p...
    cce8:	de ff bd ff fe ff fe f7 ff ff ff ff df ff bf ff     ................
    ccf8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cd08:	df f7 ff ff dd ff dc ff f7 f5 87 d1 46 e9 45 e1     ............F.E.
    cd18:	a5 e1 84 e9 69 e2 fe ff ff ef df ff ff ff df ff     ....i...........
    cd28:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cd38:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cd48:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cd58:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cd68:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cd78:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cd88:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cd98:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cda8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cdb8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cdc8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cdd8:	ff ff ff ff ff ff ff ff ff ff ff ff fe ff df ff     ................
    cde8:	bf ff bf ff bf ff df ff fd ff fc ff 7f ff ff f7     ................
    cdf8:	fe df fe f7 f6 ed 29 da 46 e1 65 f1 87 d9 a7 d9     ......).F.e.....
    ce08:	85 e1 a5 e9 a5 e9 85 e9 45 e1 05 e9 0e bb 15 d5     ........E.......
    ce18:	3c ff ff ff ff f7 ff ff bf ff 9f ff ff ff ff ff     <...............
    ce28:	ff ff ff ff ff ff ff ff ff ff ff ff df ff ff f7     ................
    ce38:	fe ff 94 dd 08 ca 46 e9 46 f1 86 e9 a5 d1 84 e1     ......F.F.......
    ce48:	69 ea fe f7 ff e7 bf ff fe ff df ff ff ff ff ff     i...............
    ce58:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ce68:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ce78:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ce88:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ce98:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cea8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ceb8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cec8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    ced8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cee8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cef8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cf08:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cf18:	ff ff ff ff ff ff ff ff ff ef ff ff df ff ff ff     ................
    cf28:	ff ff bd ff d3 e4 c9 c9 24 f9 85 f1 a5 d9 c6 d9     ........$.......
    cf38:	85 e1 86 f1 45 e9 66 f1 84 e1 85 e1 45 d9 6b ea     ....E.f.....E.k.
    cf48:	f1 db d8 f5 3d ff ff f7 fe f7 fe f7 fe f7 fe f7     ....=...........
    cf58:	dd ef fe f7 fe ff fe ff 9b ff 95 ed 49 ea 45 f1     ............I.E.
    cf68:	64 e9 a4 e1 85 e1 66 f1 63 d9 67 d9 f1 d3 ff f7     d.....f.c.g.....
    cf78:	ff ff df ff ff ff ff f7 ff ff ff ff ff ff ff ff     ................
    cf88:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cf98:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cfa8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cfb8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cfc8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cfd8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cfe8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    cff8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d008:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d018:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d028:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d038:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d048:	ff ff ff ff ff f7 ff ff df ff ff ff ff f7 fe f7     ................
    d058:	dd ff 1a ff ee db 86 c1 47 e1 26 f1 46 e9 85 e1     ........G.&.F...
    d068:	c6 e1 84 e1 46 d9 66 e1 66 e1 67 e9 66 e1 66 d9     ....F.f.f.g.f.f.
    d078:	65 c9 c6 d1 4d db ae e3 30 dc 91 dc 91 dc 51 dc     e...M...0.....Q.
    d088:	ae db 0c cb 46 d9 25 d1 a7 e1 85 d9 a5 d9 a5 d9     ....F.%.........
    d098:	a5 e1 a5 e1 65 f1 46 d9 76 f5 ff f7 ff f7 df ff     ....e.F.v.......
    d0a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d0b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d0c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d0d8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d0e8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d0f8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d108:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d118:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d128:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d138:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d148:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d158:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d168:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d178:	ff ff ff ff df ff df ff ff ff fe f7 fd ef fd f7     ................
    d188:	dd f7 fb fe d0 db 67 c1 68 e9 66 f9 65 f1 c5 e9     ......g.h.f.e...
    d198:	67 f1 46 e9 46 e9 45 e9 65 e9 84 e9 64 e9 84 e9     g.F.F.E.e...d...
    d1a8:	46 e9 66 e9 86 e9 86 e9 86 e9 66 e1 45 e1 46 e9     F.f.......f.E.F.
    d1b8:	85 f1 a6 e9 a6 d9 a6 d9 86 e1 66 e9 66 e9 86 e9     ..........f.f...
    d1c8:	66 f9 87 c9 5d ff ff f7 ff f7 ff ff ff ff df ff     f...]...........
    d1d8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d1e8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d1f8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d208:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d218:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d228:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d238:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d248:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d258:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d268:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d278:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d288:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d298:	ff ff ff ff ff ff ff ff ff ff ff ff fe ff ff ff     ................
    d2a8:	df ff df ff be ff df ff ff ff ff f7 ff f7 ff f7     ................
    d2b8:	fe ff fa fe 51 e4 66 c9 46 e1 46 f1 64 d1 a5 e1     ....Q.f.F.F.d...
    d2c8:	85 e1 85 e1 85 e1 65 e1 86 e1 86 e1 86 e1 86 e9     ......e.........
    d2d8:	86 e9 86 e9 65 e1 66 e9 66 e9 66 f1 85 e9 65 e9     ....e.f.f.f...e.
    d2e8:	86 e9 66 e1 86 e1 87 e1 87 d9 a7 d9 66 d1 14 ed     ..f.........f...
    d2f8:	de ff ff f7 ff f7 ff f7 ff f7 ff ff ff ff ff ff     ................
    d308:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d318:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d328:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d338:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d348:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d358:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d368:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d378:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d388:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d398:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d3a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d3b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d3c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d3d8:	df ff df ff df ff df ff df ff df ff df ff fe ff     ................
    d3e8:	fd f7 9c ff 14 ed 6b da 65 d1 86 d9 66 e1 66 e9     ......k.e...f.f.
    d3f8:	86 f1 a6 e9 86 e1 85 d9 a6 e1 c7 e1 85 d9 86 e1     ................
    d408:	86 e1 86 e1 86 e1 86 e1 66 e9 45 e1 65 e9 44 e1     ........f.E.e.D.
    d418:	a5 f1 45 e1 a7 e9 26 d9 ef d3 dd ff fe f7 ff f7     ..E...&.........
    d428:	ff ff ff f7 ff f7 ff f7 ff ff ff ff ff ff ff ff     ................
    d438:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d448:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d458:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d468:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d478:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d488:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d498:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d4a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d4b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d4c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d4d8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d4e8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d4f8:	ff ff ff ff df ff ff ff ff f7 ff f7 ff f7 ff ff     ................
    d508:	df ff df ff df ff df ff ff ff ff f7 de f7 fe f7     ................
    d518:	de ff de ff 39 fe 11 dc 2a c2 66 c9 86 d9 44 e1     ....9...*.f...D.
    d528:	64 e9 63 f1 66 e9 66 f1 66 f1 86 f1 66 e9 86 e9     d.c.f.f.f...f...
    d538:	86 e1 a6 e1 86 e1 a5 d9 a4 e1 63 e9 23 f1 86 f1     ..........c.#...
    d548:	66 c9 30 fc dd ff fe f7 ff ef df ff ff ff fe ff     f.0.............
    d558:	ff ff ff f7 ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d568:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d578:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d588:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d598:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d5a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d5b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d5c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d5d8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d5e8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d5f8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d608:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d618:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d628:	ff ff ff ff ff ff ff f7 ff f7 ff f7 ff f7 df ff     ................
    d638:	ff ff ff f7 ff ef ff f7 bf ff 9f ff ff ff ff e7     ................
    d648:	ff e7 ff f7 de ff 78 f6 71 dc aa da 86 d1 24 d1     ......x.q.....$.
    d658:	a6 d9 65 d9 66 e1 86 e9 46 e9 66 e9 66 e1 66 e1     ..e.f...F.f.f.f.
    d668:	87 e9 86 e1 85 d9 86 d9 a6 c9 4c d3 98 f6 fc f7     ..........L.....
    d678:	fe ff ff ef df ff bf ff ff ff fe ff df ff ff f7     ................
    d688:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d698:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d6a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d6b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d6c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d6d8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d6e8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d6f8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d708:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d718:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d728:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d738:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d748:	ff ff ff ff ff ff ff ff ff ff ff ff ff f7 ff ff     ................
    d758:	df ff ff ff fe ff ff f7 ff ff df ff ff ef ff f7     ................
    d768:	ff ff ff ff df f7 ff f7 df f7 bf ff df f7 be f7     ................
    d778:	ff ff fe f7 fe f7 ff f7 be ff 9a ee f1 e4 ee db     ................
    d788:	2b e3 89 e2 c7 d9 c8 e1 a8 e1 a8 e1 28 d2 cb e2     +...........(...
    d798:	cf e3 55 e5 5c ff ff ff ff f7 df f7 fe ff df f7     ..U.\...........
    d7a8:	bf ff 9f ff ff ff fe ff df ff ff ff ff ff ff ff     ................
    d7b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d7c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d7d8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d7e8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d7f8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d808:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d818:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d828:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d838:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d848:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    d858:	ff ff ff ff ff ff ff ff                             ........

0000d860 <GenericReport>:
    d860:	06 00 ff 09 01 a1 01 09 02 15 00 25 ff 75 08 95     ...........%.u..
    d870:	14 81 02 09 03 15 00 25 ff 75 08 95 14 91 02 c0     .......%.u......

0000d880 <DeviceDescriptor>:
    d880:	12 01 10 01 00 00 00 08 eb 03 63 20 01 00 01 02     ..........c ....
    d890:	dc 01                                               ..

0000d892 <ConfigurationDescriptor>:
    d892:	09 02 39 00 02 01 00 c0 32 09 04 00 00 02 08 06     ..9.....2.......
    d8a2:	50 00 07 05 83 02 40 00 05 07 05 04 02 40 00 05     P.....@......@..
    d8b2:	09 04 01 00 01 03 00 00 00 09 21 11 01 00 01 22     ..........!...."
    d8c2:	20 00 07 05 81 03 10 00 05                           ........

0000d8cb <LanguageString>:
    d8cb:	04 03 09 04                                         ....

0000d8cf <ManufacturerString>:
    d8cf:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
    d8df:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

0000d8e9 <ProductString>:
    d8e9:	2e 03 54 00 65 00 6d 00 70 00 65 00 72 00 61 00     ..T.e.m.p.e.r.a.
    d8f9:	74 00 75 00 72 00 65 00 20 00 44 00 61 00 74 00     t.u.r.e. .D.a.t.
    d909:	61 00 6c 00 6f 00 67 00 67 00 65 00 72 00 00 00     a.l.o.g.g.e.r...
    d919:	00                                                  .

0000d91a <__ctors_end>:
    d91a:	11 24       	eor	r1, r1
    d91c:	1f be       	out	0x3f, r1	; 63
    d91e:	cf ef       	ldi	r28, 0xFF	; 255
    d920:	d0 e2       	ldi	r29, 0x20	; 32
    d922:	de bf       	out	0x3e, r29	; 62
    d924:	cd bf       	out	0x3d, r28	; 61

0000d926 <__do_copy_data>:
    d926:	19 e0       	ldi	r17, 0x09	; 9
    d928:	a0 e0       	ldi	r26, 0x00	; 0
    d92a:	b1 e0       	ldi	r27, 0x01	; 1
    d92c:	ee e2       	ldi	r30, 0x2E	; 46
    d92e:	f1 e6       	ldi	r31, 0x61	; 97
    d930:	01 e0       	ldi	r16, 0x01	; 1
    d932:	0b bf       	out	0x3b, r16	; 59
    d934:	02 c0       	rjmp	.+4      	; 0xd93a <__do_copy_data+0x14>
    d936:	07 90       	elpm	r0, Z+
    d938:	0d 92       	st	X+, r0
    d93a:	a0 36       	cpi	r26, 0x60	; 96
    d93c:	b1 07       	cpc	r27, r17
    d93e:	d9 f7       	brne	.-10     	; 0xd936 <__do_copy_data+0x10>

0000d940 <__do_clear_bss>:
    d940:	14 e1       	ldi	r17, 0x14	; 20
    d942:	a0 e6       	ldi	r26, 0x60	; 96
    d944:	b9 e0       	ldi	r27, 0x09	; 9
    d946:	01 c0       	rjmp	.+2      	; 0xd94a <.do_clear_bss_start>

0000d948 <.do_clear_bss_loop>:
    d948:	1d 92       	st	X+, r1

0000d94a <.do_clear_bss_start>:
    d94a:	a7 32       	cpi	r26, 0x27	; 39
    d94c:	b1 07       	cpc	r27, r17
    d94e:	e1 f7       	brne	.-8      	; 0xd948 <.do_clear_bss_loop>
    d950:	0e 94 bb 7f 	call	0xff76	; 0xff76 <main>
    d954:	0c 94 95 b0 	jmp	0x1612a	; 0x1612a <_exit>

0000d958 <__bad_interrupt>:
    d958:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000d95c <LEDs_SetAllLEDs>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
    d95c:	9b b1       	in	r25, 0x0b	; 11
    d95e:	9f 70       	andi	r25, 0x0F	; 15
    d960:	98 2b       	or	r25, r24
    d962:	9b b9       	out	0x0b, r25	; 11
			}
    d964:	08 95       	ret

0000d966 <Webserver>:
         }
    sei();                                          // enable all interrupts
}

void Webserver()
{
    d966:	cf 92       	push	r12
    d968:	df 92       	push	r13
    d96a:	ef 92       	push	r14
    d96c:	ff 92       	push	r15
    d96e:	0f 93       	push	r16
    d970:	1f 93       	push	r17
    d972:	df 93       	push	r29
    d974:	cf 93       	push	r28
    d976:	cd b7       	in	r28, 0x3d	; 61
    d978:	de b7       	in	r29, 0x3e	; 62
    d97a:	ca 50       	subi	r28, 0x0A	; 10
    d97c:	d6 40       	sbci	r29, 0x06	; 6
    d97e:	0f b6       	in	r0, 0x3f	; 63
    d980:	f8 94       	cli
    d982:	de bf       	out	0x3e, r29	; 62
    d984:	0f be       	out	0x3f, r0	; 63
    d986:	cd bf       	out	0x3d, r28	; 61
    char LineBuffer[1490];
    char LineBuffer2[50];

    TimeDate_t CurrentTimeDate;
    /* Signal a 500ms tick has elapsed to the RTC */
    RTC_Tick500ms();
    d988:	0e 94 9f 85 	call	0x10b3e	; 0x10b3e <RTC_Tick500ms>

    RTC_GetTimeDate(&CurrentTimeDate);
    d98c:	ce 01       	movw	r24, r28
    d98e:	01 96       	adiw	r24, 0x01	; 1
    d990:	0e 94 a0 85 	call	0x10b40	; 0x10b40 <RTC_GetTimeDate>

    //HYT321_GetData(&Humidity, &Temperature);
    //Temperature += Sensor1Correction_SRAM;
   	strcpy(LineBuffer,"HTTP/1.1 200 OK\r\n");
    d994:	8e 01       	movw	r16, r28
    d996:	07 5c       	subi	r16, 0xC7	; 199
    d998:	1f 4f       	sbci	r17, 0xFF	; 255
    d99a:	c8 01       	movw	r24, r16
    d99c:	60 e0       	ldi	r22, 0x00	; 0
    d99e:	71 e0       	ldi	r23, 0x01	; 1
    d9a0:	0e 94 4a ad 	call	0x15a94	; 0x15a94 <strcpy>
    strcat(LineBuffer,"Connection: Close\r\n");
    d9a4:	c8 01       	movw	r24, r16
    d9a6:	62 e1       	ldi	r22, 0x12	; 18
    d9a8:	71 e0       	ldi	r23, 0x01	; 1
    d9aa:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"Content-Type: text/html\r\n\r\n");
    d9ae:	c8 01       	movw	r24, r16
    d9b0:	66 e2       	ldi	r22, 0x26	; 38
    d9b2:	71 e0       	ldi	r23, 0x01	; 1
    d9b4:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<!DOCTYPE HTML>\r\n");
    d9b8:	c8 01       	movw	r24, r16
    d9ba:	62 e4       	ldi	r22, 0x42	; 66
    d9bc:	71 e0       	ldi	r23, 0x01	; 1
    d9be:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<html><head>\r\n");
    d9c2:	c8 01       	movw	r24, r16
    d9c4:	64 e5       	ldi	r22, 0x54	; 84
    d9c6:	71 e0       	ldi	r23, 0x01	; 1
    d9c8:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<title>WIZ550 Datalogger</title></head>\r\n");
    d9cc:	c8 01       	movw	r24, r16
    d9ce:	63 e6       	ldi	r22, 0x63	; 99
    d9d0:	71 e0       	ldi	r23, 0x01	; 1
    d9d2:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<body>\r\n");
    d9d6:	c8 01       	movw	r24, r16
    d9d8:	6d e8       	ldi	r22, 0x8D	; 141
    d9da:	71 e0       	ldi	r23, 0x01	; 1
    d9dc:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<H3><font face='Verdana'>Datalogging Parameter and Configuration</H3><hr><br>\r\n");
    d9e0:	c8 01       	movw	r24, r16
    d9e2:	66 e9       	ldi	r22, 0x96	; 150
    d9e4:	71 e0       	ldi	r23, 0x01	; 1
    d9e6:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"Actual System Date: ");
    d9ea:	c8 01       	movw	r24, r16
    d9ec:	66 ee       	ldi	r22, 0xE6	; 230
    d9ee:	71 e0       	ldi	r23, 0x01	; 1
    d9f0:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf(LineBuffer2, "%02d.%02d.%02d\n", CurrentTimeDate.Day, CurrentTimeDate.Month, CurrentTimeDate.Year);
    d9f4:	8d b7       	in	r24, 0x3d	; 61
    d9f6:	9e b7       	in	r25, 0x3e	; 62
    d9f8:	0a 97       	sbiw	r24, 0x0a	; 10
    d9fa:	0f b6       	in	r0, 0x3f	; 63
    d9fc:	f8 94       	cli
    d9fe:	9e bf       	out	0x3e, r25	; 62
    da00:	0f be       	out	0x3f, r0	; 63
    da02:	8d bf       	out	0x3d, r24	; 61
    da04:	ed b7       	in	r30, 0x3d	; 61
    da06:	fe b7       	in	r31, 0x3e	; 62
    da08:	31 96       	adiw	r30, 0x01	; 1
    da0a:	67 e0       	ldi	r22, 0x07	; 7
    da0c:	e6 2e       	mov	r14, r22
    da0e:	f1 2c       	mov	r15, r1
    da10:	ec 0e       	add	r14, r28
    da12:	fd 1e       	adc	r15, r29
    da14:	ad b7       	in	r26, 0x3d	; 61
    da16:	be b7       	in	r27, 0x3e	; 62
    da18:	12 96       	adiw	r26, 0x02	; 2
    da1a:	fc 92       	st	X, r15
    da1c:	ee 92       	st	-X, r14
    da1e:	11 97       	sbiw	r26, 0x01	; 1
    da20:	8b ef       	ldi	r24, 0xFB	; 251
    da22:	91 e0       	ldi	r25, 0x01	; 1
    da24:	93 83       	std	Z+3, r25	; 0x03
    da26:	82 83       	std	Z+2, r24	; 0x02
    da28:	8c 81       	ldd	r24, Y+4	; 0x04
    da2a:	84 83       	std	Z+4, r24	; 0x04
    da2c:	15 82       	std	Z+5, r1	; 0x05
    da2e:	8d 81       	ldd	r24, Y+5	; 0x05
    da30:	86 83       	std	Z+6, r24	; 0x06
    da32:	17 82       	std	Z+7, r1	; 0x07
    da34:	8e 81       	ldd	r24, Y+6	; 0x06
    da36:	80 87       	std	Z+8, r24	; 0x08
    da38:	11 86       	std	Z+9, r1	; 0x09
    da3a:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer,LineBuffer2);
    da3e:	8d b7       	in	r24, 0x3d	; 61
    da40:	9e b7       	in	r25, 0x3e	; 62
    da42:	0a 96       	adiw	r24, 0x0a	; 10
    da44:	0f b6       	in	r0, 0x3f	; 63
    da46:	f8 94       	cli
    da48:	9e bf       	out	0x3e, r25	; 62
    da4a:	0f be       	out	0x3f, r0	; 63
    da4c:	8d bf       	out	0x3d, r24	; 61
    da4e:	c8 01       	movw	r24, r16
    da50:	b7 01       	movw	r22, r14
    da52:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<p>Actual System Time: ");
    da56:	c8 01       	movw	r24, r16
    da58:	6b e0       	ldi	r22, 0x0B	; 11
    da5a:	72 e0       	ldi	r23, 0x02	; 2
    da5c:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf(LineBuffer2, "%02d:%02d:%02d\n", CurrentTimeDate.Hour, CurrentTimeDate.Minute, CurrentTimeDate.Second);
    da60:	ad b7       	in	r26, 0x3d	; 61
    da62:	be b7       	in	r27, 0x3e	; 62
    da64:	1a 97       	sbiw	r26, 0x0a	; 10
    da66:	0f b6       	in	r0, 0x3f	; 63
    da68:	f8 94       	cli
    da6a:	be bf       	out	0x3e, r27	; 62
    da6c:	0f be       	out	0x3f, r0	; 63
    da6e:	ad bf       	out	0x3d, r26	; 61
    da70:	ed b7       	in	r30, 0x3d	; 61
    da72:	fe b7       	in	r31, 0x3e	; 62
    da74:	31 96       	adiw	r30, 0x01	; 1
    da76:	12 96       	adiw	r26, 0x02	; 2
    da78:	fc 92       	st	X, r15
    da7a:	ee 92       	st	-X, r14
    da7c:	11 97       	sbiw	r26, 0x01	; 1
    da7e:	83 e2       	ldi	r24, 0x23	; 35
    da80:	92 e0       	ldi	r25, 0x02	; 2
    da82:	93 83       	std	Z+3, r25	; 0x03
    da84:	82 83       	std	Z+2, r24	; 0x02
    da86:	89 81       	ldd	r24, Y+1	; 0x01
    da88:	84 83       	std	Z+4, r24	; 0x04
    da8a:	15 82       	std	Z+5, r1	; 0x05
    da8c:	8a 81       	ldd	r24, Y+2	; 0x02
    da8e:	86 83       	std	Z+6, r24	; 0x06
    da90:	17 82       	std	Z+7, r1	; 0x07
    da92:	8b 81       	ldd	r24, Y+3	; 0x03
    da94:	80 87       	std	Z+8, r24	; 0x08
    da96:	11 86       	std	Z+9, r1	; 0x09
    da98:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer,LineBuffer2);
    da9c:	8d b7       	in	r24, 0x3d	; 61
    da9e:	9e b7       	in	r25, 0x3e	; 62
    daa0:	0a 96       	adiw	r24, 0x0a	; 10
    daa2:	0f b6       	in	r0, 0x3f	; 63
    daa4:	f8 94       	cli
    daa6:	9e bf       	out	0x3e, r25	; 62
    daa8:	0f be       	out	0x3f, r0	; 63
    daaa:	8d bf       	out	0x3d, r24	; 61
    daac:	c8 01       	movw	r24, r16
    daae:	b7 01       	movw	r22, r14
    dab0:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<p>Actual Temperature Inside:");
    dab4:	c8 01       	movw	r24, r16
    dab6:	63 e3       	ldi	r22, 0x33	; 51
    dab8:	72 e0       	ldi	r23, 0x02	; 2
    daba:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf(LineBuffer2, "%3d C\n", Temperature);
    dabe:	00 d0       	rcall	.+0      	; 0xdac0 <Webserver+0x15a>
    dac0:	00 d0       	rcall	.+0      	; 0xdac2 <Webserver+0x15c>
    dac2:	00 d0       	rcall	.+0      	; 0xdac4 <Webserver+0x15e>
    dac4:	ed b7       	in	r30, 0x3d	; 61
    dac6:	fe b7       	in	r31, 0x3e	; 62
    dac8:	31 96       	adiw	r30, 0x01	; 1
    daca:	ad b7       	in	r26, 0x3d	; 61
    dacc:	be b7       	in	r27, 0x3e	; 62
    dace:	12 96       	adiw	r26, 0x02	; 2
    dad0:	fc 92       	st	X, r15
    dad2:	ee 92       	st	-X, r14
    dad4:	11 97       	sbiw	r26, 0x01	; 1
    dad6:	51 e5       	ldi	r21, 0x51	; 81
    dad8:	c5 2e       	mov	r12, r21
    dada:	52 e0       	ldi	r21, 0x02	; 2
    dadc:	d5 2e       	mov	r13, r21
    dade:	d3 82       	std	Z+3, r13	; 0x03
    dae0:	c2 82       	std	Z+2, r12	; 0x02
    dae2:	80 91 68 09 	lds	r24, 0x0968
    dae6:	99 27       	eor	r25, r25
    dae8:	87 fd       	sbrc	r24, 7
    daea:	90 95       	com	r25
    daec:	95 83       	std	Z+5, r25	; 0x05
    daee:	84 83       	std	Z+4, r24	; 0x04
    daf0:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer,LineBuffer2);
    daf4:	8d b7       	in	r24, 0x3d	; 61
    daf6:	9e b7       	in	r25, 0x3e	; 62
    daf8:	06 96       	adiw	r24, 0x06	; 6
    dafa:	0f b6       	in	r0, 0x3f	; 63
    dafc:	f8 94       	cli
    dafe:	9e bf       	out	0x3e, r25	; 62
    db00:	0f be       	out	0x3f, r0	; 63
    db02:	8d bf       	out	0x3d, r24	; 61
    db04:	c8 01       	movw	r24, r16
    db06:	b7 01       	movw	r22, r14
    db08:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<p>Actual Humidity Inside: ");
    db0c:	c8 01       	movw	r24, r16
    db0e:	69 e5       	ldi	r22, 0x59	; 89
    db10:	72 e0       	ldi	r23, 0x02	; 2
    db12:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf(LineBuffer2, "%3d %%\n", Humidity);
    db16:	00 d0       	rcall	.+0      	; 0xdb18 <Webserver+0x1b2>
    db18:	00 d0       	rcall	.+0      	; 0xdb1a <Webserver+0x1b4>
    db1a:	00 d0       	rcall	.+0      	; 0xdb1c <Webserver+0x1b6>
    db1c:	ed b7       	in	r30, 0x3d	; 61
    db1e:	fe b7       	in	r31, 0x3e	; 62
    db20:	31 96       	adiw	r30, 0x01	; 1
    db22:	ad b7       	in	r26, 0x3d	; 61
    db24:	be b7       	in	r27, 0x3e	; 62
    db26:	12 96       	adiw	r26, 0x02	; 2
    db28:	fc 92       	st	X, r15
    db2a:	ee 92       	st	-X, r14
    db2c:	11 97       	sbiw	r26, 0x01	; 1
    db2e:	85 e7       	ldi	r24, 0x75	; 117
    db30:	92 e0       	ldi	r25, 0x02	; 2
    db32:	93 83       	std	Z+3, r25	; 0x03
    db34:	82 83       	std	Z+2, r24	; 0x02
    db36:	80 91 69 09 	lds	r24, 0x0969
    db3a:	99 27       	eor	r25, r25
    db3c:	87 fd       	sbrc	r24, 7
    db3e:	90 95       	com	r25
    db40:	95 83       	std	Z+5, r25	; 0x05
    db42:	84 83       	std	Z+4, r24	; 0x04
    db44:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer,LineBuffer2);
    db48:	8d b7       	in	r24, 0x3d	; 61
    db4a:	9e b7       	in	r25, 0x3e	; 62
    db4c:	06 96       	adiw	r24, 0x06	; 6
    db4e:	0f b6       	in	r0, 0x3f	; 63
    db50:	f8 94       	cli
    db52:	9e bf       	out	0x3e, r25	; 62
    db54:	0f be       	out	0x3f, r0	; 63
    db56:	8d bf       	out	0x3d, r24	; 61
    db58:	c8 01       	movw	r24, r16
    db5a:	b7 01       	movw	r22, r14
    db5c:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<p>Temperature Sensor 2: ");
    db60:	c8 01       	movw	r24, r16
    db62:	6d e7       	ldi	r22, 0x7D	; 125
    db64:	72 e0       	ldi	r23, 0x02	; 2
    db66:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf(LineBuffer2, "%3d C\n", Sensor2Value);
    db6a:	00 d0       	rcall	.+0      	; 0xdb6c <Webserver+0x206>
    db6c:	00 d0       	rcall	.+0      	; 0xdb6e <Webserver+0x208>
    db6e:	00 d0       	rcall	.+0      	; 0xdb70 <Webserver+0x20a>
    db70:	ed b7       	in	r30, 0x3d	; 61
    db72:	fe b7       	in	r31, 0x3e	; 62
    db74:	31 96       	adiw	r30, 0x01	; 1
    db76:	ad b7       	in	r26, 0x3d	; 61
    db78:	be b7       	in	r27, 0x3e	; 62
    db7a:	12 96       	adiw	r26, 0x02	; 2
    db7c:	fc 92       	st	X, r15
    db7e:	ee 92       	st	-X, r14
    db80:	11 97       	sbiw	r26, 0x01	; 1
    db82:	d3 82       	std	Z+3, r13	; 0x03
    db84:	c2 82       	std	Z+2, r12	; 0x02
    db86:	80 91 62 09 	lds	r24, 0x0962
    db8a:	99 27       	eor	r25, r25
    db8c:	87 fd       	sbrc	r24, 7
    db8e:	90 95       	com	r25
    db90:	95 83       	std	Z+5, r25	; 0x05
    db92:	84 83       	std	Z+4, r24	; 0x04
    db94:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer,LineBuffer2);
    db98:	8d b7       	in	r24, 0x3d	; 61
    db9a:	9e b7       	in	r25, 0x3e	; 62
    db9c:	06 96       	adiw	r24, 0x06	; 6
    db9e:	0f b6       	in	r0, 0x3f	; 63
    dba0:	f8 94       	cli
    dba2:	9e bf       	out	0x3e, r25	; 62
    dba4:	0f be       	out	0x3f, r0	; 63
    dba6:	8d bf       	out	0x3d, r24	; 61
    dba8:	c8 01       	movw	r24, r16
    dbaa:	b7 01       	movw	r22, r14
    dbac:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<p>Temperature Sensor 3: ");
    dbb0:	c8 01       	movw	r24, r16
    dbb2:	67 e9       	ldi	r22, 0x97	; 151
    dbb4:	72 e0       	ldi	r23, 0x02	; 2
    dbb6:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf(LineBuffer2, "%3d C\n", Sensor3Value);
    dbba:	00 d0       	rcall	.+0      	; 0xdbbc <Webserver+0x256>
    dbbc:	00 d0       	rcall	.+0      	; 0xdbbe <Webserver+0x258>
    dbbe:	00 d0       	rcall	.+0      	; 0xdbc0 <Webserver+0x25a>
    dbc0:	ed b7       	in	r30, 0x3d	; 61
    dbc2:	fe b7       	in	r31, 0x3e	; 62
    dbc4:	31 96       	adiw	r30, 0x01	; 1
    dbc6:	ad b7       	in	r26, 0x3d	; 61
    dbc8:	be b7       	in	r27, 0x3e	; 62
    dbca:	12 96       	adiw	r26, 0x02	; 2
    dbcc:	fc 92       	st	X, r15
    dbce:	ee 92       	st	-X, r14
    dbd0:	11 97       	sbiw	r26, 0x01	; 1
    dbd2:	d3 82       	std	Z+3, r13	; 0x03
    dbd4:	c2 82       	std	Z+2, r12	; 0x02
    dbd6:	80 91 64 09 	lds	r24, 0x0964
    dbda:	99 27       	eor	r25, r25
    dbdc:	87 fd       	sbrc	r24, 7
    dbde:	90 95       	com	r25
    dbe0:	95 83       	std	Z+5, r25	; 0x05
    dbe2:	84 83       	std	Z+4, r24	; 0x04
    dbe4:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer,LineBuffer2);
    dbe8:	8d b7       	in	r24, 0x3d	; 61
    dbea:	9e b7       	in	r25, 0x3e	; 62
    dbec:	06 96       	adiw	r24, 0x06	; 6
    dbee:	0f b6       	in	r0, 0x3f	; 63
    dbf0:	f8 94       	cli
    dbf2:	9e bf       	out	0x3e, r25	; 62
    dbf4:	0f be       	out	0x3f, r0	; 63
    dbf6:	8d bf       	out	0x3d, r24	; 61
    dbf8:	c8 01       	movw	r24, r16
    dbfa:	b7 01       	movw	r22, r14
    dbfc:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<p>Temperature Sensor 4: ");
    dc00:	c8 01       	movw	r24, r16
    dc02:	61 eb       	ldi	r22, 0xB1	; 177
    dc04:	72 e0       	ldi	r23, 0x02	; 2
    dc06:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf(LineBuffer2, "%3d C\n", Sensor4Value);
    dc0a:	00 d0       	rcall	.+0      	; 0xdc0c <Webserver+0x2a6>
    dc0c:	00 d0       	rcall	.+0      	; 0xdc0e <Webserver+0x2a8>
    dc0e:	00 d0       	rcall	.+0      	; 0xdc10 <Webserver+0x2aa>
    dc10:	ed b7       	in	r30, 0x3d	; 61
    dc12:	fe b7       	in	r31, 0x3e	; 62
    dc14:	31 96       	adiw	r30, 0x01	; 1
    dc16:	ad b7       	in	r26, 0x3d	; 61
    dc18:	be b7       	in	r27, 0x3e	; 62
    dc1a:	12 96       	adiw	r26, 0x02	; 2
    dc1c:	fc 92       	st	X, r15
    dc1e:	ee 92       	st	-X, r14
    dc20:	11 97       	sbiw	r26, 0x01	; 1
    dc22:	d3 82       	std	Z+3, r13	; 0x03
    dc24:	c2 82       	std	Z+2, r12	; 0x02
    dc26:	80 91 66 09 	lds	r24, 0x0966
    dc2a:	99 27       	eor	r25, r25
    dc2c:	87 fd       	sbrc	r24, 7
    dc2e:	90 95       	com	r25
    dc30:	95 83       	std	Z+5, r25	; 0x05
    dc32:	84 83       	std	Z+4, r24	; 0x04
    dc34:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer,LineBuffer2);
    dc38:	8d b7       	in	r24, 0x3d	; 61
    dc3a:	9e b7       	in	r25, 0x3e	; 62
    dc3c:	06 96       	adiw	r24, 0x06	; 6
    dc3e:	0f b6       	in	r0, 0x3f	; 63
    dc40:	f8 94       	cli
    dc42:	9e bf       	out	0x3e, r25	; 62
    dc44:	0f be       	out	0x3f, r0	; 63
    dc46:	8d bf       	out	0x3d, r24	; 61
    dc48:	c8 01       	movw	r24, r16
    dc4a:	b7 01       	movw	r22, r14
    dc4c:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf (LineBuffer2, "<p>Left Days for Logging: %d\n<hr><br>", DaysLeft_SRAM);
    dc50:	00 d0       	rcall	.+0      	; 0xdc52 <Webserver+0x2ec>
    dc52:	00 d0       	rcall	.+0      	; 0xdc54 <Webserver+0x2ee>
    dc54:	00 d0       	rcall	.+0      	; 0xdc56 <Webserver+0x2f0>
    dc56:	ed b7       	in	r30, 0x3d	; 61
    dc58:	fe b7       	in	r31, 0x3e	; 62
    dc5a:	31 96       	adiw	r30, 0x01	; 1
    dc5c:	ad b7       	in	r26, 0x3d	; 61
    dc5e:	be b7       	in	r27, 0x3e	; 62
    dc60:	12 96       	adiw	r26, 0x02	; 2
    dc62:	fc 92       	st	X, r15
    dc64:	ee 92       	st	-X, r14
    dc66:	11 97       	sbiw	r26, 0x01	; 1
    dc68:	8b ec       	ldi	r24, 0xCB	; 203
    dc6a:	92 e0       	ldi	r25, 0x02	; 2
    dc6c:	93 83       	std	Z+3, r25	; 0x03
    dc6e:	82 83       	std	Z+2, r24	; 0x02
    dc70:	80 91 7d 10 	lds	r24, 0x107D
    dc74:	90 91 7e 10 	lds	r25, 0x107E
    dc78:	95 83       	std	Z+5, r25	; 0x05
    dc7a:	84 83       	std	Z+4, r24	; 0x04
    dc7c:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer,LineBuffer2);
    dc80:	8d b7       	in	r24, 0x3d	; 61
    dc82:	9e b7       	in	r25, 0x3e	; 62
    dc84:	06 96       	adiw	r24, 0x06	; 6
    dc86:	0f b6       	in	r0, 0x3f	; 63
    dc88:	f8 94       	cli
    dc8a:	9e bf       	out	0x3e, r25	; 62
    dc8c:	0f be       	out	0x3f, r0	; 63
    dc8e:	8d bf       	out	0x3d, r24	; 61
    dc90:	c8 01       	movw	r24, r16
    dc92:	b7 01       	movw	r22, r14
    dc94:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<table border=0 cellpadding=0 cellspacing=4>\n");
    dc98:	c8 01       	movw	r24, r16
    dc9a:	61 ef       	ldi	r22, 0xF1	; 241
    dc9c:	72 e0       	ldi	r23, 0x02	; 2
    dc9e:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<tr><td width=25%>Internal Logging Interval [s]:</td>\n<form method=get><td><input type=text size=8 maxlength=3 name=L value=");
    dca2:	c8 01       	movw	r24, r16
    dca4:	6f e1       	ldi	r22, 0x1F	; 31
    dca6:	73 e0       	ldi	r23, 0x03	; 3
    dca8:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf (LineBuffer2, "%d> </td></form></tr>\n", LoggingInterval500MS_SRAM/2);
    dcac:	00 d0       	rcall	.+0      	; 0xdcae <Webserver+0x348>
    dcae:	00 d0       	rcall	.+0      	; 0xdcb0 <Webserver+0x34a>
    dcb0:	00 d0       	rcall	.+0      	; 0xdcb2 <Webserver+0x34c>
    dcb2:	ed b7       	in	r30, 0x3d	; 61
    dcb4:	fe b7       	in	r31, 0x3e	; 62
    dcb6:	31 96       	adiw	r30, 0x01	; 1
    dcb8:	ad b7       	in	r26, 0x3d	; 61
    dcba:	be b7       	in	r27, 0x3e	; 62
    dcbc:	12 96       	adiw	r26, 0x02	; 2
    dcbe:	fc 92       	st	X, r15
    dcc0:	ee 92       	st	-X, r14
    dcc2:	11 97       	sbiw	r26, 0x01	; 1
    dcc4:	4c e9       	ldi	r20, 0x9C	; 156
    dcc6:	c4 2e       	mov	r12, r20
    dcc8:	43 e0       	ldi	r20, 0x03	; 3
    dcca:	d4 2e       	mov	r13, r20
    dccc:	d3 82       	std	Z+3, r13	; 0x03
    dcce:	c2 82       	std	Z+2, r12	; 0x02
    dcd0:	80 91 f0 0c 	lds	r24, 0x0CF0
    dcd4:	90 91 f1 0c 	lds	r25, 0x0CF1
    dcd8:	96 95       	lsr	r25
    dcda:	87 95       	ror	r24
    dcdc:	95 83       	std	Z+5, r25	; 0x05
    dcde:	84 83       	std	Z+4, r24	; 0x04
    dce0:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer,LineBuffer2);
    dce4:	8d b7       	in	r24, 0x3d	; 61
    dce6:	9e b7       	in	r25, 0x3e	; 62
    dce8:	06 96       	adiw	r24, 0x06	; 6
    dcea:	0f b6       	in	r0, 0x3f	; 63
    dcec:	f8 94       	cli
    dcee:	9e bf       	out	0x3e, r25	; 62
    dcf0:	0f be       	out	0x3f, r0	; 63
    dcf2:	8d bf       	out	0x3d, r24	; 61
    dcf4:	c8 01       	movw	r24, r16
    dcf6:	b7 01       	movw	r22, r14
    dcf8:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<tr><td width=25%>Web Logging Interval [s]:</td>\n<form method=get><td><input type=text size=8 maxlength=3 name=W value=");
    dcfc:	c8 01       	movw	r24, r16
    dcfe:	63 eb       	ldi	r22, 0xB3	; 179
    dd00:	73 e0       	ldi	r23, 0x03	; 3
    dd02:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf (LineBuffer2, "%d> </td></form></tr>\n", WebLoggingInterval500MS_SRAM/2);
    dd06:	00 d0       	rcall	.+0      	; 0xdd08 <Webserver+0x3a2>
    dd08:	00 d0       	rcall	.+0      	; 0xdd0a <Webserver+0x3a4>
    dd0a:	00 d0       	rcall	.+0      	; 0xdd0c <Webserver+0x3a6>
    dd0c:	ed b7       	in	r30, 0x3d	; 61
    dd0e:	fe b7       	in	r31, 0x3e	; 62
    dd10:	31 96       	adiw	r30, 0x01	; 1
    dd12:	ad b7       	in	r26, 0x3d	; 61
    dd14:	be b7       	in	r27, 0x3e	; 62
    dd16:	12 96       	adiw	r26, 0x02	; 2
    dd18:	fc 92       	st	X, r15
    dd1a:	ee 92       	st	-X, r14
    dd1c:	11 97       	sbiw	r26, 0x01	; 1
    dd1e:	d3 82       	std	Z+3, r13	; 0x03
    dd20:	c2 82       	std	Z+2, r12	; 0x02
    dd22:	80 91 b6 0b 	lds	r24, 0x0BB6
    dd26:	90 91 b7 0b 	lds	r25, 0x0BB7
    dd2a:	96 95       	lsr	r25
    dd2c:	87 95       	ror	r24
    dd2e:	95 83       	std	Z+5, r25	; 0x05
    dd30:	84 83       	std	Z+4, r24	; 0x04
    dd32:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer,LineBuffer2);
    dd36:	8d b7       	in	r24, 0x3d	; 61
    dd38:	9e b7       	in	r25, 0x3e	; 62
    dd3a:	06 96       	adiw	r24, 0x06	; 6
    dd3c:	0f b6       	in	r0, 0x3f	; 63
    dd3e:	f8 94       	cli
    dd40:	9e bf       	out	0x3e, r25	; 62
    dd42:	0f be       	out	0x3f, r0	; 63
    dd44:	8d bf       	out	0x3d, r24	; 61
    dd46:	c8 01       	movw	r24, r16
    dd48:	b7 01       	movw	r22, r14
    dd4a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<tr><td>Sensor 1 Correction [C]:</td>\n<form method=get><td><input type=text size=8 maxlength=2 name=A value=");
    dd4e:	c8 01       	movw	r24, r16
    dd50:	6b e2       	ldi	r22, 0x2B	; 43
    dd52:	74 e0       	ldi	r23, 0x04	; 4
    dd54:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf (LineBuffer2, "%d> </td></form></tr>\n", Sensor1Correction_SRAM);
    dd58:	00 d0       	rcall	.+0      	; 0xdd5a <Webserver+0x3f4>
    dd5a:	00 d0       	rcall	.+0      	; 0xdd5c <Webserver+0x3f6>
    dd5c:	00 d0       	rcall	.+0      	; 0xdd5e <Webserver+0x3f8>
    dd5e:	ed b7       	in	r30, 0x3d	; 61
    dd60:	fe b7       	in	r31, 0x3e	; 62
    dd62:	31 96       	adiw	r30, 0x01	; 1
    dd64:	ad b7       	in	r26, 0x3d	; 61
    dd66:	be b7       	in	r27, 0x3e	; 62
    dd68:	12 96       	adiw	r26, 0x02	; 2
    dd6a:	fc 92       	st	X, r15
    dd6c:	ee 92       	st	-X, r14
    dd6e:	11 97       	sbiw	r26, 0x01	; 1
    dd70:	d3 82       	std	Z+3, r13	; 0x03
    dd72:	c2 82       	std	Z+2, r12	; 0x02
    dd74:	80 91 e1 12 	lds	r24, 0x12E1
    dd78:	99 27       	eor	r25, r25
    dd7a:	87 fd       	sbrc	r24, 7
    dd7c:	90 95       	com	r25
    dd7e:	95 83       	std	Z+5, r25	; 0x05
    dd80:	84 83       	std	Z+4, r24	; 0x04
    dd82:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer,LineBuffer2);
    dd86:	8d b7       	in	r24, 0x3d	; 61
    dd88:	9e b7       	in	r25, 0x3e	; 62
    dd8a:	06 96       	adiw	r24, 0x06	; 6
    dd8c:	0f b6       	in	r0, 0x3f	; 63
    dd8e:	f8 94       	cli
    dd90:	9e bf       	out	0x3e, r25	; 62
    dd92:	0f be       	out	0x3f, r0	; 63
    dd94:	8d bf       	out	0x3d, r24	; 61
    dd96:	c8 01       	movw	r24, r16
    dd98:	b7 01       	movw	r22, r14
    dd9a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<tr><td>Sensor 2 Correction [C]:</td>\n<form method=get><td><input type=text size=8 maxlength=2 name=B value=");
    dd9e:	c8 01       	movw	r24, r16
    dda0:	69 e9       	ldi	r22, 0x99	; 153
    dda2:	74 e0       	ldi	r23, 0x04	; 4
    dda4:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf (LineBuffer2, "%d> </td></form></tr>\n", Sensor2Correction_SRAM);
    dda8:	00 d0       	rcall	.+0      	; 0xddaa <Webserver+0x444>
    ddaa:	00 d0       	rcall	.+0      	; 0xddac <Webserver+0x446>
    ddac:	00 d0       	rcall	.+0      	; 0xddae <Webserver+0x448>
    ddae:	ed b7       	in	r30, 0x3d	; 61
    ddb0:	fe b7       	in	r31, 0x3e	; 62
    ddb2:	31 96       	adiw	r30, 0x01	; 1
    ddb4:	ad b7       	in	r26, 0x3d	; 61
    ddb6:	be b7       	in	r27, 0x3e	; 62
    ddb8:	12 96       	adiw	r26, 0x02	; 2
    ddba:	fc 92       	st	X, r15
    ddbc:	ee 92       	st	-X, r14
    ddbe:	11 97       	sbiw	r26, 0x01	; 1
    ddc0:	d3 82       	std	Z+3, r13	; 0x03
    ddc2:	c2 82       	std	Z+2, r12	; 0x02
    ddc4:	80 91 76 10 	lds	r24, 0x1076
    ddc8:	99 27       	eor	r25, r25
    ddca:	87 fd       	sbrc	r24, 7
    ddcc:	90 95       	com	r25
    ddce:	95 83       	std	Z+5, r25	; 0x05
    ddd0:	84 83       	std	Z+4, r24	; 0x04
    ddd2:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer,LineBuffer2);
    ddd6:	8d b7       	in	r24, 0x3d	; 61
    ddd8:	9e b7       	in	r25, 0x3e	; 62
    ddda:	06 96       	adiw	r24, 0x06	; 6
    dddc:	0f b6       	in	r0, 0x3f	; 63
    ddde:	f8 94       	cli
    dde0:	9e bf       	out	0x3e, r25	; 62
    dde2:	0f be       	out	0x3f, r0	; 63
    dde4:	8d bf       	out	0x3d, r24	; 61
    dde6:	c8 01       	movw	r24, r16
    dde8:	b7 01       	movw	r22, r14
    ddea:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<tr><td>Sensor 3 Correction [C]:</td>\n<form method=get><td><input type=text size=8 maxlength=2 name=C value=");
    ddee:	c8 01       	movw	r24, r16
    ddf0:	67 e0       	ldi	r22, 0x07	; 7
    ddf2:	75 e0       	ldi	r23, 0x05	; 5
    ddf4:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf (LineBuffer2, "%d> </td></form></tr>\n", Sensor3Correction_SRAM);
    ddf8:	00 d0       	rcall	.+0      	; 0xddfa <Webserver+0x494>
    ddfa:	00 d0       	rcall	.+0      	; 0xddfc <Webserver+0x496>
    ddfc:	00 d0       	rcall	.+0      	; 0xddfe <Webserver+0x498>
    ddfe:	ed b7       	in	r30, 0x3d	; 61
    de00:	fe b7       	in	r31, 0x3e	; 62
    de02:	31 96       	adiw	r30, 0x01	; 1
    de04:	ad b7       	in	r26, 0x3d	; 61
    de06:	be b7       	in	r27, 0x3e	; 62
    de08:	12 96       	adiw	r26, 0x02	; 2
    de0a:	fc 92       	st	X, r15
    de0c:	ee 92       	st	-X, r14
    de0e:	11 97       	sbiw	r26, 0x01	; 1
    de10:	d3 82       	std	Z+3, r13	; 0x03
    de12:	c2 82       	std	Z+2, r12	; 0x02
    de14:	80 91 3c 0f 	lds	r24, 0x0F3C
    de18:	99 27       	eor	r25, r25
    de1a:	87 fd       	sbrc	r24, 7
    de1c:	90 95       	com	r25
    de1e:	95 83       	std	Z+5, r25	; 0x05
    de20:	84 83       	std	Z+4, r24	; 0x04
    de22:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer,LineBuffer2);
    de26:	8d b7       	in	r24, 0x3d	; 61
    de28:	9e b7       	in	r25, 0x3e	; 62
    de2a:	06 96       	adiw	r24, 0x06	; 6
    de2c:	0f b6       	in	r0, 0x3f	; 63
    de2e:	f8 94       	cli
    de30:	9e bf       	out	0x3e, r25	; 62
    de32:	0f be       	out	0x3f, r0	; 63
    de34:	8d bf       	out	0x3d, r24	; 61
    de36:	c8 01       	movw	r24, r16
    de38:	b7 01       	movw	r22, r14
    de3a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"<tr><td>Sensor 4 Correction [C]:</td>\n<form method=get><td><input type=text size=8 maxlength=2 name=D value=");
    de3e:	c8 01       	movw	r24, r16
    de40:	65 e7       	ldi	r22, 0x75	; 117
    de42:	75 e0       	ldi	r23, 0x05	; 5
    de44:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf (LineBuffer2, "%d> </td></form></tr>\n", Sensor4Correction_SRAM);
    de48:	00 d0       	rcall	.+0      	; 0xde4a <Webserver+0x4e4>
    de4a:	00 d0       	rcall	.+0      	; 0xde4c <Webserver+0x4e6>
    de4c:	00 d0       	rcall	.+0      	; 0xde4e <Webserver+0x4e8>
    de4e:	ed b7       	in	r30, 0x3d	; 61
    de50:	fe b7       	in	r31, 0x3e	; 62
    de52:	31 96       	adiw	r30, 0x01	; 1
    de54:	ad b7       	in	r26, 0x3d	; 61
    de56:	be b7       	in	r27, 0x3e	; 62
    de58:	12 96       	adiw	r26, 0x02	; 2
    de5a:	fc 92       	st	X, r15
    de5c:	ee 92       	st	-X, r14
    de5e:	11 97       	sbiw	r26, 0x01	; 1
    de60:	d3 82       	std	Z+3, r13	; 0x03
    de62:	c2 82       	std	Z+2, r12	; 0x02
    de64:	80 91 7a 10 	lds	r24, 0x107A
    de68:	99 27       	eor	r25, r25
    de6a:	87 fd       	sbrc	r24, 7
    de6c:	90 95       	com	r25
    de6e:	95 83       	std	Z+5, r25	; 0x05
    de70:	84 83       	std	Z+4, r24	; 0x04
    de72:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer,LineBuffer2);
    de76:	8d b7       	in	r24, 0x3d	; 61
    de78:	9e b7       	in	r25, 0x3e	; 62
    de7a:	06 96       	adiw	r24, 0x06	; 6
    de7c:	0f b6       	in	r0, 0x3f	; 63
    de7e:	f8 94       	cli
    de80:	9e bf       	out	0x3e, r25	; 62
    de82:	0f be       	out	0x3f, r0	; 63
    de84:	8d bf       	out	0x3d, r24	; 61
    de86:	c8 01       	movw	r24, r16
    de88:	b7 01       	movw	r22, r14
    de8a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>

   // strcat(LineBuffer,"<form method=get><input type=submit name=3 value='AUS'></form>");
    strcat(LineBuffer,"</table><br><hr><br>Datalogger Values on Xively: ");
    de8e:	c8 01       	movw	r24, r16
    de90:	63 ee       	ldi	r22, 0xE3	; 227
    de92:	75 e0       	ldi	r23, 0x05	; 5
    de94:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer, "<a href=""https://xively.com/feeds/126888"">https://xively.com/feeds/126888</a>");
    de98:	c8 01       	movw	r24, r16
    de9a:	65 e1       	ldi	r22, 0x15	; 21
    de9c:	76 e0       	ldi	r23, 0x06	; 6
    de9e:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer,"\r\n\r\n</body></html>\r\n");
    dea2:	c8 01       	movw	r24, r16
    dea4:	61 e6       	ldi	r22, 0x61	; 97
    dea6:	76 e0       	ldi	r23, 0x06	; 6
    dea8:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>


    sendData(1490, LineBuffer, 5);
    deac:	82 ed       	ldi	r24, 0xD2	; 210
    deae:	95 e0       	ldi	r25, 0x05	; 5
    deb0:	b8 01       	movw	r22, r16
    deb2:	45 e0       	ldi	r20, 0x05	; 5
    deb4:	0e 94 e7 9f 	call	0x13fce	; 0x13fce <sendData>
   // Serial_SendString(LineBuffer);
}
    deb8:	c6 5f       	subi	r28, 0xF6	; 246
    deba:	d9 4f       	sbci	r29, 0xF9	; 249
    debc:	0f b6       	in	r0, 0x3f	; 63
    debe:	f8 94       	cli
    dec0:	de bf       	out	0x3e, r29	; 62
    dec2:	0f be       	out	0x3f, r0	; 63
    dec4:	cd bf       	out	0x3d, r28	; 61
    dec6:	cf 91       	pop	r28
    dec8:	df 91       	pop	r29
    deca:	1f 91       	pop	r17
    decc:	0f 91       	pop	r16
    dece:	ff 90       	pop	r15
    ded0:	ef 90       	pop	r14
    ded2:	df 90       	pop	r13
    ded4:	cf 90       	pop	r12
    ded6:	08 95       	ret

0000ded8 <Webcontrol>:
    if (!Webclient) Webcontrol();
    }
}

void Webcontrol()
{
    ded8:	cf 92       	push	r12
    deda:	df 92       	push	r13
    dedc:	ef 92       	push	r14
    dede:	ff 92       	push	r15
    dee0:	0f 93       	push	r16
    dee2:	1f 93       	push	r17
    dee4:	df 93       	push	r29
    dee6:	cf 93       	push	r28
    dee8:	cd b7       	in	r28, 0x3d	; 61
    deea:	de b7       	in	r29, 0x3e	; 62
    deec:	60 97       	sbiw	r28, 0x10	; 16
    deee:	0f b6       	in	r0, 0x3f	; 63
    def0:	f8 94       	cli
    def2:	de bf       	out	0x3e, r29	; 62
    def4:	0f be       	out	0x3f, r0	; 63
    def6:	cd bf       	out	0x3d, r28	; 61
    uint8_t temp;
    uint32_t temp2;
    char LineBuffer[16];

    cli();                                  // disable all interrupts
    def8:	f8 94       	cli

    temp = readAddress(0x00, 0x02, 5);      // Socket  Interrupt Register -> 0xX4 -> RECV
    defa:	80 e0       	ldi	r24, 0x00	; 0
    defc:	62 e0       	ldi	r22, 0x02	; 2
    defe:	45 e0       	ldi	r20, 0x05	; 5
    df00:	0e 94 cc 9f 	call	0x13f98	; 0x13f98 <readAddress>

		if ( temp& 1<<2 )                   //Socket receive interrupt ?
    df04:	c8 2e       	mov	r12, r24
    df06:	82 ff       	sbrs	r24, 2
    df08:	d4 c0       	rjmp	.+424    	; 0xe0b2 <Webcontrol+0x1da>
        {
            getData(LineBuffer, 16, 5);
    df0a:	ce 01       	movw	r24, r28
    df0c:	01 96       	adiw	r24, 0x01	; 1
    df0e:	60 e1       	ldi	r22, 0x10	; 16
    df10:	45 e0       	ldi	r20, 0x05	; 5
    df12:	0e 94 43 a0 	call	0x14086	; 0x14086 <getData>
            //Serial_SendString(LineBuffer);
            // sendData(150,LineBuffer, 5);
           if ((LineBuffer[0] == 'G') & (LineBuffer[1] == 'E') & (LineBuffer[2] == 'T'))
    df16:	21 e0       	ldi	r18, 0x01	; 1
    df18:	8a 81       	ldd	r24, Y+2	; 0x02
    df1a:	85 34       	cpi	r24, 0x45	; 69
    df1c:	09 f0       	breq	.+2      	; 0xdf20 <Webcontrol+0x48>
    df1e:	20 e0       	ldi	r18, 0x00	; 0
    df20:	81 e0       	ldi	r24, 0x01	; 1
    df22:	99 81       	ldd	r25, Y+1	; 0x01
    df24:	97 34       	cpi	r25, 0x47	; 71
    df26:	09 f0       	breq	.+2      	; 0xdf2a <Webcontrol+0x52>
    df28:	80 e0       	ldi	r24, 0x00	; 0
    df2a:	28 23       	and	r18, r24
    df2c:	30 e0       	ldi	r19, 0x00	; 0
    df2e:	81 e0       	ldi	r24, 0x01	; 1
    df30:	90 e0       	ldi	r25, 0x00	; 0
    df32:	4b 81       	ldd	r20, Y+3	; 0x03
    df34:	44 35       	cpi	r20, 0x54	; 84
    df36:	11 f0       	breq	.+4      	; 0xdf3c <Webcontrol+0x64>
    df38:	80 e0       	ldi	r24, 0x00	; 0
    df3a:	90 e0       	ldi	r25, 0x00	; 0
    df3c:	82 23       	and	r24, r18
    df3e:	93 23       	and	r25, r19
    df40:	00 97       	sbiw	r24, 0x00	; 0
    df42:	09 f4       	brne	.+2      	; 0xdf46 <Webcontrol+0x6e>
    df44:	aa c0       	rjmp	.+340    	; 0xe09a <Webcontrol+0x1c2>
           {
              //if (LineBuffer[8] =='E') LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
              //if (LineBuffer[8] =='A') LEDs_SetAllLEDs(LEDS_NO_LEDS);
              if (LineBuffer[6] =='L')
    df46:	8f 81       	ldd	r24, Y+7	; 0x07
    df48:	8c 34       	cpi	r24, 0x4C	; 76
    df4a:	09 f0       	breq	.+2      	; 0xdf4e <Webcontrol+0x76>
    df4c:	4b c0       	rjmp	.+150    	; 0xdfe4 <Webcontrol+0x10c>
              {
                 LoggingInterval500MS_SRAM = atoi(&LineBuffer[8])*2;		 // convert in integer
    df4e:	ce 01       	movw	r24, r28
    df50:	09 96       	adiw	r24, 0x09	; 9
    df52:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <atoi>
    df56:	88 0f       	add	r24, r24
    df58:	99 1f       	adc	r25, r25
    df5a:	90 93 f1 0c 	sts	0x0CF1, r25
    df5e:	80 93 f0 0c 	sts	0x0CF0, r24
                 if (LoggingInterval500MS_SRAM<20) LoggingInterval500MS_SRAM=20; // minimal value
    df62:	84 31       	cpi	r24, 0x14	; 20
    df64:	91 05       	cpc	r25, r1
    df66:	30 f4       	brcc	.+12     	; 0xdf74 <Webcontrol+0x9c>
    df68:	84 e1       	ldi	r24, 0x14	; 20
    df6a:	90 e0       	ldi	r25, 0x00	; 0
    df6c:	90 93 f1 0c 	sts	0x0CF1, r25
    df70:	80 93 f0 0c 	sts	0x0CF0, r24
                 eeprom_update_word(&LoggingInterval500MS_EEPROM, LoggingInterval500MS_SRAM);
    df74:	60 91 f0 0c 	lds	r22, 0x0CF0
    df78:	70 91 f1 0c 	lds	r23, 0x0CF1
    df7c:	80 e0       	ldi	r24, 0x00	; 0
    df7e:	90 e0       	ldi	r25, 0x00	; 0
    df80:	0e 94 e1 af 	call	0x15fc2	; 0x15fc2 <__eeupd_word_usb1287>
                 f_getfree (0, (DWORD*)&FreeMemory,(FATFS**)&DiskFATState);
    df84:	80 e0       	ldi	r24, 0x00	; 0
    df86:	90 e0       	ldi	r25, 0x00	; 0
    df88:	69 e6       	ldi	r22, 0x69	; 105
    df8a:	70 e1       	ldi	r23, 0x10	; 16
    df8c:	45 e0       	ldi	r20, 0x05	; 5
    df8e:	5d e0       	ldi	r21, 0x0D	; 13
    df90:	0e 94 b3 98 	call	0x13166	; 0x13166 <f_getfree>
                 temp2 = (512 * FreeMemory) / (86400 * 26 * 2 / LoggingInterval500MS_SRAM);//26 data bytes, 86400 seconds = 1 day
    df94:	e0 90 69 10 	lds	r14, 0x1069
    df98:	f0 90 6a 10 	lds	r15, 0x106A
    df9c:	00 91 6b 10 	lds	r16, 0x106B
    dfa0:	10 91 6c 10 	lds	r17, 0x106C
    dfa4:	e9 e0       	ldi	r30, 0x09	; 9
    dfa6:	ee 0c       	add	r14, r14
    dfa8:	ff 1c       	adc	r15, r15
    dfaa:	00 1f       	adc	r16, r16
    dfac:	11 1f       	adc	r17, r17
    dfae:	ea 95       	dec	r30
    dfb0:	d1 f7       	brne	.-12     	; 0xdfa6 <Webcontrol+0xce>
    dfb2:	20 91 f0 0c 	lds	r18, 0x0CF0
    dfb6:	30 91 f1 0c 	lds	r19, 0x0CF1
    dfba:	40 e0       	ldi	r20, 0x00	; 0
    dfbc:	50 e0       	ldi	r21, 0x00	; 0
    dfbe:	60 e0       	ldi	r22, 0x00	; 0
    dfc0:	7e e8       	ldi	r23, 0x8E	; 142
    dfc2:	84 e4       	ldi	r24, 0x44	; 68
    dfc4:	90 e0       	ldi	r25, 0x00	; 0
    dfc6:	0e 94 ea ac 	call	0x159d4	; 0x159d4 <__divmodsi4>
    dfca:	c8 01       	movw	r24, r16
    dfcc:	b7 01       	movw	r22, r14
    dfce:	0e 94 c8 ac 	call	0x15990	; 0x15990 <__udivmodsi4>
                 DaysLeft_SRAM = (uint32_t)temp2;
    dfd2:	30 93 7e 10 	sts	0x107E, r19
    dfd6:	20 93 7d 10 	sts	0x107D, r18
                 eeprom_update_word(&DaysLeft_EEPROM, DaysLeft_SRAM);
    dfda:	88 e2       	ldi	r24, 0x28	; 40
    dfdc:	90 e0       	ldi	r25, 0x00	; 0
    dfde:	b9 01       	movw	r22, r18
    dfe0:	0e 94 e1 af 	call	0x15fc2	; 0x15fc2 <__eeupd_word_usb1287>
              }

              if (LineBuffer[6] =='W')
    dfe4:	8f 81       	ldd	r24, Y+7	; 0x07
    dfe6:	87 35       	cpi	r24, 0x57	; 87
    dfe8:	f9 f4       	brne	.+62     	; 0xe028 <Webcontrol+0x150>
              {
                 WebLoggingInterval500MS_SRAM = atoi(&LineBuffer[8])*2;		 // convert in integer
    dfea:	ce 01       	movw	r24, r28
    dfec:	09 96       	adiw	r24, 0x09	; 9
    dfee:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <atoi>
    dff2:	88 0f       	add	r24, r24
    dff4:	99 1f       	adc	r25, r25
    dff6:	90 93 b7 0b 	sts	0x0BB7, r25
    dffa:	80 93 b6 0b 	sts	0x0BB6, r24
                 if (WebLoggingInterval500MS_SRAM<20) WebLoggingInterval500MS_SRAM=20; // minimal value
    dffe:	84 31       	cpi	r24, 0x14	; 20
    e000:	91 05       	cpc	r25, r1
    e002:	30 f4       	brcc	.+12     	; 0xe010 <Webcontrol+0x138>
    e004:	84 e1       	ldi	r24, 0x14	; 20
    e006:	90 e0       	ldi	r25, 0x00	; 0
    e008:	90 93 b7 0b 	sts	0x0BB7, r25
    e00c:	80 93 b6 0b 	sts	0x0BB6, r24
                 eeprom_update_word(&WebLoggingInterval500MS_EEPROM, WebLoggingInterval500MS_SRAM);
    e010:	60 91 b6 0b 	lds	r22, 0x0BB6
    e014:	70 91 b7 0b 	lds	r23, 0x0BB7
    e018:	82 e0       	ldi	r24, 0x02	; 2
    e01a:	90 e0       	ldi	r25, 0x00	; 0
    e01c:	0e 94 e1 af 	call	0x15fc2	; 0x15fc2 <__eeupd_word_usb1287>
                 WebEnableCounter=0;
    e020:	10 92 af 11 	sts	0x11AF, r1
    e024:	10 92 ae 11 	sts	0x11AE, r1
              }

              if (LineBuffer[6] =='A')
    e028:	8f 81       	ldd	r24, Y+7	; 0x07
    e02a:	81 34       	cpi	r24, 0x41	; 65
    e02c:	59 f4       	brne	.+22     	; 0xe044 <Webcontrol+0x16c>
              {
                 Sensor1Correction_SRAM = atoi(&LineBuffer[8]);		 // convert in integer
    e02e:	ce 01       	movw	r24, r28
    e030:	09 96       	adiw	r24, 0x09	; 9
    e032:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <atoi>
    e036:	68 2f       	mov	r22, r24
    e038:	80 93 e1 12 	sts	0x12E1, r24
                 eeprom_update_byte(&Sensor1Correction_EEPROM, Sensor1Correction_SRAM);
    e03c:	84 e2       	ldi	r24, 0x24	; 36
    e03e:	90 e0       	ldi	r25, 0x00	; 0
    e040:	0e 94 cf af 	call	0x15f9e	; 0x15f9e <__eeupd_byte_usb1287>
              }
              if (LineBuffer[6] =='B')
    e044:	8f 81       	ldd	r24, Y+7	; 0x07
    e046:	82 34       	cpi	r24, 0x42	; 66
    e048:	59 f4       	brne	.+22     	; 0xe060 <Webcontrol+0x188>
              {
                 Sensor2Correction_SRAM = atoi(&LineBuffer[8]);		 // convert in integer
    e04a:	ce 01       	movw	r24, r28
    e04c:	09 96       	adiw	r24, 0x09	; 9
    e04e:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <atoi>
    e052:	68 2f       	mov	r22, r24
    e054:	80 93 76 10 	sts	0x1076, r24
                 eeprom_update_byte(&Sensor2Correction_EEPROM, Sensor2Correction_SRAM);
    e058:	85 e2       	ldi	r24, 0x25	; 37
    e05a:	90 e0       	ldi	r25, 0x00	; 0
    e05c:	0e 94 cf af 	call	0x15f9e	; 0x15f9e <__eeupd_byte_usb1287>
              }
              if (LineBuffer[6] =='C')
    e060:	8f 81       	ldd	r24, Y+7	; 0x07
    e062:	83 34       	cpi	r24, 0x43	; 67
    e064:	59 f4       	brne	.+22     	; 0xe07c <Webcontrol+0x1a4>
              {
                 Sensor3Correction_SRAM = atoi(&LineBuffer[8]);		 // convert in integer
    e066:	ce 01       	movw	r24, r28
    e068:	09 96       	adiw	r24, 0x09	; 9
    e06a:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <atoi>
    e06e:	68 2f       	mov	r22, r24
    e070:	80 93 3c 0f 	sts	0x0F3C, r24
                 eeprom_update_byte(&Sensor3Correction_EEPROM, Sensor3Correction_SRAM);
    e074:	86 e2       	ldi	r24, 0x26	; 38
    e076:	90 e0       	ldi	r25, 0x00	; 0
    e078:	0e 94 cf af 	call	0x15f9e	; 0x15f9e <__eeupd_byte_usb1287>
              }

              if (LineBuffer[6] =='D')
    e07c:	8f 81       	ldd	r24, Y+7	; 0x07
    e07e:	84 34       	cpi	r24, 0x44	; 68
    e080:	59 f4       	brne	.+22     	; 0xe098 <Webcontrol+0x1c0>
              {
                 Sensor4Correction_SRAM = atoi(&LineBuffer[8]);		 // convert in integer
    e082:	ce 01       	movw	r24, r28
    e084:	09 96       	adiw	r24, 0x09	; 9
    e086:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <atoi>
    e08a:	68 2f       	mov	r22, r24
    e08c:	80 93 7a 10 	sts	0x107A, r24
                 eeprom_update_byte(&Sensor4Correction_EEPROM, Sensor4Correction_SRAM);
    e090:	87 e2       	ldi	r24, 0x27	; 39
    e092:	90 e0       	ldi	r25, 0x00	; 0
    e094:	0e 94 cf af 	call	0x15f9e	; 0x15f9e <__eeupd_byte_usb1287>
              }

              Webserver();
    e098:	66 dc       	rcall	.-1844   	; 0xd966 <Webserver>
        }

           writeAddress(0x00, 0x02, 0x04, 5);	 // Clear Socket RECV Interrupt
    e09a:	80 e0       	ldi	r24, 0x00	; 0
    e09c:	62 e0       	ldi	r22, 0x02	; 2
    e09e:	44 e0       	ldi	r20, 0x04	; 4
    e0a0:	25 e0       	ldi	r18, 0x05	; 5
    e0a2:	0e 94 a5 9f 	call	0x13f4a	; 0x13f4a <writeAddress>
           writeAddress(0x00, 0x01, 0x08, 5);	 // Socket Command  Register -> DISCON
    e0a6:	80 e0       	ldi	r24, 0x00	; 0
    e0a8:	61 e0       	ldi	r22, 0x01	; 1
    e0aa:	48 e0       	ldi	r20, 0x08	; 8
    e0ac:	25 e0       	ldi	r18, 0x05	; 5
    e0ae:	0e 94 a5 9f 	call	0x13f4a	; 0x13f4a <writeAddress>

           //Serial_SendString("Disconnect\n");
        }

        if ( temp& 1<<1 )                       //Socket DISCON interrupt ?
    e0b2:	c1 fe       	sbrs	r12, 1
    e0b4:	18 c0       	rjmp	.+48     	; 0xe0e6 <Webcontrol+0x20e>
        {
            writeAddress(0x00, 0x02, 0x02, 5);	 // Clear Socket RECV Interrupt
    e0b6:	80 e0       	ldi	r24, 0x00	; 0
    e0b8:	62 e0       	ldi	r22, 0x02	; 2
    e0ba:	42 e0       	ldi	r20, 0x02	; 2
    e0bc:	25 e0       	ldi	r18, 0x05	; 5
    e0be:	0e 94 a5 9f 	call	0x13f4a	; 0x13f4a <writeAddress>
            writeAddress(0x00, 0x01, 0x10, 5);	 // Socket Command  Register -> CLOSE
    e0c2:	80 e0       	ldi	r24, 0x00	; 0
    e0c4:	61 e0       	ldi	r22, 0x01	; 1
    e0c6:	40 e1       	ldi	r20, 0x10	; 16
    e0c8:	25 e0       	ldi	r18, 0x05	; 5
    e0ca:	0e 94 a5 9f 	call	0x13f4a	; 0x13f4a <writeAddress>
            writeAddress(0x00, 0x01, 0x01, 5);	 // Socket Command  Register -> OPEN
    e0ce:	80 e0       	ldi	r24, 0x00	; 0
    e0d0:	61 e0       	ldi	r22, 0x01	; 1
    e0d2:	41 e0       	ldi	r20, 0x01	; 1
    e0d4:	25 e0       	ldi	r18, 0x05	; 5
    e0d6:	0e 94 a5 9f 	call	0x13f4a	; 0x13f4a <writeAddress>
            writeAddress(0x00, 0x01, 0x02, 5);	 // Socket Command  Register -> LISTEN
    e0da:	80 e0       	ldi	r24, 0x00	; 0
    e0dc:	61 e0       	ldi	r22, 0x01	; 1
    e0de:	42 e0       	ldi	r20, 0x02	; 2
    e0e0:	25 e0       	ldi	r18, 0x05	; 5
    e0e2:	0e 94 a5 9f 	call	0x13f4a	; 0x13f4a <writeAddress>

         if ( temp& 1<<3 )                       //Socket DISCON interrupt ?
        {
           // Serial_SendString("Timeout\n");
         }
    sei();                                          // enable all interrupts
    e0e6:	78 94       	sei
}
    e0e8:	60 96       	adiw	r28, 0x10	; 16
    e0ea:	0f b6       	in	r0, 0x3f	; 63
    e0ec:	f8 94       	cli
    e0ee:	de bf       	out	0x3e, r29	; 62
    e0f0:	0f be       	out	0x3f, r0	; 63
    e0f2:	cd bf       	out	0x3d, r28	; 61
    e0f4:	cf 91       	pop	r28
    e0f6:	df 91       	pop	r29
    e0f8:	1f 91       	pop	r17
    e0fa:	0f 91       	pop	r16
    e0fc:	ff 90       	pop	r15
    e0fe:	ef 90       	pop	r14
    e100:	df 90       	pop	r13
    e102:	cf 90       	pop	r12
    e104:	08 95       	ret

0000e106 <crc16_update>:
Initial value: 0xffff*/
uint16_t crc16_update(uint16_t crc, uint8_t a)
{
    uint8_t i;

    crc ^= a;
    e106:	70 e0       	ldi	r23, 0x00	; 0
    e108:	68 27       	eor	r22, r24
    e10a:	79 27       	eor	r23, r25
    e10c:	48 e0       	ldi	r20, 0x08	; 8
    for (i = 0; i < 8; ++i)
    {
        if (crc & 1)
            crc = (crc >> 1) ^ 0xa001;
    e10e:	21 e0       	ldi	r18, 0x01	; 1
    e110:	30 ea       	ldi	r19, 0xA0	; 160
    e112:	cb 01       	movw	r24, r22
    e114:	96 95       	lsr	r25
    e116:	87 95       	ror	r24
    uint8_t i;

    crc ^= a;
    for (i = 0; i < 8; ++i)
    {
        if (crc & 1)
    e118:	60 ff       	sbrs	r22, 0
    e11a:	04 c0       	rjmp	.+8      	; 0xe124 <crc16_update+0x1e>
            crc = (crc >> 1) ^ 0xa001;
    e11c:	bc 01       	movw	r22, r24
    e11e:	62 27       	eor	r22, r18
    e120:	73 27       	eor	r23, r19
    e122:	01 c0       	rjmp	.+2      	; 0xe126 <crc16_update+0x20>
        else
            crc = (crc >> 1);
    e124:	bc 01       	movw	r22, r24
    e126:	41 50       	subi	r20, 0x01	; 1
uint16_t crc16_update(uint16_t crc, uint8_t a)
{
    uint8_t i;

    crc ^= a;
    for (i = 0; i < 8; ++i)
    e128:	a1 f7       	brne	.-24     	; 0xe112 <crc16_update+0xc>
        else
            crc = (crc >> 1);
    }

    return crc;
}
    e12a:	cb 01       	movw	r24, r22
    e12c:	08 95       	ret

0000e12e <RadioReceive>:

/** Receive telegram from radio modul*/
void RadioReceive(void)
{
    e12e:	0f 93       	push	r16
    e130:	1f 93       	push	r17
    e132:	df 93       	push	r29
    e134:	cf 93       	push	r28
    e136:	cd b7       	in	r28, 0x3d	; 61
    e138:	de b7       	in	r29, 0x3e	; 62
    e13a:	2a 97       	sbiw	r28, 0x0a	; 10
    e13c:	0f b6       	in	r0, 0x3f	; 63
    e13e:	f8 94       	cli
    e140:	de bf       	out	0x3e, r29	; 62
    e142:	0f be       	out	0x3f, r0	; 63
    e144:	cd bf       	out	0x3d, r28	; 61
    #if (LCD==3)
    char LineBuffer[10];
    #endif

    cli();                                          // disable all interrupts
    e146:	f8 94       	cli
   	DataReceived = (uchar) Spi16(0xb000);           // receiver FIFO read command
    e148:	80 e0       	ldi	r24, 0x00	; 0
    e14a:	90 eb       	ldi	r25, 0xB0	; 176
    e14c:	0e 94 b3 99 	call	0x13366	; 0x13366 <Spi16>
    e150:	68 2f       	mov	r22, r24
    e152:	80 93 a5 0b 	sts	0x0BA5, r24

	if ((bufferposition>recbuf[0]+2)&rec_started)	// all bytes received
    e156:	00 91 b4 0b 	lds	r16, 0x0BB4
    e15a:	20 2f       	mov	r18, r16
    e15c:	30 e0       	ldi	r19, 0x00	; 0
    e15e:	80 91 a4 0b 	lds	r24, 0x0BA4
    e162:	40 91 a9 0b 	lds	r20, 0x0BA9
    e166:	50 e0       	ldi	r21, 0x00	; 0
    e168:	4e 5f       	subi	r20, 0xFE	; 254
    e16a:	5f 4f       	sbci	r21, 0xFF	; 255
    e16c:	e1 e0       	ldi	r30, 0x01	; 1
    e16e:	f0 e0       	ldi	r31, 0x00	; 0
    e170:	42 17       	cp	r20, r18
    e172:	53 07       	cpc	r21, r19
    e174:	14 f0       	brlt	.+4      	; 0xe17a <RadioReceive+0x4c>
    e176:	e0 e0       	ldi	r30, 0x00	; 0
    e178:	f0 e0       	ldi	r31, 0x00	; 0
    e17a:	48 2f       	mov	r20, r24
    e17c:	50 e0       	ldi	r21, 0x00	; 0
    e17e:	4e 23       	and	r20, r30
    e180:	5f 23       	and	r21, r31
    e182:	41 15       	cp	r20, r1
    e184:	51 05       	cpc	r21, r1
    e186:	09 f4       	brne	.+2      	; 0xe18a <RadioReceive+0x5c>
    e188:	72 c1       	rjmp	.+740    	; 0xe46e <RadioReceive+0x340>
    {
		rf12_crc_calculate = recbuf[6];
		rf12_crc_calculate = (rf12_crc_calculate << 8) + recbuf[5];
    e18a:	90 91 af 0b 	lds	r25, 0x0BAF
    e18e:	80 e0       	ldi	r24, 0x00	; 0
    e190:	40 91 ae 0b 	lds	r20, 0x0BAE
    e194:	84 0f       	add	r24, r20
    e196:	91 1d       	adc	r25, r1
    e198:	90 93 de 12 	sts	0x12DE, r25
    e19c:	80 93 dd 12 	sts	0x12DD, r24

		if (rf12_crc == rf12_crc_calculate) 		// Checksum OK -> display new value
    e1a0:	40 91 e3 12 	lds	r20, 0x12E3
    e1a4:	50 91 e4 12 	lds	r21, 0x12E4
    e1a8:	48 17       	cp	r20, r24
    e1aa:	59 07       	cpc	r21, r25
    e1ac:	09 f0       	breq	.+2      	; 0xe1b0 <RadioReceive+0x82>
    e1ae:	8a c1       	rjmp	.+788    	; 0xe4c4 <RadioReceive+0x396>
		{
		   recbuf[bufferposition-2] = '\0';			// set end of string, delete checksum
    e1b0:	29 55       	subi	r18, 0x59	; 89
    e1b2:	34 4f       	sbci	r19, 0xF4	; 244
    e1b4:	d9 01       	movw	r26, r18
    e1b6:	1c 92       	st	X, r1
			if (recbuf[1]=='A')					    // Sensor A
    e1b8:	80 91 aa 0b 	lds	r24, 0x0BAA
    e1bc:	81 34       	cpi	r24, 0x41	; 65
    e1be:	09 f0       	breq	.+2      	; 0xe1c2 <RadioReceive+0x94>
    e1c0:	6d c0       	rjmp	.+218    	; 0xe29c <RadioReceive+0x16e>
			{
			        Sensor2Value = atoi(&recbuf[2]);		 // convert in integer
    e1c2:	8b ea       	ldi	r24, 0xAB	; 171
    e1c4:	9b e0       	ldi	r25, 0x0B	; 11
    e1c6:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <atoi>
			        if (Sensor2Value != 0)
    e1ca:	88 23       	and	r24, r24
    e1cc:	39 f0       	breq	.+14     	; 0xe1dc <RadioReceive+0xae>
                    {
                        Sensor2Value -= 50;                       // check if conversion is ok, correct value with offset
    e1ce:	90 91 76 10 	lds	r25, 0x1076
    e1d2:	92 53       	subi	r25, 0x32	; 50
                        Sensor2Value += Sensor2Correction_SRAM;  // correct value if conversion ok
    e1d4:	98 0f       	add	r25, r24
    e1d6:	90 93 62 09 	sts	0x0962, r25
    e1da:	04 c0       	rjmp	.+8      	; 0xe1e4 <RadioReceive+0xb6>
                    }
			        else Sensor2Value = Sensor2PreviousValue;   // wrong values received
    e1dc:	80 91 b5 0b 	lds	r24, 0x0BB5
    e1e0:	80 93 62 09 	sts	0x0962, r24

			        if (recbuf[2] == 'X')                         // display battery warning message
    e1e4:	80 91 ab 0b 	lds	r24, 0x0BAB
    e1e8:	88 35       	cpi	r24, 0x58	; 88
    e1ea:	39 f4       	brne	.+14     	; 0xe1fa <RadioReceive+0xcc>
			        {
			            #if (LCD==3)
                        lcdSetFont((uint8_t*) Arial28x28);
    e1ec:	80 e6       	ldi	r24, 0x60	; 96
    e1ee:	95 e2       	ldi	r25, 0x25	; 37
    e1f0:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
			            lcdDrawString("BAT",20,170,YELLOW,BLACK);
    e1f4:	86 e7       	ldi	r24, 0x76	; 118
    e1f6:	96 e0       	ldi	r25, 0x06	; 6
    e1f8:	29 c0       	rjmp	.+82     	; 0xe24c <RadioReceive+0x11e>
			        }
                    else
                    {
                        #if (LCD==3)

                        lcdSetFont((uint8_t*) Arial28x28);
    e1fa:	80 e6       	ldi	r24, 0x60	; 96
    e1fc:	95 e2       	ldi	r25, 0x25	; 37
    e1fe:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
                        sprintf (LineBuffer, "%d~C", Sensor2Value);
    e202:	00 d0       	rcall	.+0      	; 0xe204 <RadioReceive+0xd6>
    e204:	00 d0       	rcall	.+0      	; 0xe206 <RadioReceive+0xd8>
    e206:	00 d0       	rcall	.+0      	; 0xe208 <RadioReceive+0xda>
    e208:	ed b7       	in	r30, 0x3d	; 61
    e20a:	fe b7       	in	r31, 0x3e	; 62
    e20c:	31 96       	adiw	r30, 0x01	; 1
    e20e:	8e 01       	movw	r16, r28
    e210:	0f 5f       	subi	r16, 0xFF	; 255
    e212:	1f 4f       	sbci	r17, 0xFF	; 255
    e214:	ad b7       	in	r26, 0x3d	; 61
    e216:	be b7       	in	r27, 0x3e	; 62
    e218:	12 96       	adiw	r26, 0x02	; 2
    e21a:	1c 93       	st	X, r17
    e21c:	0e 93       	st	-X, r16
    e21e:	11 97       	sbiw	r26, 0x01	; 1
    e220:	8a e7       	ldi	r24, 0x7A	; 122
    e222:	96 e0       	ldi	r25, 0x06	; 6
    e224:	93 83       	std	Z+3, r25	; 0x03
    e226:	82 83       	std	Z+2, r24	; 0x02
    e228:	80 91 62 09 	lds	r24, 0x0962
    e22c:	99 27       	eor	r25, r25
    e22e:	87 fd       	sbrc	r24, 7
    e230:	90 95       	com	r25
    e232:	95 83       	std	Z+5, r25	; 0x05
    e234:	84 83       	std	Z+4, r24	; 0x04
    e236:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
                        lcdDrawString(LineBuffer,20,170,YELLOW,BLACK);
    e23a:	ed b7       	in	r30, 0x3d	; 61
    e23c:	fe b7       	in	r31, 0x3e	; 62
    e23e:	36 96       	adiw	r30, 0x06	; 6
    e240:	0f b6       	in	r0, 0x3f	; 63
    e242:	f8 94       	cli
    e244:	fe bf       	out	0x3e, r31	; 62
    e246:	0f be       	out	0x3f, r0	; 63
    e248:	ed bf       	out	0x3d, r30	; 61
    e24a:	c8 01       	movw	r24, r16
    e24c:	64 e1       	ldi	r22, 0x14	; 20
    e24e:	70 e0       	ldi	r23, 0x00	; 0
    e250:	4a ea       	ldi	r20, 0xAA	; 170
    e252:	50 e0       	ldi	r21, 0x00	; 0
    e254:	20 ee       	ldi	r18, 0xE0	; 224
    e256:	3f ef       	ldi	r19, 0xFF	; 255
    e258:	00 e0       	ldi	r16, 0x00	; 0
    e25a:	10 e0       	ldi	r17, 0x00	; 0
    e25c:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
                        #else
                        lcd_print_value (Sensor2Value, "#C     ", '+', 2, 10, 2, 0);
                        #endif
                    }

              if (Sensor2Received)
    e260:	90 91 63 09 	lds	r25, 0x0963
    e264:	80 91 62 09 	lds	r24, 0x0962
    e268:	99 23       	and	r25, r25
    e26a:	69 f0       	breq	.+26     	; 0xe286 <RadioReceive+0x158>
              {
                  if (Sensor2Value < Sensor2MinValue) Sensor2MinValue = Sensor2Value;
    e26c:	90 91 79 10 	lds	r25, 0x1079
    e270:	89 17       	cp	r24, r25
    e272:	14 f4       	brge	.+4      	; 0xe278 <RadioReceive+0x14a>
    e274:	80 93 79 10 	sts	0x1079, r24
                  if (Sensor2Value > Sensor2MaxValue) Sensor2MaxValue = Sensor2Value;
    e278:	90 91 a6 0b 	lds	r25, 0x0BA6
    e27c:	98 17       	cp	r25, r24
    e27e:	54 f4       	brge	.+20     	; 0xe294 <RadioReceive+0x166>
    e280:	80 93 a6 0b 	sts	0x0BA6, r24
    e284:	07 c0       	rjmp	.+14     	; 0xe294 <RadioReceive+0x166>
              }
              else
              {
                  Sensor2MinValue = Sensor2Value;
    e286:	80 93 79 10 	sts	0x1079, r24
                  Sensor2MaxValue = Sensor2Value;
    e28a:	80 93 a6 0b 	sts	0x0BA6, r24
                  Sensor2Received = true;
    e28e:	81 e0       	ldi	r24, 0x01	; 1
    e290:	80 93 63 09 	sts	0x0963, r24
              }

             Sensor2Timeout = 0;								 // reset timeout
    e294:	10 92 7c 10 	sts	0x107C, r1
    e298:	10 92 7b 10 	sts	0x107B, r1
			}
			if (recbuf[1]=='B')					                    // Sensor B
    e29c:	80 91 aa 0b 	lds	r24, 0x0BAA
    e2a0:	82 34       	cpi	r24, 0x42	; 66
    e2a2:	09 f0       	breq	.+2      	; 0xe2a6 <RadioReceive+0x178>
    e2a4:	6f c0       	rjmp	.+222    	; 0xe384 <RadioReceive+0x256>
			{
			        Sensor3Value = atoi(&recbuf[2]);		 		// convert in integer
    e2a6:	8b ea       	ldi	r24, 0xAB	; 171
    e2a8:	9b e0       	ldi	r25, 0x0B	; 11
    e2aa:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <atoi>
			        if (Sensor3Value != 0)
    e2ae:	88 23       	and	r24, r24
    e2b0:	39 f0       	breq	.+14     	; 0xe2c0 <RadioReceive+0x192>
                    {
                        Sensor3Value -= 50;                         // check if conversion is ok, correct value with offset
    e2b2:	90 91 3c 0f 	lds	r25, 0x0F3C
    e2b6:	92 53       	subi	r25, 0x32	; 50
                        Sensor3Value += Sensor3Correction_SRAM; 	// correct value if conversion ok
    e2b8:	98 0f       	add	r25, r24
    e2ba:	90 93 64 09 	sts	0x0964, r25
    e2be:	04 c0       	rjmp	.+8      	; 0xe2c8 <RadioReceive+0x19a>
                    }
                    else Sensor3Value = Sensor3PreviousValue;       // // wrong values received
    e2c0:	80 91 b0 11 	lds	r24, 0x11B0
    e2c4:	80 93 64 09 	sts	0x0964, r24

                    if (recbuf[2] == 'X')                         // display battery warning message
    e2c8:	80 91 ab 0b 	lds	r24, 0x0BAB
    e2cc:	88 35       	cpi	r24, 0x58	; 88
    e2ce:	49 f4       	brne	.+18     	; 0xe2e2 <RadioReceive+0x1b4>
			        {
			            #if (LCD==3)
                        lcdSetFont((uint8_t*) Arial28x28);
    e2d0:	80 e6       	ldi	r24, 0x60	; 96
    e2d2:	95 e2       	ldi	r25, 0x25	; 37
    e2d4:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
			            lcdDrawString("BAT",125,170,MAGENTA,BLACK);
    e2d8:	86 e7       	ldi	r24, 0x76	; 118
    e2da:	96 e0       	ldi	r25, 0x06	; 6
    e2dc:	6d e7       	ldi	r22, 0x7D	; 125
    e2de:	70 e0       	ldi	r23, 0x00	; 0
    e2e0:	2b c0       	rjmp	.+86     	; 0xe338 <RadioReceive+0x20a>
			            #endif
			        }
                    else
                    {
                        #if (LCD==3)
                        lcdSetFont((uint8_t*) Arial28x28);
    e2e2:	80 e6       	ldi	r24, 0x60	; 96
    e2e4:	95 e2       	ldi	r25, 0x25	; 37
    e2e6:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
                        sprintf (LineBuffer, "%d~C", Sensor3Value);
    e2ea:	00 d0       	rcall	.+0      	; 0xe2ec <RadioReceive+0x1be>
    e2ec:	00 d0       	rcall	.+0      	; 0xe2ee <RadioReceive+0x1c0>
    e2ee:	00 d0       	rcall	.+0      	; 0xe2f0 <RadioReceive+0x1c2>
    e2f0:	ed b7       	in	r30, 0x3d	; 61
    e2f2:	fe b7       	in	r31, 0x3e	; 62
    e2f4:	31 96       	adiw	r30, 0x01	; 1
    e2f6:	8e 01       	movw	r16, r28
    e2f8:	0f 5f       	subi	r16, 0xFF	; 255
    e2fa:	1f 4f       	sbci	r17, 0xFF	; 255
    e2fc:	ad b7       	in	r26, 0x3d	; 61
    e2fe:	be b7       	in	r27, 0x3e	; 62
    e300:	12 96       	adiw	r26, 0x02	; 2
    e302:	1c 93       	st	X, r17
    e304:	0e 93       	st	-X, r16
    e306:	11 97       	sbiw	r26, 0x01	; 1
    e308:	8a e7       	ldi	r24, 0x7A	; 122
    e30a:	96 e0       	ldi	r25, 0x06	; 6
    e30c:	93 83       	std	Z+3, r25	; 0x03
    e30e:	82 83       	std	Z+2, r24	; 0x02
    e310:	80 91 64 09 	lds	r24, 0x0964
    e314:	99 27       	eor	r25, r25
    e316:	87 fd       	sbrc	r24, 7
    e318:	90 95       	com	r25
    e31a:	95 83       	std	Z+5, r25	; 0x05
    e31c:	84 83       	std	Z+4, r24	; 0x04
    e31e:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
                        lcdDrawString(LineBuffer,130,170,MAGENTA,BLACK);
    e322:	ed b7       	in	r30, 0x3d	; 61
    e324:	fe b7       	in	r31, 0x3e	; 62
    e326:	36 96       	adiw	r30, 0x06	; 6
    e328:	0f b6       	in	r0, 0x3f	; 63
    e32a:	f8 94       	cli
    e32c:	fe bf       	out	0x3e, r31	; 62
    e32e:	0f be       	out	0x3f, r0	; 63
    e330:	ed bf       	out	0x3d, r30	; 61
    e332:	c8 01       	movw	r24, r16
    e334:	62 e8       	ldi	r22, 0x82	; 130
    e336:	70 e0       	ldi	r23, 0x00	; 0
    e338:	4a ea       	ldi	r20, 0xAA	; 170
    e33a:	50 e0       	ldi	r21, 0x00	; 0
    e33c:	2f e1       	ldi	r18, 0x1F	; 31
    e33e:	38 ef       	ldi	r19, 0xF8	; 248
    e340:	00 e0       	ldi	r16, 0x00	; 0
    e342:	10 e0       	ldi	r17, 0x00	; 0
    e344:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
                        #else
                        lcd_print_value (Sensor3Value, "#C     ", '+', 3, 10, 2, 0);
                        #endif
                    }
              if (Sensor3Received)
    e348:	90 91 65 09 	lds	r25, 0x0965
    e34c:	80 91 64 09 	lds	r24, 0x0964
    e350:	99 23       	and	r25, r25
    e352:	69 f0       	breq	.+26     	; 0xe36e <RadioReceive+0x240>
              {
                  if (Sensor3Value < Sensor3MinValue) Sensor3MinValue = Sensor3Value;
    e354:	90 91 04 0d 	lds	r25, 0x0D04
    e358:	89 17       	cp	r24, r25
    e35a:	14 f4       	brge	.+4      	; 0xe360 <RadioReceive+0x232>
    e35c:	80 93 04 0d 	sts	0x0D04, r24
                  if (Sensor3Value > Sensor3MaxValue) Sensor3MaxValue = Sensor3Value;
    e360:	90 91 14 14 	lds	r25, 0x1414
    e364:	98 17       	cp	r25, r24
    e366:	54 f4       	brge	.+20     	; 0xe37c <RadioReceive+0x24e>
    e368:	80 93 14 14 	sts	0x1414, r24
    e36c:	07 c0       	rjmp	.+14     	; 0xe37c <RadioReceive+0x24e>
              }
              else
              {
                  Sensor3MinValue = Sensor3Value;
    e36e:	80 93 04 0d 	sts	0x0D04, r24
                  Sensor3MaxValue = Sensor3Value;
    e372:	80 93 14 14 	sts	0x1414, r24
                  Sensor3Received = true;
    e376:	81 e0       	ldi	r24, 0x01	; 1
    e378:	80 93 65 09 	sts	0x0965, r24
              }
              Sensor3Timeout = 0;								 // reset timeout
    e37c:	10 92 78 10 	sts	0x1078, r1
    e380:	10 92 77 10 	sts	0x1077, r1
            }
            if (recbuf[1]=='C')					    // Sensor C
    e384:	80 91 aa 0b 	lds	r24, 0x0BAA
    e388:	83 34       	cpi	r24, 0x43	; 67
    e38a:	09 f0       	breq	.+2      	; 0xe38e <RadioReceive+0x260>
    e38c:	9b c0       	rjmp	.+310    	; 0xe4c4 <RadioReceive+0x396>
			{
			        Sensor4Value = atoi(&recbuf[2]);		 // convert in integer
    e38e:	8b ea       	ldi	r24, 0xAB	; 171
    e390:	9b e0       	ldi	r25, 0x0B	; 11
    e392:	0e 94 05 ad 	call	0x15a0a	; 0x15a0a <atoi>
			        if (Sensor4Value != 0)
    e396:	88 23       	and	r24, r24
    e398:	39 f0       	breq	.+14     	; 0xe3a8 <RadioReceive+0x27a>
                    {
                        Sensor4Value -= 50;                       // check if conversion is ok, correct value with offset
    e39a:	90 91 7a 10 	lds	r25, 0x107A
    e39e:	92 53       	subi	r25, 0x32	; 50
                        Sensor4Value += Sensor4Correction_SRAM;  // correct value if conversion ok
    e3a0:	98 0f       	add	r25, r24
    e3a2:	90 93 66 09 	sts	0x0966, r25
    e3a6:	04 c0       	rjmp	.+8      	; 0xe3b0 <RadioReceive+0x282>
                    }
			        else Sensor4Value = Sensor4PreviousValue;   // wrong values received
    e3a8:	80 91 13 14 	lds	r24, 0x1413
    e3ac:	80 93 66 09 	sts	0x0966, r24

			        if (recbuf[2] == 'X')                         // display battery warning message
    e3b0:	80 91 ab 0b 	lds	r24, 0x0BAB
    e3b4:	88 35       	cpi	r24, 0x58	; 88
    e3b6:	49 f4       	brne	.+18     	; 0xe3ca <RadioReceive+0x29c>
			        {
			            #if (LCD==3)
                        lcdSetFont((uint8_t*) Arial28x28);
    e3b8:	80 e6       	ldi	r24, 0x60	; 96
    e3ba:	95 e2       	ldi	r25, 0x25	; 37
    e3bc:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
			            lcdDrawString("BAT",240,170,CYAN,BLACK);
    e3c0:	86 e7       	ldi	r24, 0x76	; 118
    e3c2:	96 e0       	ldi	r25, 0x06	; 6
    e3c4:	60 ef       	ldi	r22, 0xF0	; 240
    e3c6:	70 e0       	ldi	r23, 0x00	; 0
    e3c8:	2b c0       	rjmp	.+86     	; 0xe420 <RadioReceive+0x2f2>
			        }
                    else
                    {
                        #if (LCD==3)

                        lcdSetFont((uint8_t*) Arial28x28);
    e3ca:	80 e6       	ldi	r24, 0x60	; 96
    e3cc:	95 e2       	ldi	r25, 0x25	; 37
    e3ce:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
                        sprintf (LineBuffer, "%d~C", Sensor4Value);
    e3d2:	00 d0       	rcall	.+0      	; 0xe3d4 <RadioReceive+0x2a6>
    e3d4:	00 d0       	rcall	.+0      	; 0xe3d6 <RadioReceive+0x2a8>
    e3d6:	00 d0       	rcall	.+0      	; 0xe3d8 <RadioReceive+0x2aa>
    e3d8:	ed b7       	in	r30, 0x3d	; 61
    e3da:	fe b7       	in	r31, 0x3e	; 62
    e3dc:	31 96       	adiw	r30, 0x01	; 1
    e3de:	8e 01       	movw	r16, r28
    e3e0:	0f 5f       	subi	r16, 0xFF	; 255
    e3e2:	1f 4f       	sbci	r17, 0xFF	; 255
    e3e4:	ad b7       	in	r26, 0x3d	; 61
    e3e6:	be b7       	in	r27, 0x3e	; 62
    e3e8:	12 96       	adiw	r26, 0x02	; 2
    e3ea:	1c 93       	st	X, r17
    e3ec:	0e 93       	st	-X, r16
    e3ee:	11 97       	sbiw	r26, 0x01	; 1
    e3f0:	8a e7       	ldi	r24, 0x7A	; 122
    e3f2:	96 e0       	ldi	r25, 0x06	; 6
    e3f4:	93 83       	std	Z+3, r25	; 0x03
    e3f6:	82 83       	std	Z+2, r24	; 0x02
    e3f8:	80 91 66 09 	lds	r24, 0x0966
    e3fc:	99 27       	eor	r25, r25
    e3fe:	87 fd       	sbrc	r24, 7
    e400:	90 95       	com	r25
    e402:	95 83       	std	Z+5, r25	; 0x05
    e404:	84 83       	std	Z+4, r24	; 0x04
    e406:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
                        lcdDrawString(LineBuffer,235,170,CYAN,BLACK);
    e40a:	ed b7       	in	r30, 0x3d	; 61
    e40c:	fe b7       	in	r31, 0x3e	; 62
    e40e:	36 96       	adiw	r30, 0x06	; 6
    e410:	0f b6       	in	r0, 0x3f	; 63
    e412:	f8 94       	cli
    e414:	fe bf       	out	0x3e, r31	; 62
    e416:	0f be       	out	0x3f, r0	; 63
    e418:	ed bf       	out	0x3d, r30	; 61
    e41a:	c8 01       	movw	r24, r16
    e41c:	6b ee       	ldi	r22, 0xEB	; 235
    e41e:	70 e0       	ldi	r23, 0x00	; 0
    e420:	4a ea       	ldi	r20, 0xAA	; 170
    e422:	50 e0       	ldi	r21, 0x00	; 0
    e424:	2f ef       	ldi	r18, 0xFF	; 255
    e426:	37 e0       	ldi	r19, 0x07	; 7
    e428:	00 e0       	ldi	r16, 0x00	; 0
    e42a:	10 e0       	ldi	r17, 0x00	; 0
    e42c:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
                        #else
                        lcd_print_value (Sensor2Value, "#C     ", '+', 2, 10, 2, 0);
                        #endif
                    }

              if (Sensor4Received)
    e430:	90 91 67 09 	lds	r25, 0x0967
    e434:	80 91 66 09 	lds	r24, 0x0966
    e438:	99 23       	and	r25, r25
    e43a:	69 f0       	breq	.+26     	; 0xe456 <RadioReceive+0x328>
              {
                  if (Sensor4Value < Sensor4MinValue) Sensor4MinValue = Sensor4Value;
    e43c:	90 91 e2 12 	lds	r25, 0x12E2
    e440:	89 17       	cp	r24, r25
    e442:	14 f4       	brge	.+4      	; 0xe448 <RadioReceive+0x31a>
    e444:	80 93 e2 12 	sts	0x12E2, r24
                  if (Sensor4Value > Sensor4MaxValue) Sensor4MaxValue = Sensor4Value;
    e448:	90 91 e0 12 	lds	r25, 0x12E0
    e44c:	98 17       	cp	r25, r24
    e44e:	54 f4       	brge	.+20     	; 0xe464 <RadioReceive+0x336>
    e450:	80 93 e0 12 	sts	0x12E0, r24
    e454:	07 c0       	rjmp	.+14     	; 0xe464 <RadioReceive+0x336>
              }
              else
              {
                  Sensor4MinValue = Sensor4Value;
    e456:	80 93 e2 12 	sts	0x12E2, r24
                  Sensor4MaxValue = Sensor4Value;
    e45a:	80 93 e0 12 	sts	0x12E0, r24
                  Sensor4Received = true;
    e45e:	81 e0       	ldi	r24, 0x01	; 1
    e460:	80 93 67 09 	sts	0x0967, r24
              }

             Sensor3Timeout = 0;								 // reset timeout
    e464:	10 92 78 10 	sts	0x1078, r1
    e468:	10 92 77 10 	sts	0x1077, r1
    e46c:	2b c0       	rjmp	.+86     	; 0xe4c4 <RadioReceive+0x396>
		rec_started = 0;
		bufferposition = 0;
    }
    else
    {
		if (DataReceived == STX) 						// STX -> start of telegram -> save following characters
    e46e:	66 23       	and	r22, r22
    e470:	71 f4       	brne	.+28     	; 0xe48e <RadioReceive+0x360>
		{
			rec_started = 1;
    e472:	81 e0       	ldi	r24, 0x01	; 1
    e474:	80 93 a4 0b 	sts	0x0BA4, r24
			rf12_crc  = 0xFFFF;							// crc initial value
 			rf12_crc  = crc16_update(rf12_crc, 0xD4); 	// group ID for crc16
    e478:	8f ef       	ldi	r24, 0xFF	; 255
    e47a:	9f ef       	ldi	r25, 0xFF	; 255
    e47c:	64 ed       	ldi	r22, 0xD4	; 212
    e47e:	43 de       	rcall	.-890    	; 0xe106 <crc16_update>
      		rf12_crc  = crc16_update(rf12_crc, 0x00);
    e480:	60 e0       	ldi	r22, 0x00	; 0
    e482:	41 de       	rcall	.-894    	; 0xe106 <crc16_update>
    e484:	90 93 e4 12 	sts	0x12E4, r25
    e488:	80 93 e3 12 	sts	0x12E3, r24
    e48c:	21 c0       	rjmp	.+66     	; 0xe4d0 <RadioReceive+0x3a2>
       	}
		else if ((rec_started) && (bufferposition < 10))	// save telegram content, n -> next array position
    e48e:	88 23       	and	r24, r24
    e490:	b9 f0       	breq	.+46     	; 0xe4c0 <RadioReceive+0x392>
    e492:	0a 30       	cpi	r16, 0x0A	; 10
    e494:	b8 f4       	brcc	.+46     	; 0xe4c4 <RadioReceive+0x396>
		{
		recbuf[bufferposition] = DataReceived;
    e496:	27 55       	subi	r18, 0x57	; 87
    e498:	34 4f       	sbci	r19, 0xF4	; 244
    e49a:	d9 01       	movw	r26, r18
    e49c:	6c 93       	st	X, r22
		if (bufferposition <= recbuf[0]) rf12_crc =  crc16_update(rf12_crc, DataReceived);
    e49e:	80 91 a9 0b 	lds	r24, 0x0BA9
    e4a2:	80 17       	cp	r24, r16
    e4a4:	48 f0       	brcs	.+18     	; 0xe4b8 <RadioReceive+0x38a>
    e4a6:	80 91 e3 12 	lds	r24, 0x12E3
    e4aa:	90 91 e4 12 	lds	r25, 0x12E4
    e4ae:	2b de       	rcall	.-938    	; 0xe106 <crc16_update>
    e4b0:	90 93 e4 12 	sts	0x12E4, r25
    e4b4:	80 93 e3 12 	sts	0x12E3, r24
		bufferposition++;
    e4b8:	0f 5f       	subi	r16, 0xFF	; 255
    e4ba:	00 93 b4 0b 	sts	0x0BB4, r16
    e4be:	08 c0       	rjmp	.+16     	; 0xe4d0 <RadioReceive+0x3a2>
		}
		else if (bufferposition>=10)					// over 10 characters received -> reject telegram
    e4c0:	0a 30       	cpi	r16, 0x0A	; 10
    e4c2:	30 f0       	brcs	.+12     	; 0xe4d0 <RadioReceive+0x3a2>
		{
        RestartFifoFill_receiver();
    e4c4:	0e 94 15 9a 	call	0x1342a	; 0x1342a <RestartFifoFill_receiver>
		rec_started = 0;
    e4c8:	10 92 a4 0b 	sts	0x0BA4, r1
		bufferposition = 0;
    e4cc:	10 92 b4 0b 	sts	0x0BB4, r1
		}
	}
	sei();                                          // enable all interrupts
    e4d0:	78 94       	sei
}
    e4d2:	2a 96       	adiw	r28, 0x0a	; 10
    e4d4:	0f b6       	in	r0, 0x3f	; 63
    e4d6:	f8 94       	cli
    e4d8:	de bf       	out	0x3e, r29	; 62
    e4da:	0f be       	out	0x3f, r0	; 63
    e4dc:	cd bf       	out	0x3d, r28	; 61
    e4de:	cf 91       	pop	r28
    e4e0:	df 91       	pop	r29
    e4e2:	1f 91       	pop	r17
    e4e4:	0f 91       	pop	r16
    e4e6:	08 95       	ret

0000e4e8 <CloseLogFile>:
	}
}

/** Closes the open data log file on the Dataflash's FAT formatted partition */
void CloseLogFile(void)
{
    e4e8:	cf 93       	push	r28
    e4ea:	df 93       	push	r29
	/* Sync any data waiting to be written, unmount the storage device */
	f_sync(&TempLogFile);
    e4ec:	c3 e8       	ldi	r28, 0x83	; 131
    e4ee:	d9 e0       	ldi	r29, 0x09	; 9
    e4f0:	ce 01       	movw	r24, r28
    e4f2:	0e 94 53 96 	call	0x12ca6	; 0x12ca6 <f_sync>
	f_close(&TempLogFile);
    e4f6:	ce 01       	movw	r24, r28
    e4f8:	0e 94 ae 96 	call	0x12d5c	; 0x12d5c <f_close>
}
    e4fc:	df 91       	pop	r29
    e4fe:	cf 91       	pop	r28
    e500:	08 95       	ret

0000e502 <OpenLogFile>:
	sei();                                          // enable all interrupts
}

/** Opens the log file on the Dataflash's FAT formatted partition according to the current date */
void OpenLogFile(void)
{
    e502:	0f 93       	push	r16
    e504:	1f 93       	push	r17
    e506:	df 93       	push	r29
    e508:	cf 93       	push	r28
    e50a:	cd b7       	in	r28, 0x3d	; 61
    e50c:	de b7       	in	r29, 0x3e	; 62
    e50e:	62 97       	sbiw	r28, 0x12	; 18
    e510:	0f b6       	in	r0, 0x3f	; 63
    e512:	f8 94       	cli
    e514:	de bf       	out	0x3e, r29	; 62
    e516:	0f be       	out	0x3f, r0	; 63
    e518:	cd bf       	out	0x3d, r28	; 61
	char LogFileName[12];

	/* Get the current date for the filename as "X_DDMMYY.txt", X --> Sensor number */
	TimeDate_t CurrentTimeDate;
	RTC_GetTimeDate(&CurrentTimeDate);
    e51a:	ce 01       	movw	r24, r28
    e51c:	01 96       	adiw	r24, 0x01	; 1
    e51e:	0e 94 a0 85 	call	0x10b40	; 0x10b40 <RTC_GetTimeDate>
	oldday=CurrentTimeDate.Day;
    e522:	2c 81       	ldd	r18, Y+4	; 0x04
    e524:	20 93 f8 0c 	sts	0x0CF8, r18
	sprintf(LogFileName, "%02d%02d%02d.txt", CurrentTimeDate.Day, CurrentTimeDate.Month, CurrentTimeDate.Year);
    e528:	8d b7       	in	r24, 0x3d	; 61
    e52a:	9e b7       	in	r25, 0x3e	; 62
    e52c:	0a 97       	sbiw	r24, 0x0a	; 10
    e52e:	0f b6       	in	r0, 0x3f	; 63
    e530:	f8 94       	cli
    e532:	9e bf       	out	0x3e, r25	; 62
    e534:	0f be       	out	0x3f, r0	; 63
    e536:	8d bf       	out	0x3d, r24	; 61
    e538:	ed b7       	in	r30, 0x3d	; 61
    e53a:	fe b7       	in	r31, 0x3e	; 62
    e53c:	31 96       	adiw	r30, 0x01	; 1
    e53e:	8e 01       	movw	r16, r28
    e540:	09 5f       	subi	r16, 0xF9	; 249
    e542:	1f 4f       	sbci	r17, 0xFF	; 255
    e544:	ad b7       	in	r26, 0x3d	; 61
    e546:	be b7       	in	r27, 0x3e	; 62
    e548:	12 96       	adiw	r26, 0x02	; 2
    e54a:	1c 93       	st	X, r17
    e54c:	0e 93       	st	-X, r16
    e54e:	11 97       	sbiw	r26, 0x01	; 1
    e550:	8f e7       	ldi	r24, 0x7F	; 127
    e552:	96 e0       	ldi	r25, 0x06	; 6
    e554:	93 83       	std	Z+3, r25	; 0x03
    e556:	82 83       	std	Z+2, r24	; 0x02
    e558:	24 83       	std	Z+4, r18	; 0x04
    e55a:	15 82       	std	Z+5, r1	; 0x05
    e55c:	8d 81       	ldd	r24, Y+5	; 0x05
    e55e:	86 83       	std	Z+6, r24	; 0x06
    e560:	17 82       	std	Z+7, r1	; 0x07
    e562:	8e 81       	ldd	r24, Y+6	; 0x06
    e564:	80 87       	std	Z+8, r24	; 0x08
    e566:	11 86       	std	Z+9, r1	; 0x09
    e568:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>

	f_mount(0, &DiskFATState);
    e56c:	8d b7       	in	r24, 0x3d	; 61
    e56e:	9e b7       	in	r25, 0x3e	; 62
    e570:	0a 96       	adiw	r24, 0x0a	; 10
    e572:	0f b6       	in	r0, 0x3f	; 63
    e574:	f8 94       	cli
    e576:	9e bf       	out	0x3e, r25	; 62
    e578:	0f be       	out	0x3f, r0	; 63
    e57a:	8d bf       	out	0x3d, r24	; 61
    e57c:	80 e0       	ldi	r24, 0x00	; 0
    e57e:	65 e0       	ldi	r22, 0x05	; 5
    e580:	7d e0       	ldi	r23, 0x0D	; 13
    e582:	0e 94 33 93 	call	0x12666	; 0x12666 <f_mount>
	f_open(&TempLogFile, LogFileName, FA_OPEN_ALWAYS | FA_WRITE);
    e586:	83 e8       	ldi	r24, 0x83	; 131
    e588:	99 e0       	ldi	r25, 0x09	; 9
    e58a:	b8 01       	movw	r22, r16
    e58c:	42 e1       	ldi	r20, 0x12	; 18
    e58e:	0e 94 49 93 	call	0x12692	; 0x12692 <f_open>
	f_lseek(&TempLogFile, TempLogFile.fsize);
    e592:	40 91 8d 09 	lds	r20, 0x098D
    e596:	50 91 8e 09 	lds	r21, 0x098E
    e59a:	60 91 8f 09 	lds	r22, 0x098F
    e59e:	70 91 90 09 	lds	r23, 0x0990
    e5a2:	83 e8       	ldi	r24, 0x83	; 131
    e5a4:	99 e0       	ldi	r25, 0x09	; 9
    e5a6:	0e 94 b9 96 	call	0x12d72	; 0x12d72 <f_lseek>

	if (!(LOCAL_Port_Read & (1<<LOCAL)))
    e5aa:	37 99       	sbic	0x06, 7	; 6
    e5ac:	1e c0       	rjmp	.+60     	; 0xe5ea <OpenLogFile+0xe8>
	{
		LogfileCreateSuccess = true;
    e5ae:	81 e0       	ldi	r24, 0x01	; 1
    e5b0:	80 93 12 14 	sts	0x1412, r24

		if (DaysLeft_SRAM > 5)
    e5b4:	80 91 7d 10 	lds	r24, 0x107D
    e5b8:	90 91 7e 10 	lds	r25, 0x107E
    e5bc:	86 30       	cpi	r24, 0x06	; 6
    e5be:	91 05       	cpc	r25, r1
    e5c0:	e0 f4       	brcc	.+56     	; 0xe5fa <OpenLogFile+0xf8>
		{
			LogfileCreateSuccess = true;
		}
		else
		{
			LogfileCreateSuccess = false;
    e5c2:	10 92 12 14 	sts	0x1412, r1
			CloseLogFile();
    e5c6:	90 df       	rcall	.-224    	; 0xe4e8 <CloseLogFile>
			#if (LCD==3)
			lcdSetFont((uint8_t*) Arial28x28);
    e5c8:	80 e6       	ldi	r24, 0x60	; 96
    e5ca:	95 e2       	ldi	r25, 0x25	; 37
    e5cc:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
			lcdDrawString("Memory full",10,110,RED,BLACK);
    e5d0:	80 e9       	ldi	r24, 0x90	; 144
    e5d2:	96 e0       	ldi	r25, 0x06	; 6
    e5d4:	6a e0       	ldi	r22, 0x0A	; 10
    e5d6:	70 e0       	ldi	r23, 0x00	; 0
    e5d8:	4e e6       	ldi	r20, 0x6E	; 110
    e5da:	50 e0       	ldi	r21, 0x00	; 0
    e5dc:	20 e0       	ldi	r18, 0x00	; 0
    e5de:	38 ef       	ldi	r19, 0xF8	; 248
    e5e0:	00 e0       	ldi	r16, 0x00	; 0
    e5e2:	10 e0       	ldi	r17, 0x00	; 0
    e5e4:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    e5e8:	08 c0       	rjmp	.+16     	; 0xe5fa <OpenLogFile+0xf8>
			#endif
		}
	}
	else
	{
		f_getfree (0, (DWORD*)&FreeMemory,(FATFS**)&DiskFATState);
    e5ea:	80 e0       	ldi	r24, 0x00	; 0
    e5ec:	90 e0       	ldi	r25, 0x00	; 0
    e5ee:	69 e6       	ldi	r22, 0x69	; 105
    e5f0:	70 e1       	ldi	r23, 0x10	; 16
    e5f2:	45 e0       	ldi	r20, 0x05	; 5
    e5f4:	5d e0       	ldi	r21, 0x0D	; 13
    e5f6:	0e 94 b3 98 	call	0x13166	; 0x13166 <f_getfree>
	}
}
    e5fa:	62 96       	adiw	r28, 0x12	; 18
    e5fc:	0f b6       	in	r0, 0x3f	; 63
    e5fe:	f8 94       	cli
    e600:	de bf       	out	0x3e, r29	; 62
    e602:	0f be       	out	0x3f, r0	; 63
    e604:	cd bf       	out	0x3d, r28	; 61
    e606:	cf 91       	pop	r28
    e608:	df 91       	pop	r29
    e60a:	1f 91       	pop	r17
    e60c:	0f 91       	pop	r16
    e60e:	08 95       	ret

0000e610 <DrawFrame1>:
		}
}


void DrawFrame1 (void)
{
    e610:	0f 93       	push	r16
    e612:	1f 93       	push	r17
    lcdFillRGB(BLACK);
    e614:	80 e0       	ldi	r24, 0x00	; 0
    e616:	90 e0       	ldi	r25, 0x00	; 0
    e618:	0e 94 ea 9c 	call	0x139d4	; 0x139d4 <lcdFillRGB>

    lcdDrawRectangle(1,1,318,239,SILVER);
    e61c:	81 e0       	ldi	r24, 0x01	; 1
    e61e:	90 e0       	ldi	r25, 0x00	; 0
    e620:	61 e0       	ldi	r22, 0x01	; 1
    e622:	70 e0       	ldi	r23, 0x00	; 0
    e624:	4e e3       	ldi	r20, 0x3E	; 62
    e626:	51 e0       	ldi	r21, 0x01	; 1
    e628:	2f ee       	ldi	r18, 0xEF	; 239
    e62a:	30 e0       	ldi	r19, 0x00	; 0
    e62c:	00 e1       	ldi	r16, 0x10	; 16
    e62e:	15 ea       	ldi	r17, 0xA5	; 165
    e630:	0e 94 45 9e 	call	0x13c8a	; 0x13c8a <lcdDrawRectangle>
    lcdDrawHLine(1,120,318,SILVER);
    e634:	81 e0       	ldi	r24, 0x01	; 1
    e636:	90 e0       	ldi	r25, 0x00	; 0
    e638:	68 e7       	ldi	r22, 0x78	; 120
    e63a:	70 e0       	ldi	r23, 0x00	; 0
    e63c:	4e e3       	ldi	r20, 0x3E	; 62
    e63e:	51 e0       	ldi	r21, 0x01	; 1
    e640:	20 e1       	ldi	r18, 0x10	; 16
    e642:	35 ea       	ldi	r19, 0xA5	; 165
    e644:	0e 94 f9 9c 	call	0x139f2	; 0x139f2 <lcdDrawHLine>
    lcdDrawVLine(106,120,239,SILVER);
    e648:	8a e6       	ldi	r24, 0x6A	; 106
    e64a:	90 e0       	ldi	r25, 0x00	; 0
    e64c:	68 e7       	ldi	r22, 0x78	; 120
    e64e:	70 e0       	ldi	r23, 0x00	; 0
    e650:	4f ee       	ldi	r20, 0xEF	; 239
    e652:	50 e0       	ldi	r21, 0x00	; 0
    e654:	20 e1       	ldi	r18, 0x10	; 16
    e656:	35 ea       	ldi	r19, 0xA5	; 165
    e658:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
    lcdDrawVLine(212,120,239,SILVER);
    e65c:	84 ed       	ldi	r24, 0xD4	; 212
    e65e:	90 e0       	ldi	r25, 0x00	; 0
    e660:	68 e7       	ldi	r22, 0x78	; 120
    e662:	70 e0       	ldi	r23, 0x00	; 0
    e664:	4f ee       	ldi	r20, 0xEF	; 239
    e666:	50 e0       	ldi	r21, 0x00	; 0
    e668:	20 e1       	ldi	r18, 0x10	; 16
    e66a:	35 ea       	ldi	r19, 0xA5	; 165
    e66c:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>

    lcdSetFont((uint8_t*) Arial24x23);
    e670:	8c ef       	ldi	r24, 0xFC	; 252
    e672:	99 e0       	ldi	r25, 0x09	; 9
    e674:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
    lcdDrawChar('1',10, 140, SILVER, BLACK);
    e678:	81 e3       	ldi	r24, 0x31	; 49
    e67a:	6a e0       	ldi	r22, 0x0A	; 10
    e67c:	70 e0       	ldi	r23, 0x00	; 0
    e67e:	4c e8       	ldi	r20, 0x8C	; 140
    e680:	50 e0       	ldi	r21, 0x00	; 0
    e682:	20 e1       	ldi	r18, 0x10	; 16
    e684:	35 ea       	ldi	r19, 0xA5	; 165
    e686:	00 e0       	ldi	r16, 0x00	; 0
    e688:	10 e0       	ldi	r17, 0x00	; 0
    e68a:	0e 94 83 9e 	call	0x13d06	; 0x13d06 <lcdDrawChar>
    lcdDrawChar('2',115, 140, SILVER, BLACK);
    e68e:	82 e3       	ldi	r24, 0x32	; 50
    e690:	63 e7       	ldi	r22, 0x73	; 115
    e692:	70 e0       	ldi	r23, 0x00	; 0
    e694:	4c e8       	ldi	r20, 0x8C	; 140
    e696:	50 e0       	ldi	r21, 0x00	; 0
    e698:	20 e1       	ldi	r18, 0x10	; 16
    e69a:	35 ea       	ldi	r19, 0xA5	; 165
    e69c:	0e 94 83 9e 	call	0x13d06	; 0x13d06 <lcdDrawChar>
    lcdDrawChar('3',220, 140, SILVER, BLACK);
    e6a0:	83 e3       	ldi	r24, 0x33	; 51
    e6a2:	6c ed       	ldi	r22, 0xDC	; 220
    e6a4:	70 e0       	ldi	r23, 0x00	; 0
    e6a6:	4c e8       	ldi	r20, 0x8C	; 140
    e6a8:	50 e0       	ldi	r21, 0x00	; 0
    e6aa:	20 e1       	ldi	r18, 0x10	; 16
    e6ac:	35 ea       	ldi	r19, 0xA5	; 165
    e6ae:	0e 94 83 9e 	call	0x13d06	; 0x13d06 <lcdDrawChar>
    lcdDrawString("IN",5,50,SILVER,BLACK);
    e6b2:	8c e9       	ldi	r24, 0x9C	; 156
    e6b4:	96 e0       	ldi	r25, 0x06	; 6
    e6b6:	65 e0       	ldi	r22, 0x05	; 5
    e6b8:	70 e0       	ldi	r23, 0x00	; 0
    e6ba:	42 e3       	ldi	r20, 0x32	; 50
    e6bc:	50 e0       	ldi	r21, 0x00	; 0
    e6be:	20 e1       	ldi	r18, 0x10	; 16
    e6c0:	35 ea       	ldi	r19, 0xA5	; 165
    e6c2:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>

    lcdSetFont((uint8_t*) Arial12x12);
    e6c6:	88 e9       	ldi	r24, 0x98	; 152
    e6c8:	90 e0       	ldi	r25, 0x00	; 0
    e6ca:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
    lcdDrawString(Sensor2Name_SRAM,20,215,YELLOW,BLACK);
    e6ce:	83 e3       	ldi	r24, 0x33	; 51
    e6d0:	9f e0       	ldi	r25, 0x0F	; 15
    e6d2:	64 e1       	ldi	r22, 0x14	; 20
    e6d4:	70 e0       	ldi	r23, 0x00	; 0
    e6d6:	47 ed       	ldi	r20, 0xD7	; 215
    e6d8:	50 e0       	ldi	r21, 0x00	; 0
    e6da:	20 ee       	ldi	r18, 0xE0	; 224
    e6dc:	3f ef       	ldi	r19, 0xFF	; 255
    e6de:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString(Sensor3Name_SRAM,125,215,MAGENTA,BLACK);
    e6e2:	8d e6       	ldi	r24, 0x6D	; 109
    e6e4:	90 e1       	ldi	r25, 0x10	; 16
    e6e6:	6d e7       	ldi	r22, 0x7D	; 125
    e6e8:	70 e0       	ldi	r23, 0x00	; 0
    e6ea:	47 ed       	ldi	r20, 0xD7	; 215
    e6ec:	50 e0       	ldi	r21, 0x00	; 0
    e6ee:	2f e1       	ldi	r18, 0x1F	; 31
    e6f0:	38 ef       	ldi	r19, 0xF8	; 248
    e6f2:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString(Sensor4Name_SRAM,235,215,CYAN,BLACK);
    e6f6:	86 ee       	ldi	r24, 0xE6	; 230
    e6f8:	9c e0       	ldi	r25, 0x0C	; 12
    e6fa:	6b ee       	ldi	r22, 0xEB	; 235
    e6fc:	70 e0       	ldi	r23, 0x00	; 0
    e6fe:	47 ed       	ldi	r20, 0xD7	; 215
    e700:	50 e0       	ldi	r21, 0x00	; 0
    e702:	2f ef       	ldi	r18, 0xFF	; 255
    e704:	37 e0       	ldi	r19, 0x07	; 7
    e706:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
}
    e70a:	1f 91       	pop	r17
    e70c:	0f 91       	pop	r16
    e70e:	08 95       	ret

0000e710 <DrawFrame2>:

void DrawFrame2 (void)
{
    e710:	0f 93       	push	r16
    e712:	1f 93       	push	r17
    e714:	cf 93       	push	r28
    e716:	df 93       	push	r29
    lcdFillRGB(BLACK);
    e718:	80 e0       	ldi	r24, 0x00	; 0
    e71a:	90 e0       	ldi	r25, 0x00	; 0
    e71c:	0e 94 ea 9c 	call	0x139d4	; 0x139d4 <lcdFillRGB>

    lcdDrawRectangle(10,20,300,200,YELLOW);
    e720:	8a e0       	ldi	r24, 0x0A	; 10
    e722:	90 e0       	ldi	r25, 0x00	; 0
    e724:	64 e1       	ldi	r22, 0x14	; 20
    e726:	70 e0       	ldi	r23, 0x00	; 0
    e728:	4c e2       	ldi	r20, 0x2C	; 44
    e72a:	51 e0       	ldi	r21, 0x01	; 1
    e72c:	28 ec       	ldi	r18, 0xC8	; 200
    e72e:	30 e0       	ldi	r19, 0x00	; 0
    e730:	00 ee       	ldi	r16, 0xE0	; 224
    e732:	1f ef       	ldi	r17, 0xFF	; 255
    e734:	0e 94 45 9e 	call	0x13c8a	; 0x13c8a <lcdDrawRectangle>
    lcdDrawHLine(10,60,310,SILVER);
    e738:	8a e0       	ldi	r24, 0x0A	; 10
    e73a:	90 e0       	ldi	r25, 0x00	; 0
    e73c:	6c e3       	ldi	r22, 0x3C	; 60
    e73e:	70 e0       	ldi	r23, 0x00	; 0
    e740:	46 e3       	ldi	r20, 0x36	; 54
    e742:	51 e0       	ldi	r21, 0x01	; 1
    e744:	20 e1       	ldi	r18, 0x10	; 16
    e746:	35 ea       	ldi	r19, 0xA5	; 165
    e748:	0e 94 f9 9c 	call	0x139f2	; 0x139f2 <lcdDrawHLine>
    lcdDrawHLine(10,100,310,SILVER);
    e74c:	8a e0       	ldi	r24, 0x0A	; 10
    e74e:	90 e0       	ldi	r25, 0x00	; 0
    e750:	64 e6       	ldi	r22, 0x64	; 100
    e752:	70 e0       	ldi	r23, 0x00	; 0
    e754:	46 e3       	ldi	r20, 0x36	; 54
    e756:	51 e0       	ldi	r21, 0x01	; 1
    e758:	20 e1       	ldi	r18, 0x10	; 16
    e75a:	35 ea       	ldi	r19, 0xA5	; 165
    e75c:	0e 94 f9 9c 	call	0x139f2	; 0x139f2 <lcdDrawHLine>
    lcdDrawHLine(10,140,310,SILVER);
    e760:	8a e0       	ldi	r24, 0x0A	; 10
    e762:	90 e0       	ldi	r25, 0x00	; 0
    e764:	6c e8       	ldi	r22, 0x8C	; 140
    e766:	70 e0       	ldi	r23, 0x00	; 0
    e768:	46 e3       	ldi	r20, 0x36	; 54
    e76a:	51 e0       	ldi	r21, 0x01	; 1
    e76c:	20 e1       	ldi	r18, 0x10	; 16
    e76e:	35 ea       	ldi	r19, 0xA5	; 165
    e770:	0e 94 f9 9c 	call	0x139f2	; 0x139f2 <lcdDrawHLine>
    lcdDrawHLine(10,180,310,SILVER);
    e774:	8a e0       	ldi	r24, 0x0A	; 10
    e776:	90 e0       	ldi	r25, 0x00	; 0
    e778:	64 eb       	ldi	r22, 0xB4	; 180
    e77a:	70 e0       	ldi	r23, 0x00	; 0
    e77c:	46 e3       	ldi	r20, 0x36	; 54
    e77e:	51 e0       	ldi	r21, 0x01	; 1
    e780:	20 e1       	ldi	r18, 0x10	; 16
    e782:	35 ea       	ldi	r19, 0xA5	; 165
    e784:	0e 94 f9 9c 	call	0x139f2	; 0x139f2 <lcdDrawHLine>
    lcdDrawVLine(60,20,220,SILVER);
    e788:	8c e3       	ldi	r24, 0x3C	; 60
    e78a:	90 e0       	ldi	r25, 0x00	; 0
    e78c:	64 e1       	ldi	r22, 0x14	; 20
    e78e:	70 e0       	ldi	r23, 0x00	; 0
    e790:	4c ed       	ldi	r20, 0xDC	; 220
    e792:	50 e0       	ldi	r21, 0x00	; 0
    e794:	20 e1       	ldi	r18, 0x10	; 16
    e796:	35 ea       	ldi	r19, 0xA5	; 165
    e798:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
    lcdDrawVLine(110,20,220,SILVER);
    e79c:	8e e6       	ldi	r24, 0x6E	; 110
    e79e:	90 e0       	ldi	r25, 0x00	; 0
    e7a0:	64 e1       	ldi	r22, 0x14	; 20
    e7a2:	70 e0       	ldi	r23, 0x00	; 0
    e7a4:	4c ed       	ldi	r20, 0xDC	; 220
    e7a6:	50 e0       	ldi	r21, 0x00	; 0
    e7a8:	20 e1       	ldi	r18, 0x10	; 16
    e7aa:	35 ea       	ldi	r19, 0xA5	; 165
    e7ac:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
    lcdDrawVLine(160,20,220,SILVER);
    e7b0:	80 ea       	ldi	r24, 0xA0	; 160
    e7b2:	90 e0       	ldi	r25, 0x00	; 0
    e7b4:	64 e1       	ldi	r22, 0x14	; 20
    e7b6:	70 e0       	ldi	r23, 0x00	; 0
    e7b8:	4c ed       	ldi	r20, 0xDC	; 220
    e7ba:	50 e0       	ldi	r21, 0x00	; 0
    e7bc:	20 e1       	ldi	r18, 0x10	; 16
    e7be:	35 ea       	ldi	r19, 0xA5	; 165
    e7c0:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
    lcdDrawVLine(210,20,220,SILVER);
    e7c4:	82 ed       	ldi	r24, 0xD2	; 210
    e7c6:	90 e0       	ldi	r25, 0x00	; 0
    e7c8:	64 e1       	ldi	r22, 0x14	; 20
    e7ca:	70 e0       	ldi	r23, 0x00	; 0
    e7cc:	4c ed       	ldi	r20, 0xDC	; 220
    e7ce:	50 e0       	ldi	r21, 0x00	; 0
    e7d0:	20 e1       	ldi	r18, 0x10	; 16
    e7d2:	35 ea       	ldi	r19, 0xA5	; 165
    e7d4:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
    lcdDrawVLine(260,20,220,SILVER);
    e7d8:	84 e0       	ldi	r24, 0x04	; 4
    e7da:	91 e0       	ldi	r25, 0x01	; 1
    e7dc:	64 e1       	ldi	r22, 0x14	; 20
    e7de:	70 e0       	ldi	r23, 0x00	; 0
    e7e0:	4c ed       	ldi	r20, 0xDC	; 220
    e7e2:	50 e0       	ldi	r21, 0x00	; 0
    e7e4:	20 e1       	ldi	r18, 0x10	; 16
    e7e6:	35 ea       	ldi	r19, 0xA5	; 165
    e7e8:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>

    lcdSetFont((uint8_t*) Arial12x12);
    e7ec:	88 e9       	ldi	r24, 0x98	; 152
    e7ee:	90 e0       	ldi	r25, 0x00	; 0
    e7f0:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>

    lcdDrawString("0",5, 220, WHITE, BLACK);
    e7f4:	8f e9       	ldi	r24, 0x9F	; 159
    e7f6:	96 e0       	ldi	r25, 0x06	; 6
    e7f8:	65 e0       	ldi	r22, 0x05	; 5
    e7fa:	70 e0       	ldi	r23, 0x00	; 0
    e7fc:	4c ed       	ldi	r20, 0xDC	; 220
    e7fe:	50 e0       	ldi	r21, 0x00	; 0
    e800:	2f ef       	ldi	r18, 0xFF	; 255
    e802:	3f ef       	ldi	r19, 0xFF	; 255
    e804:	00 e0       	ldi	r16, 0x00	; 0
    e806:	10 e0       	ldi	r17, 0x00	; 0
    e808:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("10",0, 175, WHITE, BLACK);
    e80c:	81 ea       	ldi	r24, 0xA1	; 161
    e80e:	96 e0       	ldi	r25, 0x06	; 6
    e810:	60 e0       	ldi	r22, 0x00	; 0
    e812:	70 e0       	ldi	r23, 0x00	; 0
    e814:	4f ea       	ldi	r20, 0xAF	; 175
    e816:	50 e0       	ldi	r21, 0x00	; 0
    e818:	2f ef       	ldi	r18, 0xFF	; 255
    e81a:	3f ef       	ldi	r19, 0xFF	; 255
    e81c:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("20",0, 135, WHITE, BLACK);
    e820:	c4 ea       	ldi	r28, 0xA4	; 164
    e822:	d6 e0       	ldi	r29, 0x06	; 6
    e824:	ce 01       	movw	r24, r28
    e826:	60 e0       	ldi	r22, 0x00	; 0
    e828:	70 e0       	ldi	r23, 0x00	; 0
    e82a:	47 e8       	ldi	r20, 0x87	; 135
    e82c:	50 e0       	ldi	r21, 0x00	; 0
    e82e:	2f ef       	ldi	r18, 0xFF	; 255
    e830:	3f ef       	ldi	r19, 0xFF	; 255
    e832:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("30",0, 95, WHITE, BLACK);
    e836:	87 ea       	ldi	r24, 0xA7	; 167
    e838:	96 e0       	ldi	r25, 0x06	; 6
    e83a:	60 e0       	ldi	r22, 0x00	; 0
    e83c:	70 e0       	ldi	r23, 0x00	; 0
    e83e:	4f e5       	ldi	r20, 0x5F	; 95
    e840:	50 e0       	ldi	r21, 0x00	; 0
    e842:	2f ef       	ldi	r18, 0xFF	; 255
    e844:	3f ef       	ldi	r19, 0xFF	; 255
    e846:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("40",0, 55, WHITE, BLACK);
    e84a:	8a ea       	ldi	r24, 0xAA	; 170
    e84c:	96 e0       	ldi	r25, 0x06	; 6
    e84e:	60 e0       	ldi	r22, 0x00	; 0
    e850:	70 e0       	ldi	r23, 0x00	; 0
    e852:	47 e3       	ldi	r20, 0x37	; 55
    e854:	50 e0       	ldi	r21, 0x00	; 0
    e856:	2f ef       	ldi	r18, 0xFF	; 255
    e858:	3f ef       	ldi	r19, 0xFF	; 255
    e85a:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("50 Grad",0, 15, WHITE, BLACK);
    e85e:	8d ea       	ldi	r24, 0xAD	; 173
    e860:	96 e0       	ldi	r25, 0x06	; 6
    e862:	60 e0       	ldi	r22, 0x00	; 0
    e864:	70 e0       	ldi	r23, 0x00	; 0
    e866:	4f e0       	ldi	r20, 0x0F	; 15
    e868:	50 e0       	ldi	r21, 0x00	; 0
    e86a:	2f ef       	ldi	r18, 0xFF	; 255
    e86c:	3f ef       	ldi	r19, 0xFF	; 255
    e86e:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>

    lcdDrawString("4",55, 220, WHITE, BLACK);
    e872:	85 eb       	ldi	r24, 0xB5	; 181
    e874:	96 e0       	ldi	r25, 0x06	; 6
    e876:	67 e3       	ldi	r22, 0x37	; 55
    e878:	70 e0       	ldi	r23, 0x00	; 0
    e87a:	4c ed       	ldi	r20, 0xDC	; 220
    e87c:	50 e0       	ldi	r21, 0x00	; 0
    e87e:	2f ef       	ldi	r18, 0xFF	; 255
    e880:	3f ef       	ldi	r19, 0xFF	; 255
    e882:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("8",105, 220, WHITE, BLACK);
    e886:	87 eb       	ldi	r24, 0xB7	; 183
    e888:	96 e0       	ldi	r25, 0x06	; 6
    e88a:	69 e6       	ldi	r22, 0x69	; 105
    e88c:	70 e0       	ldi	r23, 0x00	; 0
    e88e:	4c ed       	ldi	r20, 0xDC	; 220
    e890:	50 e0       	ldi	r21, 0x00	; 0
    e892:	2f ef       	ldi	r18, 0xFF	; 255
    e894:	3f ef       	ldi	r19, 0xFF	; 255
    e896:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("12",155, 220, WHITE, BLACK);
    e89a:	89 eb       	ldi	r24, 0xB9	; 185
    e89c:	96 e0       	ldi	r25, 0x06	; 6
    e89e:	6b e9       	ldi	r22, 0x9B	; 155
    e8a0:	70 e0       	ldi	r23, 0x00	; 0
    e8a2:	4c ed       	ldi	r20, 0xDC	; 220
    e8a4:	50 e0       	ldi	r21, 0x00	; 0
    e8a6:	2f ef       	ldi	r18, 0xFF	; 255
    e8a8:	3f ef       	ldi	r19, 0xFF	; 255
    e8aa:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("16",205, 220, WHITE, BLACK);
    e8ae:	8c eb       	ldi	r24, 0xBC	; 188
    e8b0:	96 e0       	ldi	r25, 0x06	; 6
    e8b2:	6d ec       	ldi	r22, 0xCD	; 205
    e8b4:	70 e0       	ldi	r23, 0x00	; 0
    e8b6:	4c ed       	ldi	r20, 0xDC	; 220
    e8b8:	50 e0       	ldi	r21, 0x00	; 0
    e8ba:	2f ef       	ldi	r18, 0xFF	; 255
    e8bc:	3f ef       	ldi	r19, 0xFF	; 255
    e8be:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("20",255, 220, WHITE, BLACK);
    e8c2:	ce 01       	movw	r24, r28
    e8c4:	6f ef       	ldi	r22, 0xFF	; 255
    e8c6:	70 e0       	ldi	r23, 0x00	; 0
    e8c8:	4c ed       	ldi	r20, 0xDC	; 220
    e8ca:	50 e0       	ldi	r21, 0x00	; 0
    e8cc:	2f ef       	ldi	r18, 0xFF	; 255
    e8ce:	3f ef       	ldi	r19, 0xFF	; 255
    e8d0:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("24",290, 220, WHITE, BLACK);
    e8d4:	8f eb       	ldi	r24, 0xBF	; 191
    e8d6:	96 e0       	ldi	r25, 0x06	; 6
    e8d8:	62 e2       	ldi	r22, 0x22	; 34
    e8da:	71 e0       	ldi	r23, 0x01	; 1
    e8dc:	4c ed       	ldi	r20, 0xDC	; 220
    e8de:	50 e0       	ldi	r21, 0x00	; 0
    e8e0:	2f ef       	ldi	r18, 0xFF	; 255
    e8e2:	3f ef       	ldi	r19, 0xFF	; 255
    e8e4:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
}
    e8e8:	df 91       	pop	r29
    e8ea:	cf 91       	pop	r28
    e8ec:	1f 91       	pop	r17
    e8ee:	0f 91       	pop	r16
    e8f0:	08 95       	ret

0000e8f2 <DrawFrame3>:

void DrawFrame3 (void)
{
    e8f2:	0f 93       	push	r16
    e8f4:	1f 93       	push	r17
    e8f6:	cf 93       	push	r28
    e8f8:	df 93       	push	r29
    lcdFillRGB(BLACK);
    e8fa:	80 e0       	ldi	r24, 0x00	; 0
    e8fc:	90 e0       	ldi	r25, 0x00	; 0
    e8fe:	0e 94 ea 9c 	call	0x139d4	; 0x139d4 <lcdFillRGB>

    lcdDrawRectangle(10,20,300,200,YELLOW);
    e902:	8a e0       	ldi	r24, 0x0A	; 10
    e904:	90 e0       	ldi	r25, 0x00	; 0
    e906:	64 e1       	ldi	r22, 0x14	; 20
    e908:	70 e0       	ldi	r23, 0x00	; 0
    e90a:	4c e2       	ldi	r20, 0x2C	; 44
    e90c:	51 e0       	ldi	r21, 0x01	; 1
    e90e:	28 ec       	ldi	r18, 0xC8	; 200
    e910:	30 e0       	ldi	r19, 0x00	; 0
    e912:	00 ee       	ldi	r16, 0xE0	; 224
    e914:	1f ef       	ldi	r17, 0xFF	; 255
    e916:	0e 94 45 9e 	call	0x13c8a	; 0x13c8a <lcdDrawRectangle>
    lcdDrawHLine(10,60,310,SILVER);
    e91a:	8a e0       	ldi	r24, 0x0A	; 10
    e91c:	90 e0       	ldi	r25, 0x00	; 0
    e91e:	6c e3       	ldi	r22, 0x3C	; 60
    e920:	70 e0       	ldi	r23, 0x00	; 0
    e922:	46 e3       	ldi	r20, 0x36	; 54
    e924:	51 e0       	ldi	r21, 0x01	; 1
    e926:	20 e1       	ldi	r18, 0x10	; 16
    e928:	35 ea       	ldi	r19, 0xA5	; 165
    e92a:	0e 94 f9 9c 	call	0x139f2	; 0x139f2 <lcdDrawHLine>
    lcdDrawHLine(10,100,310,SILVER);
    e92e:	8a e0       	ldi	r24, 0x0A	; 10
    e930:	90 e0       	ldi	r25, 0x00	; 0
    e932:	64 e6       	ldi	r22, 0x64	; 100
    e934:	70 e0       	ldi	r23, 0x00	; 0
    e936:	46 e3       	ldi	r20, 0x36	; 54
    e938:	51 e0       	ldi	r21, 0x01	; 1
    e93a:	20 e1       	ldi	r18, 0x10	; 16
    e93c:	35 ea       	ldi	r19, 0xA5	; 165
    e93e:	0e 94 f9 9c 	call	0x139f2	; 0x139f2 <lcdDrawHLine>
    lcdDrawHLine(10,140,310,SILVER);
    e942:	8a e0       	ldi	r24, 0x0A	; 10
    e944:	90 e0       	ldi	r25, 0x00	; 0
    e946:	6c e8       	ldi	r22, 0x8C	; 140
    e948:	70 e0       	ldi	r23, 0x00	; 0
    e94a:	46 e3       	ldi	r20, 0x36	; 54
    e94c:	51 e0       	ldi	r21, 0x01	; 1
    e94e:	20 e1       	ldi	r18, 0x10	; 16
    e950:	35 ea       	ldi	r19, 0xA5	; 165
    e952:	0e 94 f9 9c 	call	0x139f2	; 0x139f2 <lcdDrawHLine>
    lcdDrawHLine(10,180,310,SILVER);
    e956:	8a e0       	ldi	r24, 0x0A	; 10
    e958:	90 e0       	ldi	r25, 0x00	; 0
    e95a:	64 eb       	ldi	r22, 0xB4	; 180
    e95c:	70 e0       	ldi	r23, 0x00	; 0
    e95e:	46 e3       	ldi	r20, 0x36	; 54
    e960:	51 e0       	ldi	r21, 0x01	; 1
    e962:	20 e1       	ldi	r18, 0x10	; 16
    e964:	35 ea       	ldi	r19, 0xA5	; 165
    e966:	0e 94 f9 9c 	call	0x139f2	; 0x139f2 <lcdDrawHLine>
    lcdDrawVLine(60,20,220,SILVER);
    e96a:	8c e3       	ldi	r24, 0x3C	; 60
    e96c:	90 e0       	ldi	r25, 0x00	; 0
    e96e:	64 e1       	ldi	r22, 0x14	; 20
    e970:	70 e0       	ldi	r23, 0x00	; 0
    e972:	4c ed       	ldi	r20, 0xDC	; 220
    e974:	50 e0       	ldi	r21, 0x00	; 0
    e976:	20 e1       	ldi	r18, 0x10	; 16
    e978:	35 ea       	ldi	r19, 0xA5	; 165
    e97a:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
    lcdDrawVLine(110,20,220,SILVER);
    e97e:	8e e6       	ldi	r24, 0x6E	; 110
    e980:	90 e0       	ldi	r25, 0x00	; 0
    e982:	64 e1       	ldi	r22, 0x14	; 20
    e984:	70 e0       	ldi	r23, 0x00	; 0
    e986:	4c ed       	ldi	r20, 0xDC	; 220
    e988:	50 e0       	ldi	r21, 0x00	; 0
    e98a:	20 e1       	ldi	r18, 0x10	; 16
    e98c:	35 ea       	ldi	r19, 0xA5	; 165
    e98e:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
    lcdDrawVLine(160,20,220,SILVER);
    e992:	80 ea       	ldi	r24, 0xA0	; 160
    e994:	90 e0       	ldi	r25, 0x00	; 0
    e996:	64 e1       	ldi	r22, 0x14	; 20
    e998:	70 e0       	ldi	r23, 0x00	; 0
    e99a:	4c ed       	ldi	r20, 0xDC	; 220
    e99c:	50 e0       	ldi	r21, 0x00	; 0
    e99e:	20 e1       	ldi	r18, 0x10	; 16
    e9a0:	35 ea       	ldi	r19, 0xA5	; 165
    e9a2:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
    lcdDrawVLine(210,20,220,SILVER);
    e9a6:	82 ed       	ldi	r24, 0xD2	; 210
    e9a8:	90 e0       	ldi	r25, 0x00	; 0
    e9aa:	64 e1       	ldi	r22, 0x14	; 20
    e9ac:	70 e0       	ldi	r23, 0x00	; 0
    e9ae:	4c ed       	ldi	r20, 0xDC	; 220
    e9b0:	50 e0       	ldi	r21, 0x00	; 0
    e9b2:	20 e1       	ldi	r18, 0x10	; 16
    e9b4:	35 ea       	ldi	r19, 0xA5	; 165
    e9b6:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
    lcdDrawVLine(260,20,220,SILVER);
    e9ba:	84 e0       	ldi	r24, 0x04	; 4
    e9bc:	91 e0       	ldi	r25, 0x01	; 1
    e9be:	64 e1       	ldi	r22, 0x14	; 20
    e9c0:	70 e0       	ldi	r23, 0x00	; 0
    e9c2:	4c ed       	ldi	r20, 0xDC	; 220
    e9c4:	50 e0       	ldi	r21, 0x00	; 0
    e9c6:	20 e1       	ldi	r18, 0x10	; 16
    e9c8:	35 ea       	ldi	r19, 0xA5	; 165
    e9ca:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>

    lcdSetFont((uint8_t*) Arial12x12);
    e9ce:	88 e9       	ldi	r24, 0x98	; 152
    e9d0:	90 e0       	ldi	r25, 0x00	; 0
    e9d2:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>

    lcdDrawString("0",5, 220, WHITE, BLACK);
    e9d6:	8f e9       	ldi	r24, 0x9F	; 159
    e9d8:	96 e0       	ldi	r25, 0x06	; 6
    e9da:	65 e0       	ldi	r22, 0x05	; 5
    e9dc:	70 e0       	ldi	r23, 0x00	; 0
    e9de:	4c ed       	ldi	r20, 0xDC	; 220
    e9e0:	50 e0       	ldi	r21, 0x00	; 0
    e9e2:	2f ef       	ldi	r18, 0xFF	; 255
    e9e4:	3f ef       	ldi	r19, 0xFF	; 255
    e9e6:	00 e0       	ldi	r16, 0x00	; 0
    e9e8:	10 e0       	ldi	r17, 0x00	; 0
    e9ea:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("20",0, 175, WHITE, BLACK);
    e9ee:	c4 ea       	ldi	r28, 0xA4	; 164
    e9f0:	d6 e0       	ldi	r29, 0x06	; 6
    e9f2:	ce 01       	movw	r24, r28
    e9f4:	60 e0       	ldi	r22, 0x00	; 0
    e9f6:	70 e0       	ldi	r23, 0x00	; 0
    e9f8:	4f ea       	ldi	r20, 0xAF	; 175
    e9fa:	50 e0       	ldi	r21, 0x00	; 0
    e9fc:	2f ef       	ldi	r18, 0xFF	; 255
    e9fe:	3f ef       	ldi	r19, 0xFF	; 255
    ea00:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("40",0, 135, WHITE, BLACK);
    ea04:	8a ea       	ldi	r24, 0xAA	; 170
    ea06:	96 e0       	ldi	r25, 0x06	; 6
    ea08:	60 e0       	ldi	r22, 0x00	; 0
    ea0a:	70 e0       	ldi	r23, 0x00	; 0
    ea0c:	47 e8       	ldi	r20, 0x87	; 135
    ea0e:	50 e0       	ldi	r21, 0x00	; 0
    ea10:	2f ef       	ldi	r18, 0xFF	; 255
    ea12:	3f ef       	ldi	r19, 0xFF	; 255
    ea14:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("60",0, 95, WHITE, BLACK);
    ea18:	82 ec       	ldi	r24, 0xC2	; 194
    ea1a:	96 e0       	ldi	r25, 0x06	; 6
    ea1c:	60 e0       	ldi	r22, 0x00	; 0
    ea1e:	70 e0       	ldi	r23, 0x00	; 0
    ea20:	4f e5       	ldi	r20, 0x5F	; 95
    ea22:	50 e0       	ldi	r21, 0x00	; 0
    ea24:	2f ef       	ldi	r18, 0xFF	; 255
    ea26:	3f ef       	ldi	r19, 0xFF	; 255
    ea28:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("80",0, 55, WHITE, BLACK);
    ea2c:	85 ec       	ldi	r24, 0xC5	; 197
    ea2e:	96 e0       	ldi	r25, 0x06	; 6
    ea30:	60 e0       	ldi	r22, 0x00	; 0
    ea32:	70 e0       	ldi	r23, 0x00	; 0
    ea34:	47 e3       	ldi	r20, 0x37	; 55
    ea36:	50 e0       	ldi	r21, 0x00	; 0
    ea38:	2f ef       	ldi	r18, 0xFF	; 255
    ea3a:	3f ef       	ldi	r19, 0xFF	; 255
    ea3c:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("100 %",0, 15, WHITE, BLACK);
    ea40:	88 ec       	ldi	r24, 0xC8	; 200
    ea42:	96 e0       	ldi	r25, 0x06	; 6
    ea44:	60 e0       	ldi	r22, 0x00	; 0
    ea46:	70 e0       	ldi	r23, 0x00	; 0
    ea48:	4f e0       	ldi	r20, 0x0F	; 15
    ea4a:	50 e0       	ldi	r21, 0x00	; 0
    ea4c:	2f ef       	ldi	r18, 0xFF	; 255
    ea4e:	3f ef       	ldi	r19, 0xFF	; 255
    ea50:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>

    lcdDrawString("4",55, 220, WHITE, BLACK);
    ea54:	85 eb       	ldi	r24, 0xB5	; 181
    ea56:	96 e0       	ldi	r25, 0x06	; 6
    ea58:	67 e3       	ldi	r22, 0x37	; 55
    ea5a:	70 e0       	ldi	r23, 0x00	; 0
    ea5c:	4c ed       	ldi	r20, 0xDC	; 220
    ea5e:	50 e0       	ldi	r21, 0x00	; 0
    ea60:	2f ef       	ldi	r18, 0xFF	; 255
    ea62:	3f ef       	ldi	r19, 0xFF	; 255
    ea64:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("8",105, 220, WHITE, BLACK);
    ea68:	87 eb       	ldi	r24, 0xB7	; 183
    ea6a:	96 e0       	ldi	r25, 0x06	; 6
    ea6c:	69 e6       	ldi	r22, 0x69	; 105
    ea6e:	70 e0       	ldi	r23, 0x00	; 0
    ea70:	4c ed       	ldi	r20, 0xDC	; 220
    ea72:	50 e0       	ldi	r21, 0x00	; 0
    ea74:	2f ef       	ldi	r18, 0xFF	; 255
    ea76:	3f ef       	ldi	r19, 0xFF	; 255
    ea78:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("12",155, 220, WHITE, BLACK);
    ea7c:	89 eb       	ldi	r24, 0xB9	; 185
    ea7e:	96 e0       	ldi	r25, 0x06	; 6
    ea80:	6b e9       	ldi	r22, 0x9B	; 155
    ea82:	70 e0       	ldi	r23, 0x00	; 0
    ea84:	4c ed       	ldi	r20, 0xDC	; 220
    ea86:	50 e0       	ldi	r21, 0x00	; 0
    ea88:	2f ef       	ldi	r18, 0xFF	; 255
    ea8a:	3f ef       	ldi	r19, 0xFF	; 255
    ea8c:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("16",205, 220, WHITE, BLACK);
    ea90:	8c eb       	ldi	r24, 0xBC	; 188
    ea92:	96 e0       	ldi	r25, 0x06	; 6
    ea94:	6d ec       	ldi	r22, 0xCD	; 205
    ea96:	70 e0       	ldi	r23, 0x00	; 0
    ea98:	4c ed       	ldi	r20, 0xDC	; 220
    ea9a:	50 e0       	ldi	r21, 0x00	; 0
    ea9c:	2f ef       	ldi	r18, 0xFF	; 255
    ea9e:	3f ef       	ldi	r19, 0xFF	; 255
    eaa0:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("20",255, 220, WHITE, BLACK);
    eaa4:	ce 01       	movw	r24, r28
    eaa6:	6f ef       	ldi	r22, 0xFF	; 255
    eaa8:	70 e0       	ldi	r23, 0x00	; 0
    eaaa:	4c ed       	ldi	r20, 0xDC	; 220
    eaac:	50 e0       	ldi	r21, 0x00	; 0
    eaae:	2f ef       	ldi	r18, 0xFF	; 255
    eab0:	3f ef       	ldi	r19, 0xFF	; 255
    eab2:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("24",290, 220, WHITE, BLACK);
    eab6:	8f eb       	ldi	r24, 0xBF	; 191
    eab8:	96 e0       	ldi	r25, 0x06	; 6
    eaba:	62 e2       	ldi	r22, 0x22	; 34
    eabc:	71 e0       	ldi	r23, 0x01	; 1
    eabe:	4c ed       	ldi	r20, 0xDC	; 220
    eac0:	50 e0       	ldi	r21, 0x00	; 0
    eac2:	2f ef       	ldi	r18, 0xFF	; 255
    eac4:	3f ef       	ldi	r19, 0xFF	; 255
    eac6:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
}
    eaca:	df 91       	pop	r29
    eacc:	cf 91       	pop	r28
    eace:	1f 91       	pop	r17
    ead0:	0f 91       	pop	r16
    ead2:	08 95       	ret

0000ead4 <DrawFrame4>:

void DrawFrame4 (void)
{
    ead4:	0f 93       	push	r16
    ead6:	1f 93       	push	r17
    ead8:	cf 93       	push	r28
    eada:	df 93       	push	r29
    lcdFillRGB(BLACK);
    eadc:	80 e0       	ldi	r24, 0x00	; 0
    eade:	90 e0       	ldi	r25, 0x00	; 0
    eae0:	0e 94 ea 9c 	call	0x139d4	; 0x139d4 <lcdFillRGB>

    lcdDrawRectangle(10,20,300,200,YELLOW);
    eae4:	8a e0       	ldi	r24, 0x0A	; 10
    eae6:	90 e0       	ldi	r25, 0x00	; 0
    eae8:	64 e1       	ldi	r22, 0x14	; 20
    eaea:	70 e0       	ldi	r23, 0x00	; 0
    eaec:	4c e2       	ldi	r20, 0x2C	; 44
    eaee:	51 e0       	ldi	r21, 0x01	; 1
    eaf0:	28 ec       	ldi	r18, 0xC8	; 200
    eaf2:	30 e0       	ldi	r19, 0x00	; 0
    eaf4:	00 ee       	ldi	r16, 0xE0	; 224
    eaf6:	1f ef       	ldi	r17, 0xFF	; 255
    eaf8:	0e 94 45 9e 	call	0x13c8a	; 0x13c8a <lcdDrawRectangle>
    lcdDrawHLine(10,60,310,SILVER);
    eafc:	8a e0       	ldi	r24, 0x0A	; 10
    eafe:	90 e0       	ldi	r25, 0x00	; 0
    eb00:	6c e3       	ldi	r22, 0x3C	; 60
    eb02:	70 e0       	ldi	r23, 0x00	; 0
    eb04:	46 e3       	ldi	r20, 0x36	; 54
    eb06:	51 e0       	ldi	r21, 0x01	; 1
    eb08:	20 e1       	ldi	r18, 0x10	; 16
    eb0a:	35 ea       	ldi	r19, 0xA5	; 165
    eb0c:	0e 94 f9 9c 	call	0x139f2	; 0x139f2 <lcdDrawHLine>
    lcdDrawHLine(10,100,310,SILVER);
    eb10:	8a e0       	ldi	r24, 0x0A	; 10
    eb12:	90 e0       	ldi	r25, 0x00	; 0
    eb14:	64 e6       	ldi	r22, 0x64	; 100
    eb16:	70 e0       	ldi	r23, 0x00	; 0
    eb18:	46 e3       	ldi	r20, 0x36	; 54
    eb1a:	51 e0       	ldi	r21, 0x01	; 1
    eb1c:	20 e1       	ldi	r18, 0x10	; 16
    eb1e:	35 ea       	ldi	r19, 0xA5	; 165
    eb20:	0e 94 f9 9c 	call	0x139f2	; 0x139f2 <lcdDrawHLine>
    lcdDrawHLine(10,140,310,SILVER);
    eb24:	8a e0       	ldi	r24, 0x0A	; 10
    eb26:	90 e0       	ldi	r25, 0x00	; 0
    eb28:	6c e8       	ldi	r22, 0x8C	; 140
    eb2a:	70 e0       	ldi	r23, 0x00	; 0
    eb2c:	46 e3       	ldi	r20, 0x36	; 54
    eb2e:	51 e0       	ldi	r21, 0x01	; 1
    eb30:	20 e1       	ldi	r18, 0x10	; 16
    eb32:	35 ea       	ldi	r19, 0xA5	; 165
    eb34:	0e 94 f9 9c 	call	0x139f2	; 0x139f2 <lcdDrawHLine>
    lcdDrawHLine(10,180,310,SILVER);
    eb38:	8a e0       	ldi	r24, 0x0A	; 10
    eb3a:	90 e0       	ldi	r25, 0x00	; 0
    eb3c:	64 eb       	ldi	r22, 0xB4	; 180
    eb3e:	70 e0       	ldi	r23, 0x00	; 0
    eb40:	46 e3       	ldi	r20, 0x36	; 54
    eb42:	51 e0       	ldi	r21, 0x01	; 1
    eb44:	20 e1       	ldi	r18, 0x10	; 16
    eb46:	35 ea       	ldi	r19, 0xA5	; 165
    eb48:	0e 94 f9 9c 	call	0x139f2	; 0x139f2 <lcdDrawHLine>
    lcdDrawVLine(60,20,220,SILVER);
    eb4c:	8c e3       	ldi	r24, 0x3C	; 60
    eb4e:	90 e0       	ldi	r25, 0x00	; 0
    eb50:	64 e1       	ldi	r22, 0x14	; 20
    eb52:	70 e0       	ldi	r23, 0x00	; 0
    eb54:	4c ed       	ldi	r20, 0xDC	; 220
    eb56:	50 e0       	ldi	r21, 0x00	; 0
    eb58:	20 e1       	ldi	r18, 0x10	; 16
    eb5a:	35 ea       	ldi	r19, 0xA5	; 165
    eb5c:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
    lcdDrawVLine(110,20,220,SILVER);
    eb60:	8e e6       	ldi	r24, 0x6E	; 110
    eb62:	90 e0       	ldi	r25, 0x00	; 0
    eb64:	64 e1       	ldi	r22, 0x14	; 20
    eb66:	70 e0       	ldi	r23, 0x00	; 0
    eb68:	4c ed       	ldi	r20, 0xDC	; 220
    eb6a:	50 e0       	ldi	r21, 0x00	; 0
    eb6c:	20 e1       	ldi	r18, 0x10	; 16
    eb6e:	35 ea       	ldi	r19, 0xA5	; 165
    eb70:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
    lcdDrawVLine(160,20,220,SILVER);
    eb74:	80 ea       	ldi	r24, 0xA0	; 160
    eb76:	90 e0       	ldi	r25, 0x00	; 0
    eb78:	64 e1       	ldi	r22, 0x14	; 20
    eb7a:	70 e0       	ldi	r23, 0x00	; 0
    eb7c:	4c ed       	ldi	r20, 0xDC	; 220
    eb7e:	50 e0       	ldi	r21, 0x00	; 0
    eb80:	20 e1       	ldi	r18, 0x10	; 16
    eb82:	35 ea       	ldi	r19, 0xA5	; 165
    eb84:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
    lcdDrawVLine(210,20,220,SILVER);
    eb88:	82 ed       	ldi	r24, 0xD2	; 210
    eb8a:	90 e0       	ldi	r25, 0x00	; 0
    eb8c:	64 e1       	ldi	r22, 0x14	; 20
    eb8e:	70 e0       	ldi	r23, 0x00	; 0
    eb90:	4c ed       	ldi	r20, 0xDC	; 220
    eb92:	50 e0       	ldi	r21, 0x00	; 0
    eb94:	20 e1       	ldi	r18, 0x10	; 16
    eb96:	35 ea       	ldi	r19, 0xA5	; 165
    eb98:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
    lcdDrawVLine(260,20,220,SILVER);
    eb9c:	84 e0       	ldi	r24, 0x04	; 4
    eb9e:	91 e0       	ldi	r25, 0x01	; 1
    eba0:	64 e1       	ldi	r22, 0x14	; 20
    eba2:	70 e0       	ldi	r23, 0x00	; 0
    eba4:	4c ed       	ldi	r20, 0xDC	; 220
    eba6:	50 e0       	ldi	r21, 0x00	; 0
    eba8:	20 e1       	ldi	r18, 0x10	; 16
    ebaa:	35 ea       	ldi	r19, 0xA5	; 165
    ebac:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>

    lcdSetFont((uint8_t*) Arial12x12);
    ebb0:	88 e9       	ldi	r24, 0x98	; 152
    ebb2:	90 e0       	ldi	r25, 0x00	; 0
    ebb4:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>

    lcdDrawString("-40",5, 220, WHITE, BLACK);
    ebb8:	8e ec       	ldi	r24, 0xCE	; 206
    ebba:	96 e0       	ldi	r25, 0x06	; 6
    ebbc:	65 e0       	ldi	r22, 0x05	; 5
    ebbe:	70 e0       	ldi	r23, 0x00	; 0
    ebc0:	4c ed       	ldi	r20, 0xDC	; 220
    ebc2:	50 e0       	ldi	r21, 0x00	; 0
    ebc4:	2f ef       	ldi	r18, 0xFF	; 255
    ebc6:	3f ef       	ldi	r19, 0xFF	; 255
    ebc8:	00 e0       	ldi	r16, 0x00	; 0
    ebca:	10 e0       	ldi	r17, 0x00	; 0
    ebcc:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("-20",0, 175, WHITE, BLACK);
    ebd0:	82 ed       	ldi	r24, 0xD2	; 210
    ebd2:	96 e0       	ldi	r25, 0x06	; 6
    ebd4:	60 e0       	ldi	r22, 0x00	; 0
    ebd6:	70 e0       	ldi	r23, 0x00	; 0
    ebd8:	4f ea       	ldi	r20, 0xAF	; 175
    ebda:	50 e0       	ldi	r21, 0x00	; 0
    ebdc:	2f ef       	ldi	r18, 0xFF	; 255
    ebde:	3f ef       	ldi	r19, 0xFF	; 255
    ebe0:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("0",0, 135, WHITE, BLACK);
    ebe4:	8f e9       	ldi	r24, 0x9F	; 159
    ebe6:	96 e0       	ldi	r25, 0x06	; 6
    ebe8:	60 e0       	ldi	r22, 0x00	; 0
    ebea:	70 e0       	ldi	r23, 0x00	; 0
    ebec:	47 e8       	ldi	r20, 0x87	; 135
    ebee:	50 e0       	ldi	r21, 0x00	; 0
    ebf0:	2f ef       	ldi	r18, 0xFF	; 255
    ebf2:	3f ef       	ldi	r19, 0xFF	; 255
    ebf4:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("20",0, 95, WHITE, BLACK);
    ebf8:	c4 ea       	ldi	r28, 0xA4	; 164
    ebfa:	d6 e0       	ldi	r29, 0x06	; 6
    ebfc:	ce 01       	movw	r24, r28
    ebfe:	60 e0       	ldi	r22, 0x00	; 0
    ec00:	70 e0       	ldi	r23, 0x00	; 0
    ec02:	4f e5       	ldi	r20, 0x5F	; 95
    ec04:	50 e0       	ldi	r21, 0x00	; 0
    ec06:	2f ef       	ldi	r18, 0xFF	; 255
    ec08:	3f ef       	ldi	r19, 0xFF	; 255
    ec0a:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("40",0, 55, WHITE, BLACK);
    ec0e:	8a ea       	ldi	r24, 0xAA	; 170
    ec10:	96 e0       	ldi	r25, 0x06	; 6
    ec12:	60 e0       	ldi	r22, 0x00	; 0
    ec14:	70 e0       	ldi	r23, 0x00	; 0
    ec16:	47 e3       	ldi	r20, 0x37	; 55
    ec18:	50 e0       	ldi	r21, 0x00	; 0
    ec1a:	2f ef       	ldi	r18, 0xFF	; 255
    ec1c:	3f ef       	ldi	r19, 0xFF	; 255
    ec1e:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("60 Grad",0, 15, WHITE, BLACK);
    ec22:	86 ed       	ldi	r24, 0xD6	; 214
    ec24:	96 e0       	ldi	r25, 0x06	; 6
    ec26:	60 e0       	ldi	r22, 0x00	; 0
    ec28:	70 e0       	ldi	r23, 0x00	; 0
    ec2a:	4f e0       	ldi	r20, 0x0F	; 15
    ec2c:	50 e0       	ldi	r21, 0x00	; 0
    ec2e:	2f ef       	ldi	r18, 0xFF	; 255
    ec30:	3f ef       	ldi	r19, 0xFF	; 255
    ec32:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>

    lcdDrawString("4",55, 220, WHITE, BLACK);
    ec36:	85 eb       	ldi	r24, 0xB5	; 181
    ec38:	96 e0       	ldi	r25, 0x06	; 6
    ec3a:	67 e3       	ldi	r22, 0x37	; 55
    ec3c:	70 e0       	ldi	r23, 0x00	; 0
    ec3e:	4c ed       	ldi	r20, 0xDC	; 220
    ec40:	50 e0       	ldi	r21, 0x00	; 0
    ec42:	2f ef       	ldi	r18, 0xFF	; 255
    ec44:	3f ef       	ldi	r19, 0xFF	; 255
    ec46:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("8",105, 220, WHITE, BLACK);
    ec4a:	87 eb       	ldi	r24, 0xB7	; 183
    ec4c:	96 e0       	ldi	r25, 0x06	; 6
    ec4e:	69 e6       	ldi	r22, 0x69	; 105
    ec50:	70 e0       	ldi	r23, 0x00	; 0
    ec52:	4c ed       	ldi	r20, 0xDC	; 220
    ec54:	50 e0       	ldi	r21, 0x00	; 0
    ec56:	2f ef       	ldi	r18, 0xFF	; 255
    ec58:	3f ef       	ldi	r19, 0xFF	; 255
    ec5a:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("12",155, 220, WHITE, BLACK);
    ec5e:	89 eb       	ldi	r24, 0xB9	; 185
    ec60:	96 e0       	ldi	r25, 0x06	; 6
    ec62:	6b e9       	ldi	r22, 0x9B	; 155
    ec64:	70 e0       	ldi	r23, 0x00	; 0
    ec66:	4c ed       	ldi	r20, 0xDC	; 220
    ec68:	50 e0       	ldi	r21, 0x00	; 0
    ec6a:	2f ef       	ldi	r18, 0xFF	; 255
    ec6c:	3f ef       	ldi	r19, 0xFF	; 255
    ec6e:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("16",205, 220, WHITE, BLACK);
    ec72:	8c eb       	ldi	r24, 0xBC	; 188
    ec74:	96 e0       	ldi	r25, 0x06	; 6
    ec76:	6d ec       	ldi	r22, 0xCD	; 205
    ec78:	70 e0       	ldi	r23, 0x00	; 0
    ec7a:	4c ed       	ldi	r20, 0xDC	; 220
    ec7c:	50 e0       	ldi	r21, 0x00	; 0
    ec7e:	2f ef       	ldi	r18, 0xFF	; 255
    ec80:	3f ef       	ldi	r19, 0xFF	; 255
    ec82:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("20",255, 220, WHITE, BLACK);
    ec86:	ce 01       	movw	r24, r28
    ec88:	6f ef       	ldi	r22, 0xFF	; 255
    ec8a:	70 e0       	ldi	r23, 0x00	; 0
    ec8c:	4c ed       	ldi	r20, 0xDC	; 220
    ec8e:	50 e0       	ldi	r21, 0x00	; 0
    ec90:	2f ef       	ldi	r18, 0xFF	; 255
    ec92:	3f ef       	ldi	r19, 0xFF	; 255
    ec94:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcdDrawString("24",290, 220, WHITE, BLACK);
    ec98:	8f eb       	ldi	r24, 0xBF	; 191
    ec9a:	96 e0       	ldi	r25, 0x06	; 6
    ec9c:	62 e2       	ldi	r22, 0x22	; 34
    ec9e:	71 e0       	ldi	r23, 0x01	; 1
    eca0:	4c ed       	ldi	r20, 0xDC	; 220
    eca2:	50 e0       	ldi	r21, 0x00	; 0
    eca4:	2f ef       	ldi	r18, 0xFF	; 255
    eca6:	3f ef       	ldi	r19, 0xFF	; 255
    eca8:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
}
    ecac:	df 91       	pop	r29
    ecae:	cf 91       	pop	r28
    ecb0:	1f 91       	pop	r17
    ecb2:	0f 91       	pop	r16
    ecb4:	08 95       	ret

0000ecb6 <SendToWeb>:

void SendToWeb (void)
{
    ecb6:	cf 92       	push	r12
    ecb8:	df 92       	push	r13
    ecba:	ef 92       	push	r14
    ecbc:	ff 92       	push	r15
    ecbe:	0f 93       	push	r16
    ecc0:	1f 93       	push	r17
    ecc2:	df 93       	push	r29
    ecc4:	cf 93       	push	r28
    ecc6:	cd b7       	in	r28, 0x3d	; 61
    ecc8:	de b7       	in	r29, 0x3e	; 62
    ecca:	c4 5d       	subi	r28, 0xD4	; 212
    eccc:	d0 40       	sbci	r29, 0x00	; 0
    ecce:	0f b6       	in	r0, 0x3f	; 63
    ecd0:	f8 94       	cli
    ecd2:	de bf       	out	0x3e, r29	; 62
    ecd4:	0f be       	out	0x3f, r0	; 63
    ecd6:	cd bf       	out	0x3d, r28	; 61
    char LineBuffer[200];
	char LineBuffer2[12];

    strcpy(LineBuffer,"PUT /v2/feeds/");
    ecd8:	8e 01       	movw	r16, r28
    ecda:	03 5f       	subi	r16, 0xF3	; 243
    ecdc:	1f 4f       	sbci	r17, 0xFF	; 255
    ecde:	c8 01       	movw	r24, r16
    ece0:	6e ed       	ldi	r22, 0xDE	; 222
    ece2:	76 e0       	ldi	r23, 0x06	; 6
    ece4:	0e 94 4a ad 	call	0x15a94	; 0x15a94 <strcpy>
    strcat(LineBuffer,FEED_ID);
    ece8:	c8 01       	movw	r24, r16
    ecea:	6d ee       	ldi	r22, 0xED	; 237
    ecec:	76 e0       	ldi	r23, 0x06	; 6
    ecee:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer, ".csv HTTP/1.1\r\n");
    ecf2:	c8 01       	movw	r24, r16
    ecf4:	64 ef       	ldi	r22, 0xF4	; 244
    ecf6:	76 e0       	ldi	r23, 0x06	; 6
    ecf8:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer, "Host: api.xively.com\r\n");
    ecfc:	c8 01       	movw	r24, r16
    ecfe:	64 e0       	ldi	r22, 0x04	; 4
    ed00:	77 e0       	ldi	r23, 0x07	; 7
    ed02:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer, "X-ApiKey: ");
    ed06:	c8 01       	movw	r24, r16
    ed08:	6b e1       	ldi	r22, 0x1B	; 27
    ed0a:	77 e0       	ldi	r23, 0x07	; 7
    ed0c:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer, API_KEY);
    ed10:	c8 01       	movw	r24, r16
    ed12:	66 e2       	ldi	r22, 0x26	; 38
    ed14:	77 e0       	ldi	r23, 0x07	; 7
    ed16:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer, "\r\n");
    ed1a:	87 e5       	ldi	r24, 0x57	; 87
    ed1c:	e8 2e       	mov	r14, r24
    ed1e:	87 e0       	ldi	r24, 0x07	; 7
    ed20:	f8 2e       	mov	r15, r24
    ed22:	c8 01       	movw	r24, r16
    ed24:	b7 01       	movw	r22, r14
    ed26:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer, "Content-Length: 30\r\n");
    ed2a:	c8 01       	movw	r24, r16
    ed2c:	6a e5       	ldi	r22, 0x5A	; 90
    ed2e:	77 e0       	ldi	r23, 0x07	; 7
    ed30:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer, "Content-Type: text/csv\r\n");
    ed34:	c8 01       	movw	r24, r16
    ed36:	6f e6       	ldi	r22, 0x6F	; 111
    ed38:	77 e0       	ldi	r23, 0x07	; 7
    ed3a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    strcat(LineBuffer, "\r\n");
    ed3e:	c8 01       	movw	r24, r16
    ed40:	b7 01       	movw	r22, r14
    ed42:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>

    strcat(LineBuffer, "0,");
    ed46:	c8 01       	movw	r24, r16
    ed48:	68 e8       	ldi	r22, 0x88	; 136
    ed4a:	77 e0       	ldi	r23, 0x07	; 7
    ed4c:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf(LineBuffer2, "%3d\n", Temperature);
    ed50:	00 d0       	rcall	.+0      	; 0xed52 <SendToWeb+0x9c>
    ed52:	00 d0       	rcall	.+0      	; 0xed54 <SendToWeb+0x9e>
    ed54:	00 d0       	rcall	.+0      	; 0xed56 <SendToWeb+0xa0>
    ed56:	ed b7       	in	r30, 0x3d	; 61
    ed58:	fe b7       	in	r31, 0x3e	; 62
    ed5a:	31 96       	adiw	r30, 0x01	; 1
    ed5c:	7e 01       	movw	r14, r28
    ed5e:	08 94       	sec
    ed60:	e1 1c       	adc	r14, r1
    ed62:	f1 1c       	adc	r15, r1
    ed64:	ad b7       	in	r26, 0x3d	; 61
    ed66:	be b7       	in	r27, 0x3e	; 62
    ed68:	12 96       	adiw	r26, 0x02	; 2
    ed6a:	fc 92       	st	X, r15
    ed6c:	ee 92       	st	-X, r14
    ed6e:	11 97       	sbiw	r26, 0x01	; 1
    ed70:	bb e8       	ldi	r27, 0x8B	; 139
    ed72:	cb 2e       	mov	r12, r27
    ed74:	b7 e0       	ldi	r27, 0x07	; 7
    ed76:	db 2e       	mov	r13, r27
    ed78:	d3 82       	std	Z+3, r13	; 0x03
    ed7a:	c2 82       	std	Z+2, r12	; 0x02
    ed7c:	80 91 68 09 	lds	r24, 0x0968
    ed80:	99 27       	eor	r25, r25
    ed82:	87 fd       	sbrc	r24, 7
    ed84:	90 95       	com	r25
    ed86:	95 83       	std	Z+5, r25	; 0x05
    ed88:	84 83       	std	Z+4, r24	; 0x04
    ed8a:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer, LineBuffer2);
    ed8e:	8d b7       	in	r24, 0x3d	; 61
    ed90:	9e b7       	in	r25, 0x3e	; 62
    ed92:	06 96       	adiw	r24, 0x06	; 6
    ed94:	0f b6       	in	r0, 0x3f	; 63
    ed96:	f8 94       	cli
    ed98:	9e bf       	out	0x3e, r25	; 62
    ed9a:	0f be       	out	0x3f, r0	; 63
    ed9c:	8d bf       	out	0x3d, r24	; 61
    ed9e:	c8 01       	movw	r24, r16
    eda0:	b7 01       	movw	r22, r14
    eda2:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>

    strcat(LineBuffer, "1,");
    eda6:	c8 01       	movw	r24, r16
    eda8:	60 e9       	ldi	r22, 0x90	; 144
    edaa:	77 e0       	ldi	r23, 0x07	; 7
    edac:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf(LineBuffer2, "%3d\n", Humidity);
    edb0:	00 d0       	rcall	.+0      	; 0xedb2 <SendToWeb+0xfc>
    edb2:	00 d0       	rcall	.+0      	; 0xedb4 <SendToWeb+0xfe>
    edb4:	00 d0       	rcall	.+0      	; 0xedb6 <SendToWeb+0x100>
    edb6:	ed b7       	in	r30, 0x3d	; 61
    edb8:	fe b7       	in	r31, 0x3e	; 62
    edba:	31 96       	adiw	r30, 0x01	; 1
    edbc:	ad b7       	in	r26, 0x3d	; 61
    edbe:	be b7       	in	r27, 0x3e	; 62
    edc0:	12 96       	adiw	r26, 0x02	; 2
    edc2:	fc 92       	st	X, r15
    edc4:	ee 92       	st	-X, r14
    edc6:	11 97       	sbiw	r26, 0x01	; 1
    edc8:	d3 82       	std	Z+3, r13	; 0x03
    edca:	c2 82       	std	Z+2, r12	; 0x02
    edcc:	80 91 69 09 	lds	r24, 0x0969
    edd0:	99 27       	eor	r25, r25
    edd2:	87 fd       	sbrc	r24, 7
    edd4:	90 95       	com	r25
    edd6:	95 83       	std	Z+5, r25	; 0x05
    edd8:	84 83       	std	Z+4, r24	; 0x04
    edda:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer, LineBuffer2);
    edde:	8d b7       	in	r24, 0x3d	; 61
    ede0:	9e b7       	in	r25, 0x3e	; 62
    ede2:	06 96       	adiw	r24, 0x06	; 6
    ede4:	0f b6       	in	r0, 0x3f	; 63
    ede6:	f8 94       	cli
    ede8:	9e bf       	out	0x3e, r25	; 62
    edea:	0f be       	out	0x3f, r0	; 63
    edec:	8d bf       	out	0x3d, r24	; 61
    edee:	c8 01       	movw	r24, r16
    edf0:	b7 01       	movw	r22, r14
    edf2:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>

    strcat(LineBuffer, "2,");
    edf6:	c8 01       	movw	r24, r16
    edf8:	63 e9       	ldi	r22, 0x93	; 147
    edfa:	77 e0       	ldi	r23, 0x07	; 7
    edfc:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf(LineBuffer2, "%3d\n", Sensor2Value);
    ee00:	00 d0       	rcall	.+0      	; 0xee02 <SendToWeb+0x14c>
    ee02:	00 d0       	rcall	.+0      	; 0xee04 <SendToWeb+0x14e>
    ee04:	00 d0       	rcall	.+0      	; 0xee06 <SendToWeb+0x150>
    ee06:	ed b7       	in	r30, 0x3d	; 61
    ee08:	fe b7       	in	r31, 0x3e	; 62
    ee0a:	31 96       	adiw	r30, 0x01	; 1
    ee0c:	ad b7       	in	r26, 0x3d	; 61
    ee0e:	be b7       	in	r27, 0x3e	; 62
    ee10:	12 96       	adiw	r26, 0x02	; 2
    ee12:	fc 92       	st	X, r15
    ee14:	ee 92       	st	-X, r14
    ee16:	11 97       	sbiw	r26, 0x01	; 1
    ee18:	d3 82       	std	Z+3, r13	; 0x03
    ee1a:	c2 82       	std	Z+2, r12	; 0x02
    ee1c:	80 91 62 09 	lds	r24, 0x0962
    ee20:	99 27       	eor	r25, r25
    ee22:	87 fd       	sbrc	r24, 7
    ee24:	90 95       	com	r25
    ee26:	95 83       	std	Z+5, r25	; 0x05
    ee28:	84 83       	std	Z+4, r24	; 0x04
    ee2a:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer, LineBuffer2);
    ee2e:	8d b7       	in	r24, 0x3d	; 61
    ee30:	9e b7       	in	r25, 0x3e	; 62
    ee32:	06 96       	adiw	r24, 0x06	; 6
    ee34:	0f b6       	in	r0, 0x3f	; 63
    ee36:	f8 94       	cli
    ee38:	9e bf       	out	0x3e, r25	; 62
    ee3a:	0f be       	out	0x3f, r0	; 63
    ee3c:	8d bf       	out	0x3d, r24	; 61
    ee3e:	c8 01       	movw	r24, r16
    ee40:	b7 01       	movw	r22, r14
    ee42:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>

    strcat(LineBuffer, "3,");
    ee46:	c8 01       	movw	r24, r16
    ee48:	66 e9       	ldi	r22, 0x96	; 150
    ee4a:	77 e0       	ldi	r23, 0x07	; 7
    ee4c:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf(LineBuffer2, "%3d\n", Sensor3Value);
    ee50:	00 d0       	rcall	.+0      	; 0xee52 <SendToWeb+0x19c>
    ee52:	00 d0       	rcall	.+0      	; 0xee54 <SendToWeb+0x19e>
    ee54:	00 d0       	rcall	.+0      	; 0xee56 <SendToWeb+0x1a0>
    ee56:	ed b7       	in	r30, 0x3d	; 61
    ee58:	fe b7       	in	r31, 0x3e	; 62
    ee5a:	31 96       	adiw	r30, 0x01	; 1
    ee5c:	ad b7       	in	r26, 0x3d	; 61
    ee5e:	be b7       	in	r27, 0x3e	; 62
    ee60:	12 96       	adiw	r26, 0x02	; 2
    ee62:	fc 92       	st	X, r15
    ee64:	ee 92       	st	-X, r14
    ee66:	11 97       	sbiw	r26, 0x01	; 1
    ee68:	d3 82       	std	Z+3, r13	; 0x03
    ee6a:	c2 82       	std	Z+2, r12	; 0x02
    ee6c:	80 91 64 09 	lds	r24, 0x0964
    ee70:	99 27       	eor	r25, r25
    ee72:	87 fd       	sbrc	r24, 7
    ee74:	90 95       	com	r25
    ee76:	95 83       	std	Z+5, r25	; 0x05
    ee78:	84 83       	std	Z+4, r24	; 0x04
    ee7a:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer, LineBuffer2);
    ee7e:	8d b7       	in	r24, 0x3d	; 61
    ee80:	9e b7       	in	r25, 0x3e	; 62
    ee82:	06 96       	adiw	r24, 0x06	; 6
    ee84:	0f b6       	in	r0, 0x3f	; 63
    ee86:	f8 94       	cli
    ee88:	9e bf       	out	0x3e, r25	; 62
    ee8a:	0f be       	out	0x3f, r0	; 63
    ee8c:	8d bf       	out	0x3d, r24	; 61
    ee8e:	c8 01       	movw	r24, r16
    ee90:	b7 01       	movw	r22, r14
    ee92:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>

    strcat(LineBuffer, "4,");
    ee96:	c8 01       	movw	r24, r16
    ee98:	69 e9       	ldi	r22, 0x99	; 153
    ee9a:	77 e0       	ldi	r23, 0x07	; 7
    ee9c:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>
    sprintf(LineBuffer2, "%3d\r\n", Sensor4Value);
    eea0:	00 d0       	rcall	.+0      	; 0xeea2 <SendToWeb+0x1ec>
    eea2:	00 d0       	rcall	.+0      	; 0xeea4 <SendToWeb+0x1ee>
    eea4:	00 d0       	rcall	.+0      	; 0xeea6 <SendToWeb+0x1f0>
    eea6:	ed b7       	in	r30, 0x3d	; 61
    eea8:	fe b7       	in	r31, 0x3e	; 62
    eeaa:	31 96       	adiw	r30, 0x01	; 1
    eeac:	ad b7       	in	r26, 0x3d	; 61
    eeae:	be b7       	in	r27, 0x3e	; 62
    eeb0:	12 96       	adiw	r26, 0x02	; 2
    eeb2:	fc 92       	st	X, r15
    eeb4:	ee 92       	st	-X, r14
    eeb6:	11 97       	sbiw	r26, 0x01	; 1
    eeb8:	8c e9       	ldi	r24, 0x9C	; 156
    eeba:	97 e0       	ldi	r25, 0x07	; 7
    eebc:	93 83       	std	Z+3, r25	; 0x03
    eebe:	82 83       	std	Z+2, r24	; 0x02
    eec0:	80 91 66 09 	lds	r24, 0x0966
    eec4:	99 27       	eor	r25, r25
    eec6:	87 fd       	sbrc	r24, 7
    eec8:	90 95       	com	r25
    eeca:	95 83       	std	Z+5, r25	; 0x05
    eecc:	84 83       	std	Z+4, r24	; 0x04
    eece:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    strcat(LineBuffer, LineBuffer2);
    eed2:	8d b7       	in	r24, 0x3d	; 61
    eed4:	9e b7       	in	r25, 0x3e	; 62
    eed6:	06 96       	adiw	r24, 0x06	; 6
    eed8:	0f b6       	in	r0, 0x3f	; 63
    eeda:	f8 94       	cli
    eedc:	9e bf       	out	0x3e, r25	; 62
    eede:	0f be       	out	0x3f, r0	; 63
    eee0:	8d bf       	out	0x3d, r24	; 61
    eee2:	c8 01       	movw	r24, r16
    eee4:	b7 01       	movw	r22, r14
    eee6:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <strcat>

    sendData(198, LineBuffer, 1);
    eeea:	86 ec       	ldi	r24, 0xC6	; 198
    eeec:	90 e0       	ldi	r25, 0x00	; 0
    eeee:	b8 01       	movw	r22, r16
    eef0:	41 e0       	ldi	r20, 0x01	; 1
    eef2:	0e 94 e7 9f 	call	0x13fce	; 0x13fce <sendData>

}
    eef6:	cc 52       	subi	r28, 0x2C	; 44
    eef8:	df 4f       	sbci	r29, 0xFF	; 255
    eefa:	0f b6       	in	r0, 0x3f	; 63
    eefc:	f8 94       	cli
    eefe:	de bf       	out	0x3e, r29	; 62
    ef00:	0f be       	out	0x3f, r0	; 63
    ef02:	cd bf       	out	0x3d, r28	; 61
    ef04:	cf 91       	pop	r28
    ef06:	df 91       	pop	r29
    ef08:	1f 91       	pop	r17
    ef0a:	0f 91       	pop	r16
    ef0c:	ff 90       	pop	r15
    ef0e:	ef 90       	pop	r14
    ef10:	df 90       	pop	r13
    ef12:	cf 90       	pop	r12
    ef14:	08 95       	ret

0000ef16 <__vector_17>:
}*/


/** ISR to handle the 500ms ticks for sampling and data logging */
ISR(TIMER1_COMPA_vect, ISR_BLOCK)
{
    ef16:	1f 92       	push	r1
    ef18:	0f 92       	push	r0
    ef1a:	0f b6       	in	r0, 0x3f	; 63
    ef1c:	0f 92       	push	r0
    ef1e:	0b b6       	in	r0, 0x3b	; 59
    ef20:	0f 92       	push	r0
    ef22:	11 24       	eor	r1, r1
    ef24:	9f 92       	push	r9
    ef26:	af 92       	push	r10
    ef28:	bf 92       	push	r11
    ef2a:	cf 92       	push	r12
    ef2c:	df 92       	push	r13
    ef2e:	ef 92       	push	r14
    ef30:	ff 92       	push	r15
    ef32:	0f 93       	push	r16
    ef34:	1f 93       	push	r17
    ef36:	2f 93       	push	r18
    ef38:	3f 93       	push	r19
    ef3a:	4f 93       	push	r20
    ef3c:	5f 93       	push	r21
    ef3e:	6f 93       	push	r22
    ef40:	7f 93       	push	r23
    ef42:	8f 93       	push	r24
    ef44:	9f 93       	push	r25
    ef46:	af 93       	push	r26
    ef48:	bf 93       	push	r27
    ef4a:	ef 93       	push	r30
    ef4c:	ff 93       	push	r31
    ef4e:	df 93       	push	r29
    ef50:	cf 93       	push	r28
    ef52:	cd b7       	in	r28, 0x3d	; 61
    ef54:	de b7       	in	r29, 0x3e	; 62
    ef56:	ac 97       	sbiw	r28, 0x2c	; 44
    ef58:	de bf       	out	0x3e, r29	; 62
    ef5a:	cd bf       	out	0x3d, r28	; 61
			}

			static inline uint8_t LEDs_GetLEDs(void) ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t LEDs_GetLEDs(void)
			{
				return (PORTD & LEDS_ALL_LEDS);
    ef5c:	9b b0       	in	r9, 0x0b	; 11

	char LineBuffer[30];

    TimeDate_t CurrentTimeDate;
    /* Signal a 500ms tick has elapsed to the RTC */
    RTC_Tick500ms();
    ef5e:	0e 94 9f 85 	call	0x10b3e	; 0x10b3e <RTC_Tick500ms>

    RTC_GetTimeDate(&CurrentTimeDate);
    ef62:	ce 01       	movw	r24, r28
    ef64:	03 96       	adiw	r24, 0x03	; 3
    ef66:	0e 94 a0 85 	call	0x10b40	; 0x10b40 <RTC_GetTimeDate>

    ActualTime = (uint32_t)CurrentTimeDate.Hour*3600 + (uint32_t)CurrentTimeDate.Minute*60
    ef6a:	6b 81       	ldd	r22, Y+3	; 0x03
    ef6c:	70 e0       	ldi	r23, 0x00	; 0
    ef6e:	80 e0       	ldi	r24, 0x00	; 0
    ef70:	90 e0       	ldi	r25, 0x00	; 0
    ef72:	20 e1       	ldi	r18, 0x10	; 16
    ef74:	3e e0       	ldi	r19, 0x0E	; 14
    ef76:	40 e0       	ldi	r20, 0x00	; 0
    ef78:	50 e0       	ldi	r21, 0x00	; 0
    ef7a:	0e 94 9d ac 	call	0x1593a	; 0x1593a <__mulsi3>
    ef7e:	7b 01       	movw	r14, r22
    ef80:	8c 01       	movw	r16, r24
    ef82:	6c 81       	ldd	r22, Y+4	; 0x04
    ef84:	70 e0       	ldi	r23, 0x00	; 0
    ef86:	80 e0       	ldi	r24, 0x00	; 0
    ef88:	90 e0       	ldi	r25, 0x00	; 0
    ef8a:	2c e3       	ldi	r18, 0x3C	; 60
    ef8c:	30 e0       	ldi	r19, 0x00	; 0
    ef8e:	40 e0       	ldi	r20, 0x00	; 0
    ef90:	50 e0       	ldi	r21, 0x00	; 0
    ef92:	0e 94 9d ac 	call	0x1593a	; 0x1593a <__mulsi3>
    ef96:	e6 0e       	add	r14, r22
    ef98:	f7 1e       	adc	r15, r23
    ef9a:	08 1f       	adc	r16, r24
    ef9c:	19 1f       	adc	r17, r25
        + CurrentTimeDate.Second;
    ef9e:	8d 81       	ldd	r24, Y+5	; 0x05
    efa0:	e8 0e       	add	r14, r24
    efa2:	f1 1c       	adc	r15, r1
    efa4:	01 1d       	adc	r16, r1
    efa6:	11 1d       	adc	r17, r1
    /* Signal a 500ms tick has elapsed to the RTC */
    RTC_Tick500ms();

    RTC_GetTimeDate(&CurrentTimeDate);

    ActualTime = (uint32_t)CurrentTimeDate.Hour*3600 + (uint32_t)CurrentTimeDate.Minute*60
    efa8:	e0 92 f2 0c 	sts	0x0CF2, r14
    efac:	f0 92 f3 0c 	sts	0x0CF3, r15
    efb0:	00 93 f4 0c 	sts	0x0CF4, r16
    efb4:	10 93 f5 0c 	sts	0x0CF5, r17
        + CurrentTimeDate.Second;
    /* key pressed? */
    if (!(MAX_Port_Read & (1<<MAXSWITCH)))
    efb8:	1d 99       	sbic	0x03, 5	; 3
    efba:	09 c1       	rjmp	.+530    	; 0xf1ce <__vector_17+0x2b8>
    {
       #if (LCD==3)
       FrameCounter++;
    efbc:	80 91 df 12 	lds	r24, 0x12DF
    efc0:	8f 5f       	subi	r24, 0xFF	; 255
    efc2:	80 93 df 12 	sts	0x12DF, r24

       if (FrameCounter == 1)
    efc6:	81 30       	cpi	r24, 0x01	; 1
    efc8:	69 f4       	brne	.+26     	; 0xefe4 <__vector_17+0xce>
       {
           DrawFrame2();
    efca:	a2 db       	rcall	.-2236   	; 0xe710 <DrawFrame2>
           lcdDrawString("Sensor 1, Temp.:", 120, 15, GREEN, BLACK);
    efcc:	82 ea       	ldi	r24, 0xA2	; 162
    efce:	97 e0       	ldi	r25, 0x07	; 7
    efd0:	68 e7       	ldi	r22, 0x78	; 120
    efd2:	70 e0       	ldi	r23, 0x00	; 0
    efd4:	4f e0       	ldi	r20, 0x0F	; 15
    efd6:	50 e0       	ldi	r21, 0x00	; 0
    efd8:	20 ee       	ldi	r18, 0xE0	; 224
    efda:	37 e0       	ldi	r19, 0x07	; 7
    efdc:	00 e0       	ldi	r16, 0x00	; 0
    efde:	10 e0       	ldi	r17, 0x00	; 0
    efe0:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
       }

       if (FrameCounter == 2)
    efe4:	80 91 df 12 	lds	r24, 0x12DF
    efe8:	82 30       	cpi	r24, 0x02	; 2
    efea:	69 f4       	brne	.+26     	; 0xf006 <__vector_17+0xf0>
       {
           DrawFrame3();
    efec:	82 dc       	rcall	.-1788   	; 0xe8f2 <DrawFrame3>
           lcdDrawString("Sensor 1, Hum.:", 120, 15, GREEN, BLACK);
    efee:	83 eb       	ldi	r24, 0xB3	; 179
    eff0:	97 e0       	ldi	r25, 0x07	; 7
    eff2:	68 e7       	ldi	r22, 0x78	; 120
    eff4:	70 e0       	ldi	r23, 0x00	; 0
    eff6:	4f e0       	ldi	r20, 0x0F	; 15
    eff8:	50 e0       	ldi	r21, 0x00	; 0
    effa:	20 ee       	ldi	r18, 0xE0	; 224
    effc:	37 e0       	ldi	r19, 0x07	; 7
    effe:	00 e0       	ldi	r16, 0x00	; 0
    f000:	10 e0       	ldi	r17, 0x00	; 0
    f002:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
       }

       if (FrameCounter == 3)
    f006:	80 91 df 12 	lds	r24, 0x12DF
    f00a:	83 30       	cpi	r24, 0x03	; 3
    f00c:	69 f4       	brne	.+26     	; 0xf028 <__vector_17+0x112>
       {
           DrawFrame4();
    f00e:	62 dd       	rcall	.-1340   	; 0xead4 <DrawFrame4>
           lcdDrawString("Sensor 2, Temp.:", 120, 15, YELLOW, BLACK);
    f010:	83 ec       	ldi	r24, 0xC3	; 195
    f012:	97 e0       	ldi	r25, 0x07	; 7
    f014:	68 e7       	ldi	r22, 0x78	; 120
    f016:	70 e0       	ldi	r23, 0x00	; 0
    f018:	4f e0       	ldi	r20, 0x0F	; 15
    f01a:	50 e0       	ldi	r21, 0x00	; 0
    f01c:	20 ee       	ldi	r18, 0xE0	; 224
    f01e:	3f ef       	ldi	r19, 0xFF	; 255
    f020:	00 e0       	ldi	r16, 0x00	; 0
    f022:	10 e0       	ldi	r17, 0x00	; 0
    f024:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
       }

       if (FrameCounter == 4)
    f028:	80 91 df 12 	lds	r24, 0x12DF
    f02c:	84 30       	cpi	r24, 0x04	; 4
    f02e:	69 f4       	brne	.+26     	; 0xf04a <__vector_17+0x134>
       {
           DrawFrame4();
    f030:	51 dd       	rcall	.-1374   	; 0xead4 <DrawFrame4>
           lcdDrawString("Sensor 3, Temp.:", 120, 15, MAGENTA, BLACK);
    f032:	84 ed       	ldi	r24, 0xD4	; 212
    f034:	97 e0       	ldi	r25, 0x07	; 7
    f036:	68 e7       	ldi	r22, 0x78	; 120
    f038:	70 e0       	ldi	r23, 0x00	; 0
    f03a:	4f e0       	ldi	r20, 0x0F	; 15
    f03c:	50 e0       	ldi	r21, 0x00	; 0
    f03e:	2f e1       	ldi	r18, 0x1F	; 31
    f040:	38 ef       	ldi	r19, 0xF8	; 248
    f042:	00 e0       	ldi	r16, 0x00	; 0
    f044:	10 e0       	ldi	r17, 0x00	; 0
    f046:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
       }

       if (FrameCounter == 5)
    f04a:	80 91 df 12 	lds	r24, 0x12DF
    f04e:	85 30       	cpi	r24, 0x05	; 5
    f050:	69 f4       	brne	.+26     	; 0xf06c <__vector_17+0x156>
       {
           DrawFrame4();
    f052:	40 dd       	rcall	.-1408   	; 0xead4 <DrawFrame4>
           lcdDrawString("Sensor 4, Temp.:", 120, 15, CYAN, BLACK);
    f054:	85 ee       	ldi	r24, 0xE5	; 229
    f056:	97 e0       	ldi	r25, 0x07	; 7
    f058:	68 e7       	ldi	r22, 0x78	; 120
    f05a:	70 e0       	ldi	r23, 0x00	; 0
    f05c:	4f e0       	ldi	r20, 0x0F	; 15
    f05e:	50 e0       	ldi	r21, 0x00	; 0
    f060:	2f ef       	ldi	r18, 0xFF	; 255
    f062:	37 e0       	ldi	r19, 0x07	; 7
    f064:	00 e0       	ldi	r16, 0x00	; 0
    f066:	10 e0       	ldi	r17, 0x00	; 0
    f068:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
        }

       if (FrameCounter == 6)
    f06c:	80 91 df 12 	lds	r24, 0x12DF
    f070:	86 30       	cpi	r24, 0x06	; 6
    f072:	09 f0       	breq	.+2      	; 0xf076 <__vector_17+0x160>
    f074:	ac c0       	rjmp	.+344    	; 0xf1ce <__vector_17+0x2b8>
       {
           FrameCounter = 0;
    f076:	10 92 df 12 	sts	0x12DF, r1
           DrawFrame1();
    f07a:	ca da       	rcall	.-2668   	; 0xe610 <DrawFrame1>
           Sensor1PreviousValue = 0;
    f07c:	10 92 81 10 	sts	0x1081, r1
           Sensor1Received = false;
    f080:	10 92 61 09 	sts	0x0961, r1

           lcdSetFont((uint8_t*) Arial28x28);
    f084:	80 e6       	ldi	r24, 0x60	; 96
    f086:	95 e2       	ldi	r25, 0x25	; 37
    f088:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
           sprintf (LineBuffer, "%d~C", Sensor2Value);
    f08c:	00 d0       	rcall	.+0      	; 0xf08e <__vector_17+0x178>
    f08e:	00 d0       	rcall	.+0      	; 0xf090 <__vector_17+0x17a>
    f090:	00 d0       	rcall	.+0      	; 0xf092 <__vector_17+0x17c>
    f092:	ed b7       	in	r30, 0x3d	; 61
    f094:	fe b7       	in	r31, 0x3e	; 62
    f096:	31 96       	adiw	r30, 0x01	; 1
    f098:	8e 01       	movw	r16, r28
    f09a:	01 5f       	subi	r16, 0xF1	; 241
    f09c:	1f 4f       	sbci	r17, 0xFF	; 255
    f09e:	ad b7       	in	r26, 0x3d	; 61
    f0a0:	be b7       	in	r27, 0x3e	; 62
    f0a2:	12 96       	adiw	r26, 0x02	; 2
    f0a4:	1c 93       	st	X, r17
    f0a6:	0e 93       	st	-X, r16
    f0a8:	11 97       	sbiw	r26, 0x01	; 1
    f0aa:	8a e7       	ldi	r24, 0x7A	; 122
    f0ac:	96 e0       	ldi	r25, 0x06	; 6
    f0ae:	93 83       	std	Z+3, r25	; 0x03
    f0b0:	82 83       	std	Z+2, r24	; 0x02
    f0b2:	80 91 62 09 	lds	r24, 0x0962
    f0b6:	99 27       	eor	r25, r25
    f0b8:	87 fd       	sbrc	r24, 7
    f0ba:	90 95       	com	r25
    f0bc:	95 83       	std	Z+5, r25	; 0x05
    f0be:	84 83       	std	Z+4, r24	; 0x04
    f0c0:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
           if (Sensor2Received) lcdDrawString(LineBuffer,20,170,YELLOW,BLACK);
    f0c4:	ed b7       	in	r30, 0x3d	; 61
    f0c6:	fe b7       	in	r31, 0x3e	; 62
    f0c8:	36 96       	adiw	r30, 0x06	; 6
    f0ca:	0f b6       	in	r0, 0x3f	; 63
    f0cc:	f8 94       	cli
    f0ce:	fe bf       	out	0x3e, r31	; 62
    f0d0:	0f be       	out	0x3f, r0	; 63
    f0d2:	ed bf       	out	0x3d, r30	; 61
    f0d4:	80 91 63 09 	lds	r24, 0x0963
    f0d8:	88 23       	and	r24, r24
    f0da:	59 f0       	breq	.+22     	; 0xf0f2 <__vector_17+0x1dc>
    f0dc:	c8 01       	movw	r24, r16
    f0de:	64 e1       	ldi	r22, 0x14	; 20
    f0e0:	70 e0       	ldi	r23, 0x00	; 0
    f0e2:	4a ea       	ldi	r20, 0xAA	; 170
    f0e4:	50 e0       	ldi	r21, 0x00	; 0
    f0e6:	20 ee       	ldi	r18, 0xE0	; 224
    f0e8:	3f ef       	ldi	r19, 0xFF	; 255
    f0ea:	00 e0       	ldi	r16, 0x00	; 0
    f0ec:	10 e0       	ldi	r17, 0x00	; 0
    f0ee:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>

           lcdSetFont((uint8_t*) Arial28x28);
    f0f2:	80 e6       	ldi	r24, 0x60	; 96
    f0f4:	95 e2       	ldi	r25, 0x25	; 37
    f0f6:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
           sprintf (LineBuffer, "%d~C", Sensor3Value);
    f0fa:	00 d0       	rcall	.+0      	; 0xf0fc <__vector_17+0x1e6>
    f0fc:	00 d0       	rcall	.+0      	; 0xf0fe <__vector_17+0x1e8>
    f0fe:	00 d0       	rcall	.+0      	; 0xf100 <__vector_17+0x1ea>
    f100:	ed b7       	in	r30, 0x3d	; 61
    f102:	fe b7       	in	r31, 0x3e	; 62
    f104:	31 96       	adiw	r30, 0x01	; 1
    f106:	8e 01       	movw	r16, r28
    f108:	01 5f       	subi	r16, 0xF1	; 241
    f10a:	1f 4f       	sbci	r17, 0xFF	; 255
    f10c:	ad b7       	in	r26, 0x3d	; 61
    f10e:	be b7       	in	r27, 0x3e	; 62
    f110:	12 96       	adiw	r26, 0x02	; 2
    f112:	1c 93       	st	X, r17
    f114:	0e 93       	st	-X, r16
    f116:	11 97       	sbiw	r26, 0x01	; 1
    f118:	8a e7       	ldi	r24, 0x7A	; 122
    f11a:	96 e0       	ldi	r25, 0x06	; 6
    f11c:	93 83       	std	Z+3, r25	; 0x03
    f11e:	82 83       	std	Z+2, r24	; 0x02
    f120:	80 91 64 09 	lds	r24, 0x0964
    f124:	99 27       	eor	r25, r25
    f126:	87 fd       	sbrc	r24, 7
    f128:	90 95       	com	r25
    f12a:	95 83       	std	Z+5, r25	; 0x05
    f12c:	84 83       	std	Z+4, r24	; 0x04
    f12e:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
           if (Sensor3Received) lcdDrawString(LineBuffer,130,170,MAGENTA,BLACK);
    f132:	ed b7       	in	r30, 0x3d	; 61
    f134:	fe b7       	in	r31, 0x3e	; 62
    f136:	36 96       	adiw	r30, 0x06	; 6
    f138:	0f b6       	in	r0, 0x3f	; 63
    f13a:	f8 94       	cli
    f13c:	fe bf       	out	0x3e, r31	; 62
    f13e:	0f be       	out	0x3f, r0	; 63
    f140:	ed bf       	out	0x3d, r30	; 61
    f142:	80 91 65 09 	lds	r24, 0x0965
    f146:	88 23       	and	r24, r24
    f148:	59 f0       	breq	.+22     	; 0xf160 <__vector_17+0x24a>
    f14a:	c8 01       	movw	r24, r16
    f14c:	62 e8       	ldi	r22, 0x82	; 130
    f14e:	70 e0       	ldi	r23, 0x00	; 0
    f150:	4a ea       	ldi	r20, 0xAA	; 170
    f152:	50 e0       	ldi	r21, 0x00	; 0
    f154:	2f e1       	ldi	r18, 0x1F	; 31
    f156:	38 ef       	ldi	r19, 0xF8	; 248
    f158:	00 e0       	ldi	r16, 0x00	; 0
    f15a:	10 e0       	ldi	r17, 0x00	; 0
    f15c:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>

           lcdSetFont((uint8_t*) Arial28x28);
    f160:	80 e6       	ldi	r24, 0x60	; 96
    f162:	95 e2       	ldi	r25, 0x25	; 37
    f164:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
           sprintf (LineBuffer, "%d~C", Sensor4Value);
    f168:	00 d0       	rcall	.+0      	; 0xf16a <__vector_17+0x254>
    f16a:	00 d0       	rcall	.+0      	; 0xf16c <__vector_17+0x256>
    f16c:	00 d0       	rcall	.+0      	; 0xf16e <__vector_17+0x258>
    f16e:	ed b7       	in	r30, 0x3d	; 61
    f170:	fe b7       	in	r31, 0x3e	; 62
    f172:	31 96       	adiw	r30, 0x01	; 1
    f174:	8e 01       	movw	r16, r28
    f176:	01 5f       	subi	r16, 0xF1	; 241
    f178:	1f 4f       	sbci	r17, 0xFF	; 255
    f17a:	ad b7       	in	r26, 0x3d	; 61
    f17c:	be b7       	in	r27, 0x3e	; 62
    f17e:	12 96       	adiw	r26, 0x02	; 2
    f180:	1c 93       	st	X, r17
    f182:	0e 93       	st	-X, r16
    f184:	11 97       	sbiw	r26, 0x01	; 1
    f186:	8a e7       	ldi	r24, 0x7A	; 122
    f188:	96 e0       	ldi	r25, 0x06	; 6
    f18a:	93 83       	std	Z+3, r25	; 0x03
    f18c:	82 83       	std	Z+2, r24	; 0x02
    f18e:	80 91 66 09 	lds	r24, 0x0966
    f192:	99 27       	eor	r25, r25
    f194:	87 fd       	sbrc	r24, 7
    f196:	90 95       	com	r25
    f198:	95 83       	std	Z+5, r25	; 0x05
    f19a:	84 83       	std	Z+4, r24	; 0x04
    f19c:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
           if (Sensor4Received) lcdDrawString(LineBuffer,235,170,CYAN,BLACK);
    f1a0:	ed b7       	in	r30, 0x3d	; 61
    f1a2:	fe b7       	in	r31, 0x3e	; 62
    f1a4:	36 96       	adiw	r30, 0x06	; 6
    f1a6:	0f b6       	in	r0, 0x3f	; 63
    f1a8:	f8 94       	cli
    f1aa:	fe bf       	out	0x3e, r31	; 62
    f1ac:	0f be       	out	0x3f, r0	; 63
    f1ae:	ed bf       	out	0x3d, r30	; 61
    f1b0:	80 91 67 09 	lds	r24, 0x0967
    f1b4:	88 23       	and	r24, r24
    f1b6:	59 f0       	breq	.+22     	; 0xf1ce <__vector_17+0x2b8>
    f1b8:	c8 01       	movw	r24, r16
    f1ba:	6b ee       	ldi	r22, 0xEB	; 235
    f1bc:	70 e0       	ldi	r23, 0x00	; 0
    f1be:	4a ea       	ldi	r20, 0xAA	; 170
    f1c0:	50 e0       	ldi	r21, 0x00	; 0
    f1c2:	2f ef       	ldi	r18, 0xFF	; 255
    f1c4:	37 e0       	ldi	r19, 0x07	; 7
    f1c6:	00 e0       	ldi	r16, 0x00	; 0
    f1c8:	10 e0       	ldi	r17, 0x00	; 0
    f1ca:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcd_print_str(Sensor2Name_SRAM);
    lcd_pos(3,1);
    lcd_print_str(Sensor3Name_SRAM);
    #endif
    #if (LCD==3)
    if (FrameCounter == 0)
    f1ce:	80 91 df 12 	lds	r24, 0x12DF
    f1d2:	88 23       	and	r24, r24
    f1d4:	09 f0       	breq	.+2      	; 0xf1d8 <__vector_17+0x2c2>
    f1d6:	48 c0       	rjmp	.+144    	; 0xf268 <__vector_17+0x352>
    {
        lcdSetFont((uint8_t*) Arial24x23);
    f1d8:	8c ef       	ldi	r24, 0xFC	; 252
    f1da:	99 e0       	ldi	r25, 0x09	; 9
    f1dc:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
        sprintf(LineBuffer, "%02d.%02d.%02d  %02d:%02d", CurrentTimeDate.Day, CurrentTimeDate.Month,
    f1e0:	2d b7       	in	r18, 0x3d	; 61
    f1e2:	3e b7       	in	r19, 0x3e	; 62
    f1e4:	2e 50       	subi	r18, 0x0E	; 14
    f1e6:	30 40       	sbci	r19, 0x00	; 0
    f1e8:	0f b6       	in	r0, 0x3f	; 63
    f1ea:	f8 94       	cli
    f1ec:	3e bf       	out	0x3e, r19	; 62
    f1ee:	0f be       	out	0x3f, r0	; 63
    f1f0:	2d bf       	out	0x3d, r18	; 61
    f1f2:	ed b7       	in	r30, 0x3d	; 61
    f1f4:	fe b7       	in	r31, 0x3e	; 62
    f1f6:	31 96       	adiw	r30, 0x01	; 1
    f1f8:	ce 01       	movw	r24, r28
    f1fa:	0f 96       	adiw	r24, 0x0f	; 15
    f1fc:	ad b7       	in	r26, 0x3d	; 61
    f1fe:	be b7       	in	r27, 0x3e	; 62
    f200:	12 96       	adiw	r26, 0x02	; 2
    f202:	9c 93       	st	X, r25
    f204:	8e 93       	st	-X, r24
    f206:	11 97       	sbiw	r26, 0x01	; 1
    f208:	86 ef       	ldi	r24, 0xF6	; 246
    f20a:	97 e0       	ldi	r25, 0x07	; 7
    f20c:	93 83       	std	Z+3, r25	; 0x03
    f20e:	82 83       	std	Z+2, r24	; 0x02
    f210:	8e 81       	ldd	r24, Y+6	; 0x06
    f212:	84 83       	std	Z+4, r24	; 0x04
    f214:	15 82       	std	Z+5, r1	; 0x05
    f216:	8f 81       	ldd	r24, Y+7	; 0x07
    f218:	86 83       	std	Z+6, r24	; 0x06
    f21a:	17 82       	std	Z+7, r1	; 0x07
    f21c:	88 85       	ldd	r24, Y+8	; 0x08
    f21e:	80 87       	std	Z+8, r24	; 0x08
    f220:	11 86       	std	Z+9, r1	; 0x09
    f222:	8b 81       	ldd	r24, Y+3	; 0x03
    f224:	82 87       	std	Z+10, r24	; 0x0a
    f226:	13 86       	std	Z+11, r1	; 0x0b
    f228:	8c 81       	ldd	r24, Y+4	; 0x04
    f22a:	84 87       	std	Z+12, r24	; 0x0c
    f22c:	15 86       	std	Z+13, r1	; 0x0d
    f22e:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
            CurrentTimeDate.Year, CurrentTimeDate.Hour, CurrentTimeDate.Minute);
        if (CurrentTimeDate.Second == 0 || !Sensor1Received)
    f232:	ed b7       	in	r30, 0x3d	; 61
    f234:	fe b7       	in	r31, 0x3e	; 62
    f236:	3e 96       	adiw	r30, 0x0e	; 14
    f238:	0f b6       	in	r0, 0x3f	; 63
    f23a:	f8 94       	cli
    f23c:	fe bf       	out	0x3e, r31	; 62
    f23e:	0f be       	out	0x3f, r0	; 63
    f240:	ed bf       	out	0x3d, r30	; 61
    f242:	8d 81       	ldd	r24, Y+5	; 0x05
    f244:	88 23       	and	r24, r24
    f246:	21 f0       	breq	.+8      	; 0xf250 <__vector_17+0x33a>
    f248:	80 91 61 09 	lds	r24, 0x0961
    f24c:	88 23       	and	r24, r24
    f24e:	61 f4       	brne	.+24     	; 0xf268 <__vector_17+0x352>
        lcdDrawString(LineBuffer,15,10,GRAY,BLACK);
    f250:	ce 01       	movw	r24, r28
    f252:	0f 96       	adiw	r24, 0x0f	; 15
    f254:	6f e0       	ldi	r22, 0x0F	; 15
    f256:	70 e0       	ldi	r23, 0x00	; 0
    f258:	4a e0       	ldi	r20, 0x0A	; 10
    f25a:	50 e0       	ldi	r21, 0x00	; 0
    f25c:	28 e0       	ldi	r18, 0x08	; 8
    f25e:	34 e8       	ldi	r19, 0x84	; 132
    f260:	00 e0       	ldi	r16, 0x00	; 0
    f262:	10 e0       	ldi	r17, 0x00	; 0
    f264:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    lcd_pos(1,1);
    lcd_print_str(Sensor1Name_SRAM);
    #endif

    //Temperature = Temperature_GetTemperature()+Sensor1Correction_SRAM;  // if use of local NTC
    HYT321_GetData(&Humidity, &Temperature);
    f268:	89 e6       	ldi	r24, 0x69	; 105
    f26a:	99 e0       	ldi	r25, 0x09	; 9
    f26c:	68 e6       	ldi	r22, 0x68	; 104
    f26e:	79 e0       	ldi	r23, 0x09	; 9
    f270:	0e 94 1f 9a 	call	0x1343e	; 0x1343e <HYT321_GetData>
    Temperature += Sensor1Correction_SRAM;
    f274:	80 91 68 09 	lds	r24, 0x0968
    f278:	90 91 e1 12 	lds	r25, 0x12E1
    f27c:	89 0f       	add	r24, r25
    f27e:	80 93 68 09 	sts	0x0968, r24
    if (Temperature > Sensor1PreviousValue + 1) lcd_write (0, 1);
    else if (Temperature < Sensor1PreviousValue - 1) lcd_write (1, 1);
    else lcd_print_str ("~");
    #endif
    #if (LCD==3)
      if (FrameCounter == 0)        //display actual measure values
    f282:	80 91 df 12 	lds	r24, 0x12DF
    f286:	88 23       	and	r24, r24
    f288:	09 f0       	breq	.+2      	; 0xf28c <__vector_17+0x376>
    f28a:	5f c0       	rjmp	.+190    	; 0xf34a <__vector_17+0x434>
      {

        lcdSetFont((uint8_t*) Neu42x35);
    f28c:	84 ec       	ldi	r24, 0xC4	; 196
    f28e:	9c e4       	ldi	r25, 0x4C	; 76
    f290:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>

        if ((Temperature != Sensor1PreviousValue)||(Humidity != HumidityPreviousValue))
    f294:	80 91 68 09 	lds	r24, 0x0968
    f298:	90 91 81 10 	lds	r25, 0x1081
    f29c:	89 17       	cp	r24, r25
    f29e:	39 f4       	brne	.+14     	; 0xf2ae <__vector_17+0x398>
    f2a0:	20 91 69 09 	lds	r18, 0x0969
    f2a4:	90 91 e5 12 	lds	r25, 0x12E5
    f2a8:	29 17       	cp	r18, r25
    f2aa:	09 f4       	brne	.+2      	; 0xf2ae <__vector_17+0x398>
    f2ac:	4e c0       	rjmp	.+156    	; 0xf34a <__vector_17+0x434>
        {
            sprintf (LineBuffer, "%d~C %d%%", Temperature, Humidity);
    f2ae:	2d b7       	in	r18, 0x3d	; 61
    f2b0:	3e b7       	in	r19, 0x3e	; 62
    f2b2:	28 50       	subi	r18, 0x08	; 8
    f2b4:	30 40       	sbci	r19, 0x00	; 0
    f2b6:	0f b6       	in	r0, 0x3f	; 63
    f2b8:	f8 94       	cli
    f2ba:	3e bf       	out	0x3e, r19	; 62
    f2bc:	0f be       	out	0x3f, r0	; 63
    f2be:	2d bf       	out	0x3d, r18	; 61
    f2c0:	ed b7       	in	r30, 0x3d	; 61
    f2c2:	fe b7       	in	r31, 0x3e	; 62
    f2c4:	31 96       	adiw	r30, 0x01	; 1
    f2c6:	8e 01       	movw	r16, r28
    f2c8:	01 5f       	subi	r16, 0xF1	; 241
    f2ca:	1f 4f       	sbci	r17, 0xFF	; 255
    f2cc:	ad b7       	in	r26, 0x3d	; 61
    f2ce:	be b7       	in	r27, 0x3e	; 62
    f2d0:	12 96       	adiw	r26, 0x02	; 2
    f2d2:	1c 93       	st	X, r17
    f2d4:	0e 93       	st	-X, r16
    f2d6:	11 97       	sbiw	r26, 0x01	; 1
    f2d8:	20 e1       	ldi	r18, 0x10	; 16
    f2da:	38 e0       	ldi	r19, 0x08	; 8
    f2dc:	33 83       	std	Z+3, r19	; 0x03
    f2de:	22 83       	std	Z+2, r18	; 0x02
    f2e0:	99 27       	eor	r25, r25
    f2e2:	87 fd       	sbrc	r24, 7
    f2e4:	90 95       	com	r25
    f2e6:	95 83       	std	Z+5, r25	; 0x05
    f2e8:	84 83       	std	Z+4, r24	; 0x04
    f2ea:	80 91 69 09 	lds	r24, 0x0969
    f2ee:	99 27       	eor	r25, r25
    f2f0:	87 fd       	sbrc	r24, 7
    f2f2:	90 95       	com	r25
    f2f4:	97 83       	std	Z+7, r25	; 0x07
    f2f6:	86 83       	std	Z+6, r24	; 0x06
    f2f8:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
            lcdDrawString(LineBuffer,60,50,GREEN,BLACK);
    f2fc:	ed b7       	in	r30, 0x3d	; 61
    f2fe:	fe b7       	in	r31, 0x3e	; 62
    f300:	38 96       	adiw	r30, 0x08	; 8
    f302:	0f b6       	in	r0, 0x3f	; 63
    f304:	f8 94       	cli
    f306:	fe bf       	out	0x3e, r31	; 62
    f308:	0f be       	out	0x3f, r0	; 63
    f30a:	ed bf       	out	0x3d, r30	; 61
    f30c:	c8 01       	movw	r24, r16
    f30e:	6c e3       	ldi	r22, 0x3C	; 60
    f310:	70 e0       	ldi	r23, 0x00	; 0
    f312:	42 e3       	ldi	r20, 0x32	; 50
    f314:	50 e0       	ldi	r21, 0x00	; 0
    f316:	20 ee       	ldi	r18, 0xE0	; 224
    f318:	37 e0       	ldi	r19, 0x07	; 7
    f31a:	00 e0       	ldi	r16, 0x00	; 0
    f31c:	10 e0       	ldi	r17, 0x00	; 0
    f31e:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
            lcdDrawVLine(318,0,120,SILVER); //redraw right frame line
    f322:	8e e3       	ldi	r24, 0x3E	; 62
    f324:	91 e0       	ldi	r25, 0x01	; 1
    f326:	60 e0       	ldi	r22, 0x00	; 0
    f328:	70 e0       	ldi	r23, 0x00	; 0
    f32a:	48 e7       	ldi	r20, 0x78	; 120
    f32c:	50 e0       	ldi	r21, 0x00	; 0
    f32e:	20 e1       	ldi	r18, 0x10	; 16
    f330:	35 ea       	ldi	r19, 0xA5	; 165
    f332:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
            lcdDrawVLine(1,0,120,SILVER); //redraw right frame line
    f336:	81 e0       	ldi	r24, 0x01	; 1
    f338:	90 e0       	ldi	r25, 0x00	; 0
    f33a:	60 e0       	ldi	r22, 0x00	; 0
    f33c:	70 e0       	ldi	r23, 0x00	; 0
    f33e:	48 e7       	ldi	r20, 0x78	; 120
    f340:	50 e0       	ldi	r21, 0x00	; 0
    f342:	20 e1       	ldi	r18, 0x10	; 16
    f344:	35 ea       	ldi	r19, 0xA5	; 165
    f346:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>

        }
       }

       if (FrameCounter == 1)
    f34a:	80 91 df 12 	lds	r24, 0x12DF
    f34e:	81 30       	cpi	r24, 0x01	; 1
    f350:	09 f0       	breq	.+2      	; 0xf354 <__vector_17+0x43e>
    f352:	69 c0       	rjmp	.+210    	; 0xf426 <__vector_17+0x510>
    f354:	41 eb       	ldi	r20, 0xB1	; 177
    f356:	c4 2e       	mov	r12, r20
    f358:	41 e1       	ldi	r20, 0x11	; 17
    f35a:	d4 2e       	mov	r13, r20
    f35c:	3a e0       	ldi	r19, 0x0A	; 10
    f35e:	e3 2e       	mov	r14, r19
    f360:	f1 2c       	mov	r15, r1
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor1TempValues[ArrayIndex]!=127) & (Sensor1TempValues[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,220-Sensor1TempValues[ArrayIndex]*4,ArrayIndex+11,220-Sensor1TempValues[ArrayIndex+1]*4,GREEN);
    f362:	27 e3       	ldi	r18, 0x37	; 55
    f364:	a2 2e       	mov	r10, r18
    f366:	b1 2c       	mov	r11, r1

       if (FrameCounter == 1)
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor1TempValues[ArrayIndex]!=127) & (Sensor1TempValues[ArrayIndex+1]!=127))
    f368:	d6 01       	movw	r26, r12
    f36a:	2d 91       	ld	r18, X+
    f36c:	6d 01       	movw	r12, r26
    f36e:	8c 91       	ld	r24, X
    f370:	8f 37       	cpi	r24, 0x7F	; 127
    f372:	f1 f0       	breq	.+60     	; 0xf3b0 <__vector_17+0x49a>
    f374:	2f 37       	cpi	r18, 0x7F	; 127
    f376:	e1 f0       	breq	.+56     	; 0xf3b0 <__vector_17+0x49a>
                lcdDrawLine (ArrayIndex+10,220-Sensor1TempValues[ArrayIndex]*4,ArrayIndex+11,220-Sensor1TempValues[ArrayIndex+1]*4,GREEN);
    f378:	33 27       	eor	r19, r19
    f37a:	27 fd       	sbrc	r18, 7
    f37c:	30 95       	com	r19
    f37e:	b5 01       	movw	r22, r10
    f380:	62 1b       	sub	r22, r18
    f382:	73 0b       	sbc	r23, r19
    f384:	66 0f       	add	r22, r22
    f386:	77 1f       	adc	r23, r23
    f388:	66 0f       	add	r22, r22
    f38a:	77 1f       	adc	r23, r23
    }
}*/


/** ISR to handle the 500ms ticks for sampling and data logging */
ISR(TIMER1_COMPA_vect, ISR_BLOCK)
    f38c:	a7 01       	movw	r20, r14
    f38e:	4f 5f       	subi	r20, 0xFF	; 255
    f390:	5f 4f       	sbci	r21, 0xFF	; 255
       if (FrameCounter == 1)
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor1TempValues[ArrayIndex]!=127) & (Sensor1TempValues[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,220-Sensor1TempValues[ArrayIndex]*4,ArrayIndex+11,220-Sensor1TempValues[ArrayIndex+1]*4,GREEN);
    f392:	99 27       	eor	r25, r25
    f394:	87 fd       	sbrc	r24, 7
    f396:	90 95       	com	r25
    f398:	95 01       	movw	r18, r10
    f39a:	28 1b       	sub	r18, r24
    f39c:	39 0b       	sbc	r19, r25
    f39e:	22 0f       	add	r18, r18
    f3a0:	33 1f       	adc	r19, r19
    f3a2:	22 0f       	add	r18, r18
    f3a4:	33 1f       	adc	r19, r19
    f3a6:	c7 01       	movw	r24, r14
    f3a8:	00 ee       	ldi	r16, 0xE0	; 224
    f3aa:	17 e0       	ldi	r17, 0x07	; 7
    f3ac:	0e 94 81 9d 	call	0x13b02	; 0x13b02 <lcdDrawLine>
    f3b0:	08 94       	sec
    f3b2:	e1 1c       	adc	r14, r1
    f3b4:	f1 1c       	adc	r15, r1
        }
       }

       if (FrameCounter == 1)
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
    f3b6:	b5 e3       	ldi	r27, 0x35	; 53
    f3b8:	eb 16       	cp	r14, r27
    f3ba:	b1 e0       	ldi	r27, 0x01	; 1
    f3bc:	fb 06       	cpc	r15, r27
    f3be:	a1 f6       	brne	.-88     	; 0xf368 <__vector_17+0x452>
          {
            if ((Sensor1TempValues[ArrayIndex]!=127) & (Sensor1TempValues[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,220-Sensor1TempValues[ArrayIndex]*4,ArrayIndex+11,220-Sensor1TempValues[ArrayIndex+1]*4,GREEN);
          }
          lcdSetFont((uint8_t*) Arial12x12);      //display actual measure values
    f3c0:	88 e9       	ldi	r24, 0x98	; 152
    f3c2:	90 e0       	ldi	r25, 0x00	; 0
    f3c4:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>

          sprintf (LineBuffer, "%d~C ", Temperature);
    f3c8:	00 d0       	rcall	.+0      	; 0xf3ca <__vector_17+0x4b4>
    f3ca:	00 d0       	rcall	.+0      	; 0xf3cc <__vector_17+0x4b6>
    f3cc:	00 d0       	rcall	.+0      	; 0xf3ce <__vector_17+0x4b8>
    f3ce:	ed b7       	in	r30, 0x3d	; 61
    f3d0:	fe b7       	in	r31, 0x3e	; 62
    f3d2:	31 96       	adiw	r30, 0x01	; 1
    f3d4:	8e 01       	movw	r16, r28
    f3d6:	01 5f       	subi	r16, 0xF1	; 241
    f3d8:	1f 4f       	sbci	r17, 0xFF	; 255
    f3da:	ad b7       	in	r26, 0x3d	; 61
    f3dc:	be b7       	in	r27, 0x3e	; 62
    f3de:	12 96       	adiw	r26, 0x02	; 2
    f3e0:	1c 93       	st	X, r17
    f3e2:	0e 93       	st	-X, r16
    f3e4:	11 97       	sbiw	r26, 0x01	; 1
    f3e6:	8a e1       	ldi	r24, 0x1A	; 26
    f3e8:	98 e0       	ldi	r25, 0x08	; 8
    f3ea:	93 83       	std	Z+3, r25	; 0x03
    f3ec:	82 83       	std	Z+2, r24	; 0x02
    f3ee:	80 91 68 09 	lds	r24, 0x0968
    f3f2:	99 27       	eor	r25, r25
    f3f4:	87 fd       	sbrc	r24, 7
    f3f6:	90 95       	com	r25
    f3f8:	95 83       	std	Z+5, r25	; 0x05
    f3fa:	84 83       	std	Z+4, r24	; 0x04
    f3fc:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
          lcdDrawString(LineBuffer,255,15,GREEN,BLACK);
    f400:	ed b7       	in	r30, 0x3d	; 61
    f402:	fe b7       	in	r31, 0x3e	; 62
    f404:	36 96       	adiw	r30, 0x06	; 6
    f406:	0f b6       	in	r0, 0x3f	; 63
    f408:	f8 94       	cli
    f40a:	fe bf       	out	0x3e, r31	; 62
    f40c:	0f be       	out	0x3f, r0	; 63
    f40e:	ed bf       	out	0x3d, r30	; 61
    f410:	c8 01       	movw	r24, r16
    f412:	6f ef       	ldi	r22, 0xFF	; 255
    f414:	70 e0       	ldi	r23, 0x00	; 0
    f416:	4f e0       	ldi	r20, 0x0F	; 15
    f418:	50 e0       	ldi	r21, 0x00	; 0
    f41a:	20 ee       	ldi	r18, 0xE0	; 224
    f41c:	37 e0       	ldi	r19, 0x07	; 7
    f41e:	00 e0       	ldi	r16, 0x00	; 0
    f420:	10 e0       	ldi	r17, 0x00	; 0
    f422:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>

       }

        if (FrameCounter == 2)
    f426:	80 91 df 12 	lds	r24, 0x12DF
    f42a:	82 30       	cpi	r24, 0x02	; 2
    f42c:	09 f0       	breq	.+2      	; 0xf430 <__vector_17+0x51a>
    f42e:	65 c0       	rjmp	.+202    	; 0xf4fa <__vector_17+0x5e4>
    f430:	18 eb       	ldi	r17, 0xB8	; 184
    f432:	c1 2e       	mov	r12, r17
    f434:	1b e0       	ldi	r17, 0x0B	; 11
    f436:	d1 2e       	mov	r13, r17
    f438:	ba e0       	ldi	r27, 0x0A	; 10
    f43a:	eb 2e       	mov	r14, r27
    f43c:	f1 2c       	mov	r15, r1
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor1HumditiyValues[ArrayIndex]!=127) & (Sensor1HumditiyValues[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,220-Sensor1HumditiyValues[ArrayIndex]*2,ArrayIndex+11,220-Sensor1HumditiyValues[ArrayIndex+1]*2,GREEN);
    f43e:	ae e6       	ldi	r26, 0x6E	; 110
    f440:	aa 2e       	mov	r10, r26
    f442:	b1 2c       	mov	r11, r1

        if (FrameCounter == 2)
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor1HumditiyValues[ArrayIndex]!=127) & (Sensor1HumditiyValues[ArrayIndex+1]!=127))
    f444:	d6 01       	movw	r26, r12
    f446:	2d 91       	ld	r18, X+
    f448:	6d 01       	movw	r12, r26
    f44a:	8c 91       	ld	r24, X
    f44c:	8f 37       	cpi	r24, 0x7F	; 127
    f44e:	d1 f0       	breq	.+52     	; 0xf484 <__vector_17+0x56e>
    f450:	2f 37       	cpi	r18, 0x7F	; 127
    f452:	c1 f0       	breq	.+48     	; 0xf484 <__vector_17+0x56e>
                lcdDrawLine (ArrayIndex+10,220-Sensor1HumditiyValues[ArrayIndex]*2,ArrayIndex+11,220-Sensor1HumditiyValues[ArrayIndex+1]*2,GREEN);
    f454:	33 27       	eor	r19, r19
    f456:	27 fd       	sbrc	r18, 7
    f458:	30 95       	com	r19
    f45a:	b5 01       	movw	r22, r10
    f45c:	62 1b       	sub	r22, r18
    f45e:	73 0b       	sbc	r23, r19
    f460:	66 0f       	add	r22, r22
    f462:	77 1f       	adc	r23, r23
    }
}*/


/** ISR to handle the 500ms ticks for sampling and data logging */
ISR(TIMER1_COMPA_vect, ISR_BLOCK)
    f464:	a7 01       	movw	r20, r14
    f466:	4f 5f       	subi	r20, 0xFF	; 255
    f468:	5f 4f       	sbci	r21, 0xFF	; 255
        if (FrameCounter == 2)
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor1HumditiyValues[ArrayIndex]!=127) & (Sensor1HumditiyValues[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,220-Sensor1HumditiyValues[ArrayIndex]*2,ArrayIndex+11,220-Sensor1HumditiyValues[ArrayIndex+1]*2,GREEN);
    f46a:	99 27       	eor	r25, r25
    f46c:	87 fd       	sbrc	r24, 7
    f46e:	90 95       	com	r25
    f470:	95 01       	movw	r18, r10
    f472:	28 1b       	sub	r18, r24
    f474:	39 0b       	sbc	r19, r25
    f476:	22 0f       	add	r18, r18
    f478:	33 1f       	adc	r19, r19
    f47a:	c7 01       	movw	r24, r14
    f47c:	00 ee       	ldi	r16, 0xE0	; 224
    f47e:	17 e0       	ldi	r17, 0x07	; 7
    f480:	0e 94 81 9d 	call	0x13b02	; 0x13b02 <lcdDrawLine>
    f484:	08 94       	sec
    f486:	e1 1c       	adc	r14, r1
    f488:	f1 1c       	adc	r15, r1

       }

        if (FrameCounter == 2)
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
    f48a:	b5 e3       	ldi	r27, 0x35	; 53
    f48c:	eb 16       	cp	r14, r27
    f48e:	b1 e0       	ldi	r27, 0x01	; 1
    f490:	fb 06       	cpc	r15, r27
    f492:	c1 f6       	brne	.-80     	; 0xf444 <__vector_17+0x52e>
          {
            if ((Sensor1HumditiyValues[ArrayIndex]!=127) & (Sensor1HumditiyValues[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,220-Sensor1HumditiyValues[ArrayIndex]*2,ArrayIndex+11,220-Sensor1HumditiyValues[ArrayIndex+1]*2,GREEN);
           }
          lcdSetFont((uint8_t*) Arial12x12);      //display actual measure values
    f494:	88 e9       	ldi	r24, 0x98	; 152
    f496:	90 e0       	ldi	r25, 0x00	; 0
    f498:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>

          sprintf (LineBuffer, "%d%% ", Humidity);
    f49c:	00 d0       	rcall	.+0      	; 0xf49e <__vector_17+0x588>
    f49e:	00 d0       	rcall	.+0      	; 0xf4a0 <__vector_17+0x58a>
    f4a0:	00 d0       	rcall	.+0      	; 0xf4a2 <__vector_17+0x58c>
    f4a2:	ed b7       	in	r30, 0x3d	; 61
    f4a4:	fe b7       	in	r31, 0x3e	; 62
    f4a6:	31 96       	adiw	r30, 0x01	; 1
    f4a8:	8e 01       	movw	r16, r28
    f4aa:	01 5f       	subi	r16, 0xF1	; 241
    f4ac:	1f 4f       	sbci	r17, 0xFF	; 255
    f4ae:	ad b7       	in	r26, 0x3d	; 61
    f4b0:	be b7       	in	r27, 0x3e	; 62
    f4b2:	12 96       	adiw	r26, 0x02	; 2
    f4b4:	1c 93       	st	X, r17
    f4b6:	0e 93       	st	-X, r16
    f4b8:	11 97       	sbiw	r26, 0x01	; 1
    f4ba:	80 e2       	ldi	r24, 0x20	; 32
    f4bc:	98 e0       	ldi	r25, 0x08	; 8
    f4be:	93 83       	std	Z+3, r25	; 0x03
    f4c0:	82 83       	std	Z+2, r24	; 0x02
    f4c2:	80 91 69 09 	lds	r24, 0x0969
    f4c6:	99 27       	eor	r25, r25
    f4c8:	87 fd       	sbrc	r24, 7
    f4ca:	90 95       	com	r25
    f4cc:	95 83       	std	Z+5, r25	; 0x05
    f4ce:	84 83       	std	Z+4, r24	; 0x04
    f4d0:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
          lcdDrawString(LineBuffer,255,15,GREEN,BLACK);
    f4d4:	ed b7       	in	r30, 0x3d	; 61
    f4d6:	fe b7       	in	r31, 0x3e	; 62
    f4d8:	36 96       	adiw	r30, 0x06	; 6
    f4da:	0f b6       	in	r0, 0x3f	; 63
    f4dc:	f8 94       	cli
    f4de:	fe bf       	out	0x3e, r31	; 62
    f4e0:	0f be       	out	0x3f, r0	; 63
    f4e2:	ed bf       	out	0x3d, r30	; 61
    f4e4:	c8 01       	movw	r24, r16
    f4e6:	6f ef       	ldi	r22, 0xFF	; 255
    f4e8:	70 e0       	ldi	r23, 0x00	; 0
    f4ea:	4f e0       	ldi	r20, 0x0F	; 15
    f4ec:	50 e0       	ldi	r21, 0x00	; 0
    f4ee:	20 ee       	ldi	r18, 0xE0	; 224
    f4f0:	37 e0       	ldi	r19, 0x07	; 7
    f4f2:	00 e0       	ldi	r16, 0x00	; 0
    f4f4:	10 e0       	ldi	r17, 0x00	; 0
    f4f6:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
       }

       if (FrameCounter == 3)
    f4fa:	80 91 df 12 	lds	r24, 0x12DF
    f4fe:	83 30       	cpi	r24, 0x03	; 3
    f500:	09 f0       	breq	.+2      	; 0xf504 <__vector_17+0x5ee>
    f502:	69 c0       	rjmp	.+210    	; 0xf5d6 <__vector_17+0x6c0>
    f504:	42 e8       	ldi	r20, 0x82	; 130
    f506:	c4 2e       	mov	r12, r20
    f508:	40 e1       	ldi	r20, 0x10	; 16
    f50a:	d4 2e       	mov	r13, r20
    f50c:	3a e0       	ldi	r19, 0x0A	; 10
    f50e:	e3 2e       	mov	r14, r19
    f510:	f1 2c       	mov	r15, r1
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor2Values[ArrayIndex]!=127) & (Sensor2Values[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,140-Sensor2Values[ArrayIndex]*2,ArrayIndex+11,140-Sensor2Values[ArrayIndex+1]*2,YELLOW);
    f512:	26 e4       	ldi	r18, 0x46	; 70
    f514:	a2 2e       	mov	r10, r18
    f516:	b1 2c       	mov	r11, r1

       if (FrameCounter == 3)
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor2Values[ArrayIndex]!=127) & (Sensor2Values[ArrayIndex+1]!=127))
    f518:	d6 01       	movw	r26, r12
    f51a:	2d 91       	ld	r18, X+
    f51c:	6d 01       	movw	r12, r26
    f51e:	8c 91       	ld	r24, X
    f520:	8f 37       	cpi	r24, 0x7F	; 127
    f522:	d1 f0       	breq	.+52     	; 0xf558 <__vector_17+0x642>
    f524:	2f 37       	cpi	r18, 0x7F	; 127
    f526:	c1 f0       	breq	.+48     	; 0xf558 <__vector_17+0x642>
                lcdDrawLine (ArrayIndex+10,140-Sensor2Values[ArrayIndex]*2,ArrayIndex+11,140-Sensor2Values[ArrayIndex+1]*2,YELLOW);
    f528:	33 27       	eor	r19, r19
    f52a:	27 fd       	sbrc	r18, 7
    f52c:	30 95       	com	r19
    f52e:	b5 01       	movw	r22, r10
    f530:	62 1b       	sub	r22, r18
    f532:	73 0b       	sbc	r23, r19
    f534:	66 0f       	add	r22, r22
    f536:	77 1f       	adc	r23, r23
    }
}*/


/** ISR to handle the 500ms ticks for sampling and data logging */
ISR(TIMER1_COMPA_vect, ISR_BLOCK)
    f538:	a7 01       	movw	r20, r14
    f53a:	4f 5f       	subi	r20, 0xFF	; 255
    f53c:	5f 4f       	sbci	r21, 0xFF	; 255
       if (FrameCounter == 3)
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor2Values[ArrayIndex]!=127) & (Sensor2Values[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,140-Sensor2Values[ArrayIndex]*2,ArrayIndex+11,140-Sensor2Values[ArrayIndex+1]*2,YELLOW);
    f53e:	99 27       	eor	r25, r25
    f540:	87 fd       	sbrc	r24, 7
    f542:	90 95       	com	r25
    f544:	95 01       	movw	r18, r10
    f546:	28 1b       	sub	r18, r24
    f548:	39 0b       	sbc	r19, r25
    f54a:	22 0f       	add	r18, r18
    f54c:	33 1f       	adc	r19, r19
    f54e:	c7 01       	movw	r24, r14
    f550:	00 ee       	ldi	r16, 0xE0	; 224
    f552:	1f ef       	ldi	r17, 0xFF	; 255
    f554:	0e 94 81 9d 	call	0x13b02	; 0x13b02 <lcdDrawLine>
    f558:	08 94       	sec
    f55a:	e1 1c       	adc	r14, r1
    f55c:	f1 1c       	adc	r15, r1
          lcdDrawString(LineBuffer,255,15,GREEN,BLACK);
       }

       if (FrameCounter == 3)
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
    f55e:	b5 e3       	ldi	r27, 0x35	; 53
    f560:	eb 16       	cp	r14, r27
    f562:	b1 e0       	ldi	r27, 0x01	; 1
    f564:	fb 06       	cpc	r15, r27
    f566:	c1 f6       	brne	.-80     	; 0xf518 <__vector_17+0x602>
          {
            if ((Sensor2Values[ArrayIndex]!=127) & (Sensor2Values[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,140-Sensor2Values[ArrayIndex]*2,ArrayIndex+11,140-Sensor2Values[ArrayIndex+1]*2,YELLOW);
            }

          lcdSetFont((uint8_t*) Arial12x12);      //display actual measure values
    f568:	88 e9       	ldi	r24, 0x98	; 152
    f56a:	90 e0       	ldi	r25, 0x00	; 0
    f56c:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>

          sprintf (LineBuffer, "%d~C ", Sensor2Value);
    f570:	00 d0       	rcall	.+0      	; 0xf572 <__vector_17+0x65c>
    f572:	00 d0       	rcall	.+0      	; 0xf574 <__vector_17+0x65e>
    f574:	00 d0       	rcall	.+0      	; 0xf576 <__vector_17+0x660>
    f576:	ed b7       	in	r30, 0x3d	; 61
    f578:	fe b7       	in	r31, 0x3e	; 62
    f57a:	31 96       	adiw	r30, 0x01	; 1
    f57c:	8e 01       	movw	r16, r28
    f57e:	01 5f       	subi	r16, 0xF1	; 241
    f580:	1f 4f       	sbci	r17, 0xFF	; 255
    f582:	ad b7       	in	r26, 0x3d	; 61
    f584:	be b7       	in	r27, 0x3e	; 62
    f586:	12 96       	adiw	r26, 0x02	; 2
    f588:	1c 93       	st	X, r17
    f58a:	0e 93       	st	-X, r16
    f58c:	11 97       	sbiw	r26, 0x01	; 1
    f58e:	8a e1       	ldi	r24, 0x1A	; 26
    f590:	98 e0       	ldi	r25, 0x08	; 8
    f592:	93 83       	std	Z+3, r25	; 0x03
    f594:	82 83       	std	Z+2, r24	; 0x02
    f596:	80 91 62 09 	lds	r24, 0x0962
    f59a:	99 27       	eor	r25, r25
    f59c:	87 fd       	sbrc	r24, 7
    f59e:	90 95       	com	r25
    f5a0:	95 83       	std	Z+5, r25	; 0x05
    f5a2:	84 83       	std	Z+4, r24	; 0x04
    f5a4:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
          if (Sensor2Received) lcdDrawString(LineBuffer,255,15,YELLOW,BLACK);
    f5a8:	ed b7       	in	r30, 0x3d	; 61
    f5aa:	fe b7       	in	r31, 0x3e	; 62
    f5ac:	36 96       	adiw	r30, 0x06	; 6
    f5ae:	0f b6       	in	r0, 0x3f	; 63
    f5b0:	f8 94       	cli
    f5b2:	fe bf       	out	0x3e, r31	; 62
    f5b4:	0f be       	out	0x3f, r0	; 63
    f5b6:	ed bf       	out	0x3d, r30	; 61
    f5b8:	80 91 63 09 	lds	r24, 0x0963
    f5bc:	88 23       	and	r24, r24
    f5be:	59 f0       	breq	.+22     	; 0xf5d6 <__vector_17+0x6c0>
    f5c0:	c8 01       	movw	r24, r16
    f5c2:	6f ef       	ldi	r22, 0xFF	; 255
    f5c4:	70 e0       	ldi	r23, 0x00	; 0
    f5c6:	4f e0       	ldi	r20, 0x0F	; 15
    f5c8:	50 e0       	ldi	r21, 0x00	; 0
    f5ca:	20 ee       	ldi	r18, 0xE0	; 224
    f5cc:	3f ef       	ldi	r19, 0xFF	; 255
    f5ce:	00 e0       	ldi	r16, 0x00	; 0
    f5d0:	10 e0       	ldi	r17, 0x00	; 0
    f5d2:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
       }

       if (FrameCounter == 4)
    f5d6:	80 91 df 12 	lds	r24, 0x12DF
    f5da:	84 30       	cpi	r24, 0x04	; 4
    f5dc:	09 f0       	breq	.+2      	; 0xf5e0 <__vector_17+0x6ca>
    f5de:	69 c0       	rjmp	.+210    	; 0xf6b2 <__vector_17+0x79c>
    f5e0:	16 ee       	ldi	r17, 0xE6	; 230
    f5e2:	c1 2e       	mov	r12, r17
    f5e4:	12 e1       	ldi	r17, 0x12	; 18
    f5e6:	d1 2e       	mov	r13, r17
    f5e8:	ba e0       	ldi	r27, 0x0A	; 10
    f5ea:	eb 2e       	mov	r14, r27
    f5ec:	f1 2c       	mov	r15, r1
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor3Values[ArrayIndex]!=127) & (Sensor3Values[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,140-Sensor3Values[ArrayIndex]*2,ArrayIndex+11,140-Sensor3Values[ArrayIndex+1]*2,MAGENTA);
    f5ee:	a6 e4       	ldi	r26, 0x46	; 70
    f5f0:	aa 2e       	mov	r10, r26
    f5f2:	b1 2c       	mov	r11, r1

       if (FrameCounter == 4)
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor3Values[ArrayIndex]!=127) & (Sensor3Values[ArrayIndex+1]!=127))
    f5f4:	d6 01       	movw	r26, r12
    f5f6:	2d 91       	ld	r18, X+
    f5f8:	6d 01       	movw	r12, r26
    f5fa:	8c 91       	ld	r24, X
    f5fc:	8f 37       	cpi	r24, 0x7F	; 127
    f5fe:	d1 f0       	breq	.+52     	; 0xf634 <__vector_17+0x71e>
    f600:	2f 37       	cpi	r18, 0x7F	; 127
    f602:	c1 f0       	breq	.+48     	; 0xf634 <__vector_17+0x71e>
                lcdDrawLine (ArrayIndex+10,140-Sensor3Values[ArrayIndex]*2,ArrayIndex+11,140-Sensor3Values[ArrayIndex+1]*2,MAGENTA);
    f604:	33 27       	eor	r19, r19
    f606:	27 fd       	sbrc	r18, 7
    f608:	30 95       	com	r19
    f60a:	b5 01       	movw	r22, r10
    f60c:	62 1b       	sub	r22, r18
    f60e:	73 0b       	sbc	r23, r19
    f610:	66 0f       	add	r22, r22
    f612:	77 1f       	adc	r23, r23
    }
}*/


/** ISR to handle the 500ms ticks for sampling and data logging */
ISR(TIMER1_COMPA_vect, ISR_BLOCK)
    f614:	a7 01       	movw	r20, r14
    f616:	4f 5f       	subi	r20, 0xFF	; 255
    f618:	5f 4f       	sbci	r21, 0xFF	; 255
       if (FrameCounter == 4)
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor3Values[ArrayIndex]!=127) & (Sensor3Values[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,140-Sensor3Values[ArrayIndex]*2,ArrayIndex+11,140-Sensor3Values[ArrayIndex+1]*2,MAGENTA);
    f61a:	99 27       	eor	r25, r25
    f61c:	87 fd       	sbrc	r24, 7
    f61e:	90 95       	com	r25
    f620:	95 01       	movw	r18, r10
    f622:	28 1b       	sub	r18, r24
    f624:	39 0b       	sbc	r19, r25
    f626:	22 0f       	add	r18, r18
    f628:	33 1f       	adc	r19, r19
    f62a:	c7 01       	movw	r24, r14
    f62c:	0f e1       	ldi	r16, 0x1F	; 31
    f62e:	18 ef       	ldi	r17, 0xF8	; 248
    f630:	0e 94 81 9d 	call	0x13b02	; 0x13b02 <lcdDrawLine>
    f634:	08 94       	sec
    f636:	e1 1c       	adc	r14, r1
    f638:	f1 1c       	adc	r15, r1
          if (Sensor2Received) lcdDrawString(LineBuffer,255,15,YELLOW,BLACK);
       }

       if (FrameCounter == 4)
       {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
    f63a:	b5 e3       	ldi	r27, 0x35	; 53
    f63c:	eb 16       	cp	r14, r27
    f63e:	b1 e0       	ldi	r27, 0x01	; 1
    f640:	fb 06       	cpc	r15, r27
    f642:	c1 f6       	brne	.-80     	; 0xf5f4 <__vector_17+0x6de>
          {
            if ((Sensor3Values[ArrayIndex]!=127) & (Sensor3Values[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,140-Sensor3Values[ArrayIndex]*2,ArrayIndex+11,140-Sensor3Values[ArrayIndex+1]*2,MAGENTA);
            }
          lcdSetFont((uint8_t*) Arial12x12);      //display actual measure values
    f644:	88 e9       	ldi	r24, 0x98	; 152
    f646:	90 e0       	ldi	r25, 0x00	; 0
    f648:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>

          sprintf (LineBuffer, "%d~C ", Sensor3Value);
    f64c:	00 d0       	rcall	.+0      	; 0xf64e <__vector_17+0x738>
    f64e:	00 d0       	rcall	.+0      	; 0xf650 <__vector_17+0x73a>
    f650:	00 d0       	rcall	.+0      	; 0xf652 <__vector_17+0x73c>
    f652:	ed b7       	in	r30, 0x3d	; 61
    f654:	fe b7       	in	r31, 0x3e	; 62
    f656:	31 96       	adiw	r30, 0x01	; 1
    f658:	8e 01       	movw	r16, r28
    f65a:	01 5f       	subi	r16, 0xF1	; 241
    f65c:	1f 4f       	sbci	r17, 0xFF	; 255
    f65e:	ad b7       	in	r26, 0x3d	; 61
    f660:	be b7       	in	r27, 0x3e	; 62
    f662:	12 96       	adiw	r26, 0x02	; 2
    f664:	1c 93       	st	X, r17
    f666:	0e 93       	st	-X, r16
    f668:	11 97       	sbiw	r26, 0x01	; 1
    f66a:	8a e1       	ldi	r24, 0x1A	; 26
    f66c:	98 e0       	ldi	r25, 0x08	; 8
    f66e:	93 83       	std	Z+3, r25	; 0x03
    f670:	82 83       	std	Z+2, r24	; 0x02
    f672:	80 91 64 09 	lds	r24, 0x0964
    f676:	99 27       	eor	r25, r25
    f678:	87 fd       	sbrc	r24, 7
    f67a:	90 95       	com	r25
    f67c:	95 83       	std	Z+5, r25	; 0x05
    f67e:	84 83       	std	Z+4, r24	; 0x04
    f680:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
          if (Sensor3Received) lcdDrawString(LineBuffer,255,15,MAGENTA,BLACK);
    f684:	ed b7       	in	r30, 0x3d	; 61
    f686:	fe b7       	in	r31, 0x3e	; 62
    f688:	36 96       	adiw	r30, 0x06	; 6
    f68a:	0f b6       	in	r0, 0x3f	; 63
    f68c:	f8 94       	cli
    f68e:	fe bf       	out	0x3e, r31	; 62
    f690:	0f be       	out	0x3f, r0	; 63
    f692:	ed bf       	out	0x3d, r30	; 61
    f694:	80 91 65 09 	lds	r24, 0x0965
    f698:	88 23       	and	r24, r24
    f69a:	59 f0       	breq	.+22     	; 0xf6b2 <__vector_17+0x79c>
    f69c:	c8 01       	movw	r24, r16
    f69e:	6f ef       	ldi	r22, 0xFF	; 255
    f6a0:	70 e0       	ldi	r23, 0x00	; 0
    f6a2:	4f e0       	ldi	r20, 0x0F	; 15
    f6a4:	50 e0       	ldi	r21, 0x00	; 0
    f6a6:	2f e1       	ldi	r18, 0x1F	; 31
    f6a8:	38 ef       	ldi	r19, 0xF8	; 248
    f6aa:	00 e0       	ldi	r16, 0x00	; 0
    f6ac:	10 e0       	ldi	r17, 0x00	; 0
    f6ae:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
       }

        if (FrameCounter == 5)
    f6b2:	80 91 df 12 	lds	r24, 0x12DF
    f6b6:	85 30       	cpi	r24, 0x05	; 5
    f6b8:	09 f0       	breq	.+2      	; 0xf6bc <__vector_17+0x7a6>
    f6ba:	69 c0       	rjmp	.+210    	; 0xf78e <__vector_17+0x878>
    f6bc:	5d e3       	ldi	r21, 0x3D	; 61
    f6be:	c5 2e       	mov	r12, r21
    f6c0:	5f e0       	ldi	r21, 0x0F	; 15
    f6c2:	d5 2e       	mov	r13, r21
    f6c4:	4a e0       	ldi	r20, 0x0A	; 10
    f6c6:	e4 2e       	mov	r14, r20
    f6c8:	f1 2c       	mov	r15, r1
        {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor4Values[ArrayIndex]!=127) & (Sensor4Values[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,140-Sensor4Values[ArrayIndex]*2,ArrayIndex+11,140-Sensor4Values[ArrayIndex+1]*2,CYAN);
    f6ca:	36 e4       	ldi	r19, 0x46	; 70
    f6cc:	a3 2e       	mov	r10, r19
    f6ce:	b1 2c       	mov	r11, r1

        if (FrameCounter == 5)
        {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor4Values[ArrayIndex]!=127) & (Sensor4Values[ArrayIndex+1]!=127))
    f6d0:	d6 01       	movw	r26, r12
    f6d2:	2d 91       	ld	r18, X+
    f6d4:	6d 01       	movw	r12, r26
    f6d6:	8c 91       	ld	r24, X
    f6d8:	8f 37       	cpi	r24, 0x7F	; 127
    f6da:	d1 f0       	breq	.+52     	; 0xf710 <__vector_17+0x7fa>
    f6dc:	2f 37       	cpi	r18, 0x7F	; 127
    f6de:	c1 f0       	breq	.+48     	; 0xf710 <__vector_17+0x7fa>
                lcdDrawLine (ArrayIndex+10,140-Sensor4Values[ArrayIndex]*2,ArrayIndex+11,140-Sensor4Values[ArrayIndex+1]*2,CYAN);
    f6e0:	33 27       	eor	r19, r19
    f6e2:	27 fd       	sbrc	r18, 7
    f6e4:	30 95       	com	r19
    f6e6:	b5 01       	movw	r22, r10
    f6e8:	62 1b       	sub	r22, r18
    f6ea:	73 0b       	sbc	r23, r19
    f6ec:	66 0f       	add	r22, r22
    f6ee:	77 1f       	adc	r23, r23
    }
}*/


/** ISR to handle the 500ms ticks for sampling and data logging */
ISR(TIMER1_COMPA_vect, ISR_BLOCK)
    f6f0:	a7 01       	movw	r20, r14
    f6f2:	4f 5f       	subi	r20, 0xFF	; 255
    f6f4:	5f 4f       	sbci	r21, 0xFF	; 255
        if (FrameCounter == 5)
        {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
          {
            if ((Sensor4Values[ArrayIndex]!=127) & (Sensor4Values[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,140-Sensor4Values[ArrayIndex]*2,ArrayIndex+11,140-Sensor4Values[ArrayIndex+1]*2,CYAN);
    f6f6:	99 27       	eor	r25, r25
    f6f8:	87 fd       	sbrc	r24, 7
    f6fa:	90 95       	com	r25
    f6fc:	95 01       	movw	r18, r10
    f6fe:	28 1b       	sub	r18, r24
    f700:	39 0b       	sbc	r19, r25
    f702:	22 0f       	add	r18, r18
    f704:	33 1f       	adc	r19, r19
    f706:	c7 01       	movw	r24, r14
    f708:	0f ef       	ldi	r16, 0xFF	; 255
    f70a:	17 e0       	ldi	r17, 0x07	; 7
    f70c:	0e 94 81 9d 	call	0x13b02	; 0x13b02 <lcdDrawLine>
    f710:	08 94       	sec
    f712:	e1 1c       	adc	r14, r1
    f714:	f1 1c       	adc	r15, r1
          if (Sensor3Received) lcdDrawString(LineBuffer,255,15,MAGENTA,BLACK);
       }

        if (FrameCounter == 5)
        {
          for (ArrayIndex=0; ArrayIndex<299; ArrayIndex++)
    f716:	b5 e3       	ldi	r27, 0x35	; 53
    f718:	eb 16       	cp	r14, r27
    f71a:	b1 e0       	ldi	r27, 0x01	; 1
    f71c:	fb 06       	cpc	r15, r27
    f71e:	c1 f6       	brne	.-80     	; 0xf6d0 <__vector_17+0x7ba>
          {
            if ((Sensor4Values[ArrayIndex]!=127) & (Sensor4Values[ArrayIndex+1]!=127))
                lcdDrawLine (ArrayIndex+10,140-Sensor4Values[ArrayIndex]*2,ArrayIndex+11,140-Sensor4Values[ArrayIndex+1]*2,CYAN);
            }
          lcdSetFont((uint8_t*) Arial12x12);      //display actual measure values
    f720:	88 e9       	ldi	r24, 0x98	; 152
    f722:	90 e0       	ldi	r25, 0x00	; 0
    f724:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>

          sprintf (LineBuffer, "%d~C ", Sensor4Value);
    f728:	00 d0       	rcall	.+0      	; 0xf72a <__vector_17+0x814>
    f72a:	00 d0       	rcall	.+0      	; 0xf72c <__vector_17+0x816>
    f72c:	00 d0       	rcall	.+0      	; 0xf72e <__vector_17+0x818>
    f72e:	ed b7       	in	r30, 0x3d	; 61
    f730:	fe b7       	in	r31, 0x3e	; 62
    f732:	31 96       	adiw	r30, 0x01	; 1
    f734:	8e 01       	movw	r16, r28
    f736:	01 5f       	subi	r16, 0xF1	; 241
    f738:	1f 4f       	sbci	r17, 0xFF	; 255
    f73a:	ad b7       	in	r26, 0x3d	; 61
    f73c:	be b7       	in	r27, 0x3e	; 62
    f73e:	12 96       	adiw	r26, 0x02	; 2
    f740:	1c 93       	st	X, r17
    f742:	0e 93       	st	-X, r16
    f744:	11 97       	sbiw	r26, 0x01	; 1
    f746:	8a e1       	ldi	r24, 0x1A	; 26
    f748:	98 e0       	ldi	r25, 0x08	; 8
    f74a:	93 83       	std	Z+3, r25	; 0x03
    f74c:	82 83       	std	Z+2, r24	; 0x02
    f74e:	80 91 66 09 	lds	r24, 0x0966
    f752:	99 27       	eor	r25, r25
    f754:	87 fd       	sbrc	r24, 7
    f756:	90 95       	com	r25
    f758:	95 83       	std	Z+5, r25	; 0x05
    f75a:	84 83       	std	Z+4, r24	; 0x04
    f75c:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
          if (Sensor4Received) lcdDrawString(LineBuffer,255,15,CYAN,BLACK);
    f760:	ed b7       	in	r30, 0x3d	; 61
    f762:	fe b7       	in	r31, 0x3e	; 62
    f764:	36 96       	adiw	r30, 0x06	; 6
    f766:	0f b6       	in	r0, 0x3f	; 63
    f768:	f8 94       	cli
    f76a:	fe bf       	out	0x3e, r31	; 62
    f76c:	0f be       	out	0x3f, r0	; 63
    f76e:	ed bf       	out	0x3d, r30	; 61
    f770:	80 91 67 09 	lds	r24, 0x0967
    f774:	88 23       	and	r24, r24
    f776:	59 f0       	breq	.+22     	; 0xf78e <__vector_17+0x878>
    f778:	c8 01       	movw	r24, r16
    f77a:	6f ef       	ldi	r22, 0xFF	; 255
    f77c:	70 e0       	ldi	r23, 0x00	; 0
    f77e:	4f e0       	ldi	r20, 0x0F	; 15
    f780:	50 e0       	ldi	r21, 0x00	; 0
    f782:	2f ef       	ldi	r18, 0xFF	; 255
    f784:	37 e0       	ldi	r19, 0x07	; 7
    f786:	00 e0       	ldi	r16, 0x00	; 0
    f788:	10 e0       	ldi	r17, 0x00	; 0
    f78a:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
        }

       if (ActualTime % 288 == 0)          //store values for trend graphic in arrays
    f78e:	60 91 f2 0c 	lds	r22, 0x0CF2
    f792:	70 91 f3 0c 	lds	r23, 0x0CF3
    f796:	80 91 f4 0c 	lds	r24, 0x0CF4
    f79a:	90 91 f5 0c 	lds	r25, 0x0CF5
    f79e:	20 e2       	ldi	r18, 0x20	; 32
    f7a0:	31 e0       	ldi	r19, 0x01	; 1
    f7a2:	40 e0       	ldi	r20, 0x00	; 0
    f7a4:	50 e0       	ldi	r21, 0x00	; 0
    f7a6:	0e 94 c8 ac 	call	0x15990	; 0x15990 <__udivmodsi4>
    f7aa:	61 15       	cp	r22, r1
    f7ac:	71 05       	cpc	r23, r1
    f7ae:	81 05       	cpc	r24, r1
    f7b0:	91 05       	cpc	r25, r1
    f7b2:	51 f5       	brne	.+84     	; 0xf808 <__vector_17+0x8f2>
        {
            ArrayIndex = ActualTime / 288;
            Sensor1TempValues[ArrayIndex] = Temperature;
    f7b4:	f9 01       	movw	r30, r18
    f7b6:	ef 54       	subi	r30, 0x4F	; 79
    f7b8:	fe 4e       	sbci	r31, 0xEE	; 238
    f7ba:	80 91 68 09 	lds	r24, 0x0968
    f7be:	80 83       	st	Z, r24
            Sensor1HumditiyValues[ArrayIndex] = Humidity;
    f7c0:	f9 01       	movw	r30, r18
    f7c2:	e8 54       	subi	r30, 0x48	; 72
    f7c4:	f4 4f       	sbci	r31, 0xF4	; 244
    f7c6:	80 91 69 09 	lds	r24, 0x0969
    f7ca:	80 83       	st	Z, r24
            if (Sensor2Received) Sensor2Values[ArrayIndex] = Sensor2Value;
    f7cc:	80 91 63 09 	lds	r24, 0x0963
    f7d0:	88 23       	and	r24, r24
    f7d2:	31 f0       	breq	.+12     	; 0xf7e0 <__vector_17+0x8ca>
    f7d4:	f9 01       	movw	r30, r18
    f7d6:	ee 57       	subi	r30, 0x7E	; 126
    f7d8:	ff 4e       	sbci	r31, 0xEF	; 239
    f7da:	80 91 62 09 	lds	r24, 0x0962
    f7de:	80 83       	st	Z, r24
            if (Sensor3Received) Sensor3Values[ArrayIndex] = Sensor3Value;
    f7e0:	80 91 65 09 	lds	r24, 0x0965
    f7e4:	88 23       	and	r24, r24
    f7e6:	31 f0       	breq	.+12     	; 0xf7f4 <__vector_17+0x8de>
    f7e8:	f9 01       	movw	r30, r18
    f7ea:	ea 51       	subi	r30, 0x1A	; 26
    f7ec:	fd 4e       	sbci	r31, 0xED	; 237
    f7ee:	80 91 64 09 	lds	r24, 0x0964
    f7f2:	80 83       	st	Z, r24
            if (Sensor4Received) Sensor4Values[ArrayIndex] = Sensor4Value;
    f7f4:	80 91 67 09 	lds	r24, 0x0967
    f7f8:	88 23       	and	r24, r24
    f7fa:	31 f0       	breq	.+12     	; 0xf808 <__vector_17+0x8f2>
    f7fc:	23 5c       	subi	r18, 0xC3	; 195
    f7fe:	30 4f       	sbci	r19, 0xF0	; 240
    f800:	80 91 66 09 	lds	r24, 0x0966
    f804:	d9 01       	movw	r26, r18
    f806:	8c 93       	st	X, r24
        }

    #endif

    if (Sensor1Received)
    f808:	90 91 61 09 	lds	r25, 0x0961
    f80c:	80 91 68 09 	lds	r24, 0x0968
    f810:	99 23       	and	r25, r25
    f812:	69 f0       	breq	.+26     	; 0xf82e <__vector_17+0x918>
    {
        if (Temperature < Sensor1MinValue) Sensor1MinValue = Temperature;
    f814:	90 91 60 09 	lds	r25, 0x0960
    f818:	89 17       	cp	r24, r25
    f81a:	14 f4       	brge	.+4      	; 0xf820 <__vector_17+0x90a>
    f81c:	80 93 60 09 	sts	0x0960, r24
        if (Temperature > Sensor1MaxValue) Sensor1MaxValue = Temperature;
    f820:	90 91 ef 0c 	lds	r25, 0x0CEF
    f824:	98 17       	cp	r25, r24
    f826:	54 f4       	brge	.+20     	; 0xf83c <__vector_17+0x926>
    f828:	80 93 ef 0c 	sts	0x0CEF, r24
    f82c:	07 c0       	rjmp	.+14     	; 0xf83c <__vector_17+0x926>
    }
    else
    {
       Sensor1MinValue = Temperature;
    f82e:	80 93 60 09 	sts	0x0960, r24
       Sensor1MaxValue = Temperature;
    f832:	80 93 ef 0c 	sts	0x0CEF, r24
       Sensor1Received = true;
    f836:	81 e0       	ldi	r24, 0x01	; 1
    f838:	80 93 61 09 	sts	0x0961, r24
    }

    Sensor1PreviousValue = Temperature;
    f83c:	80 91 68 09 	lds	r24, 0x0968
    f840:	80 93 81 10 	sts	0x1081, r24
    HumidityPreviousValue = Humidity;
    f844:	80 91 69 09 	lds	r24, 0x0969
    f848:	80 93 e5 12 	sts	0x12E5, r24


    //if(Sensor2Received&Sensor3Received)         // transmit values to webserver only if sensor values received, optional
    {

        if(WebEnableCounter++ == WebLoggingInterval500MS_SRAM)
    f84c:	80 91 ae 11 	lds	r24, 0x11AE
    f850:	90 91 af 11 	lds	r25, 0x11AF
    f854:	20 91 b6 0b 	lds	r18, 0x0BB6
    f858:	30 91 b7 0b 	lds	r19, 0x0BB7
    f85c:	ac 01       	movw	r20, r24
    f85e:	4f 5f       	subi	r20, 0xFF	; 255
    f860:	5f 4f       	sbci	r21, 0xFF	; 255
    f862:	50 93 af 11 	sts	0x11AF, r21
    f866:	40 93 ae 11 	sts	0x11AE, r20
    f86a:	82 17       	cp	r24, r18
    f86c:	93 07       	cpc	r25, r19
    f86e:	79 f4       	brne	.+30     	; 0xf88e <__vector_17+0x978>
        {
           // POWER_ENABLE_Port_Write |= (1<<POWER_ENABLE);      // activate web module LDO
            writeAddress(0x00, 0x01, 0x01, 1);	 // Socket Command  Register -> OPEN
    f870:	80 e0       	ldi	r24, 0x00	; 0
    f872:	61 e0       	ldi	r22, 0x01	; 1
    f874:	41 e0       	ldi	r20, 0x01	; 1
    f876:	21 e0       	ldi	r18, 0x01	; 1
    f878:	0e 94 a5 9f 	call	0x13f4a	; 0x13f4a <writeAddress>
            writeAddress(0x00, 0x01, 0x04, 1);	 // Socket  Command  Register -> CONNECT
    f87c:	80 e0       	ldi	r24, 0x00	; 0
    f87e:	61 e0       	ldi	r22, 0x01	; 1
    f880:	44 e0       	ldi	r20, 0x04	; 4
    f882:	21 e0       	ldi	r18, 0x01	; 1
    f884:	0e 94 a5 9f 	call	0x13f4a	; 0x13f4a <writeAddress>
            /*temp = readAddress(0x00, 0x03, 1);   // Socket Status Register -> 0x13
            sprintf (LineBuffer, "Status: %X", temp);
            Serial_SendString(LineBuffer);
            Serial_SendString("\n");*/
            Webclient=true;
    f888:	81 e0       	ldi	r24, 0x01	; 1
    f88a:	80 93 6a 09 	sts	0x096A, r24
        }

        if(Webclient & (WebEnableCounter == 1))
    f88e:	21 e0       	ldi	r18, 0x01	; 1
    f890:	30 e0       	ldi	r19, 0x00	; 0
    f892:	80 91 ae 11 	lds	r24, 0x11AE
    f896:	90 91 af 11 	lds	r25, 0x11AF
    f89a:	81 30       	cpi	r24, 0x01	; 1
    f89c:	91 05       	cpc	r25, r1
    f89e:	11 f0       	breq	.+4      	; 0xf8a4 <__vector_17+0x98e>
    f8a0:	20 e0       	ldi	r18, 0x00	; 0
    f8a2:	30 e0       	ldi	r19, 0x00	; 0
    f8a4:	80 91 6a 09 	lds	r24, 0x096A
    f8a8:	90 e0       	ldi	r25, 0x00	; 0
    f8aa:	82 23       	and	r24, r18
    f8ac:	93 23       	and	r25, r19
    f8ae:	00 97       	sbiw	r24, 0x00	; 0
    f8b0:	71 f0       	breq	.+28     	; 0xf8ce <__vector_17+0x9b8>
        {
            writeAddress(0x00, 0x01, 0x08, 1);	 // Socket Command  Register -> DISCONNECT
    f8b2:	80 e0       	ldi	r24, 0x00	; 0
    f8b4:	61 e0       	ldi	r22, 0x01	; 1
    f8b6:	48 e0       	ldi	r20, 0x08	; 8
    f8b8:	21 e0       	ldi	r18, 0x01	; 1
    f8ba:	0e 94 a5 9f 	call	0x13f4a	; 0x13f4a <writeAddress>
            writeAddress(0x00, 0x01, 0x10, 1);	 // Socket Command  Register -> CLOSE
    f8be:	80 e0       	ldi	r24, 0x00	; 0
    f8c0:	61 e0       	ldi	r22, 0x01	; 1
    f8c2:	40 e1       	ldi	r20, 0x10	; 16
    f8c4:	21 e0       	ldi	r18, 0x01	; 1
    f8c6:	0e 94 a5 9f 	call	0x13f4a	; 0x13f4a <writeAddress>
           /* temp = readAddress(0x00, 0x03, 1);   // Socket Status Register -> 0x13
            sprintf (LineBuffer, "Status: %X", temp);
            Serial_SendString(LineBuffer);
            Serial_SendString("\n");*/
            Webclient=false;
    f8ca:	10 92 6a 09 	sts	0x096A, r1
        {
            Serial_Disable();                                 // disable uart after 15 seconds
            POWER_ENABLE_Port_Write &= ~(1<<POWER_ENABLE);     // disable web module LDO
        }*/

        if(WebEnableCounter == WebLoggingInterval500MS_SRAM+3)   // transmit values to webserver xively 0,5 seconds after activation of module
    f8ce:	80 91 b6 0b 	lds	r24, 0x0BB6
    f8d2:	90 91 b7 0b 	lds	r25, 0x0BB7
    f8d6:	03 96       	adiw	r24, 0x03	; 3
    f8d8:	20 91 ae 11 	lds	r18, 0x11AE
    f8dc:	30 91 af 11 	lds	r19, 0x11AF
    f8e0:	28 17       	cp	r18, r24
    f8e2:	39 07       	cpc	r19, r25
    f8e4:	29 f4       	brne	.+10     	; 0xf8f0 <__vector_17+0x9da>
        {


            SendToWeb();
    f8e6:	e7 d9       	rcall	.-3122   	; 0xecb6 <SendToWeb>
            WebEnableCounter=0;        // reset weblogging counter
    f8e8:	10 92 af 11 	sts	0x11AF, r1
    f8ec:	10 92 ae 11 	sts	0x11AE, r1
    //sendToServer(sizeof(LineBuffer),LineBuffer, 1);

	/* Check to see if the logging interval has expired */


	if (CurrentLoggingTicks++ < LoggingInterval500MS_SRAM)
    f8f0:	80 91 02 0d 	lds	r24, 0x0D02
    f8f4:	90 91 03 0d 	lds	r25, 0x0D03
    f8f8:	20 91 f0 0c 	lds	r18, 0x0CF0
    f8fc:	30 91 f1 0c 	lds	r19, 0x0CF1
    f900:	ac 01       	movw	r20, r24
    f902:	4f 5f       	subi	r20, 0xFF	; 255
    f904:	5f 4f       	sbci	r21, 0xFF	; 255
    f906:	50 93 03 0d 	sts	0x0D03, r21
    f90a:	40 93 02 0d 	sts	0x0D02, r20
    f90e:	82 17       	cp	r24, r18
    f910:	93 07       	cpc	r25, r19
    f912:	08 f4       	brcc	.+2      	; 0xf916 <__vector_17+0xa00>
    f914:	d5 c0       	rjmp	.+426    	; 0xfac0 <__vector_17+0xbaa>
	  return;

	/* Reset log tick counter to prepare for next logging interval */
	CurrentLoggingTicks = 0;
    f916:	10 92 03 0d 	sts	0x0D03, r1
    f91a:	10 92 02 0d 	sts	0x0D02, r1

	LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
    f91e:	80 e2       	ldi	r24, 0x20	; 32
    f920:	0e 94 ae 6c 	call	0xd95c	; 0xd95c <LEDs_SetAllLEDs>

	/* Only log when not connected to a USB host */
	if (!(LOCAL_Port_Read & (1<<LOCAL)))
    f924:	37 99       	sbic	0x06, 7	; 6
    f926:	c8 c0       	rjmp	.+400    	; 0xfab8 <__vector_17+0xba2>
	{
		uint16_t BytesWritten;
		TimeDate_t CurrentTimeDate;
        RTC_GetTimeDate(&CurrentTimeDate);
    f928:	ce 01       	movw	r24, r28
    f92a:	09 96       	adiw	r24, 0x09	; 9
    f92c:	0e 94 a0 85 	call	0x10b40	; 0x10b40 <RTC_GetTimeDate>

        if ((CurrentTimeDate.Day != oldday) & (LogfileCreateSuccess==true)) 	/* new day -> new logfile */
    f930:	20 91 12 14 	lds	r18, 0x1412
    f934:	30 e0       	ldi	r19, 0x00	; 0
    f936:	81 e0       	ldi	r24, 0x01	; 1
    f938:	90 e0       	ldi	r25, 0x00	; 0
    f93a:	5c 85       	ldd	r21, Y+12	; 0x0c
    f93c:	40 91 f8 0c 	lds	r20, 0x0CF8
    f940:	54 17       	cp	r21, r20
    f942:	11 f4       	brne	.+4      	; 0xf948 <__vector_17+0xa32>
    f944:	80 e0       	ldi	r24, 0x00	; 0
    f946:	90 e0       	ldi	r25, 0x00	; 0
    f948:	82 23       	and	r24, r18
    f94a:	93 23       	and	r25, r19
    f94c:	00 97       	sbiw	r24, 0x00	; 0
    f94e:	09 f4       	brne	.+2      	; 0xf952 <__vector_17+0xa3c>
    f950:	4f c0       	rjmp	.+158    	; 0xf9f0 <__vector_17+0xada>
		{
			LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
    f952:	80 e1       	ldi	r24, 0x10	; 16
    f954:	0e 94 ae 6c 	call	0xd95c	; 0xd95c <LEDs_SetAllLEDs>
			/* Close the log file */
			CloseLogFile();
    f958:	0e 94 74 72 	call	0xe4e8	; 0xe4e8 <CloseLogFile>
			DaysLeft_SRAM--;			                         // decrement day counter
    f95c:	60 91 7d 10 	lds	r22, 0x107D
    f960:	70 91 7e 10 	lds	r23, 0x107E
    f964:	61 50       	subi	r22, 0x01	; 1
    f966:	70 40       	sbci	r23, 0x00	; 0
    f968:	70 93 7e 10 	sts	0x107E, r23
    f96c:	60 93 7d 10 	sts	0x107D, r22
			eeprom_update_word(&DaysLeft_EEPROM, DaysLeft_SRAM); // update eeprom value
    f970:	88 e2       	ldi	r24, 0x28	; 40
    f972:	90 e0       	ldi	r25, 0x00	; 0
    f974:	0e 94 e1 af 	call	0x15fc2	; 0x15fc2 <__eeupd_word_usb1287>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    f978:	8f e7       	ldi	r24, 0x7F	; 127
    f97a:	9a e1       	ldi	r25, 0x1A	; 26
    f97c:	a6 e0       	ldi	r26, 0x06	; 6
    f97e:	81 50       	subi	r24, 0x01	; 1
    f980:	90 40       	sbci	r25, 0x00	; 0
    f982:	a0 40       	sbci	r26, 0x00	; 0
    f984:	e1 f7       	brne	.-8      	; 0xf97e <__vector_17+0xa68>
    f986:	00 c0       	rjmp	.+0      	; 0xf988 <__vector_17+0xa72>
    f988:	00 00       	nop

			_delay_ms(250);
			/* Mount and open new log file on the Dataflash FAT partition */
			OpenLogFile();
    f98a:	0e 94 81 72 	call	0xe502	; 0xe502 <OpenLogFile>
    f98e:	8f e7       	ldi	r24, 0x7F	; 127
    f990:	9a e1       	ldi	r25, 0x1A	; 26
    f992:	a6 e0       	ldi	r26, 0x06	; 6
    f994:	81 50       	subi	r24, 0x01	; 1
    f996:	90 40       	sbci	r25, 0x00	; 0
    f998:	a0 40       	sbci	r26, 0x00	; 0
    f99a:	e1 f7       	brne	.-8      	; 0xf994 <__vector_17+0xa7e>
    f99c:	00 c0       	rjmp	.+0      	; 0xf99e <__vector_17+0xa88>
    f99e:	00 00       	nop
    f9a0:	e1 eb       	ldi	r30, 0xB1	; 177
    f9a2:	f1 e1       	ldi	r31, 0x11	; 17

			#if (LCD==3)
            {
                uint16_t i;

                for (i=0; i<300; i++) Sensor1TempValues[i]=127; // clear arrays for trend values
    f9a4:	8f e7       	ldi	r24, 0x7F	; 127
    f9a6:	81 93       	st	Z+, r24
    f9a8:	92 e1       	ldi	r25, 0x12	; 18
    f9aa:	ed 3d       	cpi	r30, 0xDD	; 221
    f9ac:	f9 07       	cpc	r31, r25
    f9ae:	d9 f7       	brne	.-10     	; 0xf9a6 <__vector_17+0xa90>
    f9b0:	e8 eb       	ldi	r30, 0xB8	; 184
    f9b2:	fb e0       	ldi	r31, 0x0B	; 11
                for (i=0; i<300; i++) Sensor1HumditiyValues[i]=127; // clear arrays for trend values
    f9b4:	8f e7       	ldi	r24, 0x7F	; 127
    f9b6:	81 93       	st	Z+, r24
    f9b8:	ac e0       	ldi	r26, 0x0C	; 12
    f9ba:	e4 3e       	cpi	r30, 0xE4	; 228
    f9bc:	fa 07       	cpc	r31, r26
    f9be:	d9 f7       	brne	.-10     	; 0xf9b6 <__vector_17+0xaa0>
    f9c0:	e2 e8       	ldi	r30, 0x82	; 130
    f9c2:	f0 e1       	ldi	r31, 0x10	; 16
                for (i=0; i<300; i++) Sensor2Values[i]=127; // clear arrays for trend values
    f9c4:	8f e7       	ldi	r24, 0x7F	; 127
    f9c6:	81 93       	st	Z+, r24
    f9c8:	b1 e1       	ldi	r27, 0x11	; 17
    f9ca:	ee 3a       	cpi	r30, 0xAE	; 174
    f9cc:	fb 07       	cpc	r31, r27
    f9ce:	d9 f7       	brne	.-10     	; 0xf9c6 <__vector_17+0xab0>
    f9d0:	e6 ee       	ldi	r30, 0xE6	; 230
    f9d2:	f2 e1       	ldi	r31, 0x12	; 18
                for (i=0; i<300; i++) Sensor3Values[i]=127; // clear arrays for trend values
    f9d4:	8f e7       	ldi	r24, 0x7F	; 127
    f9d6:	81 93       	st	Z+, r24
    f9d8:	24 e1       	ldi	r18, 0x14	; 20
    f9da:	e2 31       	cpi	r30, 0x12	; 18
    f9dc:	f2 07       	cpc	r31, r18
    f9de:	d9 f7       	brne	.-10     	; 0xf9d6 <__vector_17+0xac0>
    f9e0:	ed e3       	ldi	r30, 0x3D	; 61
    f9e2:	ff e0       	ldi	r31, 0x0F	; 15
                for (i=0; i<300; i++) Sensor4Values[i]=127; // clear arrays for trend values
    f9e4:	8f e7       	ldi	r24, 0x7F	; 127
    f9e6:	81 93       	st	Z+, r24
    f9e8:	30 e1       	ldi	r19, 0x10	; 16
    f9ea:	e9 36       	cpi	r30, 0x69	; 105
    f9ec:	f3 07       	cpc	r31, r19
    f9ee:	d9 f7       	brne	.-10     	; 0xf9e6 <__vector_17+0xad0>
            }
            #endif
		}
		if ((LogfileCreateSuccess==true))
    f9f0:	80 91 12 14 	lds	r24, 0x1412
    f9f4:	88 23       	and	r24, r24
    f9f6:	09 f4       	brne	.+2      	; 0xf9fa <__vector_17+0xae4>
    f9f8:	5d c0       	rjmp	.+186    	; 0xfab4 <__vector_17+0xb9e>
		{
			BytesWritten = sprintf(LineBuffer, "%02d:%02d:%02d,%d,%d,%d,%d,%d\r\n", CurrentTimeDate.Hour,
    f9fa:	8d b7       	in	r24, 0x3d	; 61
    f9fc:	9e b7       	in	r25, 0x3e	; 62
    f9fe:	44 97       	sbiw	r24, 0x14	; 20
    fa00:	0f b6       	in	r0, 0x3f	; 63
    fa02:	f8 94       	cli
    fa04:	9e bf       	out	0x3e, r25	; 62
    fa06:	0f be       	out	0x3f, r0	; 63
    fa08:	8d bf       	out	0x3d, r24	; 61
    fa0a:	ed b7       	in	r30, 0x3d	; 61
    fa0c:	fe b7       	in	r31, 0x3e	; 62
    fa0e:	31 96       	adiw	r30, 0x01	; 1
    fa10:	8e 01       	movw	r16, r28
    fa12:	01 5f       	subi	r16, 0xF1	; 241
    fa14:	1f 4f       	sbci	r17, 0xFF	; 255
    fa16:	ad b7       	in	r26, 0x3d	; 61
    fa18:	be b7       	in	r27, 0x3e	; 62
    fa1a:	12 96       	adiw	r26, 0x02	; 2
    fa1c:	1c 93       	st	X, r17
    fa1e:	0e 93       	st	-X, r16
    fa20:	11 97       	sbiw	r26, 0x01	; 1
    fa22:	86 e2       	ldi	r24, 0x26	; 38
    fa24:	98 e0       	ldi	r25, 0x08	; 8
    fa26:	93 83       	std	Z+3, r25	; 0x03
    fa28:	82 83       	std	Z+2, r24	; 0x02
    fa2a:	89 85       	ldd	r24, Y+9	; 0x09
    fa2c:	84 83       	std	Z+4, r24	; 0x04
    fa2e:	15 82       	std	Z+5, r1	; 0x05
    fa30:	8a 85       	ldd	r24, Y+10	; 0x0a
    fa32:	86 83       	std	Z+6, r24	; 0x06
    fa34:	17 82       	std	Z+7, r1	; 0x07
    fa36:	8b 85       	ldd	r24, Y+11	; 0x0b
    fa38:	80 87       	std	Z+8, r24	; 0x08
    fa3a:	11 86       	std	Z+9, r1	; 0x09
    fa3c:	80 91 68 09 	lds	r24, 0x0968
    fa40:	99 27       	eor	r25, r25
    fa42:	87 fd       	sbrc	r24, 7
    fa44:	90 95       	com	r25
    fa46:	93 87       	std	Z+11, r25	; 0x0b
    fa48:	82 87       	std	Z+10, r24	; 0x0a
    fa4a:	80 91 69 09 	lds	r24, 0x0969
    fa4e:	99 27       	eor	r25, r25
    fa50:	87 fd       	sbrc	r24, 7
    fa52:	90 95       	com	r25
    fa54:	95 87       	std	Z+13, r25	; 0x0d
    fa56:	84 87       	std	Z+12, r24	; 0x0c
    fa58:	80 91 62 09 	lds	r24, 0x0962
    fa5c:	99 27       	eor	r25, r25
    fa5e:	87 fd       	sbrc	r24, 7
    fa60:	90 95       	com	r25
    fa62:	97 87       	std	Z+15, r25	; 0x0f
    fa64:	86 87       	std	Z+14, r24	; 0x0e
    fa66:	80 91 64 09 	lds	r24, 0x0964
    fa6a:	99 27       	eor	r25, r25
    fa6c:	87 fd       	sbrc	r24, 7
    fa6e:	90 95       	com	r25
    fa70:	91 8b       	std	Z+17, r25	; 0x11
    fa72:	80 8b       	std	Z+16, r24	; 0x10
    fa74:	80 91 66 09 	lds	r24, 0x0966
    fa78:	99 27       	eor	r25, r25
    fa7a:	87 fd       	sbrc	r24, 7
    fa7c:	90 95       	com	r25
    fa7e:	93 8b       	std	Z+19, r25	; 0x13
    fa80:	82 8b       	std	Z+18, r24	; 0x12
    fa82:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
    fa86:	ac 01       	movw	r20, r24
    fa88:	89 83       	std	Y+1, r24	; 0x01
    fa8a:	5a 83       	std	Y+2, r21	; 0x02
                          CurrentTimeDate.Minute, CurrentTimeDate.Second,
			Temperature, Humidity, Sensor2Value, Sensor3Value, Sensor4Value);

			f_write(&TempLogFile, LineBuffer, BytesWritten, &BytesWritten);
    fa8c:	ed b7       	in	r30, 0x3d	; 61
    fa8e:	fe b7       	in	r31, 0x3e	; 62
    fa90:	74 96       	adiw	r30, 0x14	; 20
    fa92:	0f b6       	in	r0, 0x3f	; 63
    fa94:	f8 94       	cli
    fa96:	fe bf       	out	0x3e, r31	; 62
    fa98:	0f be       	out	0x3f, r0	; 63
    fa9a:	ed bf       	out	0x3d, r30	; 61
    fa9c:	83 e8       	ldi	r24, 0x83	; 131
    fa9e:	99 e0       	ldi	r25, 0x09	; 9
    faa0:	b8 01       	movw	r22, r16
    faa2:	9e 01       	movw	r18, r28
    faa4:	2f 5f       	subi	r18, 0xFF	; 255
    faa6:	3f 4f       	sbci	r19, 0xFF	; 255
    faa8:	0e 94 52 94 	call	0x128a4	; 0x128a4 <f_write>
			f_sync(&TempLogFile);
    faac:	83 e8       	ldi	r24, 0x83	; 131
    faae:	99 e0       	ldi	r25, 0x09	; 9
    fab0:	0e 94 53 96 	call	0x12ca6	; 0x12ca6 <f_sync>
		}

       	LEDs_SetAllLEDs(LEDS_NO_LEDS);
    fab4:	80 e0       	ldi	r24, 0x00	; 0
    fab6:	02 c0       	rjmp	.+4      	; 0xfabc <__vector_17+0xba6>

          LEDs_SetAllLEDs(LEDS_NO_LEDS);
        }
        #endif
	}
	else LEDs_SetAllLEDs(LEDMask);
    fab8:	89 2d       	mov	r24, r9
    faba:	80 7f       	andi	r24, 0xF0	; 240
    fabc:	0e 94 ae 6c 	call	0xd95c	; 0xd95c <LEDs_SetAllLEDs>
}
    fac0:	ac 96       	adiw	r28, 0x2c	; 44
    fac2:	de bf       	out	0x3e, r29	; 62
    fac4:	cd bf       	out	0x3d, r28	; 61
    fac6:	cf 91       	pop	r28
    fac8:	df 91       	pop	r29
    faca:	ff 91       	pop	r31
    facc:	ef 91       	pop	r30
    face:	bf 91       	pop	r27
    fad0:	af 91       	pop	r26
    fad2:	9f 91       	pop	r25
    fad4:	8f 91       	pop	r24
    fad6:	7f 91       	pop	r23
    fad8:	6f 91       	pop	r22
    fada:	5f 91       	pop	r21
    fadc:	4f 91       	pop	r20
    fade:	3f 91       	pop	r19
    fae0:	2f 91       	pop	r18
    fae2:	1f 91       	pop	r17
    fae4:	0f 91       	pop	r16
    fae6:	ff 90       	pop	r15
    fae8:	ef 90       	pop	r14
    faea:	df 90       	pop	r13
    faec:	cf 90       	pop	r12
    faee:	bf 90       	pop	r11
    faf0:	af 90       	pop	r10
    faf2:	9f 90       	pop	r9
    faf4:	0f 90       	pop	r0
    faf6:	0b be       	out	0x3b, r0	; 59
    faf8:	0f 90       	pop	r0
    fafa:	0f be       	out	0x3f, r0	; 63
    fafc:	0f 90       	pop	r0
    fafe:	1f 90       	pop	r1
    fb00:	18 95       	reti

0000fb02 <GetCorrectionValues>:
	if (Sensor2Name_SRAM[0] == 0xFF) sprintf(Sensor2Name_SRAM, DEFAULT_SENSOR2_NAME);

	eeprom_read_block(&Sensor3Name_SRAM,&Sensor3Name_EEPROM,8);
	if (Sensor3Name_SRAM[0] == 0xFF) sprintf(Sensor3Name_SRAM, DEFAULT_SENSOR3_NAME);*/
    /* Fetch logging interval from EEPROM */
	LoggingInterval500MS_SRAM = eeprom_read_word(&LoggingInterval500MS_EEPROM);
    fb02:	80 e0       	ldi	r24, 0x00	; 0
    fb04:	90 e0       	ldi	r25, 0x00	; 0
    fb06:	0e 94 ca af 	call	0x15f94	; 0x15f94 <__eerd_word_usb1287>
    fb0a:	90 93 f1 0c 	sts	0x0CF1, r25
    fb0e:	80 93 f0 0c 	sts	0x0CF0, r24

	/* Check if the logging interval is invalid (0xFF) indicating that the EEPROM is blank */
	if (LoggingInterval500MS_SRAM == 0xFF) LoggingInterval500MS_SRAM = DEFAULT_LOG_INTERVAL;
    fb12:	8f 3f       	cpi	r24, 0xFF	; 255
    fb14:	91 05       	cpc	r25, r1
    fb16:	31 f4       	brne	.+12     	; 0xfb24 <GetCorrectionValues+0x22>
    fb18:	84 e1       	ldi	r24, 0x14	; 20
    fb1a:	90 e0       	ldi	r25, 0x00	; 0
    fb1c:	90 93 f1 0c 	sts	0x0CF1, r25
    fb20:	80 93 f0 0c 	sts	0x0CF0, r24

	/* Fetch web logging interval from EEPROM */
	WebLoggingInterval500MS_SRAM = eeprom_read_word(&WebLoggingInterval500MS_EEPROM);
    fb24:	82 e0       	ldi	r24, 0x02	; 2
    fb26:	90 e0       	ldi	r25, 0x00	; 0
    fb28:	0e 94 ca af 	call	0x15f94	; 0x15f94 <__eerd_word_usb1287>
    fb2c:	90 93 b7 0b 	sts	0x0BB7, r25
    fb30:	80 93 b6 0b 	sts	0x0BB6, r24

	/* Check if the web logging interval is invalid (0xFF) indicating that the EEPROM is blank */
	if (WebLoggingInterval500MS_SRAM == 0xFF) WebLoggingInterval500MS_SRAM = WEB_LOGGING_INTERVAL;
    fb34:	8f 3f       	cpi	r24, 0xFF	; 255
    fb36:	91 05       	cpc	r25, r1
    fb38:	31 f4       	brne	.+12     	; 0xfb46 <GetCorrectionValues+0x44>
    fb3a:	88 e7       	ldi	r24, 0x78	; 120
    fb3c:	90 e0       	ldi	r25, 0x00	; 0
    fb3e:	90 93 b7 0b 	sts	0x0BB7, r25
    fb42:	80 93 b6 0b 	sts	0x0BB6, r24

	//LoggingInterval500MS_SRAM = DEFAULT_LOG_INTERVAL;

    sprintf(Sensor1Name_SRAM, DEFAULT_SENSOR1_NAME);
    fb46:	89 ef       	ldi	r24, 0xF9	; 249
    fb48:	9c e0       	ldi	r25, 0x0C	; 12
    fb4a:	66 e4       	ldi	r22, 0x46	; 70
    fb4c:	78 e0       	ldi	r23, 0x08	; 8
    fb4e:	0e 94 4a ad 	call	0x15a94	; 0x15a94 <strcpy>
    sprintf(Sensor2Name_SRAM, DEFAULT_SENSOR2_NAME);
    fb52:	83 e3       	ldi	r24, 0x33	; 51
    fb54:	9f e0       	ldi	r25, 0x0F	; 15
    fb56:	6e e4       	ldi	r22, 0x4E	; 78
    fb58:	78 e0       	ldi	r23, 0x08	; 8
    fb5a:	0e 94 4a ad 	call	0x15a94	; 0x15a94 <strcpy>
    sprintf(Sensor3Name_SRAM, DEFAULT_SENSOR3_NAME);
    fb5e:	8d e6       	ldi	r24, 0x6D	; 109
    fb60:	90 e1       	ldi	r25, 0x10	; 16
    fb62:	66 e5       	ldi	r22, 0x56	; 86
    fb64:	78 e0       	ldi	r23, 0x08	; 8
    fb66:	0e 94 4a ad 	call	0x15a94	; 0x15a94 <strcpy>
    sprintf(Sensor4Name_SRAM, DEFAULT_SENSOR4_NAME);
    fb6a:	86 ee       	ldi	r24, 0xE6	; 230
    fb6c:	9c e0       	ldi	r25, 0x0C	; 12
    fb6e:	6e e5       	ldi	r22, 0x5E	; 94
    fb70:	78 e0       	ldi	r23, 0x08	; 8
    fb72:	0e 94 4a ad 	call	0x15a94	; 0x15a94 <strcpy>


	/* Fetch correction values from EEPROM */
	Sensor1Correction_SRAM = eeprom_read_byte(&Sensor1Correction_EEPROM);
    fb76:	84 e2       	ldi	r24, 0x24	; 36
    fb78:	90 e0       	ldi	r25, 0x00	; 0
    fb7a:	0e 94 c2 af 	call	0x15f84	; 0x15f84 <__eerd_byte_usb1287>
    fb7e:	80 93 e1 12 	sts	0x12E1, r24
	Sensor2Correction_SRAM = eeprom_read_byte(&Sensor2Correction_EEPROM);
    fb82:	85 e2       	ldi	r24, 0x25	; 37
    fb84:	90 e0       	ldi	r25, 0x00	; 0
    fb86:	0e 94 c2 af 	call	0x15f84	; 0x15f84 <__eerd_byte_usb1287>
    fb8a:	80 93 76 10 	sts	0x1076, r24
	Sensor3Correction_SRAM = eeprom_read_byte(&Sensor3Correction_EEPROM);
    fb8e:	86 e2       	ldi	r24, 0x26	; 38
    fb90:	90 e0       	ldi	r25, 0x00	; 0
    fb92:	0e 94 c2 af 	call	0x15f84	; 0x15f84 <__eerd_byte_usb1287>
    fb96:	80 93 3c 0f 	sts	0x0F3C, r24
	Sensor4Correction_SRAM = eeprom_read_byte(&Sensor4Correction_EEPROM);
    fb9a:	87 e2       	ldi	r24, 0x27	; 39
    fb9c:	90 e0       	ldi	r25, 0x00	; 0
    fb9e:	0e 94 c2 af 	call	0x15f84	; 0x15f84 <__eerd_byte_usb1287>
    fba2:	80 93 7a 10 	sts	0x107A, r24
	if (Sensor2Correction_SRAM == 0xFF) Sensor2Correction_SRAM = 0;
	if (Sensor3Correction_SRAM == 0xFF) Sensor3Correction_SRAM = 0;
	if (Sensor4Correction_SRAM == 0xFF) Sensor4Correction_SRAM = 0;

	/* Fetch days left from EEPROM */
	DaysLeft_SRAM = eeprom_read_word(&DaysLeft_EEPROM);
    fba6:	88 e2       	ldi	r24, 0x28	; 40
    fba8:	90 e0       	ldi	r25, 0x00	; 0
    fbaa:	0e 94 ca af 	call	0x15f94	; 0x15f94 <__eerd_word_usb1287>
    fbae:	90 93 7e 10 	sts	0x107E, r25
    fbb2:	80 93 7d 10 	sts	0x107D, r24
	if (DaysLeft_SRAM == 0xFFFF) DaysLeft_SRAM = 50;
    fbb6:	2f ef       	ldi	r18, 0xFF	; 255
    fbb8:	8f 3f       	cpi	r24, 0xFF	; 255
    fbba:	92 07       	cpc	r25, r18
    fbbc:	31 f4       	brne	.+12     	; 0xfbca <GetCorrectionValues+0xc8>
    fbbe:	82 e3       	ldi	r24, 0x32	; 50
    fbc0:	90 e0       	ldi	r25, 0x00	; 0
    fbc2:	90 93 7e 10 	sts	0x107E, r25
    fbc6:	80 93 7d 10 	sts	0x107D, r24
    fbca:	08 95       	ret

0000fbcc <SetupHardware>:
	f_close(&TempLogFile);
}

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
    fbcc:	ef 92       	push	r14
    fbce:	ff 92       	push	r15
    fbd0:	0f 93       	push	r16
    fbd2:	1f 93       	push	r17
    fbd4:	df 93       	push	r29
    fbd6:	cf 93       	push	r28
    fbd8:	cd b7       	in	r28, 0x3d	; 61
    fbda:	de b7       	in	r29, 0x3e	; 62
    fbdc:	6e 97       	sbiw	r28, 0x1e	; 30
    fbde:	0f b6       	in	r0, 0x3f	; 63
    fbe0:	f8 94       	cli
    fbe2:	de bf       	out	0x3e, r29	; 62
    fbe4:	0f be       	out	0x3f, r0	; 63
    fbe6:	cd bf       	out	0x3d, r28	; 61
    char LineBuffer[30];


    #if (ARCH == ARCH_AVR8)
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
    fbe8:	84 b7       	in	r24, 0x34	; 52
    fbea:	87 7f       	andi	r24, 0xF7	; 247
    fbec:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
    fbee:	18 e1       	ldi	r17, 0x18	; 24
    fbf0:	0f b6       	in	r0, 0x3f	; 63
    fbf2:	f8 94       	cli
    fbf4:	10 93 60 00 	sts	0x0060, r17
    fbf8:	10 92 60 00 	sts	0x0060, r1
    fbfc:	0f be       	out	0x3f, r0	; 63
The type of x is clock_div_t.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
    fbfe:	90 e0       	ldi	r25, 0x00	; 0
    fc00:	80 e8       	ldi	r24, 0x80	; 128
    fc02:	0f b6       	in	r0, 0x3f	; 63
    fc04:	f8 94       	cli
    fc06:	80 93 61 00 	sts	0x0061, r24
    fc0a:	90 93 61 00 	sts	0x0061, r25
    fc0e:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
    fc10:	8a b1       	in	r24, 0x0a	; 10
    fc12:	80 6f       	ori	r24, 0xF0	; 240
    fc14:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
    fc16:	8b b1       	in	r24, 0x0b	; 11
    fc18:	8f 70       	andi	r24, 0x0F	; 15
    fc1a:	8b b9       	out	0x0b, r24	; 11
			/** Initializes the dataflash driver so that commands and data may be sent to an attached dataflash IC.
			 *  The appropriate SPI interface will be automatically configured.
			 */
			static inline void Dataflash_Init(void)
			{
				DATAFLASH_CHIPCS_DDR  |= DATAFLASH_CHIPCS_MASK;
    fc1c:	8d b1       	in	r24, 0x0d	; 13
    fc1e:	83 60       	ori	r24, 0x03	; 3
    fc20:	8d b9       	out	0x0d, r24	; 13
				DATAFLASH_CHIPCS_PORT |= DATAFLASH_CHIPCS_MASK;
    fc22:	8e b1       	in	r24, 0x0e	; 14
    fc24:	83 60       	ori	r24, 0x03	; 3
    fc26:	8e b9       	out	0x0e, r24	; 14
			 */
			static inline void SPI_Init(const uint8_t SPIOptions);
			static inline void SPI_Init(const uint8_t SPIOptions)
			{
				/* Prevent high rise times on PB.0 (/SS) from forcing a change to SPI slave mode */
				DDRB  |= (1 << 0);
    fc28:	20 9a       	sbi	0x04, 0	; 4
				PORTB |= (1 << 0);
    fc2a:	28 9a       	sbi	0x05, 0	; 5

				DDRB  |=  ((1 << 1) | (1 << 2));
    fc2c:	84 b1       	in	r24, 0x04	; 4
    fc2e:	86 60       	ori	r24, 0x06	; 6
    fc30:	84 b9       	out	0x04, r24	; 4
				DDRB  &= ~(1 << 3);
    fc32:	23 98       	cbi	0x04, 3	; 4
				PORTB |=  (1 << 3);
    fc34:	2b 9a       	sbi	0x05, 3	; 5

				if (SPIOptions & SPI_USE_DOUBLESPEED)
				  SPSR |= (1 << SPI2X);
    fc36:	8d b5       	in	r24, 0x2d	; 45
    fc38:	81 60       	ori	r24, 0x01	; 1
    fc3a:	8d bd       	out	0x2d, r24	; 45
				else
				  SPSR &= ~(1 << SPI2X);

				/* Switch /SS to input mode after configuration to allow for forced mode changes */
				DDRB &= ~(1 << 0);
    fc3c:	20 98       	cbi	0x04, 0	; 4

				SPCR  = ((1 << SPE) | SPIOptions);
    fc3e:	8c e5       	ldi	r24, 0x5C	; 92
    fc40:	8c bd       	out	0x2c, r24	; 44
    #endif

	/* Hardware Initialization */
	LEDs_Init();
	Dataflash_Init();
	USB_Init();
    fc42:	0e 94 2b a5 	call	0x14a56	; 0x14a56 <USB_Init>
			static inline void TWI_Init(const uint8_t Prescale,
			                            const uint8_t BitLength) ATTR_ALWAYS_INLINE;
			static inline void TWI_Init(const uint8_t Prescale,
			                            const uint8_t BitLength)
			{
				TWCR |= (1 << TWEN);
    fc46:	80 91 bc 00 	lds	r24, 0x00BC
    fc4a:	84 60       	ori	r24, 0x04	; 4
    fc4c:	80 93 bc 00 	sts	0x00BC, r24
				TWSR  = Prescale;
    fc50:	81 e0       	ldi	r24, 0x01	; 1
    fc52:	80 93 b9 00 	sts	0x00B9, r24
				TWBR  = BitLength;
    fc56:	8c e0       	ldi	r24, 0x0C	; 12
    fc58:	80 93 b8 00 	sts	0x00B8, r24
	TWI_Init(TWI_BIT_PRESCALE_4, TWI_BITLENGTH_FROM_FREQ(4, 50000));
	RTC_Init();
    fc5c:	6f d7       	rcall	.+3806   	; 0x10b3c <RTC_Init>
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed);
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
    fc5e:	83 e3       	ldi	r24, 0x33	; 51
    fc60:	90 e0       	ldi	r25, 0x00	; 0
    fc62:	90 93 cd 00 	sts	0x00CD, r25
    fc66:	80 93 cc 00 	sts	0x00CC, r24

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
    fc6a:	86 e0       	ldi	r24, 0x06	; 6
    fc6c:	80 93 ca 00 	sts	0x00CA, r24
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
    fc70:	10 92 c8 00 	sts	0x00C8, r1
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
    fc74:	10 93 c9 00 	sts	0x00C9, r17

				DDRD  |= (1 << 3);
    fc78:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
    fc7a:	5a 9a       	sbi	0x0b, 2	; 11

	Serial_Init(9600, 0);   // initialize uart for debugging

    Init_W5500();
    fc7c:	0e 94 12 a1 	call	0x14224	; 0x14224 <Init_W5500>

    RFM12_Init();			// init RFM12 radio modul
    fc80:	0e 94 d8 99 	call	0x133b0	; 0x133b0 <RFM12_Init>

    #if (LCD==3)
    {
        FRESULT Result;

        ili9341_init();
    fc84:	0e 94 77 9c 	call	0x138ee	; 0x138ee <ili9341_init>
        lcdFillRGB(BLACK);
    fc88:	80 e0       	ldi	r24, 0x00	; 0
    fc8a:	90 e0       	ldi	r25, 0x00	; 0
    fc8c:	0e 94 ea 9c 	call	0x139d4	; 0x139d4 <lcdFillRGB>

        f_mount(0, &DiskFATState);
    fc90:	80 e0       	ldi	r24, 0x00	; 0
    fc92:	65 e0       	ldi	r22, 0x05	; 5
    fc94:	7d e0       	ldi	r23, 0x0D	; 13
    fc96:	0e 94 33 93 	call	0x12666	; 0x12666 <f_mount>
        lcdSetFont((uint8_t*) Arial28x28);
        lcdDrawString("Hallo Kai...",5,110,GREEN,BLACK);
        lcdSetFont((uint8_t*) Arial24x23);
        lcdDrawString("Hallo Kai...",5,150,GOLD,BLACK);*/

        lcdSetFont((uint8_t*) Neu42x35);
    fc9a:	84 ec       	ldi	r24, 0xC4	; 196
    fc9c:	9c e4       	ldi	r25, 0x4C	; 76
    fc9e:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
        lcdDrawString("Datalogger",40,80,MAGENTA,BLACK);
    fca2:	86 e6       	ldi	r24, 0x66	; 102
    fca4:	98 e0       	ldi	r25, 0x08	; 8
    fca6:	68 e2       	ldi	r22, 0x28	; 40
    fca8:	70 e0       	ldi	r23, 0x00	; 0
    fcaa:	40 e5       	ldi	r20, 0x50	; 80
    fcac:	50 e0       	ldi	r21, 0x00	; 0
    fcae:	2f e1       	ldi	r18, 0x1F	; 31
    fcb0:	38 ef       	ldi	r19, 0xF8	; 248
    fcb2:	00 e0       	ldi	r16, 0x00	; 0
    fcb4:	10 e0       	ldi	r17, 0x00	; 0
    fcb6:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
        lcdDrawString(" WZ1056",40,120,MAGENTA,BLACK);
    fcba:	81 e7       	ldi	r24, 0x71	; 113
    fcbc:	98 e0       	ldi	r25, 0x08	; 8
    fcbe:	68 e2       	ldi	r22, 0x28	; 40
    fcc0:	70 e0       	ldi	r23, 0x00	; 0
    fcc2:	48 e7       	ldi	r20, 0x78	; 120
    fcc4:	50 e0       	ldi	r21, 0x00	; 0
    fcc6:	2f e1       	ldi	r18, 0x1F	; 31
    fcc8:	38 ef       	ldi	r19, 0xF8	; 248
    fcca:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    fcce:	8f ef       	ldi	r24, 0xFF	; 255
    fcd0:	93 ed       	ldi	r25, 0xD3	; 211
    fcd2:	a0 e3       	ldi	r26, 0x30	; 48
    fcd4:	81 50       	subi	r24, 0x01	; 1
    fcd6:	90 40       	sbci	r25, 0x00	; 0
    fcd8:	a0 40       	sbci	r26, 0x00	; 0
    fcda:	e1 f7       	brne	.-8      	; 0xfcd4 <SetupHardware+0x108>
    fcdc:	00 c0       	rjmp	.+0      	; 0xfcde <SetupHardware+0x112>
    fcde:	00 00       	nop
        lcdSetFont((uint8_t*) Arial24x23);
        lcdDrawString("powered by",85,50,RED,WHITE);

        lcdDrawBMP(85,90,150,50,logo);
        _delay_ms(2000);*/
        lcdFillRGB(BLACK);
    fce0:	80 e0       	ldi	r24, 0x00	; 0
    fce2:	90 e0       	ldi	r25, 0x00	; 0
    fce4:	0e 94 ea 9c 	call	0x139d4	; 0x139d4 <lcdFillRGB>
    {
        lcd_init();
    }
    #endif

    HYT321_GetData(&Humidity, &Temperature);
    fce8:	89 e6       	ldi	r24, 0x69	; 105
    fcea:	99 e0       	ldi	r25, 0x09	; 9
    fcec:	68 e6       	ldi	r22, 0x68	; 104
    fcee:	79 e0       	ldi	r23, 0x09	; 9
    fcf0:	0e 94 1f 9a 	call	0x1343e	; 0x1343e <HYT321_GetData>

    // send start value to webserver
    SendToWeb();
    fcf4:	0e 94 5b 76 	call	0xecb6	; 0xecb6 <SendToWeb>

	MAX_Port_DDR &= MAX_DataInput;      //connection of max/min switch
    fcf8:	25 98       	cbi	0x04, 5	; 4
	MAX_Port_Write |= (1<<MAXSWITCH);
    fcfa:	2d 9a       	sbi	0x05, 5	; 5
    r1 = SPI_TransferByte(0x80);
    r1 = SPI_TransferByte(0x9A);
    _delay_ms(10000);
    WIZNET_FL2_Port_Write |= (1<<WIZNET_FL2);      //disable Wiznet module, cs -> 1
    */
	DDRE |= 0x80;                                   //disable UVCON - Q1 at AT90USBKey Board
    fcfc:	6f 9a       	sbi	0x0d, 7	; 13
	PORTE &= 0x7F;
    fcfe:	77 98       	cbi	0x0e, 7	; 14

   	/* Check if the Dataflash is working, abort if not */
	if (!(DataflashManager_CheckDataflashOperation()))
    fd00:	f2 d6       	rcall	.+3556   	; 0x10ae6 <DataflashManager_CheckDataflashOperation>
    fd02:	88 23       	and	r24, r24
    fd04:	21 f4       	brne	.+8      	; 0xfd0e <SetupHardware+0x142>
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    fd06:	80 e9       	ldi	r24, 0x90	; 144
    fd08:	0e 94 ae 6c 	call	0xd95c	; 0xd95c <LEDs_SetAllLEDs>
    fd0c:	ff cf       	rjmp	.-2      	; 0xfd0c <SetupHardware+0x140>
		for(;;);
	}

	GetCorrectionValues();			//get correction values from eeprom
    fd0e:	f9 de       	rcall	.-526    	; 0xfb02 <GetCorrectionValues>

    /* Clear Dataflash sector protections, if enabled */
	DataflashManager_ResetDataflashProtections();
    fd10:	9c d6       	rcall	.+3384   	; 0x10a4a <DataflashManager_ResetDataflashProtections>


	/* Only if not connected to pc usb interface */
	if (!(LOCAL_Port_Read & (1<<LOCAL)))
    fd12:	37 99       	sbic	0x06, 7	; 6
    fd14:	23 c1       	rjmp	.+582    	; 0xff5c <SetupHardware+0x390>
            lcd_print_str(Sensor1Name_SRAM);
        }
        #endif
        #if (LCD==3)
        {
            lcdSetFont((uint8_t*) Arial28x28);
    fd16:	80 e6       	ldi	r24, 0x60	; 96
    fd18:	95 e2       	ldi	r25, 0x25	; 37
    fd1a:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
            sprintf (LineBuffer, "Days: %d", DaysLeft_SRAM);
    fd1e:	00 d0       	rcall	.+0      	; 0xfd20 <SetupHardware+0x154>
    fd20:	00 d0       	rcall	.+0      	; 0xfd22 <SetupHardware+0x156>
    fd22:	00 d0       	rcall	.+0      	; 0xfd24 <SetupHardware+0x158>
    fd24:	ed b7       	in	r30, 0x3d	; 61
    fd26:	fe b7       	in	r31, 0x3e	; 62
    fd28:	31 96       	adiw	r30, 0x01	; 1
    fd2a:	7e 01       	movw	r14, r28
    fd2c:	08 94       	sec
    fd2e:	e1 1c       	adc	r14, r1
    fd30:	f1 1c       	adc	r15, r1
    fd32:	ad b7       	in	r26, 0x3d	; 61
    fd34:	be b7       	in	r27, 0x3e	; 62
    fd36:	12 96       	adiw	r26, 0x02	; 2
    fd38:	fc 92       	st	X, r15
    fd3a:	ee 92       	st	-X, r14
    fd3c:	11 97       	sbiw	r26, 0x01	; 1
    fd3e:	89 e7       	ldi	r24, 0x79	; 121
    fd40:	98 e0       	ldi	r25, 0x08	; 8
    fd42:	93 83       	std	Z+3, r25	; 0x03
    fd44:	82 83       	std	Z+2, r24	; 0x02
    fd46:	80 91 7d 10 	lds	r24, 0x107D
    fd4a:	90 91 7e 10 	lds	r25, 0x107E
    fd4e:	95 83       	std	Z+5, r25	; 0x05
    fd50:	84 83       	std	Z+4, r24	; 0x04
    fd52:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
            lcdDrawString(LineBuffer,5,50,MAGENTA,BLACK);
    fd56:	8d b7       	in	r24, 0x3d	; 61
    fd58:	9e b7       	in	r25, 0x3e	; 62
    fd5a:	06 96       	adiw	r24, 0x06	; 6
    fd5c:	0f b6       	in	r0, 0x3f	; 63
    fd5e:	f8 94       	cli
    fd60:	9e bf       	out	0x3e, r25	; 62
    fd62:	0f be       	out	0x3f, r0	; 63
    fd64:	8d bf       	out	0x3d, r24	; 61
    fd66:	c7 01       	movw	r24, r14
    fd68:	65 e0       	ldi	r22, 0x05	; 5
    fd6a:	70 e0       	ldi	r23, 0x00	; 0
    fd6c:	42 e3       	ldi	r20, 0x32	; 50
    fd6e:	50 e0       	ldi	r21, 0x00	; 0
    fd70:	2f e1       	ldi	r18, 0x1F	; 31
    fd72:	38 ef       	ldi	r19, 0xF8	; 248
    fd74:	00 e0       	ldi	r16, 0x00	; 0
    fd76:	10 e0       	ldi	r17, 0x00	; 0
    fd78:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>

            sprintf (LineBuffer, "Interval: %ds", LoggingInterval500MS_SRAM/2);
    fd7c:	00 d0       	rcall	.+0      	; 0xfd7e <SetupHardware+0x1b2>
    fd7e:	00 d0       	rcall	.+0      	; 0xfd80 <SetupHardware+0x1b4>
    fd80:	00 d0       	rcall	.+0      	; 0xfd82 <SetupHardware+0x1b6>
    fd82:	ed b7       	in	r30, 0x3d	; 61
    fd84:	fe b7       	in	r31, 0x3e	; 62
    fd86:	31 96       	adiw	r30, 0x01	; 1
    fd88:	ad b7       	in	r26, 0x3d	; 61
    fd8a:	be b7       	in	r27, 0x3e	; 62
    fd8c:	12 96       	adiw	r26, 0x02	; 2
    fd8e:	fc 92       	st	X, r15
    fd90:	ee 92       	st	-X, r14
    fd92:	11 97       	sbiw	r26, 0x01	; 1
    fd94:	82 e8       	ldi	r24, 0x82	; 130
    fd96:	98 e0       	ldi	r25, 0x08	; 8
    fd98:	93 83       	std	Z+3, r25	; 0x03
    fd9a:	82 83       	std	Z+2, r24	; 0x02
    fd9c:	80 91 f0 0c 	lds	r24, 0x0CF0
    fda0:	90 91 f1 0c 	lds	r25, 0x0CF1
    fda4:	96 95       	lsr	r25
    fda6:	87 95       	ror	r24
    fda8:	95 83       	std	Z+5, r25	; 0x05
    fdaa:	84 83       	std	Z+4, r24	; 0x04
    fdac:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
            lcdDrawString(LineBuffer,5,100,MAGENTA,BLACK);
    fdb0:	8d b7       	in	r24, 0x3d	; 61
    fdb2:	9e b7       	in	r25, 0x3e	; 62
    fdb4:	06 96       	adiw	r24, 0x06	; 6
    fdb6:	0f b6       	in	r0, 0x3f	; 63
    fdb8:	f8 94       	cli
    fdba:	9e bf       	out	0x3e, r25	; 62
    fdbc:	0f be       	out	0x3f, r0	; 63
    fdbe:	8d bf       	out	0x3d, r24	; 61
    fdc0:	c7 01       	movw	r24, r14
    fdc2:	65 e0       	ldi	r22, 0x05	; 5
    fdc4:	70 e0       	ldi	r23, 0x00	; 0
    fdc6:	44 e6       	ldi	r20, 0x64	; 100
    fdc8:	50 e0       	ldi	r21, 0x00	; 0
    fdca:	2f e1       	ldi	r18, 0x1F	; 31
    fdcc:	38 ef       	ldi	r19, 0xF8	; 248
    fdce:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>

            sprintf (LineBuffer, "Webinterval: %ds", WebLoggingInterval500MS_SRAM/2);
    fdd2:	00 d0       	rcall	.+0      	; 0xfdd4 <SetupHardware+0x208>
    fdd4:	00 d0       	rcall	.+0      	; 0xfdd6 <SetupHardware+0x20a>
    fdd6:	00 d0       	rcall	.+0      	; 0xfdd8 <SetupHardware+0x20c>
    fdd8:	ed b7       	in	r30, 0x3d	; 61
    fdda:	fe b7       	in	r31, 0x3e	; 62
    fddc:	31 96       	adiw	r30, 0x01	; 1
    fdde:	ad b7       	in	r26, 0x3d	; 61
    fde0:	be b7       	in	r27, 0x3e	; 62
    fde2:	12 96       	adiw	r26, 0x02	; 2
    fde4:	fc 92       	st	X, r15
    fde6:	ee 92       	st	-X, r14
    fde8:	11 97       	sbiw	r26, 0x01	; 1
    fdea:	80 e9       	ldi	r24, 0x90	; 144
    fdec:	98 e0       	ldi	r25, 0x08	; 8
    fdee:	93 83       	std	Z+3, r25	; 0x03
    fdf0:	82 83       	std	Z+2, r24	; 0x02
    fdf2:	80 91 b6 0b 	lds	r24, 0x0BB6
    fdf6:	90 91 b7 0b 	lds	r25, 0x0BB7
    fdfa:	96 95       	lsr	r25
    fdfc:	87 95       	ror	r24
    fdfe:	95 83       	std	Z+5, r25	; 0x05
    fe00:	84 83       	std	Z+4, r24	; 0x04
    fe02:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
            lcdDrawString(LineBuffer,5,150,MAGENTA,BLACK);
    fe06:	8d b7       	in	r24, 0x3d	; 61
    fe08:	9e b7       	in	r25, 0x3e	; 62
    fe0a:	06 96       	adiw	r24, 0x06	; 6
    fe0c:	0f b6       	in	r0, 0x3f	; 63
    fe0e:	f8 94       	cli
    fe10:	9e bf       	out	0x3e, r25	; 62
    fe12:	0f be       	out	0x3f, r0	; 63
    fe14:	8d bf       	out	0x3d, r24	; 61
    fe16:	c7 01       	movw	r24, r14
    fe18:	65 e0       	ldi	r22, 0x05	; 5
    fe1a:	70 e0       	ldi	r23, 0x00	; 0
    fe1c:	46 e9       	ldi	r20, 0x96	; 150
    fe1e:	50 e0       	ldi	r21, 0x00	; 0
    fe20:	2f e1       	ldi	r18, 0x1F	; 31
    fe22:	38 ef       	ldi	r19, 0xF8	; 248
    fe24:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
    fe28:	8f ef       	ldi	r24, 0xFF	; 255
    fe2a:	93 ed       	ldi	r25, 0xD3	; 211
    fe2c:	a0 e3       	ldi	r26, 0x30	; 48
    fe2e:	81 50       	subi	r24, 0x01	; 1
    fe30:	90 40       	sbci	r25, 0x00	; 0
    fe32:	a0 40       	sbci	r26, 0x00	; 0
    fe34:	e1 f7       	brne	.-8      	; 0xfe2e <SetupHardware+0x262>
    fe36:	00 c0       	rjmp	.+0      	; 0xfe38 <SetupHardware+0x26c>
    fe38:	00 00       	nop
        }
        #endif

		//Temperature = Temperature_GetTemperature()+Sensor1Correction_SRAM; // if use of local NTC

		HYT321_GetData(&Humidity, &Temperature);
    fe3a:	89 e6       	ldi	r24, 0x69	; 105
    fe3c:	99 e0       	ldi	r25, 0x09	; 9
    fe3e:	68 e6       	ldi	r22, 0x68	; 104
    fe40:	79 e0       	ldi	r23, 0x09	; 9
    fe42:	0e 94 1f 9a 	call	0x1343e	; 0x1343e <HYT321_GetData>
        #endif
        #if (LCD==3)
        {
            uint16_t i;

            DrawFrame1 ();
    fe46:	0e 94 08 73 	call	0xe610	; 0xe610 <DrawFrame1>

            lcdSetFont((uint8_t*) Neu42x35);
    fe4a:	84 ec       	ldi	r24, 0xC4	; 196
    fe4c:	9c e4       	ldi	r25, 0x4C	; 76
    fe4e:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
            sprintf (LineBuffer, "%d~C %d%%", Temperature+Sensor1Correction_SRAM,Humidity);
    fe52:	ad b7       	in	r26, 0x3d	; 61
    fe54:	be b7       	in	r27, 0x3e	; 62
    fe56:	18 97       	sbiw	r26, 0x08	; 8
    fe58:	0f b6       	in	r0, 0x3f	; 63
    fe5a:	f8 94       	cli
    fe5c:	be bf       	out	0x3e, r27	; 62
    fe5e:	0f be       	out	0x3f, r0	; 63
    fe60:	ad bf       	out	0x3d, r26	; 61
    fe62:	ed b7       	in	r30, 0x3d	; 61
    fe64:	fe b7       	in	r31, 0x3e	; 62
    fe66:	31 96       	adiw	r30, 0x01	; 1
    fe68:	12 96       	adiw	r26, 0x02	; 2
    fe6a:	fc 92       	st	X, r15
    fe6c:	ee 92       	st	-X, r14
    fe6e:	11 97       	sbiw	r26, 0x01	; 1
    fe70:	80 e1       	ldi	r24, 0x10	; 16
    fe72:	98 e0       	ldi	r25, 0x08	; 8
    fe74:	93 83       	std	Z+3, r25	; 0x03
    fe76:	82 83       	std	Z+2, r24	; 0x02
    fe78:	80 91 e1 12 	lds	r24, 0x12E1
    fe7c:	99 27       	eor	r25, r25
    fe7e:	87 fd       	sbrc	r24, 7
    fe80:	90 95       	com	r25
    fe82:	20 91 68 09 	lds	r18, 0x0968
    fe86:	33 27       	eor	r19, r19
    fe88:	27 fd       	sbrc	r18, 7
    fe8a:	30 95       	com	r19
    fe8c:	82 0f       	add	r24, r18
    fe8e:	93 1f       	adc	r25, r19
    fe90:	95 83       	std	Z+5, r25	; 0x05
    fe92:	84 83       	std	Z+4, r24	; 0x04
    fe94:	80 91 69 09 	lds	r24, 0x0969
    fe98:	99 27       	eor	r25, r25
    fe9a:	87 fd       	sbrc	r24, 7
    fe9c:	90 95       	com	r25
    fe9e:	97 83       	std	Z+7, r25	; 0x07
    fea0:	86 83       	std	Z+6, r24	; 0x06
    fea2:	0e 94 90 ad 	call	0x15b20	; 0x15b20 <sprintf>
            lcdDrawString(LineBuffer,60,50,GREEN,BLACK);
    fea6:	8d b7       	in	r24, 0x3d	; 61
    fea8:	9e b7       	in	r25, 0x3e	; 62
    feaa:	08 96       	adiw	r24, 0x08	; 8
    feac:	0f b6       	in	r0, 0x3f	; 63
    feae:	f8 94       	cli
    feb0:	9e bf       	out	0x3e, r25	; 62
    feb2:	0f be       	out	0x3f, r0	; 63
    feb4:	8d bf       	out	0x3d, r24	; 61
    feb6:	c7 01       	movw	r24, r14
    feb8:	6c e3       	ldi	r22, 0x3C	; 60
    feba:	70 e0       	ldi	r23, 0x00	; 0
    febc:	42 e3       	ldi	r20, 0x32	; 50
    febe:	50 e0       	ldi	r21, 0x00	; 0
    fec0:	20 ee       	ldi	r18, 0xE0	; 224
    fec2:	37 e0       	ldi	r19, 0x07	; 7
    fec4:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
            lcdDrawVLine(318,0,120,SILVER); //redraw right frame line
    fec8:	8e e3       	ldi	r24, 0x3E	; 62
    feca:	91 e0       	ldi	r25, 0x01	; 1
    fecc:	60 e0       	ldi	r22, 0x00	; 0
    fece:	70 e0       	ldi	r23, 0x00	; 0
    fed0:	48 e7       	ldi	r20, 0x78	; 120
    fed2:	50 e0       	ldi	r21, 0x00	; 0
    fed4:	20 e1       	ldi	r18, 0x10	; 16
    fed6:	35 ea       	ldi	r19, 0xA5	; 165
    fed8:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
            lcdDrawVLine(1,0,120,SILVER); //redraw right frame line
    fedc:	81 e0       	ldi	r24, 0x01	; 1
    fede:	90 e0       	ldi	r25, 0x00	; 0
    fee0:	60 e0       	ldi	r22, 0x00	; 0
    fee2:	70 e0       	ldi	r23, 0x00	; 0
    fee4:	48 e7       	ldi	r20, 0x78	; 120
    fee6:	50 e0       	ldi	r21, 0x00	; 0
    fee8:	20 e1       	ldi	r18, 0x10	; 16
    feea:	35 ea       	ldi	r19, 0xA5	; 165
    feec:	0e 94 40 9d 	call	0x13a80	; 0x13a80 <lcdDrawVLine>
    fef0:	e1 eb       	ldi	r30, 0xB1	; 177
    fef2:	f1 e1       	ldi	r31, 0x11	; 17
            for (i=0; i<300; i++) Sensor1TempValues[i]=127; // clear arrays for trend values
    fef4:	8f e7       	ldi	r24, 0x7F	; 127
    fef6:	81 93       	st	Z+, r24
    fef8:	92 e1       	ldi	r25, 0x12	; 18
    fefa:	ed 3d       	cpi	r30, 0xDD	; 221
    fefc:	f9 07       	cpc	r31, r25
    fefe:	d9 f7       	brne	.-10     	; 0xfef6 <SetupHardware+0x32a>
    ff00:	e8 eb       	ldi	r30, 0xB8	; 184
    ff02:	fb e0       	ldi	r31, 0x0B	; 11
            for (i=0; i<300; i++) Sensor1HumditiyValues[i]=127; // clear arrays for trend values
    ff04:	8f e7       	ldi	r24, 0x7F	; 127
    ff06:	81 93       	st	Z+, r24
    ff08:	ac e0       	ldi	r26, 0x0C	; 12
    ff0a:	e4 3e       	cpi	r30, 0xE4	; 228
    ff0c:	fa 07       	cpc	r31, r26
    ff0e:	d9 f7       	brne	.-10     	; 0xff06 <SetupHardware+0x33a>
    ff10:	e2 e8       	ldi	r30, 0x82	; 130
    ff12:	f0 e1       	ldi	r31, 0x10	; 16
            for (i=0; i<300; i++) Sensor2Values[i]=127; // clear arrays for trend values
    ff14:	8f e7       	ldi	r24, 0x7F	; 127
    ff16:	81 93       	st	Z+, r24
    ff18:	b1 e1       	ldi	r27, 0x11	; 17
    ff1a:	ee 3a       	cpi	r30, 0xAE	; 174
    ff1c:	fb 07       	cpc	r31, r27
    ff1e:	d9 f7       	brne	.-10     	; 0xff16 <SetupHardware+0x34a>
    ff20:	e6 ee       	ldi	r30, 0xE6	; 230
    ff22:	f2 e1       	ldi	r31, 0x12	; 18
            for (i=0; i<300; i++) Sensor3Values[i]=127; // clear arrays for trend values
    ff24:	8f e7       	ldi	r24, 0x7F	; 127
    ff26:	81 93       	st	Z+, r24
    ff28:	94 e1       	ldi	r25, 0x14	; 20
    ff2a:	e2 31       	cpi	r30, 0x12	; 18
    ff2c:	f9 07       	cpc	r31, r25
    ff2e:	d9 f7       	brne	.-10     	; 0xff26 <SetupHardware+0x35a>
    ff30:	ed e3       	ldi	r30, 0x3D	; 61
    ff32:	ff e0       	ldi	r31, 0x0F	; 15
            for (i=0; i<300; i++) Sensor4Values[i]=127; // clear arrays for trend values
    ff34:	8f e7       	ldi	r24, 0x7F	; 127
    ff36:	81 93       	st	Z+, r24
    ff38:	a0 e1       	ldi	r26, 0x10	; 16
    ff3a:	e9 36       	cpi	r30, 0x69	; 105
    ff3c:	fa 07       	cpc	r31, r26
    ff3e:	d9 f7       	brne	.-10     	; 0xff36 <SetupHardware+0x36a>

        }
        #endif

		Enable_receiver();		// enable radio receiver
    ff40:	0e 94 0e 9a 	call	0x1341c	; 0x1341c <Enable_receiver>

        //Serial_Init(9600, 0);   // initialize uart for debugging

      	/* 500ms logging interval timer configuration */
        OCR1A   = (((F_CPU / 256) / 2) - 1);
    ff44:	88 e0       	ldi	r24, 0x08	; 8
    ff46:	9d e3       	ldi	r25, 0x3D	; 61
    ff48:	90 93 89 00 	sts	0x0089, r25
    ff4c:	80 93 88 00 	sts	0x0088, r24
        TCCR1B  = (1 << WGM12) | (1 << CS12);
    ff50:	8c e0       	ldi	r24, 0x0C	; 12
    ff52:	80 93 81 00 	sts	0x0081, r24
        TIMSK1  = (1 << OCIE1A); // enable Timer 1 interrupt
    ff56:	82 e0       	ldi	r24, 0x02	; 2
    ff58:	80 93 6f 00 	sts	0x006F, r24
		}
}
    ff5c:	6e 96       	adiw	r28, 0x1e	; 30
    ff5e:	0f b6       	in	r0, 0x3f	; 63
    ff60:	f8 94       	cli
    ff62:	de bf       	out	0x3e, r29	; 62
    ff64:	0f be       	out	0x3f, r0	; 63
    ff66:	cd bf       	out	0x3d, r28	; 61
    ff68:	cf 91       	pop	r28
    ff6a:	df 91       	pop	r29
    ff6c:	1f 91       	pop	r17
    ff6e:	0f 91       	pop	r16
    ff70:	ff 90       	pop	r15
    ff72:	ef 90       	pop	r14
    ff74:	08 95       	ret

0000ff76 <main>:
/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
	SetupHardware();
    ff76:	2a de       	rcall	.-940    	; 0xfbcc <SetupHardware>

	/* Mount and open the log file on the Dataflash FAT partition */
	OpenLogFile();
    ff78:	0e 94 81 72 	call	0xe502	; 0xe502 <OpenLogFile>

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
    ff7c:	80 e1       	ldi	r24, 0x10	; 16
    ff7e:	0e 94 ae 6c 	call	0xd95c	; 0xd95c <LEDs_SetAllLEDs>
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    ff82:	78 94       	sei
	GlobalInterruptEnable();

	for (;;)
	{
       if (!(LOCAL_Port_Read & (1<<LOCAL)))    // mode: temperature logging
    ff84:	37 99       	sbic	0x06, 7	; 6
    ff86:	0a c0       	rjmp	.+20     	; 0xff9c <main+0x26>
		{
		    if (FrameCounter == 0)
    ff88:	80 91 df 12 	lds	r24, 0x12DF
    ff8c:	88 23       	and	r24, r24
    ff8e:	81 f4       	brne	.+32     	; 0xffb0 <main+0x3a>
            {
                RFM12_Port_Write &=~ (1<<NSEL); //NSEL = 0, chip select -> activ
    ff90:	11 98       	cbi	0x02, 1	; 2
                if (RFM12_Port_Read&(1<<SDO)) RadioReceive();
    ff92:	02 9b       	sbis	0x00, 2	; 0
    ff94:	0d c0       	rjmp	.+26     	; 0xffb0 <main+0x3a>
    ff96:	0e 94 97 70 	call	0xe12e	; 0xe12e <RadioReceive>
    ff9a:	0a c0       	rjmp	.+20     	; 0xffb0 <main+0x3a>
            }
		}
		else
		{
		MS_Device_USBTask(&Disk_MS_Interface);      // USB mode -> connection to pc
    ff9c:	81 eb       	ldi	r24, 0xB1	; 177
    ff9e:	98 e0       	ldi	r25, 0x08	; 8
    ffa0:	0e 94 4e aa 	call	0x1549c	; 0x1549c <MS_Device_USBTask>
        HID_Device_USBTask(&Generic_HID_Interface);
    ffa4:	8a ee       	ldi	r24, 0xEA	; 234
    ffa6:	98 e0       	ldi	r25, 0x08	; 8
    ffa8:	0e 94 29 a9 	call	0x15252	; 0x15252 <HID_Device_USBTask>
        USB_USBTask();
    ffac:	0e 94 b6 a7 	call	0x14f6c	; 0x14f6c <USB_USBTask>
		}
    if (!Webclient) Webcontrol();
    ffb0:	80 91 6a 09 	lds	r24, 0x096A
    ffb4:	88 23       	and	r24, r24
    ffb6:	31 f7       	brne	.-52     	; 0xff84 <main+0xe>
    ffb8:	0e 94 6c 6f 	call	0xded8	; 0xded8 <Webcontrol>
    ffbc:	e3 cf       	rjmp	.-58     	; 0xff84 <main+0xe>

0000ffbe <EVENT_USB_Device_Connect>:
	if (DaysLeft_SRAM == 0xFFFF) DaysLeft_SRAM = 50;
}

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
    ffbe:	0f 93       	push	r16
    ffc0:	1f 93       	push	r17
    TIMSK1  &= ~(1 << OCIE1A); // disable Timer 1 interrupt
    ffc2:	ef e6       	ldi	r30, 0x6F	; 111
    ffc4:	f0 e0       	ldi	r31, 0x00	; 0
    ffc6:	80 81       	ld	r24, Z
    ffc8:	8d 7f       	andi	r24, 0xFD	; 253
    ffca:	80 83       	st	Z, r24
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
    ffcc:	80 ea       	ldi	r24, 0xA0	; 160
    ffce:	0e 94 ae 6c 	call	0xd95c	; 0xd95c <LEDs_SetAllLEDs>

	/* Close the log file so that the host has exclusive filesystem access */
	CloseLogFile();
    ffd2:	0e 94 74 72 	call	0xe4e8	; 0xe4e8 <CloseLogFile>

    #if(LCD==3)
    lcdFillRGB(BLACK);
    ffd6:	80 e0       	ldi	r24, 0x00	; 0
    ffd8:	90 e0       	ldi	r25, 0x00	; 0
    ffda:	0e 94 ea 9c 	call	0x139d4	; 0x139d4 <lcdFillRGB>
    lcdSetFont((uint8_t*) Arial28x28);
    ffde:	80 e6       	ldi	r24, 0x60	; 96
    ffe0:	95 e2       	ldi	r25, 0x25	; 37
    ffe2:	0e 94 88 9c 	call	0x13910	; 0x13910 <lcdSetFont>
	lcdDrawString("Connected to PC",5,50,GREEN,BLACK);
    ffe6:	81 ea       	ldi	r24, 0xA1	; 161
    ffe8:	98 e0       	ldi	r25, 0x08	; 8
    ffea:	65 e0       	ldi	r22, 0x05	; 5
    ffec:	70 e0       	ldi	r23, 0x00	; 0
    ffee:	42 e3       	ldi	r20, 0x32	; 50
    fff0:	50 e0       	ldi	r21, 0x00	; 0
    fff2:	20 ee       	ldi	r18, 0xE0	; 224
    fff4:	37 e0       	ldi	r19, 0x07	; 7
    fff6:	00 e0       	ldi	r16, 0x00	; 0
    fff8:	10 e0       	ldi	r17, 0x00	; 0
    fffa:	0e 94 73 9f 	call	0x13ee6	; 0x13ee6 <lcdDrawString>
	#else
	lcd_clear();
	lcd_print_str("Connected to PC");
    #endif

}
    fffe:	1f 91       	pop	r17
   10000:	0f 91       	pop	r16
   10002:	08 95       	ret

00010004 <EVENT_USB_Device_Disconnect>:

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
   10004:	80 e1       	ldi	r24, 0x10	; 16
   10006:	0e 94 ae 6c 	call	0xd95c	; 0xd95c <LEDs_SetAllLEDs>

	//SetupHardware();

	/* Mount and open the log file on the Dataflash FAT partition */
	OpenLogFile();
   1000a:	0c 94 81 72 	jmp	0xe502	; 0xe502 <OpenLogFile>

0001000e <EVENT_USB_Device_ConfigurationChanged>:

}

/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
   1000e:	1f 93       	push	r17
	bool ConfigSuccess = true;

	ConfigSuccess &= HID_Device_ConfigureEndpoints(&Generic_HID_Interface);
   10010:	8a ee       	ldi	r24, 0xEA	; 234
   10012:	98 e0       	ldi	r25, 0x08	; 8
   10014:	0e 94 10 a9 	call	0x15220	; 0x15220 <HID_Device_ConfigureEndpoints>
   10018:	18 2f       	mov	r17, r24
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);
   1001a:	81 eb       	ldi	r24, 0xB1	; 177
   1001c:	98 e0       	ldi	r25, 0x08	; 8
   1001e:	0e 94 32 aa 	call	0x15464	; 0x15464 <MS_Device_ConfigureEndpoints>
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= HID_Device_ConfigureEndpoints(&Generic_HID_Interface);
   10022:	21 2f       	mov	r18, r17
   10024:	30 e0       	ldi	r19, 0x00	; 0
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);
   10026:	90 e0       	ldi	r25, 0x00	; 0
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= HID_Device_ConfigureEndpoints(&Generic_HID_Interface);
   10028:	28 23       	and	r18, r24
   1002a:	39 23       	and	r19, r25
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
   1002c:	20 ff       	sbrs	r18, 0
   1002e:	02 c0       	rjmp	.+4      	; 0x10034 <EVENT_USB_Device_ConfigurationChanged+0x26>
   10030:	80 e6       	ldi	r24, 0x60	; 96
   10032:	01 c0       	rjmp	.+2      	; 0x10036 <EVENT_USB_Device_ConfigurationChanged+0x28>
   10034:	80 e9       	ldi	r24, 0x90	; 144
   10036:	0e 94 ae 6c 	call	0xd95c	; 0xd95c <LEDs_SetAllLEDs>
}
   1003a:	1f 91       	pop	r17
   1003c:	08 95       	ret

0001003e <EVENT_USB_Device_ControlRequest>:

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	MS_Device_ProcessControlRequest(&Disk_MS_Interface);
   1003e:	81 eb       	ldi	r24, 0xB1	; 177
   10040:	98 e0       	ldi	r25, 0x08	; 8
   10042:	0e 94 f5 a9 	call	0x153ea	; 0x153ea <MS_Device_ProcessControlRequest>
	HID_Device_ProcessControlRequest(&Generic_HID_Interface);
   10046:	8a ee       	ldi	r24, 0xEA	; 234
   10048:	98 e0       	ldi	r25, 0x08	; 8
   1004a:	0c 94 d1 a7 	jmp	0x14fa2	; 0x14fa2 <HID_Device_ProcessControlRequest>

0001004e <CALLBACK_MS_Device_SCSICommandReceived>:
/** Mass Storage class driver callback function the reception of SCSI commands from the host, which must be processed.
 *
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface configuration structure being referenced
 */
bool CALLBACK_MS_Device_SCSICommandReceived(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
   1004e:	1f 93       	push	r17
   10050:	cf 93       	push	r28
   10052:	df 93       	push	r29
   10054:	ec 01       	movw	r28, r24
	bool CommandSuccess;

	LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
   10056:	80 e2       	ldi	r24, 0x20	; 32
   10058:	0e 94 ae 6c 	call	0xd95c	; 0xd95c <LEDs_SetAllLEDs>
	CommandSuccess = SCSI_DecodeSCSICommand(MSInterfaceInfo);
   1005c:	ce 01       	movw	r24, r28
   1005e:	0c d7       	rcall	.+3608   	; 0x10e78 <SCSI_DecodeSCSICommand>
   10060:	18 2f       	mov	r17, r24
	LEDs_SetAllLEDs(LEDMASK_USB_READY);
   10062:	80 e6       	ldi	r24, 0x60	; 96
   10064:	0e 94 ae 6c 	call	0xd95c	; 0xd95c <LEDs_SetAllLEDs>

	return CommandSuccess;
}
   10068:	81 2f       	mov	r24, r17
   1006a:	df 91       	pop	r29
   1006c:	cf 91       	pop	r28
   1006e:	1f 91       	pop	r17
   10070:	08 95       	ret

00010072 <CALLBACK_HID_Device_CreateHIDReport>:
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
                                         uint8_t* const ReportID,
                                         const uint8_t ReportType,
                                         void* ReportData,
                                         uint16_t* const ReportSize)
{
   10072:	ef 92       	push	r14
   10074:	ff 92       	push	r15
   10076:	0f 93       	push	r16
   10078:	1f 93       	push	r17
   1007a:	cf 93       	push	r28
   1007c:	df 93       	push	r29
	Device_Report_t* ReportParams = (Device_Report_t*)ReportData;
   1007e:	e2 2e       	mov	r14, r18
   10080:	e7 01       	movw	r28, r14
   10082:	7e 01       	movw	r14, r28
   10084:	f3 2e       	mov	r15, r19
   10086:	e7 01       	movw	r28, r14

    RTC_GetTimeDate(&ReportParams->TimeDate);
   10088:	c7 01       	movw	r24, r14
   1008a:	5a d5       	rcall	.+2740   	; 0x10b40 <RTC_GetTimeDate>

	ReportParams->LogInterval500MS = LoggingInterval500MS_SRAM;
   1008c:	80 91 f0 0c 	lds	r24, 0x0CF0
   10090:	90 91 f1 0c 	lds	r25, 0x0CF1
   10094:	9f 83       	std	Y+7, r25	; 0x07
   10096:	8e 83       	std	Y+6, r24	; 0x06
	ReportParams->WebLogInterval500MS = WebLoggingInterval500MS_SRAM;
   10098:	80 91 b6 0b 	lds	r24, 0x0BB6
   1009c:	90 91 b7 0b 	lds	r25, 0x0BB7
   100a0:	9b 8b       	std	Y+19, r25	; 0x13
   100a2:	8a 8b       	std	Y+18, r24	; 0x12

	ReportParams->Sensor1Correction = Sensor1Correction_SRAM;
   100a4:	80 91 e1 12 	lds	r24, 0x12E1
   100a8:	88 87       	std	Y+8, r24	; 0x08
	ReportParams->Sensor2Correction = Sensor2Correction_SRAM;
   100aa:	80 91 76 10 	lds	r24, 0x1076
   100ae:	89 87       	std	Y+9, r24	; 0x09
	ReportParams->Sensor3Correction = Sensor3Correction_SRAM;
   100b0:	80 91 3c 0f 	lds	r24, 0x0F3C
   100b4:	8a 87       	std	Y+10, r24	; 0x0a
	ReportParams->Sensor4Correction = Sensor4Correction_SRAM;
   100b6:	80 91 7a 10 	lds	r24, 0x107A
   100ba:	8b 87       	std	Y+11, r24	; 0x0b

   	ReportParams->FreeMemory = FreeMemory;
   100bc:	80 91 69 10 	lds	r24, 0x1069
   100c0:	90 91 6a 10 	lds	r25, 0x106A
   100c4:	a0 91 6b 10 	lds	r26, 0x106B
   100c8:	b0 91 6c 10 	lds	r27, 0x106C
   100cc:	8c 87       	std	Y+12, r24	; 0x0c
   100ce:	9d 87       	std	Y+13, r25	; 0x0d
   100d0:	ae 87       	std	Y+14, r26	; 0x0e
   100d2:	bf 87       	std	Y+15, r27	; 0x0f

    *ReportSize = sizeof(Device_Report_t);
   100d4:	84 e1       	ldi	r24, 0x14	; 20
   100d6:	90 e0       	ldi	r25, 0x00	; 0
   100d8:	f8 01       	movw	r30, r16
   100da:	91 83       	std	Z+1, r25	; 0x01
   100dc:	80 83       	st	Z, r24
	return true;
}
   100de:	81 e0       	ldi	r24, 0x01	; 1
   100e0:	df 91       	pop	r29
   100e2:	cf 91       	pop	r28
   100e4:	1f 91       	pop	r17
   100e6:	0f 91       	pop	r16
   100e8:	ff 90       	pop	r15
   100ea:	ef 90       	pop	r14
   100ec:	08 95       	ret

000100ee <CALLBACK_HID_Device_ProcessHIDReport>:
void CALLBACK_HID_Device_ProcessHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
                                          const uint8_t ReportID,
                                          const uint8_t ReportType,
                                          const void* ReportData,
                                          const uint16_t ReportSize)
{
   100ee:	ef 92       	push	r14
   100f0:	ff 92       	push	r15
   100f2:	cf 93       	push	r28
   100f4:	df 93       	push	r29
	Device_Report_t* ReportParams = (Device_Report_t*)ReportData;
   100f6:	e2 2e       	mov	r14, r18
   100f8:	e7 01       	movw	r28, r14
   100fa:	7e 01       	movw	r14, r28
   100fc:	f3 2e       	mov	r15, r19
   100fe:	e7 01       	movw	r28, r14

	RTC_SetTimeDate(&ReportParams->TimeDate);
   10100:	c7 01       	movw	r24, r14
   10102:	c6 d5       	rcall	.+2956   	; 0x10c90 <RTC_SetTimeDate>

	/* If the logging interval has changed from its current value, write it to EEPROM */
	if (LoggingInterval500MS_SRAM != ReportParams->LogInterval500MS)
   10104:	6e 81       	ldd	r22, Y+6	; 0x06
   10106:	7f 81       	ldd	r23, Y+7	; 0x07
   10108:	80 91 f0 0c 	lds	r24, 0x0CF0
   1010c:	90 91 f1 0c 	lds	r25, 0x0CF1
   10110:	86 17       	cp	r24, r22
   10112:	97 07       	cpc	r25, r23
   10114:	41 f0       	breq	.+16     	; 0x10126 <CALLBACK_HID_Device_ProcessHIDReport+0x38>
	{
		LoggingInterval500MS_SRAM = ReportParams->LogInterval500MS;
   10116:	70 93 f1 0c 	sts	0x0CF1, r23
   1011a:	60 93 f0 0c 	sts	0x0CF0, r22
		eeprom_update_word(&LoggingInterval500MS_EEPROM, LoggingInterval500MS_SRAM);
   1011e:	80 e0       	ldi	r24, 0x00	; 0
   10120:	90 e0       	ldi	r25, 0x00	; 0
   10122:	0e 94 e1 af 	call	0x15fc2	; 0x15fc2 <__eeupd_word_usb1287>
	}

	if (WebLoggingInterval500MS_SRAM != ReportParams->WebLogInterval500MS)
   10126:	6a 89       	ldd	r22, Y+18	; 0x12
   10128:	7b 89       	ldd	r23, Y+19	; 0x13
   1012a:	80 91 b6 0b 	lds	r24, 0x0BB6
   1012e:	90 91 b7 0b 	lds	r25, 0x0BB7
   10132:	86 17       	cp	r24, r22
   10134:	97 07       	cpc	r25, r23
   10136:	41 f0       	breq	.+16     	; 0x10148 <CALLBACK_HID_Device_ProcessHIDReport+0x5a>
	{
		WebLoggingInterval500MS_SRAM = ReportParams->WebLogInterval500MS;
   10138:	70 93 b7 0b 	sts	0x0BB7, r23
   1013c:	60 93 b6 0b 	sts	0x0BB6, r22
		eeprom_update_word(&WebLoggingInterval500MS_EEPROM, WebLoggingInterval500MS_SRAM);
   10140:	82 e0       	ldi	r24, 0x02	; 2
   10142:	90 e0       	ldi	r25, 0x00	; 0
   10144:	0e 94 e1 af 	call	0x15fc2	; 0x15fc2 <__eeupd_word_usb1287>
	}

	if (Sensor1Correction_SRAM != ReportParams->Sensor1Correction)
   10148:	68 85       	ldd	r22, Y+8	; 0x08
   1014a:	20 91 e1 12 	lds	r18, 0x12E1
   1014e:	33 27       	eor	r19, r19
   10150:	27 fd       	sbrc	r18, 7
   10152:	30 95       	com	r19
   10154:	86 2f       	mov	r24, r22
   10156:	90 e0       	ldi	r25, 0x00	; 0
   10158:	28 17       	cp	r18, r24
   1015a:	39 07       	cpc	r19, r25
   1015c:	31 f0       	breq	.+12     	; 0x1016a <CALLBACK_HID_Device_ProcessHIDReport+0x7c>
	{
		Sensor1Correction_SRAM = ReportParams->Sensor1Correction;
   1015e:	60 93 e1 12 	sts	0x12E1, r22
		eeprom_update_byte(&Sensor1Correction_EEPROM, Sensor1Correction_SRAM);
   10162:	84 e2       	ldi	r24, 0x24	; 36
   10164:	90 e0       	ldi	r25, 0x00	; 0
   10166:	0e 94 cf af 	call	0x15f9e	; 0x15f9e <__eeupd_byte_usb1287>
	}

	if (Sensor2Correction_SRAM != ReportParams->Sensor2Correction)
   1016a:	69 85       	ldd	r22, Y+9	; 0x09
   1016c:	20 91 76 10 	lds	r18, 0x1076
   10170:	33 27       	eor	r19, r19
   10172:	27 fd       	sbrc	r18, 7
   10174:	30 95       	com	r19
   10176:	86 2f       	mov	r24, r22
   10178:	90 e0       	ldi	r25, 0x00	; 0
   1017a:	28 17       	cp	r18, r24
   1017c:	39 07       	cpc	r19, r25
   1017e:	31 f0       	breq	.+12     	; 0x1018c <CALLBACK_HID_Device_ProcessHIDReport+0x9e>
	{
		Sensor2Correction_SRAM = ReportParams->Sensor2Correction;
   10180:	60 93 76 10 	sts	0x1076, r22
		eeprom_update_byte(&Sensor2Correction_EEPROM, Sensor2Correction_SRAM);
   10184:	85 e2       	ldi	r24, 0x25	; 37
   10186:	90 e0       	ldi	r25, 0x00	; 0
   10188:	0e 94 cf af 	call	0x15f9e	; 0x15f9e <__eeupd_byte_usb1287>
	}

	if (Sensor3Correction_SRAM != ReportParams->Sensor3Correction)
   1018c:	6a 85       	ldd	r22, Y+10	; 0x0a
   1018e:	20 91 3c 0f 	lds	r18, 0x0F3C
   10192:	33 27       	eor	r19, r19
   10194:	27 fd       	sbrc	r18, 7
   10196:	30 95       	com	r19
   10198:	86 2f       	mov	r24, r22
   1019a:	90 e0       	ldi	r25, 0x00	; 0
   1019c:	28 17       	cp	r18, r24
   1019e:	39 07       	cpc	r19, r25
   101a0:	31 f0       	breq	.+12     	; 0x101ae <CALLBACK_HID_Device_ProcessHIDReport+0xc0>
	{
		Sensor3Correction_SRAM = ReportParams->Sensor3Correction;
   101a2:	60 93 3c 0f 	sts	0x0F3C, r22
		eeprom_update_byte(&Sensor3Correction_EEPROM, Sensor3Correction_SRAM);
   101a6:	86 e2       	ldi	r24, 0x26	; 38
   101a8:	90 e0       	ldi	r25, 0x00	; 0
   101aa:	0e 94 cf af 	call	0x15f9e	; 0x15f9e <__eeupd_byte_usb1287>
	}

	if (Sensor4Correction_SRAM != ReportParams->Sensor4Correction)
   101ae:	6b 85       	ldd	r22, Y+11	; 0x0b
   101b0:	20 91 7a 10 	lds	r18, 0x107A
   101b4:	33 27       	eor	r19, r19
   101b6:	27 fd       	sbrc	r18, 7
   101b8:	30 95       	com	r19
   101ba:	86 2f       	mov	r24, r22
   101bc:	90 e0       	ldi	r25, 0x00	; 0
   101be:	28 17       	cp	r18, r24
   101c0:	39 07       	cpc	r19, r25
   101c2:	31 f0       	breq	.+12     	; 0x101d0 <CALLBACK_HID_Device_ProcessHIDReport+0xe2>
	{
		Sensor4Correction_SRAM = ReportParams->Sensor4Correction;
   101c4:	60 93 7a 10 	sts	0x107A, r22
		eeprom_update_byte(&Sensor4Correction_EEPROM, Sensor4Correction_SRAM);
   101c8:	87 e2       	ldi	r24, 0x27	; 39
   101ca:	90 e0       	ldi	r25, 0x00	; 0
   101cc:	0e 94 cf af 	call	0x15f9e	; 0x15f9e <__eeupd_byte_usb1287>
	}

	if (DaysLeft_SRAM  != ReportParams->DaysLeft)
   101d0:	68 89       	ldd	r22, Y+16	; 0x10
   101d2:	79 89       	ldd	r23, Y+17	; 0x11
   101d4:	80 91 7d 10 	lds	r24, 0x107D
   101d8:	90 91 7e 10 	lds	r25, 0x107E
   101dc:	86 17       	cp	r24, r22
   101de:	97 07       	cpc	r25, r23
   101e0:	41 f0       	breq	.+16     	; 0x101f2 <CALLBACK_HID_Device_ProcessHIDReport+0x104>
	{
		DaysLeft_SRAM  = ReportParams->DaysLeft;
   101e2:	70 93 7e 10 	sts	0x107E, r23
   101e6:	60 93 7d 10 	sts	0x107D, r22
		eeprom_update_word(&DaysLeft_EEPROM, DaysLeft_SRAM);
   101ea:	88 e2       	ldi	r24, 0x28	; 40
   101ec:	90 e0       	ldi	r25, 0x00	; 0
   101ee:	0e 94 e1 af 	call	0x15fc2	; 0x15fc2 <__eeupd_word_usb1287>
	}
}
   101f2:	df 91       	pop	r29
   101f4:	cf 91       	pop	r28
   101f6:	ff 90       	pop	r15
   101f8:	ef 90       	pop	r14
   101fa:	08 95       	ret

000101fc <CALLBACK_USB_GetDescriptor>:
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
   101fc:	93 30       	cpi	r25, 0x03	; 3
   101fe:	89 f0       	breq	.+34     	; 0x10222 <CALLBACK_USB_GetDescriptor+0x26>
   10200:	94 30       	cpi	r25, 0x04	; 4
   10202:	28 f4       	brcc	.+10     	; 0x1020e <CALLBACK_USB_GetDescriptor+0x12>
   10204:	91 30       	cpi	r25, 0x01	; 1
   10206:	59 f1       	breq	.+86     	; 0x1025e <CALLBACK_USB_GetDescriptor+0x62>
   10208:	92 30       	cpi	r25, 0x02	; 2
   1020a:	71 f5       	brne	.+92     	; 0x10268 <CALLBACK_USB_GetDescriptor+0x6c>
   1020c:	05 c0       	rjmp	.+10     	; 0x10218 <CALLBACK_USB_GetDescriptor+0x1c>
   1020e:	91 32       	cpi	r25, 0x21	; 33
   10210:	e1 f0       	breq	.+56     	; 0x1024a <CALLBACK_USB_GetDescriptor+0x4e>
   10212:	92 32       	cpi	r25, 0x22	; 34
   10214:	49 f5       	brne	.+82     	; 0x10268 <CALLBACK_USB_GetDescriptor+0x6c>
   10216:	1e c0       	rjmp	.+60     	; 0x10254 <CALLBACK_USB_GetDescriptor+0x58>
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
   10218:	29 e3       	ldi	r18, 0x39	; 57
   1021a:	30 e0       	ldi	r19, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
   1021c:	e2 e9       	ldi	r30, 0x92	; 146
   1021e:	f8 ed       	ldi	r31, 0xD8	; 216
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
   10220:	27 c0       	rjmp	.+78     	; 0x10270 <CALLBACK_USB_GetDescriptor+0x74>
		case DTYPE_String:
			switch (DescriptorNumber)
   10222:	81 30       	cpi	r24, 0x01	; 1
   10224:	49 f0       	breq	.+18     	; 0x10238 <CALLBACK_USB_GetDescriptor+0x3c>
   10226:	81 30       	cpi	r24, 0x01	; 1
   10228:	18 f0       	brcs	.+6      	; 0x10230 <CALLBACK_USB_GetDescriptor+0x34>
   1022a:	82 30       	cpi	r24, 0x02	; 2
   1022c:	e9 f4       	brne	.+58     	; 0x10268 <CALLBACK_USB_GetDescriptor+0x6c>
   1022e:	08 c0       	rjmp	.+16     	; 0x10240 <CALLBACK_USB_GetDescriptor+0x44>
			{
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
   10230:	eb ec       	ldi	r30, 0xCB	; 203
   10232:	f8 ed       	ldi	r31, 0xD8	; 216
   10234:	24 91       	lpm	r18, Z+
   10236:	07 c0       	rjmp	.+14     	; 0x10246 <CALLBACK_USB_GetDescriptor+0x4a>
					break;
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
   10238:	ef ec       	ldi	r30, 0xCF	; 207
   1023a:	f8 ed       	ldi	r31, 0xD8	; 216
   1023c:	24 91       	lpm	r18, Z+
   1023e:	03 c0       	rjmp	.+6      	; 0x10246 <CALLBACK_USB_GetDescriptor+0x4a>
					break;
				case STRING_ID_Product:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
   10240:	e9 ee       	ldi	r30, 0xE9	; 233
   10242:	f8 ed       	ldi	r31, 0xD8	; 216
   10244:	24 91       	lpm	r18, Z+
   10246:	30 e0       	ldi	r19, 0x00	; 0
					break;
   10248:	13 c0       	rjmp	.+38     	; 0x10270 <CALLBACK_USB_GetDescriptor+0x74>
			}

			break;
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_GenericHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
   1024a:	29 e0       	ldi	r18, 0x09	; 9
   1024c:	30 e0       	ldi	r19, 0x00	; 0
					break;
			}

			break;
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_GenericHID;
   1024e:	eb eb       	ldi	r30, 0xBB	; 187
   10250:	f8 ed       	ldi	r31, 0xD8	; 216
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
   10252:	0e c0       	rjmp	.+28     	; 0x10270 <CALLBACK_USB_GetDescriptor+0x74>
		case HID_DTYPE_Report:
			Address = &GenericReport;
			Size    = sizeof(GenericReport);
   10254:	20 e2       	ldi	r18, 0x20	; 32
   10256:	30 e0       	ldi	r19, 0x00	; 0
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_GenericHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
		case HID_DTYPE_Report:
			Address = &GenericReport;
   10258:	e0 e6       	ldi	r30, 0x60	; 96
   1025a:	f8 ed       	ldi	r31, 0xD8	; 216
			Size    = sizeof(GenericReport);
			break;
   1025c:	09 c0       	rjmp	.+18     	; 0x10270 <CALLBACK_USB_GetDescriptor+0x74>

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
   1025e:	22 e1       	ldi	r18, 0x12	; 18
   10260:	30 e0       	ldi	r19, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
   10262:	e0 e8       	ldi	r30, 0x80	; 128
   10264:	f8 ed       	ldi	r31, 0xD8	; 216
   10266:	04 c0       	rjmp	.+8      	; 0x10270 <CALLBACK_USB_GetDescriptor+0x74>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
   10268:	20 e0       	ldi	r18, 0x00	; 0
   1026a:	30 e0       	ldi	r19, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
   1026c:	e0 e0       	ldi	r30, 0x00	; 0
   1026e:	f0 e0       	ldi	r31, 0x00	; 0
			Address = &GenericReport;
			Size    = sizeof(GenericReport);
			break;
	}

	*DescriptorAddress = Address;
   10270:	da 01       	movw	r26, r20
   10272:	11 96       	adiw	r26, 0x01	; 1
   10274:	fc 93       	st	X, r31
   10276:	ee 93       	st	-X, r30
	return Size;
}
   10278:	c9 01       	movw	r24, r18
   1027a:	08 95       	ret

0001027c <Dataflash_SelectChipFromPage>:
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
   1027c:	2e b1       	in	r18, 0x0e	; 14
   1027e:	23 60       	ori	r18, 0x03	; 3
   10280:	2e b9       	out	0x0e, r18	; 14
			 */
			static inline void Dataflash_SelectChipFromPage(const uint16_t PageAddress)
			{
				Dataflash_DeselectChip();

				if (PageAddress >= (DATAFLASH_PAGES * DATAFLASH_TOTALCHIPS))
   10282:	20 e4       	ldi	r18, 0x40	; 64
   10284:	80 30       	cpi	r24, 0x00	; 0
   10286:	92 07       	cpc	r25, r18
   10288:	58 f4       	brcc	.+22     	; 0x102a0 <Dataflash_SelectChipFromPage+0x24>
				  return;

				#if (DATAFLASH_TOTALCHIPS == 2)
					if (PageAddress & 0x01)
   1028a:	80 ff       	sbrs	r24, 0
   1028c:	05 c0       	rjmp	.+10     	; 0x10298 <Dataflash_SelectChipFromPage+0x1c>
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
   1028e:	8e b1       	in	r24, 0x0e	; 14
   10290:	83 60       	ori	r24, 0x03	; 3
   10292:	8d 7f       	andi	r24, 0xFD	; 253
   10294:	8e b9       	out	0x0e, r24	; 14
   10296:	08 95       	ret
   10298:	8e b1       	in	r24, 0x0e	; 14
   1029a:	83 60       	ori	r24, 0x03	; 3
   1029c:	8e 7f       	andi	r24, 0xFE	; 254
   1029e:	8e b9       	out	0x0e, r24	; 14
   102a0:	08 95       	ret

000102a2 <Dataflash_ToggleSelectedChipCS>:
			 *          or a DATAFLASH_CHIPn mask (where n is the chip number).
			 */
			static inline uint8_t Dataflash_GetSelectedChip(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Dataflash_GetSelectedChip(void)
			{
				return (~DATAFLASH_CHIPCS_PORT & DATAFLASH_CHIPCS_MASK);
   102a2:	8e b1       	in	r24, 0x0e	; 14
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
   102a4:	9e b1       	in	r25, 0x0e	; 14
   102a6:	93 60       	ori	r25, 0x03	; 3
   102a8:	9e b9       	out	0x0e, r25	; 14
   102aa:	9e b1       	in	r25, 0x0e	; 14
   102ac:	8c 6f       	ori	r24, 0xFC	; 252
   102ae:	93 60       	ori	r25, 0x03	; 3
   102b0:	89 23       	and	r24, r25
   102b2:	8e b9       	out	0x0e, r24	; 14
			{
				uint8_t SelectedChipMask = Dataflash_GetSelectedChip();

				Dataflash_DeselectChip();
				Dataflash_SelectChip(SelectedChipMask);
			}
   102b4:	08 95       	ret

000102b6 <Dataflash_WaitWhileBusy>:
			/** Spin-loops while the currently selected dataflash is busy executing a command, such as a main
			 *  memory page program or main memory to buffer transfer.
			 */
			static inline void Dataflash_WaitWhileBusy(void)
			{
				Dataflash_ToggleSelectedChipCS();
   102b6:	f5 df       	rcall	.-22     	; 0x102a2 <Dataflash_ToggleSelectedChipCS>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   102b8:	87 ed       	ldi	r24, 0xD7	; 215
   102ba:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   102bc:	0d b4       	in	r0, 0x2d	; 45
   102be:	07 fe       	sbrs	r0, 7
   102c0:	fd cf       	rjmp	.-6      	; 0x102bc <Dataflash_WaitWhileBusy+0x6>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   102c2:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   102c4:	0d b4       	in	r0, 0x2d	; 45
   102c6:	07 fe       	sbrs	r0, 7
   102c8:	fd cf       	rjmp	.-6      	; 0x102c4 <Dataflash_WaitWhileBusy+0xe>
				Dataflash_SendByte(DF_CMD_GETSTATUS);
				while (!(Dataflash_ReceiveByte() & DF_STATUS_READY));
   102ca:	0e b4       	in	r0, 0x2e	; 46
   102cc:	07 fe       	sbrs	r0, 7
   102ce:	f9 cf       	rjmp	.-14     	; 0x102c2 <Dataflash_WaitWhileBusy+0xc>
				Dataflash_ToggleSelectedChipCS();
			}
   102d0:	e8 cf       	rjmp	.-48     	; 0x102a2 <Dataflash_ToggleSelectedChipCS>

000102d2 <Dataflash_SendAddressBytes>:
			 */
			static inline void Dataflash_SendAddressBytes(uint16_t PageAddress,
			                                              const uint16_t BufferByte)
			{
				#if (DATAFLASH_TOTALCHIPS == 2)
					PageAddress >>= 1;
   102d2:	9c 01       	movw	r18, r24
   102d4:	36 95       	lsr	r19
   102d6:	27 95       	ror	r18
				#endif

				Dataflash_SendByte(PageAddress >> 5);
   102d8:	36 e0       	ldi	r19, 0x06	; 6
   102da:	96 95       	lsr	r25
   102dc:	87 95       	ror	r24
   102de:	3a 95       	dec	r19
   102e0:	e1 f7       	brne	.-8      	; 0x102da <Dataflash_SendAddressBytes+0x8>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   102e2:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   102e4:	0d b4       	in	r0, 0x2d	; 45
   102e6:	07 fe       	sbrs	r0, 7
   102e8:	fd cf       	rjmp	.-6      	; 0x102e4 <Dataflash_SendAddressBytes+0x12>
				Dataflash_SendByte((PageAddress << 3) | (BufferByte >> 8));
   102ea:	22 0f       	add	r18, r18
   102ec:	22 0f       	add	r18, r18
   102ee:	22 0f       	add	r18, r18
   102f0:	27 2b       	or	r18, r23
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   102f2:	2e bd       	out	0x2e, r18	; 46
				while (!(SPSR & (1 << SPIF)));
   102f4:	0d b4       	in	r0, 0x2d	; 45
   102f6:	07 fe       	sbrs	r0, 7
   102f8:	fd cf       	rjmp	.-6      	; 0x102f4 <Dataflash_SendAddressBytes+0x22>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   102fa:	6e bd       	out	0x2e, r22	; 46
				while (!(SPSR & (1 << SPIF)));
   102fc:	0d b4       	in	r0, 0x2d	; 45
   102fe:	07 fe       	sbrs	r0, 7
   10300:	fd cf       	rjmp	.-6      	; 0x102fc <Dataflash_SendAddressBytes+0x2a>
				Dataflash_SendByte(BufferByte);
			}
   10302:	08 95       	ret

00010304 <DataflashManager_WriteBlocks>:
 *  \param[in] TotalBlocks   Number of blocks of data to write
 */
void DataflashManager_WriteBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                  const uint32_t BlockAddress,
                                  uint16_t TotalBlocks)
{
   10304:	6f 92       	push	r6
   10306:	7f 92       	push	r7
   10308:	9f 92       	push	r9
   1030a:	af 92       	push	r10
   1030c:	bf 92       	push	r11
   1030e:	cf 92       	push	r12
   10310:	df 92       	push	r13
   10312:	ef 92       	push	r14
   10314:	ff 92       	push	r15
   10316:	0f 93       	push	r16
   10318:	1f 93       	push	r17
   1031a:	df 93       	push	r29
   1031c:	cf 93       	push	r28
   1031e:	0f 92       	push	r0
   10320:	cd b7       	in	r28, 0x3d	; 61
   10322:	de b7       	in	r29, 0x3e	; 62
   10324:	6c 01       	movw	r12, r24
   10326:	79 01       	movw	r14, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
   10328:	db 01       	movw	r26, r22
   1032a:	ca 01       	movw	r24, r20
   1032c:	19 e0       	ldi	r17, 0x09	; 9
   1032e:	88 0f       	add	r24, r24
   10330:	99 1f       	adc	r25, r25
   10332:	aa 1f       	adc	r26, r26
   10334:	bb 1f       	adc	r27, r27
   10336:	1a 95       	dec	r17
   10338:	d1 f7       	brne	.-12     	; 0x1032e <DataflashManager_WriteBlocks+0x2a>
   1033a:	fa e0       	ldi	r31, 0x0A	; 10
   1033c:	b6 95       	lsr	r27
   1033e:	a7 95       	ror	r26
   10340:	97 95       	ror	r25
   10342:	87 95       	ror	r24
   10344:	fa 95       	dec	r31
   10346:	d1 f7       	brne	.-12     	; 0x1033c <DataflashManager_WriteBlocks+0x38>
   10348:	3c 01       	movw	r6, r24
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
   1034a:	8a 01       	movw	r16, r20
   1034c:	10 2f       	mov	r17, r16
   1034e:	00 27       	eor	r16, r16
   10350:	11 0f       	add	r17, r17
   10352:	13 70       	andi	r17, 0x03	; 3
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
	bool     UsingSecondBuffer   = false;

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
   10354:	93 df       	rcall	.-218    	; 0x1027c <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10356:	83 e5       	ldi	r24, 0x53	; 83
   10358:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   1035a:	0d b4       	in	r0, 0x2d	; 45
   1035c:	07 fe       	sbrs	r0, 7
   1035e:	fd cf       	rjmp	.-6      	; 0x1035a <DataflashManager_WriteBlocks+0x56>

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
	/* Copy selected dataflash's current page contents to the Dataflash buffer */
	Dataflash_SendByte(DF_CMD_MAINMEMTOBUFF1);
	Dataflash_SendAddressBytes(CurrDFPage, 0);
   10360:	c3 01       	movw	r24, r6
   10362:	60 e0       	ldi	r22, 0x00	; 0
   10364:	70 e0       	ldi	r23, 0x00	; 0
   10366:	b5 df       	rcall	.-150    	; 0x102d2 <Dataflash_SendAddressBytes>
	Dataflash_WaitWhileBusy();
   10368:	a6 df       	rcall	.-180    	; 0x102b6 <Dataflash_WaitWhileBusy>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   1036a:	84 e8       	ldi	r24, 0x84	; 132
   1036c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   1036e:	0d b4       	in	r0, 0x2d	; 45
   10370:	07 fe       	sbrs	r0, 7
   10372:	fd cf       	rjmp	.-6      	; 0x1036e <DataflashManager_WriteBlocks+0x6a>
#endif

	/* Send the Dataflash buffer write command */
	Dataflash_SendByte(DF_CMD_BUFF1WRITE);
	Dataflash_SendAddressBytes(0, CurrDFPageByte);
   10374:	80 e0       	ldi	r24, 0x00	; 0
   10376:	90 e0       	ldi	r25, 0x00	; 0
   10378:	b8 01       	movw	r22, r16
   1037a:	ab df       	rcall	.-170    	; 0x102d2 <Dataflash_SendAddressBytes>

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
   1037c:	0e 94 b4 a4 	call	0x14968	; 0x14968 <Endpoint_WaitUntilReady>
   10380:	88 23       	and	r24, r24
   10382:	09 f0       	breq	.+2      	; 0x10386 <DataflashManager_WriteBlocks+0x82>
   10384:	eb c0       	rjmp	.+470    	; 0x1055c <DataflashManager_WriteBlocks+0x258>
                                  const uint32_t BlockAddress,
                                  uint16_t TotalBlocks)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
   10386:	74 e0       	ldi	r23, 0x04	; 4
   10388:	16 95       	lsr	r17
   1038a:	07 95       	ror	r16
   1038c:	7a 95       	dec	r23
   1038e:	e1 f7       	brne	.-8      	; 0x10388 <DataflashManager_WriteBlocks+0x84>
   10390:	90 2f       	mov	r25, r16
   10392:	87 01       	movw	r16, r14
   10394:	65 e0       	ldi	r22, 0x05	; 5
   10396:	00 0f       	add	r16, r16
   10398:	11 1f       	adc	r17, r17
   1039a:	6a 95       	dec	r22
   1039c:	e1 f7       	brne	.-8      	; 0x10396 <DataflashManager_WriteBlocks+0x92>
   1039e:	bb 24       	eor	r11, r11
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;

				/* Once all the Dataflash ICs have had their first buffers filled, switch buffers to maintain throughput */
				if (Dataflash_GetSelectedChip() == DATAFLASH_CHIP_MASK(DATAFLASH_TOTALCHIPS))
				  UsingSecondBuffer = !(UsingSecondBuffer);
   103a0:	99 24       	eor	r9, r9
   103a2:	93 94       	inc	r9
   103a4:	bc c0       	rjmp	.+376    	; 0x1051e <DataflashManager_WriteBlocks+0x21a>

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
   103a6:	50 e2       	ldi	r21, 0x20	; 32
   103a8:	a5 2e       	mov	r10, r21
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
   103aa:	80 91 e8 00 	lds	r24, 0x00E8

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if the endpoint is currently empty */
			if (!(Endpoint_IsReadWriteAllowed()))
   103ae:	85 fd       	sbrc	r24, 5
   103b0:	0c c0       	rjmp	.+24     	; 0x103ca <DataflashManager_WriteBlocks+0xc6>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
   103b2:	80 91 e8 00 	lds	r24, 0x00E8
   103b6:	8b 77       	andi	r24, 0x7B	; 123
   103b8:	80 93 e8 00 	sts	0x00E8, r24
			{
				/* Clear the current endpoint bank */
				Endpoint_ClearOUT();

				/* Wait until the host has sent another packet */
				if (Endpoint_WaitUntilReady())
   103bc:	99 83       	std	Y+1, r25	; 0x01
   103be:	0e 94 b4 a4 	call	0x14968	; 0x14968 <Endpoint_WaitUntilReady>
   103c2:	99 81       	ldd	r25, Y+1	; 0x01
   103c4:	88 23       	and	r24, r24
   103c6:	09 f0       	breq	.+2      	; 0x103ca <DataflashManager_WriteBlocks+0xc6>
   103c8:	c9 c0       	rjmp	.+402    	; 0x1055c <DataflashManager_WriteBlocks+0x258>
				  return;
			}

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
   103ca:	90 34       	cpi	r25, 0x40	; 64
   103cc:	09 f0       	breq	.+2      	; 0x103d0 <DataflashManager_WriteBlocks+0xcc>
   103ce:	3a c0       	rjmp	.+116    	; 0x10444 <DataflashManager_WriteBlocks+0x140>
			{
				/* Write the Dataflash buffer contents back to the Dataflash page */
				Dataflash_WaitWhileBusy();
   103d0:	72 df       	rcall	.-284    	; 0x102b6 <Dataflash_WaitWhileBusy>
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
   103d2:	bb 20       	and	r11, r11
   103d4:	11 f0       	breq	.+4      	; 0x103da <DataflashManager_WriteBlocks+0xd6>
   103d6:	86 e8       	ldi	r24, 0x86	; 134
   103d8:	01 c0       	rjmp	.+2      	; 0x103dc <DataflashManager_WriteBlocks+0xd8>
   103da:	83 e8       	ldi	r24, 0x83	; 131
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   103dc:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   103de:	0d b4       	in	r0, 0x2d	; 45
   103e0:	07 fe       	sbrs	r0, 7
   103e2:	fd cf       	rjmp	.-6      	; 0x103de <DataflashManager_WriteBlocks+0xda>
				Dataflash_SendAddressBytes(CurrDFPage, 0);
   103e4:	c3 01       	movw	r24, r6
   103e6:	60 e0       	ldi	r22, 0x00	; 0
   103e8:	70 e0       	ldi	r23, 0x00	; 0
   103ea:	73 df       	rcall	.-282    	; 0x102d2 <Dataflash_SendAddressBytes>

				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
   103ec:	08 94       	sec
   103ee:	61 1c       	adc	r6, r1
   103f0:	71 1c       	adc	r7, r1
			 *          or a DATAFLASH_CHIPn mask (where n is the chip number).
			 */
			static inline uint8_t Dataflash_GetSelectedChip(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Dataflash_GetSelectedChip(void)
			{
				return (~DATAFLASH_CHIPCS_PORT & DATAFLASH_CHIPCS_MASK);
   103f2:	8e b1       	in	r24, 0x0e	; 14
   103f4:	80 95       	com	r24
   103f6:	83 70       	andi	r24, 0x03	; 3

				/* Once all the Dataflash ICs have had their first buffers filled, switch buffers to maintain throughput */
				if (Dataflash_GetSelectedChip() == DATAFLASH_CHIP_MASK(DATAFLASH_TOTALCHIPS))
   103f8:	82 30       	cpi	r24, 0x02	; 2
   103fa:	09 f4       	brne	.+2      	; 0x103fe <DataflashManager_WriteBlocks+0xfa>
				  UsingSecondBuffer = !(UsingSecondBuffer);
   103fc:	b9 24       	eor	r11, r9

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
   103fe:	c3 01       	movw	r24, r6
   10400:	3d df       	rcall	.-390    	; 0x1027c <Dataflash_SelectChipFromPage>

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
				/* If less than one Dataflash page remaining, copy over the existing page to preserve trailing data */
				if ((TotalBlocks * (VIRTUAL_MEMORY_BLOCK_SIZE >> 4)) < (DATAFLASH_PAGE_SIZE >> 4))
   10402:	00 34       	cpi	r16, 0x40	; 64
   10404:	11 05       	cpc	r17, r1
   10406:	78 f4       	brcc	.+30     	; 0x10426 <DataflashManager_WriteBlocks+0x122>
				{
					/* Copy selected dataflash's current page contents to the Dataflash buffer */
					Dataflash_WaitWhileBusy();
   10408:	56 df       	rcall	.-340    	; 0x102b6 <Dataflash_WaitWhileBusy>
					Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_MAINMEMTOBUFF2 : DF_CMD_MAINMEMTOBUFF1);
   1040a:	bb 20       	and	r11, r11
   1040c:	11 f0       	breq	.+4      	; 0x10412 <DataflashManager_WriteBlocks+0x10e>
   1040e:	85 e5       	ldi	r24, 0x55	; 85
   10410:	01 c0       	rjmp	.+2      	; 0x10414 <DataflashManager_WriteBlocks+0x110>
   10412:	83 e5       	ldi	r24, 0x53	; 83
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10414:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10416:	0d b4       	in	r0, 0x2d	; 45
   10418:	07 fe       	sbrs	r0, 7
   1041a:	fd cf       	rjmp	.-6      	; 0x10416 <DataflashManager_WriteBlocks+0x112>
					Dataflash_SendAddressBytes(CurrDFPage, 0);
   1041c:	c3 01       	movw	r24, r6
   1041e:	60 e0       	ldi	r22, 0x00	; 0
   10420:	70 e0       	ldi	r23, 0x00	; 0
   10422:	57 df       	rcall	.-338    	; 0x102d2 <Dataflash_SendAddressBytes>
					Dataflash_WaitWhileBusy();
   10424:	48 df       	rcall	.-368    	; 0x102b6 <Dataflash_WaitWhileBusy>
				}
#endif

				/* Send the Dataflash buffer write command */
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2WRITE : DF_CMD_BUFF1WRITE);
   10426:	bb 20       	and	r11, r11
   10428:	11 f0       	breq	.+4      	; 0x1042e <DataflashManager_WriteBlocks+0x12a>
   1042a:	87 e8       	ldi	r24, 0x87	; 135
   1042c:	01 c0       	rjmp	.+2      	; 0x10430 <DataflashManager_WriteBlocks+0x12c>
   1042e:	84 e8       	ldi	r24, 0x84	; 132
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10430:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10432:	0d b4       	in	r0, 0x2d	; 45
   10434:	07 fe       	sbrs	r0, 7
   10436:	fd cf       	rjmp	.-6      	; 0x10432 <DataflashManager_WriteBlocks+0x12e>
				Dataflash_SendAddressBytes(0, 0);
   10438:	80 e0       	ldi	r24, 0x00	; 0
   1043a:	90 e0       	ldi	r25, 0x00	; 0
   1043c:	60 e0       	ldi	r22, 0x00	; 0
   1043e:	70 e0       	ldi	r23, 0x00	; 0
   10440:	48 df       	rcall	.-368    	; 0x102d2 <Dataflash_SendAddressBytes>
				Dataflash_WaitWhileBusy();
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
				Dataflash_SendAddressBytes(CurrDFPage, 0);

				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
   10442:	90 e0       	ldi	r25, 0x00	; 0
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
   10444:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10448:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   1044a:	0d b4       	in	r0, 0x2d	; 45
   1044c:	07 fe       	sbrs	r0, 7
   1044e:	fd cf       	rjmp	.-6      	; 0x1044a <DataflashManager_WriteBlocks+0x146>
   10450:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10454:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10456:	0d b4       	in	r0, 0x2d	; 45
   10458:	07 fe       	sbrs	r0, 7
   1045a:	fd cf       	rjmp	.-6      	; 0x10456 <DataflashManager_WriteBlocks+0x152>
   1045c:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10460:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10462:	0d b4       	in	r0, 0x2d	; 45
   10464:	07 fe       	sbrs	r0, 7
   10466:	fd cf       	rjmp	.-6      	; 0x10462 <DataflashManager_WriteBlocks+0x15e>
   10468:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   1046c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   1046e:	0d b4       	in	r0, 0x2d	; 45
   10470:	07 fe       	sbrs	r0, 7
   10472:	fd cf       	rjmp	.-6      	; 0x1046e <DataflashManager_WriteBlocks+0x16a>
   10474:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10478:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   1047a:	0d b4       	in	r0, 0x2d	; 45
   1047c:	07 fe       	sbrs	r0, 7
   1047e:	fd cf       	rjmp	.-6      	; 0x1047a <DataflashManager_WriteBlocks+0x176>
   10480:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10484:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10486:	0d b4       	in	r0, 0x2d	; 45
   10488:	07 fe       	sbrs	r0, 7
   1048a:	fd cf       	rjmp	.-6      	; 0x10486 <DataflashManager_WriteBlocks+0x182>
   1048c:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10490:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10492:	0d b4       	in	r0, 0x2d	; 45
   10494:	07 fe       	sbrs	r0, 7
   10496:	fd cf       	rjmp	.-6      	; 0x10492 <DataflashManager_WriteBlocks+0x18e>
   10498:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   1049c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   1049e:	0d b4       	in	r0, 0x2d	; 45
   104a0:	07 fe       	sbrs	r0, 7
   104a2:	fd cf       	rjmp	.-6      	; 0x1049e <DataflashManager_WriteBlocks+0x19a>
   104a4:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   104a8:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   104aa:	0d b4       	in	r0, 0x2d	; 45
   104ac:	07 fe       	sbrs	r0, 7
   104ae:	fd cf       	rjmp	.-6      	; 0x104aa <DataflashManager_WriteBlocks+0x1a6>
   104b0:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   104b4:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   104b6:	0d b4       	in	r0, 0x2d	; 45
   104b8:	07 fe       	sbrs	r0, 7
   104ba:	fd cf       	rjmp	.-6      	; 0x104b6 <DataflashManager_WriteBlocks+0x1b2>
   104bc:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   104c0:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   104c2:	0d b4       	in	r0, 0x2d	; 45
   104c4:	07 fe       	sbrs	r0, 7
   104c6:	fd cf       	rjmp	.-6      	; 0x104c2 <DataflashManager_WriteBlocks+0x1be>
   104c8:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   104cc:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   104ce:	0d b4       	in	r0, 0x2d	; 45
   104d0:	07 fe       	sbrs	r0, 7
   104d2:	fd cf       	rjmp	.-6      	; 0x104ce <DataflashManager_WriteBlocks+0x1ca>
   104d4:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   104d8:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   104da:	0d b4       	in	r0, 0x2d	; 45
   104dc:	07 fe       	sbrs	r0, 7
   104de:	fd cf       	rjmp	.-6      	; 0x104da <DataflashManager_WriteBlocks+0x1d6>
   104e0:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   104e4:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   104e6:	0d b4       	in	r0, 0x2d	; 45
   104e8:	07 fe       	sbrs	r0, 7
   104ea:	fd cf       	rjmp	.-6      	; 0x104e6 <DataflashManager_WriteBlocks+0x1e2>
   104ec:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   104f0:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   104f2:	0d b4       	in	r0, 0x2d	; 45
   104f4:	07 fe       	sbrs	r0, 7
   104f6:	fd cf       	rjmp	.-6      	; 0x104f2 <DataflashManager_WriteBlocks+0x1ee>
   104f8:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   104fc:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   104fe:	0d b4       	in	r0, 0x2d	; 45
   10500:	07 fe       	sbrs	r0, 7
   10502:	fd cf       	rjmp	.-6      	; 0x104fe <DataflashManager_WriteBlocks+0x1fa>

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;

			/* Check if the current command is being aborted by the host */
			if (MSInterfaceInfo->State.IsMassStoreReset)
   10504:	f6 01       	movw	r30, r12
   10506:	80 ad       	ldd	r24, Z+56	; 0x38
   10508:	88 23       	and	r24, r24
   1050a:	41 f5       	brne	.+80     	; 0x1055c <DataflashManager_WriteBlocks+0x258>
			Dataflash_SendByte(Endpoint_Read_8());
			Dataflash_SendByte(Endpoint_Read_8());
			Dataflash_SendByte(Endpoint_Read_8());

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
   1050c:	9f 5f       	subi	r25, 0xFF	; 255
   1050e:	aa 94       	dec	r10
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
   10510:	09 f0       	breq	.+2      	; 0x10514 <DataflashManager_WriteBlocks+0x210>
   10512:	4b cf       	rjmp	.-362    	; 0x103aa <DataflashManager_WriteBlocks+0xa6>
			if (MSInterfaceInfo->State.IsMassStoreReset)
			  return;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
   10514:	08 94       	sec
   10516:	e1 08       	sbc	r14, r1
   10518:	f1 08       	sbc	r15, r1
   1051a:	00 52       	subi	r16, 0x20	; 32
   1051c:	10 40       	sbci	r17, 0x00	; 0

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
   1051e:	e1 14       	cp	r14, r1
   10520:	f1 04       	cpc	r15, r1
   10522:	09 f0       	breq	.+2      	; 0x10526 <DataflashManager_WriteBlocks+0x222>
   10524:	40 cf       	rjmp	.-384    	; 0x103a6 <DataflashManager_WriteBlocks+0xa2>
		/* Decrement the blocks remaining counter */
		TotalBlocks--;
	}

	/* Write the Dataflash buffer contents back to the Dataflash page */
	Dataflash_WaitWhileBusy();
   10526:	c7 de       	rcall	.-626    	; 0x102b6 <Dataflash_WaitWhileBusy>
	Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
   10528:	bb 20       	and	r11, r11
   1052a:	11 f0       	breq	.+4      	; 0x10530 <DataflashManager_WriteBlocks+0x22c>
   1052c:	86 e8       	ldi	r24, 0x86	; 134
   1052e:	01 c0       	rjmp	.+2      	; 0x10532 <DataflashManager_WriteBlocks+0x22e>
   10530:	83 e8       	ldi	r24, 0x83	; 131
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10532:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10534:	0d b4       	in	r0, 0x2d	; 45
   10536:	07 fe       	sbrs	r0, 7
   10538:	fd cf       	rjmp	.-6      	; 0x10534 <DataflashManager_WriteBlocks+0x230>
	Dataflash_SendAddressBytes(CurrDFPage, 0x00);
   1053a:	c3 01       	movw	r24, r6
   1053c:	60 e0       	ldi	r22, 0x00	; 0
   1053e:	70 e0       	ldi	r23, 0x00	; 0
   10540:	c8 de       	rcall	.-624    	; 0x102d2 <Dataflash_SendAddressBytes>
	Dataflash_WaitWhileBusy();
   10542:	b9 de       	rcall	.-654    	; 0x102b6 <Dataflash_WaitWhileBusy>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
   10544:	80 91 e8 00 	lds	r24, 0x00E8

	/* If the endpoint is empty, clear it ready for the next packet from the host */
	if (!(Endpoint_IsReadWriteAllowed()))
   10548:	85 fd       	sbrc	r24, 5
   1054a:	05 c0       	rjmp	.+10     	; 0x10556 <DataflashManager_WriteBlocks+0x252>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
   1054c:	80 91 e8 00 	lds	r24, 0x00E8
   10550:	8b 77       	andi	r24, 0x7B	; 123
   10552:	80 93 e8 00 	sts	0x00E8, r24
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
   10556:	8e b1       	in	r24, 0x0e	; 14
   10558:	83 60       	ori	r24, 0x03	; 3
   1055a:	8e b9       	out	0x0e, r24	; 14
	  Endpoint_ClearOUT();

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
   1055c:	0f 90       	pop	r0
   1055e:	cf 91       	pop	r28
   10560:	df 91       	pop	r29
   10562:	1f 91       	pop	r17
   10564:	0f 91       	pop	r16
   10566:	ff 90       	pop	r15
   10568:	ef 90       	pop	r14
   1056a:	df 90       	pop	r13
   1056c:	cf 90       	pop	r12
   1056e:	bf 90       	pop	r11
   10570:	af 90       	pop	r10
   10572:	9f 90       	pop	r9
   10574:	7f 90       	pop	r7
   10576:	6f 90       	pop	r6
   10578:	08 95       	ret

0001057a <DataflashManager_ReadBlocks>:
 *  \param[in] TotalBlocks   Number of blocks of data to read
 */
void DataflashManager_ReadBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                 const uint32_t BlockAddress,
                                 uint16_t TotalBlocks)
{
   1057a:	bf 92       	push	r11
   1057c:	cf 92       	push	r12
   1057e:	df 92       	push	r13
   10580:	ef 92       	push	r14
   10582:	ff 92       	push	r15
   10584:	0f 93       	push	r16
   10586:	1f 93       	push	r17
   10588:	cf 93       	push	r28
   1058a:	df 93       	push	r29
   1058c:	6c 01       	movw	r12, r24
   1058e:	79 01       	movw	r14, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
   10590:	db 01       	movw	r26, r22
   10592:	ca 01       	movw	r24, r20
   10594:	69 e0       	ldi	r22, 0x09	; 9
   10596:	88 0f       	add	r24, r24
   10598:	99 1f       	adc	r25, r25
   1059a:	aa 1f       	adc	r26, r26
   1059c:	bb 1f       	adc	r27, r27
   1059e:	6a 95       	dec	r22
   105a0:	d1 f7       	brne	.-12     	; 0x10596 <DataflashManager_ReadBlocks+0x1c>
   105a2:	3a e0       	ldi	r19, 0x0A	; 10
   105a4:	b6 95       	lsr	r27
   105a6:	a7 95       	ror	r26
   105a8:	97 95       	ror	r25
   105aa:	87 95       	ror	r24
   105ac:	3a 95       	dec	r19
   105ae:	d1 f7       	brne	.-12     	; 0x105a4 <DataflashManager_ReadBlocks+0x2a>
   105b0:	ec 01       	movw	r28, r24
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
   105b2:	8a 01       	movw	r16, r20
   105b4:	10 2f       	mov	r17, r16
   105b6:	00 27       	eor	r16, r16
   105b8:	11 0f       	add	r17, r17
   105ba:	13 70       	andi	r17, 0x03	; 3
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
   105bc:	5f de       	rcall	.-834    	; 0x1027c <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   105be:	82 ed       	ldi	r24, 0xD2	; 210
   105c0:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   105c2:	0d b4       	in	r0, 0x2d	; 45
   105c4:	07 fe       	sbrs	r0, 7
   105c6:	fd cf       	rjmp	.-6      	; 0x105c2 <DataflashManager_ReadBlocks+0x48>

	/* Send the Dataflash main memory page read command */
	Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
	Dataflash_SendAddressBytes(CurrDFPage, CurrDFPageByte);
   105c8:	ce 01       	movw	r24, r28
   105ca:	b8 01       	movw	r22, r16
   105cc:	82 de       	rcall	.-764    	; 0x102d2 <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   105ce:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   105d0:	0d b4       	in	r0, 0x2d	; 45
   105d2:	07 fe       	sbrs	r0, 7
   105d4:	fd cf       	rjmp	.-6      	; 0x105d0 <DataflashManager_ReadBlocks+0x56>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   105d6:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   105d8:	0d b4       	in	r0, 0x2d	; 45
   105da:	07 fe       	sbrs	r0, 7
   105dc:	fd cf       	rjmp	.-6      	; 0x105d8 <DataflashManager_ReadBlocks+0x5e>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   105de:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   105e0:	0d b4       	in	r0, 0x2d	; 45
   105e2:	07 fe       	sbrs	r0, 7
   105e4:	fd cf       	rjmp	.-6      	; 0x105e0 <DataflashManager_ReadBlocks+0x66>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   105e6:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   105e8:	0d b4       	in	r0, 0x2d	; 45
   105ea:	07 fe       	sbrs	r0, 7
   105ec:	fd cf       	rjmp	.-6      	; 0x105e8 <DataflashManager_ReadBlocks+0x6e>
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
   105ee:	0e 94 b4 a4 	call	0x14968	; 0x14968 <Endpoint_WaitUntilReady>
   105f2:	88 23       	and	r24, r24
   105f4:	09 f0       	breq	.+2      	; 0x105f8 <DataflashManager_ReadBlocks+0x7e>
   105f6:	c0 c0       	rjmp	.+384    	; 0x10778 <DataflashManager_ReadBlocks+0x1fe>
                                 const uint32_t BlockAddress,
                                 uint16_t TotalBlocks)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
   105f8:	94 e0       	ldi	r25, 0x04	; 4
   105fa:	16 95       	lsr	r17
   105fc:	07 95       	ror	r16
   105fe:	9a 95       	dec	r25
   10600:	e1 f7       	brne	.-8      	; 0x105fa <DataflashManager_ReadBlocks+0x80>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10602:	82 ed       	ldi	r24, 0xD2	; 210
   10604:	b8 2e       	mov	r11, r24
   10606:	a8 c0       	rjmp	.+336    	; 0x10758 <DataflashManager_ReadBlocks+0x1de>

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
   10608:	10 e2       	ldi	r17, 0x20	; 32
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
   1060a:	80 91 e8 00 	lds	r24, 0x00E8

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if the endpoint is currently full */
			if (!(Endpoint_IsReadWriteAllowed()))
   1060e:	85 fd       	sbrc	r24, 5
   10610:	0a c0       	rjmp	.+20     	; 0x10626 <DataflashManager_ReadBlocks+0xac>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   10612:	80 91 e8 00 	lds	r24, 0x00E8
   10616:	8e 77       	andi	r24, 0x7E	; 126
   10618:	80 93 e8 00 	sts	0x00E8, r24
			{
				/* Clear the endpoint bank to send its contents to the host */
				Endpoint_ClearIN();

				/* Wait until the endpoint is ready for more data */
				if (Endpoint_WaitUntilReady())
   1061c:	0e 94 b4 a4 	call	0x14968	; 0x14968 <Endpoint_WaitUntilReady>
   10620:	88 23       	and	r24, r24
   10622:	09 f0       	breq	.+2      	; 0x10626 <DataflashManager_ReadBlocks+0xac>
   10624:	a9 c0       	rjmp	.+338    	; 0x10778 <DataflashManager_ReadBlocks+0x1fe>
				  return;
			}

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
   10626:	00 34       	cpi	r16, 0x40	; 64
   10628:	e1 f4       	brne	.+56     	; 0x10662 <DataflashManager_ReadBlocks+0xe8>
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
   1062a:	21 96       	adiw	r28, 0x01	; 1

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
   1062c:	ce 01       	movw	r24, r28
   1062e:	26 de       	rcall	.-948    	; 0x1027c <Dataflash_SelectChipFromPage>
   10630:	be bc       	out	0x2e, r11	; 46
				while (!(SPSR & (1 << SPIF)));
   10632:	0d b4       	in	r0, 0x2d	; 45
   10634:	07 fe       	sbrs	r0, 7
   10636:	fd cf       	rjmp	.-6      	; 0x10632 <DataflashManager_ReadBlocks+0xb8>

				/* Send the Dataflash main memory page read command */
				Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
				Dataflash_SendAddressBytes(CurrDFPage, 0);
   10638:	ce 01       	movw	r24, r28
   1063a:	60 e0       	ldi	r22, 0x00	; 0
   1063c:	70 e0       	ldi	r23, 0x00	; 0
   1063e:	49 de       	rcall	.-878    	; 0x102d2 <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10640:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   10642:	0d b4       	in	r0, 0x2d	; 45
   10644:	07 fe       	sbrs	r0, 7
   10646:	fd cf       	rjmp	.-6      	; 0x10642 <DataflashManager_ReadBlocks+0xc8>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10648:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   1064a:	0d b4       	in	r0, 0x2d	; 45
   1064c:	07 fe       	sbrs	r0, 7
   1064e:	fd cf       	rjmp	.-6      	; 0x1064a <DataflashManager_ReadBlocks+0xd0>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10650:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   10652:	0d b4       	in	r0, 0x2d	; 45
   10654:	07 fe       	sbrs	r0, 7
   10656:	fd cf       	rjmp	.-6      	; 0x10652 <DataflashManager_ReadBlocks+0xd8>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10658:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   1065a:	0d b4       	in	r0, 0x2d	; 45
   1065c:	07 fe       	sbrs	r0, 7
   1065e:	fd cf       	rjmp	.-6      	; 0x1065a <DataflashManager_ReadBlocks+0xe0>

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
   10660:	00 e0       	ldi	r16, 0x00	; 0
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   10662:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   10664:	0d b4       	in	r0, 0x2d	; 45
   10666:	07 fe       	sbrs	r0, 7
   10668:	fd cf       	rjmp	.-6      	; 0x10664 <DataflashManager_ReadBlocks+0xea>
				return SPDR;
   1066a:	8e b5       	in	r24, 0x2e	; 46
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
   1066c:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   10670:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   10672:	0d b4       	in	r0, 0x2d	; 45
   10674:	07 fe       	sbrs	r0, 7
   10676:	fd cf       	rjmp	.-6      	; 0x10672 <DataflashManager_ReadBlocks+0xf8>
				return SPDR;
   10678:	8e b5       	in	r24, 0x2e	; 46
   1067a:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   1067e:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   10680:	0d b4       	in	r0, 0x2d	; 45
   10682:	07 fe       	sbrs	r0, 7
   10684:	fd cf       	rjmp	.-6      	; 0x10680 <DataflashManager_ReadBlocks+0x106>
				return SPDR;
   10686:	8e b5       	in	r24, 0x2e	; 46
   10688:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   1068c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   1068e:	0d b4       	in	r0, 0x2d	; 45
   10690:	07 fe       	sbrs	r0, 7
   10692:	fd cf       	rjmp	.-6      	; 0x1068e <DataflashManager_ReadBlocks+0x114>
				return SPDR;
   10694:	8e b5       	in	r24, 0x2e	; 46
   10696:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   1069a:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   1069c:	0d b4       	in	r0, 0x2d	; 45
   1069e:	07 fe       	sbrs	r0, 7
   106a0:	fd cf       	rjmp	.-6      	; 0x1069c <DataflashManager_ReadBlocks+0x122>
				return SPDR;
   106a2:	8e b5       	in	r24, 0x2e	; 46
   106a4:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   106a8:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   106aa:	0d b4       	in	r0, 0x2d	; 45
   106ac:	07 fe       	sbrs	r0, 7
   106ae:	fd cf       	rjmp	.-6      	; 0x106aa <DataflashManager_ReadBlocks+0x130>
				return SPDR;
   106b0:	8e b5       	in	r24, 0x2e	; 46
   106b2:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   106b6:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   106b8:	0d b4       	in	r0, 0x2d	; 45
   106ba:	07 fe       	sbrs	r0, 7
   106bc:	fd cf       	rjmp	.-6      	; 0x106b8 <DataflashManager_ReadBlocks+0x13e>
				return SPDR;
   106be:	8e b5       	in	r24, 0x2e	; 46
   106c0:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   106c4:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   106c6:	0d b4       	in	r0, 0x2d	; 45
   106c8:	07 fe       	sbrs	r0, 7
   106ca:	fd cf       	rjmp	.-6      	; 0x106c6 <DataflashManager_ReadBlocks+0x14c>
				return SPDR;
   106cc:	8e b5       	in	r24, 0x2e	; 46
   106ce:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   106d2:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   106d4:	0d b4       	in	r0, 0x2d	; 45
   106d6:	07 fe       	sbrs	r0, 7
   106d8:	fd cf       	rjmp	.-6      	; 0x106d4 <DataflashManager_ReadBlocks+0x15a>
				return SPDR;
   106da:	8e b5       	in	r24, 0x2e	; 46
   106dc:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   106e0:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   106e2:	0d b4       	in	r0, 0x2d	; 45
   106e4:	07 fe       	sbrs	r0, 7
   106e6:	fd cf       	rjmp	.-6      	; 0x106e2 <DataflashManager_ReadBlocks+0x168>
				return SPDR;
   106e8:	8e b5       	in	r24, 0x2e	; 46
   106ea:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   106ee:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   106f0:	0d b4       	in	r0, 0x2d	; 45
   106f2:	07 fe       	sbrs	r0, 7
   106f4:	fd cf       	rjmp	.-6      	; 0x106f0 <DataflashManager_ReadBlocks+0x176>
				return SPDR;
   106f6:	8e b5       	in	r24, 0x2e	; 46
   106f8:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   106fc:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   106fe:	0d b4       	in	r0, 0x2d	; 45
   10700:	07 fe       	sbrs	r0, 7
   10702:	fd cf       	rjmp	.-6      	; 0x106fe <DataflashManager_ReadBlocks+0x184>
				return SPDR;
   10704:	8e b5       	in	r24, 0x2e	; 46
   10706:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   1070a:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   1070c:	0d b4       	in	r0, 0x2d	; 45
   1070e:	07 fe       	sbrs	r0, 7
   10710:	fd cf       	rjmp	.-6      	; 0x1070c <DataflashManager_ReadBlocks+0x192>
				return SPDR;
   10712:	8e b5       	in	r24, 0x2e	; 46
   10714:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   10718:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   1071a:	0d b4       	in	r0, 0x2d	; 45
   1071c:	07 fe       	sbrs	r0, 7
   1071e:	fd cf       	rjmp	.-6      	; 0x1071a <DataflashManager_ReadBlocks+0x1a0>
				return SPDR;
   10720:	8e b5       	in	r24, 0x2e	; 46
   10722:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   10726:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   10728:	0d b4       	in	r0, 0x2d	; 45
   1072a:	07 fe       	sbrs	r0, 7
   1072c:	fd cf       	rjmp	.-6      	; 0x10728 <DataflashManager_ReadBlocks+0x1ae>
				return SPDR;
   1072e:	8e b5       	in	r24, 0x2e	; 46
   10730:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   10734:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   10736:	0d b4       	in	r0, 0x2d	; 45
   10738:	07 fe       	sbrs	r0, 7
   1073a:	fd cf       	rjmp	.-6      	; 0x10736 <DataflashManager_ReadBlocks+0x1bc>
				return SPDR;
   1073c:	8e b5       	in	r24, 0x2e	; 46
   1073e:	80 93 f1 00 	sts	0x00F1, r24

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;

			/* Check if the current command is being aborted by the host */
			if (MSInterfaceInfo->State.IsMassStoreReset)
   10742:	f6 01       	movw	r30, r12
   10744:	80 ad       	ldd	r24, Z+56	; 0x38
   10746:	88 23       	and	r24, r24
   10748:	b9 f4       	brne	.+46     	; 0x10778 <DataflashManager_ReadBlocks+0x1fe>
			Endpoint_Write_8(Dataflash_ReceiveByte());
			Endpoint_Write_8(Dataflash_ReceiveByte());
			Endpoint_Write_8(Dataflash_ReceiveByte());

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
   1074a:	0f 5f       	subi	r16, 0xFF	; 255
   1074c:	11 50       	subi	r17, 0x01	; 1
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
   1074e:	09 f0       	breq	.+2      	; 0x10752 <DataflashManager_ReadBlocks+0x1d8>
   10750:	5c cf       	rjmp	.-328    	; 0x1060a <DataflashManager_ReadBlocks+0x90>
			if (MSInterfaceInfo->State.IsMassStoreReset)
			  return;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
   10752:	08 94       	sec
   10754:	e1 08       	sbc	r14, r1
   10756:	f1 08       	sbc	r15, r1

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
   10758:	e1 14       	cp	r14, r1
   1075a:	f1 04       	cpc	r15, r1
   1075c:	09 f0       	breq	.+2      	; 0x10760 <DataflashManager_ReadBlocks+0x1e6>
   1075e:	54 cf       	rjmp	.-344    	; 0x10608 <DataflashManager_ReadBlocks+0x8e>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
   10760:	80 91 e8 00 	lds	r24, 0x00E8
		/* Decrement the blocks remaining counter */
		TotalBlocks--;
	}

	/* If the endpoint is full, send its contents to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
   10764:	85 fd       	sbrc	r24, 5
   10766:	05 c0       	rjmp	.+10     	; 0x10772 <DataflashManager_ReadBlocks+0x1f8>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   10768:	80 91 e8 00 	lds	r24, 0x00E8
   1076c:	8e 77       	andi	r24, 0x7E	; 126
   1076e:	80 93 e8 00 	sts	0x00E8, r24
   10772:	8e b1       	in	r24, 0x0e	; 14
   10774:	83 60       	ori	r24, 0x03	; 3
   10776:	8e b9       	out	0x0e, r24	; 14
	  Endpoint_ClearIN();

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
   10778:	df 91       	pop	r29
   1077a:	cf 91       	pop	r28
   1077c:	1f 91       	pop	r17
   1077e:	0f 91       	pop	r16
   10780:	ff 90       	pop	r15
   10782:	ef 90       	pop	r14
   10784:	df 90       	pop	r13
   10786:	cf 90       	pop	r12
   10788:	bf 90       	pop	r11
   1078a:	08 95       	ret

0001078c <DataflashManager_WriteBlocks_RAM>:
 *  \param[in] BufferPtr     Pointer to the data source RAM buffer
 */
void DataflashManager_WriteBlocks_RAM(const uint32_t BlockAddress,
                                      uint16_t TotalBlocks,
                                      const uint8_t* BufferPtr)
{
   1078c:	6f 92       	push	r6
   1078e:	7f 92       	push	r7
   10790:	8f 92       	push	r8
   10792:	9f 92       	push	r9
   10794:	af 92       	push	r10
   10796:	bf 92       	push	r11
   10798:	cf 92       	push	r12
   1079a:	df 92       	push	r13
   1079c:	ef 92       	push	r14
   1079e:	ff 92       	push	r15
   107a0:	0f 93       	push	r16
   107a2:	1f 93       	push	r17
   107a4:	cf 93       	push	r28
   107a6:	df 93       	push	r29
   107a8:	5a 01       	movw	r10, r20
   107aa:	39 01       	movw	r6, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
   107ac:	9b 01       	movw	r18, r22
   107ae:	ac 01       	movw	r20, r24
   107b0:	19 e0       	ldi	r17, 0x09	; 9
   107b2:	22 0f       	add	r18, r18
   107b4:	33 1f       	adc	r19, r19
   107b6:	44 1f       	adc	r20, r20
   107b8:	55 1f       	adc	r21, r21
   107ba:	1a 95       	dec	r17
   107bc:	d1 f7       	brne	.-12     	; 0x107b2 <DataflashManager_WriteBlocks_RAM+0x26>
   107be:	ba e0       	ldi	r27, 0x0A	; 10
   107c0:	56 95       	lsr	r21
   107c2:	47 95       	ror	r20
   107c4:	37 95       	ror	r19
   107c6:	27 95       	ror	r18
   107c8:	ba 95       	dec	r27
   107ca:	d1 f7       	brne	.-12     	; 0x107c0 <DataflashManager_WriteBlocks_RAM+0x34>
   107cc:	e9 01       	movw	r28, r18
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
   107ce:	8b 01       	movw	r16, r22
   107d0:	10 2f       	mov	r17, r16
   107d2:	00 27       	eor	r16, r16
   107d4:	11 0f       	add	r17, r17
   107d6:	13 70       	andi	r17, 0x03	; 3
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
   107d8:	c8 01       	movw	r24, r16
   107da:	f4 e0       	ldi	r31, 0x04	; 4
   107dc:	96 95       	lsr	r25
   107de:	87 95       	ror	r24
   107e0:	fa 95       	dec	r31
   107e2:	e1 f7       	brne	.-8      	; 0x107dc <DataflashManager_WriteBlocks_RAM+0x50>
   107e4:	d8 2e       	mov	r13, r24
	bool     UsingSecondBuffer   = false;

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
   107e6:	c9 01       	movw	r24, r18
   107e8:	49 dd       	rcall	.-1390   	; 0x1027c <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   107ea:	83 e5       	ldi	r24, 0x53	; 83
   107ec:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   107ee:	0d b4       	in	r0, 0x2d	; 45
   107f0:	07 fe       	sbrs	r0, 7
   107f2:	fd cf       	rjmp	.-6      	; 0x107ee <DataflashManager_WriteBlocks_RAM+0x62>

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
	/* Copy selected dataflash's current page contents to the Dataflash buffer */
	Dataflash_SendByte(DF_CMD_MAINMEMTOBUFF1);
	Dataflash_SendAddressBytes(CurrDFPage, 0);
   107f4:	ce 01       	movw	r24, r28
   107f6:	60 e0       	ldi	r22, 0x00	; 0
   107f8:	70 e0       	ldi	r23, 0x00	; 0
   107fa:	6b dd       	rcall	.-1322   	; 0x102d2 <Dataflash_SendAddressBytes>
	Dataflash_WaitWhileBusy();
   107fc:	5c dd       	rcall	.-1352   	; 0x102b6 <Dataflash_WaitWhileBusy>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   107fe:	84 e8       	ldi	r24, 0x84	; 132
   10800:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10802:	0d b4       	in	r0, 0x2d	; 45
   10804:	07 fe       	sbrs	r0, 7
   10806:	fd cf       	rjmp	.-6      	; 0x10802 <DataflashManager_WriteBlocks_RAM+0x76>
#endif

	/* Send the Dataflash buffer write command */
	Dataflash_SendByte(DF_CMD_BUFF1WRITE);
	Dataflash_SendAddressBytes(0, CurrDFPageByte);
   10808:	80 e0       	ldi	r24, 0x00	; 0
   1080a:	90 e0       	ldi	r25, 0x00	; 0
   1080c:	b8 01       	movw	r22, r16
   1080e:	61 dd       	rcall	.-1342   	; 0x102d2 <Dataflash_SendAddressBytes>
   10810:	75 01       	movw	r14, r10
   10812:	e5 e0       	ldi	r30, 0x05	; 5
   10814:	ee 0c       	add	r14, r14
   10816:	ff 1c       	adc	r15, r15
   10818:	ea 95       	dec	r30
   1081a:	e1 f7       	brne	.-8      	; 0x10814 <DataflashManager_WriteBlocks_RAM+0x88>
                                      const uint8_t* BufferPtr)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
	bool     UsingSecondBuffer   = false;
   1081c:	cc 24       	eor	r12, r12
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;

				/* Once all the Dataflash ICs have had their first buffers filled, switch buffers to maintain throughput */
				if (Dataflash_GetSelectedChip() == DATAFLASH_CHIP_MASK(DATAFLASH_TOTALCHIPS))
				  UsingSecondBuffer = !(UsingSecondBuffer);
   1081e:	88 24       	eor	r8, r8
   10820:	83 94       	inc	r8

	/* Send the Dataflash buffer write command */
	Dataflash_SendByte(DF_CMD_BUFF1WRITE);
	Dataflash_SendAddressBytes(0, CurrDFPageByte);

	while (TotalBlocks)
   10822:	5b c0       	rjmp	.+182    	; 0x108da <DataflashManager_WriteBlocks_RAM+0x14e>
   10824:	83 01       	movw	r16, r6
   10826:	70 e2       	ldi	r23, 0x20	; 32
   10828:	97 2e       	mov	r9, r23

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
   1082a:	8d 2d       	mov	r24, r13
   1082c:	80 34       	cpi	r24, 0x40	; 64
   1082e:	09 f0       	breq	.+2      	; 0x10832 <DataflashManager_WriteBlocks_RAM+0xa6>
   10830:	3a c0       	rjmp	.+116    	; 0x108a6 <DataflashManager_WriteBlocks_RAM+0x11a>
			{
				/* Write the Dataflash buffer contents back to the Dataflash page */
				Dataflash_WaitWhileBusy();
   10832:	41 dd       	rcall	.-1406   	; 0x102b6 <Dataflash_WaitWhileBusy>
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
   10834:	cc 20       	and	r12, r12
   10836:	11 f0       	breq	.+4      	; 0x1083c <DataflashManager_WriteBlocks_RAM+0xb0>
   10838:	86 e8       	ldi	r24, 0x86	; 134
   1083a:	01 c0       	rjmp	.+2      	; 0x1083e <DataflashManager_WriteBlocks_RAM+0xb2>
   1083c:	83 e8       	ldi	r24, 0x83	; 131
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   1083e:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10840:	0d b4       	in	r0, 0x2d	; 45
   10842:	07 fe       	sbrs	r0, 7
   10844:	fd cf       	rjmp	.-6      	; 0x10840 <DataflashManager_WriteBlocks_RAM+0xb4>
				Dataflash_SendAddressBytes(CurrDFPage, 0);
   10846:	ce 01       	movw	r24, r28
   10848:	60 e0       	ldi	r22, 0x00	; 0
   1084a:	70 e0       	ldi	r23, 0x00	; 0
   1084c:	42 dd       	rcall	.-1404   	; 0x102d2 <Dataflash_SendAddressBytes>

				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
   1084e:	21 96       	adiw	r28, 0x01	; 1
			 *          or a DATAFLASH_CHIPn mask (where n is the chip number).
			 */
			static inline uint8_t Dataflash_GetSelectedChip(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Dataflash_GetSelectedChip(void)
			{
				return (~DATAFLASH_CHIPCS_PORT & DATAFLASH_CHIPCS_MASK);
   10850:	8e b1       	in	r24, 0x0e	; 14
   10852:	80 95       	com	r24
   10854:	83 70       	andi	r24, 0x03	; 3

				/* Once all the Dataflash ICs have had their first buffers filled, switch buffers to maintain throughput */
				if (Dataflash_GetSelectedChip() == DATAFLASH_CHIP_MASK(DATAFLASH_TOTALCHIPS))
   10856:	82 30       	cpi	r24, 0x02	; 2
   10858:	09 f4       	brne	.+2      	; 0x1085c <DataflashManager_WriteBlocks_RAM+0xd0>
				  UsingSecondBuffer = !(UsingSecondBuffer);
   1085a:	c8 24       	eor	r12, r8

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
   1085c:	ce 01       	movw	r24, r28
   1085e:	0e dd       	rcall	.-1508   	; 0x1027c <Dataflash_SelectChipFromPage>

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
				/* If less than one Dataflash page remaining, copy over the existing page to preserve trailing data */
				if ((TotalBlocks * (VIRTUAL_MEMORY_BLOCK_SIZE >> 4)) < (DATAFLASH_PAGE_SIZE >> 4))
   10860:	90 e4       	ldi	r25, 0x40	; 64
   10862:	e9 16       	cp	r14, r25
   10864:	f1 04       	cpc	r15, r1
   10866:	78 f4       	brcc	.+30     	; 0x10886 <DataflashManager_WriteBlocks_RAM+0xfa>
				{
					/* Copy selected dataflash's current page contents to the Dataflash buffer */
					Dataflash_WaitWhileBusy();
   10868:	26 dd       	rcall	.-1460   	; 0x102b6 <Dataflash_WaitWhileBusy>
					Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_MAINMEMTOBUFF2 : DF_CMD_MAINMEMTOBUFF1);
   1086a:	cc 20       	and	r12, r12
   1086c:	11 f0       	breq	.+4      	; 0x10872 <DataflashManager_WriteBlocks_RAM+0xe6>
   1086e:	85 e5       	ldi	r24, 0x55	; 85
   10870:	01 c0       	rjmp	.+2      	; 0x10874 <DataflashManager_WriteBlocks_RAM+0xe8>
   10872:	83 e5       	ldi	r24, 0x53	; 83
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10874:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10876:	0d b4       	in	r0, 0x2d	; 45
   10878:	07 fe       	sbrs	r0, 7
   1087a:	fd cf       	rjmp	.-6      	; 0x10876 <DataflashManager_WriteBlocks_RAM+0xea>
					Dataflash_SendAddressBytes(CurrDFPage, 0);
   1087c:	ce 01       	movw	r24, r28
   1087e:	60 e0       	ldi	r22, 0x00	; 0
   10880:	70 e0       	ldi	r23, 0x00	; 0
   10882:	27 dd       	rcall	.-1458   	; 0x102d2 <Dataflash_SendAddressBytes>
					Dataflash_WaitWhileBusy();
   10884:	18 dd       	rcall	.-1488   	; 0x102b6 <Dataflash_WaitWhileBusy>
				}
#endif

				/* Send the Dataflash buffer write command */
				Dataflash_ToggleSelectedChipCS();
   10886:	0d dd       	rcall	.-1510   	; 0x102a2 <Dataflash_ToggleSelectedChipCS>
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2WRITE : DF_CMD_BUFF1WRITE);
   10888:	cc 20       	and	r12, r12
   1088a:	11 f0       	breq	.+4      	; 0x10890 <DataflashManager_WriteBlocks_RAM+0x104>
   1088c:	87 e8       	ldi	r24, 0x87	; 135
   1088e:	01 c0       	rjmp	.+2      	; 0x10892 <DataflashManager_WriteBlocks_RAM+0x106>
   10890:	84 e8       	ldi	r24, 0x84	; 132
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10892:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10894:	0d b4       	in	r0, 0x2d	; 45
   10896:	07 fe       	sbrs	r0, 7
   10898:	fd cf       	rjmp	.-6      	; 0x10894 <DataflashManager_WriteBlocks_RAM+0x108>
				Dataflash_SendAddressBytes(0, 0);
   1089a:	80 e0       	ldi	r24, 0x00	; 0
   1089c:	90 e0       	ldi	r25, 0x00	; 0
   1089e:	60 e0       	ldi	r22, 0x00	; 0
   108a0:	70 e0       	ldi	r23, 0x00	; 0
   108a2:	17 dd       	rcall	.-1490   	; 0x102d2 <Dataflash_SendAddressBytes>
				Dataflash_WaitWhileBusy();
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
				Dataflash_SendAddressBytes(CurrDFPage, 0);

				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
   108a4:	dd 24       	eor	r13, r13
   108a6:	f8 01       	movw	r30, r16
   108a8:	80 e1       	ldi	r24, 0x10	; 16
				Dataflash_SendAddressBytes(0, 0);
			}

			/* Write one 16-byte chunk of data to the Dataflash */
			for (uint8_t ByteNum = 0; ByteNum < 16; ByteNum++)
			  Dataflash_SendByte(*(BufferPtr++));
   108aa:	91 91       	ld	r25, Z+
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   108ac:	9e bd       	out	0x2e, r25	; 46
				while (!(SPSR & (1 << SPIF)));
   108ae:	0d b4       	in	r0, 0x2d	; 45
   108b0:	07 fe       	sbrs	r0, 7
   108b2:	fd cf       	rjmp	.-6      	; 0x108ae <DataflashManager_WriteBlocks_RAM+0x122>
   108b4:	81 50       	subi	r24, 0x01	; 1
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2WRITE : DF_CMD_BUFF1WRITE);
				Dataflash_SendAddressBytes(0, 0);
			}

			/* Write one 16-byte chunk of data to the Dataflash */
			for (uint8_t ByteNum = 0; ByteNum < 16; ByteNum++)
   108b6:	c9 f7       	brne	.-14     	; 0x108aa <DataflashManager_WriteBlocks_RAM+0x11e>
   108b8:	00 5f       	subi	r16, 0xF0	; 240
   108ba:	1f 4f       	sbci	r17, 0xFF	; 255
			  Dataflash_SendByte(*(BufferPtr++));

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
   108bc:	d3 94       	inc	r13
   108be:	9a 94       	dec	r9
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
   108c0:	09 f0       	breq	.+2      	; 0x108c4 <DataflashManager_WriteBlocks_RAM+0x138>
   108c2:	b3 cf       	rjmp	.-154    	; 0x1082a <DataflashManager_WriteBlocks_RAM+0x9e>
   108c4:	80 e0       	ldi	r24, 0x00	; 0
   108c6:	92 e0       	ldi	r25, 0x02	; 2
   108c8:	68 0e       	add	r6, r24
   108ca:	79 1e       	adc	r7, r25
			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
   108cc:	08 94       	sec
   108ce:	a1 08       	sbc	r10, r1
   108d0:	b1 08       	sbc	r11, r1
   108d2:	80 ee       	ldi	r24, 0xE0	; 224
   108d4:	9f ef       	ldi	r25, 0xFF	; 255
   108d6:	e8 0e       	add	r14, r24
   108d8:	f9 1e       	adc	r15, r25

	/* Send the Dataflash buffer write command */
	Dataflash_SendByte(DF_CMD_BUFF1WRITE);
	Dataflash_SendAddressBytes(0, CurrDFPageByte);

	while (TotalBlocks)
   108da:	a1 14       	cp	r10, r1
   108dc:	b1 04       	cpc	r11, r1
   108de:	09 f0       	breq	.+2      	; 0x108e2 <DataflashManager_WriteBlocks_RAM+0x156>
   108e0:	a1 cf       	rjmp	.-190    	; 0x10824 <DataflashManager_WriteBlocks_RAM+0x98>
		/* Decrement the blocks remaining counter */
		TotalBlocks--;
	}

	/* Write the Dataflash buffer contents back to the Dataflash page */
	Dataflash_WaitWhileBusy();
   108e2:	e9 dc       	rcall	.-1582   	; 0x102b6 <Dataflash_WaitWhileBusy>
	Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
   108e4:	cc 20       	and	r12, r12
   108e6:	11 f0       	breq	.+4      	; 0x108ec <DataflashManager_WriteBlocks_RAM+0x160>
   108e8:	86 e8       	ldi	r24, 0x86	; 134
   108ea:	01 c0       	rjmp	.+2      	; 0x108ee <DataflashManager_WriteBlocks_RAM+0x162>
   108ec:	83 e8       	ldi	r24, 0x83	; 131
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   108ee:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   108f0:	0d b4       	in	r0, 0x2d	; 45
   108f2:	07 fe       	sbrs	r0, 7
   108f4:	fd cf       	rjmp	.-6      	; 0x108f0 <DataflashManager_WriteBlocks_RAM+0x164>
	Dataflash_SendAddressBytes(CurrDFPage, 0x00);
   108f6:	ce 01       	movw	r24, r28
   108f8:	60 e0       	ldi	r22, 0x00	; 0
   108fa:	70 e0       	ldi	r23, 0x00	; 0
   108fc:	ea dc       	rcall	.-1580   	; 0x102d2 <Dataflash_SendAddressBytes>
	Dataflash_WaitWhileBusy();
   108fe:	db dc       	rcall	.-1610   	; 0x102b6 <Dataflash_WaitWhileBusy>
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
   10900:	8e b1       	in	r24, 0x0e	; 14
   10902:	83 60       	ori	r24, 0x03	; 3
   10904:	8e b9       	out	0x0e, r24	; 14

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
   10906:	df 91       	pop	r29
   10908:	cf 91       	pop	r28
   1090a:	1f 91       	pop	r17
   1090c:	0f 91       	pop	r16
   1090e:	ff 90       	pop	r15
   10910:	ef 90       	pop	r14
   10912:	df 90       	pop	r13
   10914:	cf 90       	pop	r12
   10916:	bf 90       	pop	r11
   10918:	af 90       	pop	r10
   1091a:	9f 90       	pop	r9
   1091c:	8f 90       	pop	r8
   1091e:	7f 90       	pop	r7
   10920:	6f 90       	pop	r6
   10922:	08 95       	ret

00010924 <DataflashManager_ReadBlocks_RAM>:
 *  \param[out] BufferPtr    Pointer to the data destination RAM buffer
 */
void DataflashManager_ReadBlocks_RAM(const uint32_t BlockAddress,
                                     uint16_t TotalBlocks,
                                     uint8_t* BufferPtr)
{
   10924:	9f 92       	push	r9
   10926:	af 92       	push	r10
   10928:	bf 92       	push	r11
   1092a:	cf 92       	push	r12
   1092c:	df 92       	push	r13
   1092e:	ef 92       	push	r14
   10930:	ff 92       	push	r15
   10932:	0f 93       	push	r16
   10934:	1f 93       	push	r17
   10936:	cf 93       	push	r28
   10938:	df 93       	push	r29
   1093a:	5a 01       	movw	r10, r20
   1093c:	69 01       	movw	r12, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
   1093e:	9b 01       	movw	r18, r22
   10940:	ac 01       	movw	r20, r24
   10942:	f9 e0       	ldi	r31, 0x09	; 9
   10944:	22 0f       	add	r18, r18
   10946:	33 1f       	adc	r19, r19
   10948:	44 1f       	adc	r20, r20
   1094a:	55 1f       	adc	r21, r21
   1094c:	fa 95       	dec	r31
   1094e:	d1 f7       	brne	.-12     	; 0x10944 <DataflashManager_ReadBlocks_RAM+0x20>
   10950:	ea e0       	ldi	r30, 0x0A	; 10
   10952:	56 95       	lsr	r21
   10954:	47 95       	ror	r20
   10956:	37 95       	ror	r19
   10958:	27 95       	ror	r18
   1095a:	ea 95       	dec	r30
   1095c:	d1 f7       	brne	.-12     	; 0x10952 <DataflashManager_ReadBlocks_RAM+0x2e>
   1095e:	e9 01       	movw	r28, r18
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
   10960:	8b 01       	movw	r16, r22
   10962:	10 2f       	mov	r17, r16
   10964:	00 27       	eor	r16, r16
   10966:	11 0f       	add	r17, r17
   10968:	13 70       	andi	r17, 0x03	; 3
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
   1096a:	c8 01       	movw	r24, r16
   1096c:	44 e0       	ldi	r20, 0x04	; 4
   1096e:	96 95       	lsr	r25
   10970:	87 95       	ror	r24
   10972:	4a 95       	dec	r20
   10974:	e1 f7       	brne	.-8      	; 0x1096e <DataflashManager_ReadBlocks_RAM+0x4a>
   10976:	f8 2e       	mov	r15, r24

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
   10978:	c9 01       	movw	r24, r18
   1097a:	80 dc       	rcall	.-1792   	; 0x1027c <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   1097c:	82 ed       	ldi	r24, 0xD2	; 210
   1097e:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10980:	0d b4       	in	r0, 0x2d	; 45
   10982:	07 fe       	sbrs	r0, 7
   10984:	fd cf       	rjmp	.-6      	; 0x10980 <DataflashManager_ReadBlocks_RAM+0x5c>

	/* Send the Dataflash main memory page read command */
	Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
	Dataflash_SendAddressBytes(CurrDFPage, CurrDFPageByte);
   10986:	ce 01       	movw	r24, r28
   10988:	b8 01       	movw	r22, r16
   1098a:	a3 dc       	rcall	.-1722   	; 0x102d2 <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   1098c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   1098e:	0d b4       	in	r0, 0x2d	; 45
   10990:	07 fe       	sbrs	r0, 7
   10992:	fd cf       	rjmp	.-6      	; 0x1098e <DataflashManager_ReadBlocks_RAM+0x6a>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10994:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   10996:	0d b4       	in	r0, 0x2d	; 45
   10998:	07 fe       	sbrs	r0, 7
   1099a:	fd cf       	rjmp	.-6      	; 0x10996 <DataflashManager_ReadBlocks_RAM+0x72>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   1099c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   1099e:	0d b4       	in	r0, 0x2d	; 45
   109a0:	07 fe       	sbrs	r0, 7
   109a2:	fd cf       	rjmp	.-6      	; 0x1099e <DataflashManager_ReadBlocks_RAM+0x7a>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   109a4:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   109a6:	0d b4       	in	r0, 0x2d	; 45
   109a8:	07 fe       	sbrs	r0, 7
   109aa:	fd cf       	rjmp	.-6      	; 0x109a6 <DataflashManager_ReadBlocks_RAM+0x82>
   109ac:	39 c0       	rjmp	.+114    	; 0x10a20 <DataflashManager_ReadBlocks_RAM+0xfc>
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	while (TotalBlocks)
   109ae:	86 01       	movw	r16, r12
   109b0:	80 e2       	ldi	r24, 0x20	; 32
   109b2:	e8 2e       	mov	r14, r24

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
   109b4:	8f 2d       	mov	r24, r15
   109b6:	80 34       	cpi	r24, 0x40	; 64
   109b8:	e1 f4       	brne	.+56     	; 0x109f2 <DataflashManager_ReadBlocks_RAM+0xce>
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
   109ba:	21 96       	adiw	r28, 0x01	; 1

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
   109bc:	ce 01       	movw	r24, r28
   109be:	5e dc       	rcall	.-1860   	; 0x1027c <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   109c0:	9e bc       	out	0x2e, r9	; 46
				while (!(SPSR & (1 << SPIF)));
   109c2:	0d b4       	in	r0, 0x2d	; 45
   109c4:	07 fe       	sbrs	r0, 7
   109c6:	fd cf       	rjmp	.-6      	; 0x109c2 <DataflashManager_ReadBlocks_RAM+0x9e>

				/* Send the Dataflash main memory page read command */
				Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
				Dataflash_SendAddressBytes(CurrDFPage, 0);
   109c8:	ce 01       	movw	r24, r28
   109ca:	60 e0       	ldi	r22, 0x00	; 0
   109cc:	70 e0       	ldi	r23, 0x00	; 0
   109ce:	81 dc       	rcall	.-1790   	; 0x102d2 <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   109d0:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   109d2:	0d b4       	in	r0, 0x2d	; 45
   109d4:	07 fe       	sbrs	r0, 7
   109d6:	fd cf       	rjmp	.-6      	; 0x109d2 <DataflashManager_ReadBlocks_RAM+0xae>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   109d8:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   109da:	0d b4       	in	r0, 0x2d	; 45
   109dc:	07 fe       	sbrs	r0, 7
   109de:	fd cf       	rjmp	.-6      	; 0x109da <DataflashManager_ReadBlocks_RAM+0xb6>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   109e0:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   109e2:	0d b4       	in	r0, 0x2d	; 45
   109e4:	07 fe       	sbrs	r0, 7
   109e6:	fd cf       	rjmp	.-6      	; 0x109e2 <DataflashManager_ReadBlocks_RAM+0xbe>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   109e8:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   109ea:	0d b4       	in	r0, 0x2d	; 45
   109ec:	07 fe       	sbrs	r0, 7
   109ee:	fd cf       	rjmp	.-6      	; 0x109ea <DataflashManager_ReadBlocks_RAM+0xc6>
		{
			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
   109f0:	ff 24       	eor	r15, r15
   109f2:	f8 01       	movw	r30, r16
   109f4:	80 e1       	ldi	r24, 0x10	; 16
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   109f6:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   109f8:	0d b4       	in	r0, 0x2d	; 45
   109fa:	07 fe       	sbrs	r0, 7
   109fc:	fd cf       	rjmp	.-6      	; 0x109f8 <DataflashManager_ReadBlocks_RAM+0xd4>
				return SPDR;
   109fe:	9e b5       	in	r25, 0x2e	; 46
				Dataflash_SendByte(0x00);
			}

			/* Read one 16-byte chunk of data from the Dataflash */
			for (uint8_t ByteNum = 0; ByteNum < 16; ByteNum++)
			  *(BufferPtr++) = Dataflash_ReceiveByte();
   10a00:	91 93       	st	Z+, r25
   10a02:	81 50       	subi	r24, 0x01	; 1
				Dataflash_SendByte(0x00);
				Dataflash_SendByte(0x00);
			}

			/* Read one 16-byte chunk of data from the Dataflash */
			for (uint8_t ByteNum = 0; ByteNum < 16; ByteNum++)
   10a04:	c1 f7       	brne	.-16     	; 0x109f6 <DataflashManager_ReadBlocks_RAM+0xd2>
   10a06:	00 5f       	subi	r16, 0xF0	; 240
   10a08:	1f 4f       	sbci	r17, 0xFF	; 255
			  *(BufferPtr++) = Dataflash_ReceiveByte();

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
   10a0a:	f3 94       	inc	r15
   10a0c:	ea 94       	dec	r14
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
   10a0e:	91 f6       	brne	.-92     	; 0x109b4 <DataflashManager_ReadBlocks_RAM+0x90>
   10a10:	80 e0       	ldi	r24, 0x00	; 0
   10a12:	92 e0       	ldi	r25, 0x02	; 2
   10a14:	c8 0e       	add	r12, r24
   10a16:	d9 1e       	adc	r13, r25
			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
   10a18:	08 94       	sec
   10a1a:	a1 08       	sbc	r10, r1
   10a1c:	b1 08       	sbc	r11, r1
   10a1e:	02 c0       	rjmp	.+4      	; 0x10a24 <DataflashManager_ReadBlocks_RAM+0x100>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10a20:	02 ed       	ldi	r16, 0xD2	; 210
   10a22:	90 2e       	mov	r9, r16
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	while (TotalBlocks)
   10a24:	a1 14       	cp	r10, r1
   10a26:	b1 04       	cpc	r11, r1
   10a28:	09 f0       	breq	.+2      	; 0x10a2c <DataflashManager_ReadBlocks_RAM+0x108>
   10a2a:	c1 cf       	rjmp	.-126    	; 0x109ae <DataflashManager_ReadBlocks_RAM+0x8a>
   10a2c:	8e b1       	in	r24, 0x0e	; 14
   10a2e:	83 60       	ori	r24, 0x03	; 3
   10a30:	8e b9       	out	0x0e, r24	; 14
		TotalBlocks--;
	}

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
   10a32:	df 91       	pop	r29
   10a34:	cf 91       	pop	r28
   10a36:	1f 91       	pop	r17
   10a38:	0f 91       	pop	r16
   10a3a:	ff 90       	pop	r15
   10a3c:	ef 90       	pop	r14
   10a3e:	df 90       	pop	r13
   10a40:	cf 90       	pop	r12
   10a42:	bf 90       	pop	r11
   10a44:	af 90       	pop	r10
   10a46:	9f 90       	pop	r9
   10a48:	08 95       	ret

00010a4a <DataflashManager_ResetDataflashProtections>:
   10a4a:	8e b1       	in	r24, 0x0e	; 14
   10a4c:	83 60       	ori	r24, 0x03	; 3
   10a4e:	8e 7f       	andi	r24, 0xFE	; 254
   10a50:	8e b9       	out	0x0e, r24	; 14
   10a52:	87 ed       	ldi	r24, 0xD7	; 215
   10a54:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10a56:	0d b4       	in	r0, 0x2d	; 45
   10a58:	07 fe       	sbrs	r0, 7
   10a5a:	fd cf       	rjmp	.-6      	; 0x10a56 <DataflashManager_ResetDataflashProtections+0xc>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   10a5c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   10a5e:	0d b4       	in	r0, 0x2d	; 45
   10a60:	07 fe       	sbrs	r0, 7
   10a62:	fd cf       	rjmp	.-6      	; 0x10a5e <DataflashManager_ResetDataflashProtections+0x14>
	/* Select first Dataflash chip, send the read status register command */
	Dataflash_SelectChip(DATAFLASH_CHIP1);
	Dataflash_SendByte(DF_CMD_GETSTATUS);

	/* Check if sector protection is enabled */
	if (Dataflash_ReceiveByte() & DF_STATUS_SECTORPROTECTION_ON)
   10a64:	0e b4       	in	r0, 0x2e	; 46
   10a66:	01 fe       	sbrs	r0, 1
   10a68:	15 c0       	rjmp	.+42     	; 0x10a94 <DataflashManager_ResetDataflashProtections+0x4a>
	{
		Dataflash_ToggleSelectedChipCS();
   10a6a:	1b dc       	rcall	.-1994   	; 0x102a2 <Dataflash_ToggleSelectedChipCS>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10a6c:	8d e3       	ldi	r24, 0x3D	; 61
   10a6e:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10a70:	0d b4       	in	r0, 0x2d	; 45
   10a72:	07 fe       	sbrs	r0, 7
   10a74:	fd cf       	rjmp	.-6      	; 0x10a70 <DataflashManager_ResetDataflashProtections+0x26>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10a76:	8a e2       	ldi	r24, 0x2A	; 42
   10a78:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10a7a:	0d b4       	in	r0, 0x2d	; 45
   10a7c:	07 fe       	sbrs	r0, 7
   10a7e:	fd cf       	rjmp	.-6      	; 0x10a7a <DataflashManager_ResetDataflashProtections+0x30>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10a80:	8f e7       	ldi	r24, 0x7F	; 127
   10a82:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10a84:	0d b4       	in	r0, 0x2d	; 45
   10a86:	07 fe       	sbrs	r0, 7
   10a88:	fd cf       	rjmp	.-6      	; 0x10a84 <DataflashManager_ResetDataflashProtections+0x3a>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10a8a:	8a e9       	ldi	r24, 0x9A	; 154
   10a8c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10a8e:	0d b4       	in	r0, 0x2d	; 45
   10a90:	07 fe       	sbrs	r0, 7
   10a92:	fd cf       	rjmp	.-6      	; 0x10a8e <DataflashManager_ResetDataflashProtections+0x44>
   10a94:	8e b1       	in	r24, 0x0e	; 14
   10a96:	83 60       	ori	r24, 0x03	; 3
   10a98:	8d 7f       	andi	r24, 0xFD	; 253
   10a9a:	8e b9       	out	0x0e, r24	; 14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10a9c:	87 ed       	ldi	r24, 0xD7	; 215
   10a9e:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10aa0:	0d b4       	in	r0, 0x2d	; 45
   10aa2:	07 fe       	sbrs	r0, 7
   10aa4:	fd cf       	rjmp	.-6      	; 0x10aa0 <DataflashManager_ResetDataflashProtections+0x56>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   10aa6:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   10aa8:	0d b4       	in	r0, 0x2d	; 45
   10aaa:	07 fe       	sbrs	r0, 7
   10aac:	fd cf       	rjmp	.-6      	; 0x10aa8 <DataflashManager_ResetDataflashProtections+0x5e>
	#if (DATAFLASH_TOTALCHIPS == 2)
	Dataflash_SelectChip(DATAFLASH_CHIP2);
	Dataflash_SendByte(DF_CMD_GETSTATUS);

	/* Check if sector protection is enabled */
	if (Dataflash_ReceiveByte() & DF_STATUS_SECTORPROTECTION_ON)
   10aae:	0e b4       	in	r0, 0x2e	; 46
   10ab0:	01 fe       	sbrs	r0, 1
   10ab2:	15 c0       	rjmp	.+42     	; 0x10ade <DataflashManager_ResetDataflashProtections+0x94>
	{
		Dataflash_ToggleSelectedChipCS();
   10ab4:	f6 db       	rcall	.-2068   	; 0x102a2 <Dataflash_ToggleSelectedChipCS>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10ab6:	8d e3       	ldi	r24, 0x3D	; 61
   10ab8:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10aba:	0d b4       	in	r0, 0x2d	; 45
   10abc:	07 fe       	sbrs	r0, 7
   10abe:	fd cf       	rjmp	.-6      	; 0x10aba <DataflashManager_ResetDataflashProtections+0x70>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10ac0:	8a e2       	ldi	r24, 0x2A	; 42
   10ac2:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10ac4:	0d b4       	in	r0, 0x2d	; 45
   10ac6:	07 fe       	sbrs	r0, 7
   10ac8:	fd cf       	rjmp	.-6      	; 0x10ac4 <DataflashManager_ResetDataflashProtections+0x7a>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10aca:	8f e7       	ldi	r24, 0x7F	; 127
   10acc:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10ace:	0d b4       	in	r0, 0x2d	; 45
   10ad0:	07 fe       	sbrs	r0, 7
   10ad2:	fd cf       	rjmp	.-6      	; 0x10ace <DataflashManager_ResetDataflashProtections+0x84>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10ad4:	8a e9       	ldi	r24, 0x9A	; 154
   10ad6:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10ad8:	0d b4       	in	r0, 0x2d	; 45
   10ada:	07 fe       	sbrs	r0, 7
   10adc:	fd cf       	rjmp	.-6      	; 0x10ad8 <DataflashManager_ResetDataflashProtections+0x8e>
   10ade:	8e b1       	in	r24, 0x0e	; 14
   10ae0:	83 60       	ori	r24, 0x03	; 3
   10ae2:	8e b9       	out	0x0e, r24	; 14
	}
	#endif

	/* Deselect current Dataflash chip */
	Dataflash_DeselectChip();
}
   10ae4:	08 95       	ret

00010ae6 <DataflashManager_CheckDataflashOperation>:
   10ae6:	8e b1       	in	r24, 0x0e	; 14
   10ae8:	83 60       	ori	r24, 0x03	; 3
   10aea:	8e 7f       	andi	r24, 0xFE	; 254
   10aec:	8e b9       	out	0x0e, r24	; 14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10aee:	8f e9       	ldi	r24, 0x9F	; 159
   10af0:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10af2:	0d b4       	in	r0, 0x2d	; 45
   10af4:	07 fe       	sbrs	r0, 7
   10af6:	fd cf       	rjmp	.-6      	; 0x10af2 <DataflashManager_CheckDataflashOperation+0xc>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   10af8:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   10afa:	0d b4       	in	r0, 0x2d	; 45
   10afc:	07 fe       	sbrs	r0, 7
   10afe:	fd cf       	rjmp	.-6      	; 0x10afa <DataflashManager_CheckDataflashOperation+0x14>
				return SPDR;
   10b00:	9e b5       	in	r25, 0x2e	; 46
   10b02:	8e b1       	in	r24, 0x0e	; 14
   10b04:	83 60       	ori	r24, 0x03	; 3
   10b06:	8e b9       	out	0x0e, r24	; 14
	Dataflash_SendByte(DF_CMD_READMANUFACTURERDEVICEINFO);
	ReturnByte = Dataflash_ReceiveByte();
	Dataflash_DeselectChip();

	/* If returned data is invalid, fail the command */
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
   10b08:	9f 31       	cpi	r25, 0x1F	; 31
   10b0a:	b1 f4       	brne	.+44     	; 0x10b38 <DataflashManager_CheckDataflashOperation+0x52>
   10b0c:	8e b1       	in	r24, 0x0e	; 14
   10b0e:	83 60       	ori	r24, 0x03	; 3
   10b10:	8d 7f       	andi	r24, 0xFD	; 253
   10b12:	8e b9       	out	0x0e, r24	; 14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
   10b14:	8f e9       	ldi	r24, 0x9F	; 159
   10b16:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   10b18:	0d b4       	in	r0, 0x2d	; 45
   10b1a:	07 fe       	sbrs	r0, 7
   10b1c:	fd cf       	rjmp	.-6      	; 0x10b18 <DataflashManager_CheckDataflashOperation+0x32>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
   10b1e:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   10b20:	0d b4       	in	r0, 0x2d	; 45
   10b22:	07 fe       	sbrs	r0, 7
   10b24:	fd cf       	rjmp	.-6      	; 0x10b20 <DataflashManager_CheckDataflashOperation+0x3a>
				return SPDR;
   10b26:	9e b5       	in	r25, 0x2e	; 46
   10b28:	8e b1       	in	r24, 0x0e	; 14
   10b2a:	83 60       	ori	r24, 0x03	; 3
   10b2c:	8e b9       	out	0x0e, r24	; 14

/** Performs a simple test on the attached Dataflash IC(s) to ensure that they are working.
 *
 *  \return Boolean \c true if all media chips are working, \c false otherwise
 */
bool DataflashManager_CheckDataflashOperation(void)
   10b2e:	81 e0       	ldi	r24, 0x01	; 1
   10b30:	9f 31       	cpi	r25, 0x1F	; 31
   10b32:	19 f0       	breq	.+6      	; 0x10b3a <DataflashManager_CheckDataflashOperation+0x54>
   10b34:	80 e0       	ldi	r24, 0x00	; 0
   10b36:	08 95       	ret
	ReturnByte = Dataflash_ReceiveByte();
	Dataflash_DeselectChip();

	/* If returned data is invalid, fail the command */
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
	  return false;
   10b38:	80 e0       	ldi	r24, 0x00	; 0
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
	  return false;
	#endif

	return true;
}
   10b3a:	08 95       	ret

00010b3c <RTC_Init>:
   10b3c:	08 95       	ret

00010b3e <RTC_Tick500ms>:
   10b3e:	08 95       	ret

00010b40 <RTC_GetTimeDate>:
   10b40:	cf 92       	push	r12
   10b42:	df 92       	push	r13
   10b44:	ef 92       	push	r14
   10b46:	0f 93       	push	r16
   10b48:	1f 93       	push	r17
   10b4a:	df 93       	push	r29
   10b4c:	cf 93       	push	r28
   10b4e:	cd b7       	in	r28, 0x3d	; 61
   10b50:	de b7       	in	r29, 0x3e	; 62
   10b52:	28 97       	sbiw	r28, 0x08	; 8
   10b54:	0f b6       	in	r0, 0x3f	; 63
   10b56:	f8 94       	cli
   10b58:	de bf       	out	0x3e, r29	; 62
   10b5a:	0f be       	out	0x3f, r0	; 63
   10b5c:	cd bf       	out	0x3d, r28	; 61
   10b5e:	6c 01       	movw	r12, r24
   10b60:	19 82       	std	Y+1, r1	; 0x01
   10b62:	80 ed       	ldi	r24, 0xD0	; 208
   10b64:	6a e0       	ldi	r22, 0x0A	; 10
   10b66:	ae 01       	movw	r20, r28
   10b68:	4f 5f       	subi	r20, 0xFF	; 255
   10b6a:	5f 4f       	sbci	r21, 0xFF	; 255
   10b6c:	21 e0       	ldi	r18, 0x01	; 1
   10b6e:	8e 01       	movw	r16, r28
   10b70:	0e 5f       	subi	r16, 0xFE	; 254
   10b72:	1f 4f       	sbci	r17, 0xFF	; 255
   10b74:	a7 e0       	ldi	r26, 0x07	; 7
   10b76:	ea 2e       	mov	r14, r26
   10b78:	0e 94 0d ac 	call	0x1581a	; 0x1581a <TWI_ReadPacket>
   10b7c:	88 23       	and	r24, r24
   10b7e:	11 f0       	breq	.+4      	; 0x10b84 <RTC_GetTimeDate+0x44>
   10b80:	80 e0       	ldi	r24, 0x00	; 0
   10b82:	78 c0       	rjmp	.+240    	; 0x10c74 <RTC_GetTimeDate+0x134>
   10b84:	4a 81       	ldd	r20, Y+2	; 0x02
   10b86:	24 2f       	mov	r18, r20
   10b88:	22 95       	swap	r18
   10b8a:	2f 70       	andi	r18, 0x0F	; 15
   10b8c:	82 2f       	mov	r24, r18
   10b8e:	87 70       	andi	r24, 0x07	; 7
   10b90:	90 e0       	ldi	r25, 0x00	; 0
   10b92:	9c 01       	movw	r18, r24
   10b94:	f3 e0       	ldi	r31, 0x03	; 3
   10b96:	22 0f       	add	r18, r18
   10b98:	33 1f       	adc	r19, r19
   10b9a:	fa 95       	dec	r31
   10b9c:	e1 f7       	brne	.-8      	; 0x10b96 <RTC_GetTimeDate+0x56>
   10b9e:	88 0f       	add	r24, r24
   10ba0:	99 1f       	adc	r25, r25
   10ba2:	28 0f       	add	r18, r24
   10ba4:	39 1f       	adc	r19, r25
   10ba6:	4f 70       	andi	r20, 0x0F	; 15
   10ba8:	42 0f       	add	r20, r18
   10baa:	f6 01       	movw	r30, r12
   10bac:	42 83       	std	Z+2, r20	; 0x02
   10bae:	4b 81       	ldd	r20, Y+3	; 0x03
   10bb0:	24 2f       	mov	r18, r20
   10bb2:	22 95       	swap	r18
   10bb4:	2f 70       	andi	r18, 0x0F	; 15
   10bb6:	82 2f       	mov	r24, r18
   10bb8:	87 70       	andi	r24, 0x07	; 7
   10bba:	90 e0       	ldi	r25, 0x00	; 0
   10bbc:	9c 01       	movw	r18, r24
   10bbe:	73 e0       	ldi	r23, 0x03	; 3
   10bc0:	22 0f       	add	r18, r18
   10bc2:	33 1f       	adc	r19, r19
   10bc4:	7a 95       	dec	r23
   10bc6:	e1 f7       	brne	.-8      	; 0x10bc0 <RTC_GetTimeDate+0x80>
   10bc8:	88 0f       	add	r24, r24
   10bca:	99 1f       	adc	r25, r25
   10bcc:	28 0f       	add	r18, r24
   10bce:	39 1f       	adc	r19, r25
   10bd0:	4f 70       	andi	r20, 0x0F	; 15
   10bd2:	42 0f       	add	r20, r18
   10bd4:	41 83       	std	Z+1, r20	; 0x01
   10bd6:	4c 81       	ldd	r20, Y+4	; 0x04
   10bd8:	24 2f       	mov	r18, r20
   10bda:	22 95       	swap	r18
   10bdc:	2f 70       	andi	r18, 0x0F	; 15
   10bde:	82 2f       	mov	r24, r18
   10be0:	83 70       	andi	r24, 0x03	; 3
   10be2:	90 e0       	ldi	r25, 0x00	; 0
   10be4:	9c 01       	movw	r18, r24
   10be6:	53 e0       	ldi	r21, 0x03	; 3
   10be8:	22 0f       	add	r18, r18
   10bea:	33 1f       	adc	r19, r19
   10bec:	5a 95       	dec	r21
   10bee:	e1 f7       	brne	.-8      	; 0x10be8 <RTC_GetTimeDate+0xa8>
   10bf0:	88 0f       	add	r24, r24
   10bf2:	99 1f       	adc	r25, r25
   10bf4:	28 0f       	add	r18, r24
   10bf6:	39 1f       	adc	r19, r25
   10bf8:	4f 70       	andi	r20, 0x0F	; 15
   10bfa:	42 0f       	add	r20, r18
   10bfc:	40 83       	st	Z, r20
   10bfe:	4e 81       	ldd	r20, Y+6	; 0x06
   10c00:	24 2f       	mov	r18, r20
   10c02:	22 95       	swap	r18
   10c04:	2f 70       	andi	r18, 0x0F	; 15
   10c06:	82 2f       	mov	r24, r18
   10c08:	83 70       	andi	r24, 0x03	; 3
   10c0a:	90 e0       	ldi	r25, 0x00	; 0
   10c0c:	9c 01       	movw	r18, r24
   10c0e:	13 e0       	ldi	r17, 0x03	; 3
   10c10:	22 0f       	add	r18, r18
   10c12:	33 1f       	adc	r19, r19
   10c14:	1a 95       	dec	r17
   10c16:	e1 f7       	brne	.-8      	; 0x10c10 <RTC_GetTimeDate+0xd0>
   10c18:	88 0f       	add	r24, r24
   10c1a:	99 1f       	adc	r25, r25
   10c1c:	28 0f       	add	r18, r24
   10c1e:	39 1f       	adc	r19, r25
   10c20:	4f 70       	andi	r20, 0x0F	; 15
   10c22:	42 0f       	add	r20, r18
   10c24:	43 83       	std	Z+3, r20	; 0x03
   10c26:	4f 81       	ldd	r20, Y+7	; 0x07
   10c28:	24 2f       	mov	r18, r20
   10c2a:	22 95       	swap	r18
   10c2c:	2f 70       	andi	r18, 0x0F	; 15
   10c2e:	82 2f       	mov	r24, r18
   10c30:	81 70       	andi	r24, 0x01	; 1
   10c32:	90 e0       	ldi	r25, 0x00	; 0
   10c34:	9c 01       	movw	r18, r24
   10c36:	a3 e0       	ldi	r26, 0x03	; 3
   10c38:	22 0f       	add	r18, r18
   10c3a:	33 1f       	adc	r19, r19
   10c3c:	aa 95       	dec	r26
   10c3e:	e1 f7       	brne	.-8      	; 0x10c38 <RTC_GetTimeDate+0xf8>
   10c40:	88 0f       	add	r24, r24
   10c42:	99 1f       	adc	r25, r25
   10c44:	28 0f       	add	r18, r24
   10c46:	39 1f       	adc	r19, r25
   10c48:	4f 70       	andi	r20, 0x0F	; 15
   10c4a:	42 0f       	add	r20, r18
   10c4c:	44 83       	std	Z+4, r20	; 0x04
   10c4e:	48 85       	ldd	r20, Y+8	; 0x08
   10c50:	84 2f       	mov	r24, r20
   10c52:	82 95       	swap	r24
   10c54:	8f 70       	andi	r24, 0x0F	; 15
   10c56:	90 e0       	ldi	r25, 0x00	; 0
   10c58:	9c 01       	movw	r18, r24
   10c5a:	63 e0       	ldi	r22, 0x03	; 3
   10c5c:	22 0f       	add	r18, r18
   10c5e:	33 1f       	adc	r19, r19
   10c60:	6a 95       	dec	r22
   10c62:	e1 f7       	brne	.-8      	; 0x10c5c <RTC_GetTimeDate+0x11c>
   10c64:	88 0f       	add	r24, r24
   10c66:	99 1f       	adc	r25, r25
   10c68:	28 0f       	add	r18, r24
   10c6a:	39 1f       	adc	r19, r25
   10c6c:	4f 70       	andi	r20, 0x0F	; 15
   10c6e:	42 0f       	add	r20, r18
   10c70:	45 83       	std	Z+5, r20	; 0x05
   10c72:	81 e0       	ldi	r24, 0x01	; 1
   10c74:	28 96       	adiw	r28, 0x08	; 8
   10c76:	0f b6       	in	r0, 0x3f	; 63
   10c78:	f8 94       	cli
   10c7a:	de bf       	out	0x3e, r29	; 62
   10c7c:	0f be       	out	0x3f, r0	; 63
   10c7e:	cd bf       	out	0x3d, r28	; 61
   10c80:	cf 91       	pop	r28
   10c82:	df 91       	pop	r29
   10c84:	1f 91       	pop	r17
   10c86:	0f 91       	pop	r16
   10c88:	ef 90       	pop	r14
   10c8a:	df 90       	pop	r13
   10c8c:	cf 90       	pop	r12
   10c8e:	08 95       	ret

00010c90 <RTC_SetTimeDate>:
   10c90:	ef 92       	push	r14
   10c92:	0f 93       	push	r16
   10c94:	1f 93       	push	r17
   10c96:	df 93       	push	r29
   10c98:	cf 93       	push	r28
   10c9a:	cd b7       	in	r28, 0x3d	; 61
   10c9c:	de b7       	in	r29, 0x3e	; 62
   10c9e:	28 97       	sbiw	r28, 0x08	; 8
   10ca0:	0f b6       	in	r0, 0x3f	; 63
   10ca2:	f8 94       	cli
   10ca4:	de bf       	out	0x3e, r29	; 62
   10ca6:	0f be       	out	0x3f, r0	; 63
   10ca8:	cd bf       	out	0x3d, r28	; 61
   10caa:	fc 01       	movw	r30, r24
   10cac:	19 82       	std	Y+1, r1	; 0x01
   10cae:	32 81       	ldd	r19, Z+2	; 0x02
   10cb0:	83 2f       	mov	r24, r19
   10cb2:	6a e0       	ldi	r22, 0x0A	; 10
   10cb4:	0e 94 bc ac 	call	0x15978	; 0x15978 <__udivmodqi4>
   10cb8:	28 2f       	mov	r18, r24
   10cba:	27 70       	andi	r18, 0x07	; 7
   10cbc:	22 95       	swap	r18
   10cbe:	20 7f       	andi	r18, 0xF0	; 240
   10cc0:	83 2f       	mov	r24, r19
   10cc2:	0e 94 bc ac 	call	0x15978	; 0x15978 <__udivmodqi4>
   10cc6:	9f 70       	andi	r25, 0x0F	; 15
   10cc8:	29 2b       	or	r18, r25
   10cca:	2a 83       	std	Y+2, r18	; 0x02
   10ccc:	41 81       	ldd	r20, Z+1	; 0x01
   10cce:	84 2f       	mov	r24, r20
   10cd0:	0e 94 bc ac 	call	0x15978	; 0x15978 <__udivmodqi4>
   10cd4:	38 2f       	mov	r19, r24
   10cd6:	37 70       	andi	r19, 0x07	; 7
   10cd8:	32 95       	swap	r19
   10cda:	30 7f       	andi	r19, 0xF0	; 240
   10cdc:	2b 81       	ldd	r18, Y+3	; 0x03
   10cde:	20 78       	andi	r18, 0x80	; 128
   10ce0:	84 2f       	mov	r24, r20
   10ce2:	0e 94 bc ac 	call	0x15978	; 0x15978 <__udivmodqi4>
   10ce6:	9f 70       	andi	r25, 0x0F	; 15
   10ce8:	23 2b       	or	r18, r19
   10cea:	29 2b       	or	r18, r25
   10cec:	2b 83       	std	Y+3, r18	; 0x03
   10cee:	40 81       	ld	r20, Z
   10cf0:	84 2f       	mov	r24, r20
   10cf2:	0e 94 bc ac 	call	0x15978	; 0x15978 <__udivmodqi4>
   10cf6:	38 2f       	mov	r19, r24
   10cf8:	33 70       	andi	r19, 0x03	; 3
   10cfa:	32 95       	swap	r19
   10cfc:	30 7f       	andi	r19, 0xF0	; 240
   10cfe:	2c 81       	ldd	r18, Y+4	; 0x04
   10d00:	20 7c       	andi	r18, 0xC0	; 192
   10d02:	84 2f       	mov	r24, r20
   10d04:	0e 94 bc ac 	call	0x15978	; 0x15978 <__udivmodqi4>
   10d08:	9f 70       	andi	r25, 0x0F	; 15
   10d0a:	23 2b       	or	r18, r19
   10d0c:	29 2b       	or	r18, r25
   10d0e:	2f 7b       	andi	r18, 0xBF	; 191
   10d10:	2c 83       	std	Y+4, r18	; 0x04
   10d12:	8d 81       	ldd	r24, Y+5	; 0x05
   10d14:	88 7f       	andi	r24, 0xF8	; 248
   10d16:	8d 83       	std	Y+5, r24	; 0x05
   10d18:	43 81       	ldd	r20, Z+3	; 0x03
   10d1a:	84 2f       	mov	r24, r20
   10d1c:	0e 94 bc ac 	call	0x15978	; 0x15978 <__udivmodqi4>
   10d20:	38 2f       	mov	r19, r24
   10d22:	33 70       	andi	r19, 0x03	; 3
   10d24:	32 95       	swap	r19
   10d26:	30 7f       	andi	r19, 0xF0	; 240
   10d28:	2e 81       	ldd	r18, Y+6	; 0x06
   10d2a:	20 7c       	andi	r18, 0xC0	; 192
   10d2c:	84 2f       	mov	r24, r20
   10d2e:	0e 94 bc ac 	call	0x15978	; 0x15978 <__udivmodqi4>
   10d32:	9f 70       	andi	r25, 0x0F	; 15
   10d34:	23 2b       	or	r18, r19
   10d36:	29 2b       	or	r18, r25
   10d38:	2e 83       	std	Y+6, r18	; 0x06
   10d3a:	44 81       	ldd	r20, Z+4	; 0x04
   10d3c:	84 2f       	mov	r24, r20
   10d3e:	0e 94 bc ac 	call	0x15978	; 0x15978 <__udivmodqi4>
   10d42:	38 2f       	mov	r19, r24
   10d44:	31 70       	andi	r19, 0x01	; 1
   10d46:	32 95       	swap	r19
   10d48:	30 7f       	andi	r19, 0xF0	; 240
   10d4a:	2f 81       	ldd	r18, Y+7	; 0x07
   10d4c:	20 7e       	andi	r18, 0xE0	; 224
   10d4e:	84 2f       	mov	r24, r20
   10d50:	0e 94 bc ac 	call	0x15978	; 0x15978 <__udivmodqi4>
   10d54:	9f 70       	andi	r25, 0x0F	; 15
   10d56:	23 2b       	or	r18, r19
   10d58:	29 2b       	or	r18, r25
   10d5a:	2f 83       	std	Y+7, r18	; 0x07
   10d5c:	25 81       	ldd	r18, Z+5	; 0x05
   10d5e:	82 2f       	mov	r24, r18
   10d60:	0e 94 bc ac 	call	0x15978	; 0x15978 <__udivmodqi4>
   10d64:	38 2f       	mov	r19, r24
   10d66:	32 95       	swap	r19
   10d68:	30 7f       	andi	r19, 0xF0	; 240
   10d6a:	82 2f       	mov	r24, r18
   10d6c:	0e 94 bc ac 	call	0x15978	; 0x15978 <__udivmodqi4>
   10d70:	9f 70       	andi	r25, 0x0F	; 15
   10d72:	93 2b       	or	r25, r19
   10d74:	98 87       	std	Y+8, r25	; 0x08
   10d76:	80 ed       	ldi	r24, 0xD0	; 208
   10d78:	ae 01       	movw	r20, r28
   10d7a:	4f 5f       	subi	r20, 0xFF	; 255
   10d7c:	5f 4f       	sbci	r21, 0xFF	; 255
   10d7e:	21 e0       	ldi	r18, 0x01	; 1
   10d80:	8e 01       	movw	r16, r28
   10d82:	0e 5f       	subi	r16, 0xFE	; 254
   10d84:	1f 4f       	sbci	r17, 0xFF	; 255
   10d86:	b7 e0       	ldi	r27, 0x07	; 7
   10d88:	eb 2e       	mov	r14, r27
   10d8a:	0e 94 59 ac 	call	0x158b2	; 0x158b2 <TWI_WritePacket>
   10d8e:	90 e0       	ldi	r25, 0x00	; 0
   10d90:	88 23       	and	r24, r24
   10d92:	09 f4       	brne	.+2      	; 0x10d96 <RTC_SetTimeDate+0x106>
   10d94:	91 e0       	ldi	r25, 0x01	; 1
   10d96:	89 2f       	mov	r24, r25
   10d98:	28 96       	adiw	r28, 0x08	; 8
   10d9a:	0f b6       	in	r0, 0x3f	; 63
   10d9c:	f8 94       	cli
   10d9e:	de bf       	out	0x3e, r29	; 62
   10da0:	0f be       	out	0x3f, r0	; 63
   10da2:	cd bf       	out	0x3d, r28	; 61
   10da4:	cf 91       	pop	r28
   10da6:	df 91       	pop	r29
   10da8:	1f 91       	pop	r17
   10daa:	0f 91       	pop	r16
   10dac:	ef 90       	pop	r14
   10dae:	08 95       	ret

00010db0 <SwapEndian_16>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
			{
   10db0:	28 2f       	mov	r18, r24
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
   10db2:	89 2f       	mov	r24, r25
   10db4:	92 2f       	mov	r25, r18
   10db6:	08 95       	ret

00010db8 <SCSI_Command_ReadWrite_10>:
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_ReadWrite_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                      const bool IsDataRead)
{
   10db8:	af 92       	push	r10
   10dba:	bf 92       	push	r11
   10dbc:	cf 92       	push	r12
   10dbe:	df 92       	push	r13
   10dc0:	ef 92       	push	r14
   10dc2:	ff 92       	push	r15
   10dc4:	0f 93       	push	r16
   10dc6:	1f 93       	push	r17
   10dc8:	df 93       	push	r29
   10dca:	cf 93       	push	r28
   10dcc:	0f 92       	push	r0
   10dce:	cd b7       	in	r28, 0x3d	; 61
   10dd0:	de b7       	in	r29, 0x3e	; 62
   10dd2:	5c 01       	movw	r10, r24

		return false;
	}

	/* Load in the 32-bit block address (SCSI uses big-endian, so have to reverse the byte order) */
	BlockAddress = SwapEndian_32(*(uint32_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[2]);
   10dd4:	fc 01       	movw	r30, r24
   10dd6:	7b 96       	adiw	r30, 0x1b	; 27

				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
   10dd8:	e5 80       	ldd	r14, Z+5	; 0x05
   10dda:	f4 80       	ldd	r15, Z+4	; 0x04
   10ddc:	03 81       	ldd	r16, Z+3	; 0x03
   10dde:	12 81       	ldd	r17, Z+2	; 0x02

	/* Load in the 16-bit total blocks (SCSI uses big-endian, so have to reverse the byte order) */
	TotalBlocks  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[7]);
   10de0:	87 81       	ldd	r24, Z+7	; 0x07
   10de2:	90 85       	ldd	r25, Z+8	; 0x08
   10de4:	69 83       	std	Y+1, r22	; 0x01
   10de6:	e4 df       	rcall	.-56     	; 0x10db0 <SwapEndian_16>
   10de8:	6c 01       	movw	r12, r24

	/* Check if the block address is outside the maximum allowable value for the LUN */
	if (BlockAddress >= VIRTUAL_MEMORY_BLOCKS)
   10dea:	69 81       	ldd	r22, Y+1	; 0x01
   10dec:	80 e0       	ldi	r24, 0x00	; 0
   10dee:	e8 16       	cp	r14, r24
   10df0:	80 e8       	ldi	r24, 0x80	; 128
   10df2:	f8 06       	cpc	r15, r24
   10df4:	80 e0       	ldi	r24, 0x00	; 0
   10df6:	08 07       	cpc	r16, r24
   10df8:	80 e0       	ldi	r24, 0x00	; 0
   10dfa:	18 07       	cpc	r17, r24
   10dfc:	68 f0       	brcs	.+26     	; 0x10e18 <SCSI_Command_ReadWrite_10+0x60>
	{
		/* Block address is invalid, update SENSE key and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
   10dfe:	80 91 ff 08 	lds	r24, 0x08FF
   10e02:	80 7f       	andi	r24, 0xF0	; 240
   10e04:	85 60       	ori	r24, 0x05	; 5
   10e06:	80 93 ff 08 	sts	0x08FF, r24
   10e0a:	81 e2       	ldi	r24, 0x21	; 33
   10e0c:	80 93 09 09 	sts	0x0909, r24
   10e10:	10 92 0a 09 	sts	0x090A, r1
		               SCSI_ASENSE_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
   10e14:	80 e0       	ldi	r24, 0x00	; 0
   10e16:	24 c0       	rjmp	.+72     	; 0x10e60 <SCSI_Command_ReadWrite_10+0xa8>
	}

	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
   10e18:	66 23       	and	r22, r22
   10e1a:	31 f0       	breq	.+12     	; 0x10e28 <SCSI_Command_ReadWrite_10+0x70>
	  DataflashManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
   10e1c:	c5 01       	movw	r24, r10
   10e1e:	b8 01       	movw	r22, r16
   10e20:	a7 01       	movw	r20, r14
   10e22:	96 01       	movw	r18, r12
   10e24:	aa db       	rcall	.-2220   	; 0x1057a <DataflashManager_ReadBlocks>
   10e26:	05 c0       	rjmp	.+10     	; 0x10e32 <SCSI_Command_ReadWrite_10+0x7a>
	else
	  DataflashManager_WriteBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
   10e28:	c5 01       	movw	r24, r10
   10e2a:	b8 01       	movw	r22, r16
   10e2c:	a7 01       	movw	r20, r14
   10e2e:	96 01       	movw	r18, r12
   10e30:	69 da       	rcall	.-2862   	; 0x10304 <DataflashManager_WriteBlocks>

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= ((uint32_t)TotalBlocks * VIRTUAL_MEMORY_BLOCK_SIZE);
   10e32:	ee 24       	eor	r14, r14
   10e34:	ff 24       	eor	r15, r15
   10e36:	89 e0       	ldi	r24, 0x09	; 9
   10e38:	cc 0c       	add	r12, r12
   10e3a:	dd 1c       	adc	r13, r13
   10e3c:	ee 1c       	adc	r14, r14
   10e3e:	ff 1c       	adc	r15, r15
   10e40:	8a 95       	dec	r24
   10e42:	d1 f7       	brne	.-12     	; 0x10e38 <SCSI_Command_ReadWrite_10+0x80>
   10e44:	f5 01       	movw	r30, r10
   10e46:	84 89       	ldd	r24, Z+20	; 0x14
   10e48:	95 89       	ldd	r25, Z+21	; 0x15
   10e4a:	a6 89       	ldd	r26, Z+22	; 0x16
   10e4c:	b7 89       	ldd	r27, Z+23	; 0x17
   10e4e:	8c 19       	sub	r24, r12
   10e50:	9d 09       	sbc	r25, r13
   10e52:	ae 09       	sbc	r26, r14
   10e54:	bf 09       	sbc	r27, r15
   10e56:	84 8b       	std	Z+20, r24	; 0x14
   10e58:	95 8b       	std	Z+21, r25	; 0x15
   10e5a:	a6 8b       	std	Z+22, r26	; 0x16
   10e5c:	b7 8b       	std	Z+23, r27	; 0x17

	return true;
   10e5e:	81 e0       	ldi	r24, 0x01	; 1
}
   10e60:	0f 90       	pop	r0
   10e62:	cf 91       	pop	r28
   10e64:	df 91       	pop	r29
   10e66:	1f 91       	pop	r17
   10e68:	0f 91       	pop	r16
   10e6a:	ff 90       	pop	r15
   10e6c:	ef 90       	pop	r14
   10e6e:	df 90       	pop	r13
   10e70:	cf 90       	pop	r12
   10e72:	bf 90       	pop	r11
   10e74:	af 90       	pop	r10
   10e76:	08 95       	ret

00010e78 <SCSI_DecodeSCSICommand>:
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise
 */
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
   10e78:	cf 92       	push	r12
   10e7a:	df 92       	push	r13
   10e7c:	ef 92       	push	r14
   10e7e:	ff 92       	push	r15
   10e80:	0f 93       	push	r16
   10e82:	1f 93       	push	r17
   10e84:	df 93       	push	r29
   10e86:	cf 93       	push	r28
   10e88:	cd b7       	in	r28, 0x3d	; 61
   10e8a:	de b7       	in	r29, 0x3e	; 62
   10e8c:	28 97       	sbiw	r28, 0x08	; 8
   10e8e:	0f b6       	in	r0, 0x3f	; 63
   10e90:	f8 94       	cli
   10e92:	de bf       	out	0x3e, r29	; 62
   10e94:	0f be       	out	0x3f, r0	; 63
   10e96:	cd bf       	out	0x3d, r28	; 61
   10e98:	8c 01       	movw	r16, r24
	bool CommandSuccess = false;

	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
   10e9a:	fc 01       	movw	r30, r24
   10e9c:	83 8d       	ldd	r24, Z+27	; 0x1b
   10e9e:	8d 31       	cpi	r24, 0x1D	; 29
   10ea0:	09 f4       	brne	.+2      	; 0x10ea4 <SCSI_DecodeSCSICommand+0x2c>
   10ea2:	b5 c0       	rjmp	.+362    	; 0x1100e <SCSI_DecodeSCSICommand+0x196>
   10ea4:	8e 31       	cpi	r24, 0x1E	; 30
   10ea6:	90 f4       	brcc	.+36     	; 0x10ecc <SCSI_DecodeSCSICommand+0x54>
   10ea8:	82 31       	cpi	r24, 0x12	; 18
   10eaa:	19 f1       	breq	.+70     	; 0x10ef2 <SCSI_DecodeSCSICommand+0x7a>
   10eac:	83 31       	cpi	r24, 0x13	; 19
   10eae:	38 f4       	brcc	.+14     	; 0x10ebe <SCSI_DecodeSCSICommand+0x46>
   10eb0:	88 23       	and	r24, r24
   10eb2:	09 f4       	brne	.+2      	; 0x10eb6 <SCSI_DecodeSCSICommand+0x3e>
   10eb4:	e9 c0       	rjmp	.+466    	; 0x11088 <SCSI_DecodeSCSICommand+0x210>
   10eb6:	83 30       	cpi	r24, 0x03	; 3
   10eb8:	09 f0       	breq	.+2      	; 0x10ebc <SCSI_DecodeSCSICommand+0x44>
   10eba:	ec c0       	rjmp	.+472    	; 0x11094 <SCSI_DecodeSCSICommand+0x21c>
   10ebc:	53 c0       	rjmp	.+166    	; 0x10f64 <SCSI_DecodeSCSICommand+0xec>
   10ebe:	8a 31       	cpi	r24, 0x1A	; 26
   10ec0:	09 f4       	brne	.+2      	; 0x10ec4 <SCSI_DecodeSCSICommand+0x4c>
   10ec2:	c8 c0       	rjmp	.+400    	; 0x11054 <SCSI_DecodeSCSICommand+0x1dc>
   10ec4:	8b 31       	cpi	r24, 0x1B	; 27
   10ec6:	09 f0       	breq	.+2      	; 0x10eca <SCSI_DecodeSCSICommand+0x52>
   10ec8:	e5 c0       	rjmp	.+458    	; 0x11094 <SCSI_DecodeSCSICommand+0x21c>
   10eca:	de c0       	rjmp	.+444    	; 0x11088 <SCSI_DecodeSCSICommand+0x210>
   10ecc:	88 32       	cpi	r24, 0x28	; 40
   10ece:	09 f4       	brne	.+2      	; 0x10ed2 <SCSI_DecodeSCSICommand+0x5a>
   10ed0:	bb c0       	rjmp	.+374    	; 0x11048 <SCSI_DecodeSCSICommand+0x1d0>
   10ed2:	89 32       	cpi	r24, 0x29	; 41
   10ed4:	38 f4       	brcc	.+14     	; 0x10ee4 <SCSI_DecodeSCSICommand+0x6c>
   10ed6:	8e 31       	cpi	r24, 0x1E	; 30
   10ed8:	09 f4       	brne	.+2      	; 0x10edc <SCSI_DecodeSCSICommand+0x64>
   10eda:	d6 c0       	rjmp	.+428    	; 0x11088 <SCSI_DecodeSCSICommand+0x210>
   10edc:	85 32       	cpi	r24, 0x25	; 37
   10ede:	09 f0       	breq	.+2      	; 0x10ee2 <SCSI_DecodeSCSICommand+0x6a>
   10ee0:	d9 c0       	rjmp	.+434    	; 0x11094 <SCSI_DecodeSCSICommand+0x21c>
   10ee2:	67 c0       	rjmp	.+206    	; 0x10fb2 <SCSI_DecodeSCSICommand+0x13a>
   10ee4:	8a 32       	cpi	r24, 0x2A	; 42
   10ee6:	09 f4       	brne	.+2      	; 0x10eea <SCSI_DecodeSCSICommand+0x72>
   10ee8:	ac c0       	rjmp	.+344    	; 0x11042 <SCSI_DecodeSCSICommand+0x1ca>
   10eea:	8f 32       	cpi	r24, 0x2F	; 47
   10eec:	09 f0       	breq	.+2      	; 0x10ef0 <SCSI_DecodeSCSICommand+0x78>
   10eee:	d2 c0       	rjmp	.+420    	; 0x11094 <SCSI_DecodeSCSICommand+0x21c>
   10ef0:	cb c0       	rjmp	.+406    	; 0x11088 <SCSI_DecodeSCSICommand+0x210>
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
   10ef2:	f8 01       	movw	r30, r16
   10ef4:	86 8d       	ldd	r24, Z+30	; 0x1e
   10ef6:	97 8d       	ldd	r25, Z+31	; 0x1f
   10ef8:	5b df       	rcall	.-330    	; 0x10db0 <SwapEndian_16>
   10efa:	6c 01       	movw	r12, r24
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));

	/* Only the standard INQUIRY data is supported, check if any optional INQUIRY bits set */
	if ((MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & ((1 << 0) | (1 << 1))) ||
   10efc:	f8 01       	movw	r30, r16
   10efe:	84 8d       	ldd	r24, Z+28	; 0x1c
   10f00:	90 e0       	ldi	r25, 0x00	; 0
   10f02:	83 70       	andi	r24, 0x03	; 3
   10f04:	90 70       	andi	r25, 0x00	; 0
   10f06:	00 97       	sbiw	r24, 0x00	; 0
   10f08:	09 f0       	breq	.+2      	; 0x10f0c <SCSI_DecodeSCSICommand+0x94>
   10f0a:	85 c0       	rjmp	.+266    	; 0x11016 <SCSI_DecodeSCSICommand+0x19e>
   10f0c:	85 8d       	ldd	r24, Z+29	; 0x1d
   10f0e:	88 23       	and	r24, r24
   10f10:	09 f0       	breq	.+2      	; 0x10f14 <SCSI_DecodeSCSICommand+0x9c>
   10f12:	81 c0       	rjmp	.+258    	; 0x11016 <SCSI_DecodeSCSICommand+0x19e>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));
   10f14:	76 01       	movw	r14, r12
   10f16:	f5 e2       	ldi	r31, 0x25	; 37
   10f18:	cf 16       	cp	r12, r31
   10f1a:	d1 04       	cpc	r13, r1
   10f1c:	18 f0       	brcs	.+6      	; 0x10f24 <SCSI_DecodeSCSICommand+0xac>
   10f1e:	24 e2       	ldi	r18, 0x24	; 36
   10f20:	e2 2e       	mov	r14, r18
   10f22:	f1 2c       	mov	r15, r1
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
	}

	Endpoint_Write_Stream_LE(&InquiryData, BytesTransferred, NULL);
   10f24:	8f e0       	ldi	r24, 0x0F	; 15
   10f26:	99 e0       	ldi	r25, 0x09	; 9
   10f28:	b7 01       	movw	r22, r14
   10f2a:	40 e0       	ldi	r20, 0x00	; 0
   10f2c:	50 e0       	ldi	r21, 0x00	; 0
   10f2e:	0e 94 15 a2 	call	0x1442a	; 0x1442a <Endpoint_Write_Stream_LE>

	/* Pad out remaining bytes with 0x00 */
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
   10f32:	c6 01       	movw	r24, r12
   10f34:	8e 19       	sub	r24, r14
   10f36:	9f 09       	sbc	r25, r15
   10f38:	60 e0       	ldi	r22, 0x00	; 0
   10f3a:	70 e0       	ldi	r23, 0x00	; 0
   10f3c:	0e 94 d0 a1 	call	0x143a0	; 0x143a0 <Endpoint_Null_Stream>
   10f40:	80 91 e8 00 	lds	r24, 0x00E8
   10f44:	8e 77       	andi	r24, 0x7E	; 126
   10f46:	80 93 e8 00 	sts	0x00E8, r24

	/* Finalize the stream transfer to send the last packet */
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
   10f4a:	97 01       	movw	r18, r14
   10f4c:	40 e0       	ldi	r20, 0x00	; 0
   10f4e:	50 e0       	ldi	r21, 0x00	; 0
   10f50:	f8 01       	movw	r30, r16
   10f52:	84 89       	ldd	r24, Z+20	; 0x14
   10f54:	95 89       	ldd	r25, Z+21	; 0x15
   10f56:	a6 89       	ldd	r26, Z+22	; 0x16
   10f58:	b7 89       	ldd	r27, Z+23	; 0x17
   10f5a:	82 1b       	sub	r24, r18
   10f5c:	93 0b       	sbc	r25, r19
   10f5e:	a4 0b       	sbc	r26, r20
   10f60:	b5 0b       	sbc	r27, r21
   10f62:	8d c0       	rjmp	.+282    	; 0x1107e <SCSI_DecodeSCSICommand+0x206>
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Request_Sense(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint8_t  AllocationLength = MSInterfaceInfo->State.CommandBlock.SCSICommandData[4];
   10f64:	f8 01       	movw	r30, r16
   10f66:	c7 8c       	ldd	r12, Z+31	; 0x1f
	uint8_t  BytesTransferred = MIN(AllocationLength, sizeof(SenseData));
   10f68:	ec 2c       	mov	r14, r12
   10f6a:	fc 2d       	mov	r31, r12
   10f6c:	f3 31       	cpi	r31, 0x13	; 19
   10f6e:	10 f0       	brcs	.+4      	; 0x10f74 <SCSI_DecodeSCSICommand+0xfc>
   10f70:	92 e1       	ldi	r25, 0x12	; 18
   10f72:	e9 2e       	mov	r14, r25

	Endpoint_Write_Stream_LE(&SenseData, BytesTransferred, NULL);
   10f74:	8d ef       	ldi	r24, 0xFD	; 253
   10f76:	98 e0       	ldi	r25, 0x08	; 8
   10f78:	6e 2d       	mov	r22, r14
   10f7a:	70 e0       	ldi	r23, 0x00	; 0
   10f7c:	40 e0       	ldi	r20, 0x00	; 0
   10f7e:	50 e0       	ldi	r21, 0x00	; 0
   10f80:	0e 94 15 a2 	call	0x1442a	; 0x1442a <Endpoint_Write_Stream_LE>
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
   10f84:	8c 2d       	mov	r24, r12
   10f86:	90 e0       	ldi	r25, 0x00	; 0
   10f88:	8e 19       	sub	r24, r14
   10f8a:	91 09       	sbc	r25, r1
   10f8c:	60 e0       	ldi	r22, 0x00	; 0
   10f8e:	70 e0       	ldi	r23, 0x00	; 0
   10f90:	0e 94 d0 a1 	call	0x143a0	; 0x143a0 <Endpoint_Null_Stream>
   10f94:	80 91 e8 00 	lds	r24, 0x00E8
   10f98:	8e 77       	andi	r24, 0x7E	; 126
   10f9a:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
   10f9e:	f8 01       	movw	r30, r16
   10fa0:	84 89       	ldd	r24, Z+20	; 0x14
   10fa2:	95 89       	ldd	r25, Z+21	; 0x15
   10fa4:	a6 89       	ldd	r26, Z+22	; 0x16
   10fa6:	b7 89       	ldd	r27, Z+23	; 0x17
   10fa8:	8e 19       	sub	r24, r14
   10faa:	91 09       	sbc	r25, r1
   10fac:	a1 09       	sbc	r26, r1
   10fae:	b1 09       	sbc	r27, r1
   10fb0:	66 c0       	rjmp	.+204    	; 0x1107e <SCSI_DecodeSCSICommand+0x206>
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Read_Capacity_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint32_t LastBlockAddressInLUN = (VIRTUAL_MEMORY_BLOCKS - 1);
   10fb2:	8f ef       	ldi	r24, 0xFF	; 255
   10fb4:	9f e7       	ldi	r25, 0x7F	; 127
   10fb6:	a0 e0       	ldi	r26, 0x00	; 0
   10fb8:	b0 e0       	ldi	r27, 0x00	; 0
   10fba:	89 83       	std	Y+1, r24	; 0x01
   10fbc:	9a 83       	std	Y+2, r25	; 0x02
   10fbe:	ab 83       	std	Y+3, r26	; 0x03
   10fc0:	bc 83       	std	Y+4, r27	; 0x04
	uint32_t MediaBlockSize        = VIRTUAL_MEMORY_BLOCK_SIZE;
   10fc2:	80 e0       	ldi	r24, 0x00	; 0
   10fc4:	92 e0       	ldi	r25, 0x02	; 2
   10fc6:	a0 e0       	ldi	r26, 0x00	; 0
   10fc8:	b0 e0       	ldi	r27, 0x00	; 0
   10fca:	8d 83       	std	Y+5, r24	; 0x05
   10fcc:	9e 83       	std	Y+6, r25	; 0x06
   10fce:	af 83       	std	Y+7, r26	; 0x07
   10fd0:	b8 87       	std	Y+8, r27	; 0x08

	Endpoint_Write_Stream_BE(&LastBlockAddressInLUN, sizeof(LastBlockAddressInLUN), NULL);
   10fd2:	ce 01       	movw	r24, r28
   10fd4:	01 96       	adiw	r24, 0x01	; 1
   10fd6:	64 e0       	ldi	r22, 0x04	; 4
   10fd8:	70 e0       	ldi	r23, 0x00	; 0
   10fda:	40 e0       	ldi	r20, 0x00	; 0
   10fdc:	50 e0       	ldi	r21, 0x00	; 0
   10fde:	0e 94 72 a2 	call	0x144e4	; 0x144e4 <Endpoint_Write_Stream_BE>
	Endpoint_Write_Stream_BE(&MediaBlockSize, sizeof(MediaBlockSize), NULL);
   10fe2:	ce 01       	movw	r24, r28
   10fe4:	05 96       	adiw	r24, 0x05	; 5
   10fe6:	64 e0       	ldi	r22, 0x04	; 4
   10fe8:	70 e0       	ldi	r23, 0x00	; 0
   10fea:	40 e0       	ldi	r20, 0x00	; 0
   10fec:	50 e0       	ldi	r21, 0x00	; 0
   10fee:	0e 94 72 a2 	call	0x144e4	; 0x144e4 <Endpoint_Write_Stream_BE>
   10ff2:	80 91 e8 00 	lds	r24, 0x00E8
   10ff6:	8e 77       	andi	r24, 0x7E	; 126
   10ff8:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 8;
   10ffc:	f8 01       	movw	r30, r16
   10ffe:	84 89       	ldd	r24, Z+20	; 0x14
   11000:	95 89       	ldd	r25, Z+21	; 0x15
   11002:	a6 89       	ldd	r26, Z+22	; 0x16
   11004:	b7 89       	ldd	r27, Z+23	; 0x17
   11006:	08 97       	sbiw	r24, 0x08	; 8
   11008:	a1 09       	sbc	r26, r1
   1100a:	b1 09       	sbc	r27, r1
   1100c:	38 c0       	rjmp	.+112    	; 0x1107e <SCSI_DecodeSCSICommand+0x206>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Send_Diagnostic(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	/* Check to see if the SELF TEST bit is not set */
	if (!(MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & (1 << 2)))
   1100e:	f8 01       	movw	r30, r16
   11010:	84 8d       	ldd	r24, Z+28	; 0x1c
   11012:	82 fd       	sbrc	r24, 2
   11014:	08 c0       	rjmp	.+16     	; 0x11026 <SCSI_DecodeSCSICommand+0x1ae>
	{
		/* Only self-test supported - update SENSE key and fail the command */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
   11016:	80 91 ff 08 	lds	r24, 0x08FF
   1101a:	80 7f       	andi	r24, 0xF0	; 240
   1101c:	85 60       	ori	r24, 0x05	; 5
   1101e:	80 93 ff 08 	sts	0x08FF, r24
   11022:	84 e2       	ldi	r24, 0x24	; 36
   11024:	3e c0       	rjmp	.+124    	; 0x110a2 <SCSI_DecodeSCSICommand+0x22a>

		return false;
	}

	/* Check to see if all attached Dataflash ICs are functional */
	if (!(DataflashManager_CheckDataflashOperation()))
   11026:	5f dd       	rcall	.-1346   	; 0x10ae6 <DataflashManager_CheckDataflashOperation>
   11028:	88 23       	and	r24, r24
   1102a:	71 f5       	brne	.+92     	; 0x11088 <SCSI_DecodeSCSICommand+0x210>
	{
		/* Update SENSE key with a hardware error condition and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_HARDWARE_ERROR,
   1102c:	80 91 ff 08 	lds	r24, 0x08FF
   11030:	80 7f       	andi	r24, 0xF0	; 240
   11032:	84 60       	ori	r24, 0x04	; 4
   11034:	80 93 ff 08 	sts	0x08FF, r24
   11038:	10 92 09 09 	sts	0x0909, r1
   1103c:	10 92 0a 09 	sts	0x090A, r1
   11040:	3e c0       	rjmp	.+124    	; 0x110be <SCSI_DecodeSCSICommand+0x246>
			break;
		case SCSI_CMD_SEND_DIAGNOSTIC:
			CommandSuccess = SCSI_Command_Send_Diagnostic(MSInterfaceInfo);
			break;
		case SCSI_CMD_WRITE_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_WRITE);
   11042:	c8 01       	movw	r24, r16
   11044:	60 e0       	ldi	r22, 0x00	; 0
   11046:	02 c0       	rjmp	.+4      	; 0x1104c <SCSI_DecodeSCSICommand+0x1d4>
			break;
		case SCSI_CMD_READ_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
   11048:	c8 01       	movw	r24, r16
   1104a:	61 e0       	ldi	r22, 0x01	; 1
   1104c:	b5 de       	rcall	.-662    	; 0x10db8 <SCSI_Command_ReadWrite_10>
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
   1104e:	88 23       	and	r24, r24
   11050:	b1 f1       	breq	.+108    	; 0x110be <SCSI_DecodeSCSICommand+0x246>
   11052:	2a c0       	rjmp	.+84     	; 0x110a8 <SCSI_DecodeSCSICommand+0x230>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
   11054:	10 92 f1 00 	sts	0x00F1, r1
   11058:	10 92 f1 00 	sts	0x00F1, r1
   1105c:	10 92 f1 00 	sts	0x00F1, r1
   11060:	10 92 f1 00 	sts	0x00F1, r1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   11064:	80 91 e8 00 	lds	r24, 0x00E8
   11068:	8e 77       	andi	r24, 0x7E	; 126
   1106a:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_Write_8(DISK_READ_ONLY ? 0x80 : 0x00);
	Endpoint_Write_8(0x00);
	Endpoint_ClearIN();

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 4;
   1106e:	f8 01       	movw	r30, r16
   11070:	84 89       	ldd	r24, Z+20	; 0x14
   11072:	95 89       	ldd	r25, Z+21	; 0x15
   11074:	a6 89       	ldd	r26, Z+22	; 0x16
   11076:	b7 89       	ldd	r27, Z+23	; 0x17
   11078:	04 97       	sbiw	r24, 0x04	; 4
   1107a:	a1 09       	sbc	r26, r1
   1107c:	b1 09       	sbc	r27, r1
   1107e:	84 8b       	std	Z+20, r24	; 0x14
   11080:	95 8b       	std	Z+21, r25	; 0x15
   11082:	a6 8b       	std	Z+22, r26	; 0x16
   11084:	b7 8b       	std	Z+23, r27	; 0x17
		case SCSI_CMD_READ_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
			break;
		case SCSI_CMD_MODE_SENSE_6:
			CommandSuccess = SCSI_Command_ModeSense_6(MSInterfaceInfo);
			break;
   11086:	10 c0       	rjmp	.+32     	; 0x110a8 <SCSI_DecodeSCSICommand+0x230>
		case SCSI_CMD_TEST_UNIT_READY:
		case SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
		case SCSI_CMD_VERIFY_10:
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
   11088:	f8 01       	movw	r30, r16
   1108a:	14 8a       	std	Z+20, r1	; 0x14
   1108c:	15 8a       	std	Z+21, r1	; 0x15
   1108e:	16 8a       	std	Z+22, r1	; 0x16
   11090:	17 8a       	std	Z+23, r1	; 0x17
   11092:	0a c0       	rjmp	.+20     	; 0x110a8 <SCSI_DecodeSCSICommand+0x230>
			break;
		default:
			/* Update the SENSE key to reflect the invalid command */
			SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
   11094:	80 91 ff 08 	lds	r24, 0x08FF
   11098:	80 7f       	andi	r24, 0xF0	; 240
   1109a:	85 60       	ori	r24, 0x05	; 5
   1109c:	80 93 ff 08 	sts	0x08FF, r24
   110a0:	80 e2       	ldi	r24, 0x20	; 32
   110a2:	80 93 09 09 	sts	0x0909, r24
   110a6:	ca cf       	rjmp	.-108    	; 0x1103c <SCSI_DecodeSCSICommand+0x1c4>
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
	{
		SCSI_SET_SENSE(SCSI_SENSE_KEY_GOOD,
   110a8:	80 91 ff 08 	lds	r24, 0x08FF
   110ac:	80 7f       	andi	r24, 0xF0	; 240
   110ae:	80 93 ff 08 	sts	0x08FF, r24
   110b2:	10 92 09 09 	sts	0x0909, r1
   110b6:	10 92 0a 09 	sts	0x090A, r1
		               SCSI_ASENSE_NO_ADDITIONAL_INFORMATION,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return true;
   110ba:	81 e0       	ldi	r24, 0x01	; 1
   110bc:	01 c0       	rjmp	.+2      	; 0x110c0 <SCSI_DecodeSCSICommand+0x248>
	}

	return false;
   110be:	80 e0       	ldi	r24, 0x00	; 0
}
   110c0:	28 96       	adiw	r28, 0x08	; 8
   110c2:	0f b6       	in	r0, 0x3f	; 63
   110c4:	f8 94       	cli
   110c6:	de bf       	out	0x3e, r29	; 62
   110c8:	0f be       	out	0x3f, r0	; 63
   110ca:	cd bf       	out	0x3d, r28	; 61
   110cc:	cf 91       	pop	r28
   110ce:	df 91       	pop	r29
   110d0:	1f 91       	pop	r17
   110d2:	0f 91       	pop	r16
   110d4:	ff 90       	pop	r15
   110d6:	ef 90       	pop	r14
   110d8:	df 90       	pop	r13
   110da:	cf 90       	pop	r12
   110dc:	08 95       	ret

000110de <disk_initialize>:
DSTATUS disk_initialize (
	BYTE drv				/* Physical drive number (0..) */
)
{
	return FR_OK;
}
   110de:	80 e0       	ldi	r24, 0x00	; 0
   110e0:	08 95       	ret

000110e2 <disk_status>:
DSTATUS disk_status (
	BYTE drv		/* Physical drive number (0..) */
)
{
	return FR_OK;
}
   110e2:	80 e0       	ldi	r24, 0x00	; 0
   110e4:	08 95       	ret

000110e6 <disk_read>:
	BYTE drv,		/* Physical drive number (0..) */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address (LBA) */
	BYTE count		/* Number of sectors to read (1..128) */
)
{
   110e6:	0f 93       	push	r16
   110e8:	fb 01       	movw	r30, r22
   110ea:	ca 01       	movw	r24, r20
   110ec:	b9 01       	movw	r22, r18
   110ee:	40 2f       	mov	r20, r16
	DataflashManager_ReadBlocks_RAM(sector, count, buff);
   110f0:	50 e0       	ldi	r21, 0x00	; 0
   110f2:	9f 01       	movw	r18, r30
   110f4:	17 dc       	rcall	.-2002   	; 0x10924 <DataflashManager_ReadBlocks_RAM>
	return RES_OK;
}
   110f6:	80 e0       	ldi	r24, 0x00	; 0
   110f8:	0f 91       	pop	r16
   110fa:	08 95       	ret

000110fc <disk_write>:
	BYTE drv,			/* Physical drive number (0..) */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address (LBA) */
	BYTE count			/* Number of sectors to write (1..128) */
)
{
   110fc:	0f 93       	push	r16
   110fe:	fb 01       	movw	r30, r22
   11100:	ca 01       	movw	r24, r20
   11102:	b9 01       	movw	r22, r18
   11104:	40 2f       	mov	r20, r16
	DataflashManager_WriteBlocks_RAM(sector, count, buff);
   11106:	50 e0       	ldi	r21, 0x00	; 0
   11108:	9f 01       	movw	r18, r30
   1110a:	40 db       	rcall	.-2432   	; 0x1078c <DataflashManager_WriteBlocks_RAM>
	return RES_OK;
}
   1110c:	80 e0       	ldi	r24, 0x00	; 0
   1110e:	0f 91       	pop	r16
   11110:	08 95       	ret

00011112 <disk_ioctl>:
	BYTE drv,		/* Physical drive number (0..) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
	if (ctrl == CTRL_SYNC)
   11112:	66 23       	and	r22, r22
   11114:	11 f4       	brne	.+4      	; 0x1111a <disk_ioctl+0x8>
	  return RES_OK;
   11116:	80 e0       	ldi	r24, 0x00	; 0
   11118:	08 95       	ret
	else
	  return RES_PARERR;
   1111a:	84 e0       	ldi	r24, 0x04	; 4
}
   1111c:	08 95       	ret

0001111e <get_fattime>:


DWORD get_fattime (void)
{
   1111e:	df 93       	push	r29
   11120:	cf 93       	push	r28
   11122:	00 d0       	rcall	.+0      	; 0x11124 <get_fattime+0x6>
   11124:	00 d0       	rcall	.+0      	; 0x11126 <get_fattime+0x8>
   11126:	00 d0       	rcall	.+0      	; 0x11128 <get_fattime+0xa>
   11128:	cd b7       	in	r28, 0x3d	; 61
   1112a:	de b7       	in	r29, 0x3e	; 62
	TimeDate_t CurrTimeDate;

	RTC_GetTimeDate(&CurrTimeDate);
   1112c:	ce 01       	movw	r24, r28
   1112e:	01 96       	adiw	r24, 0x01	; 1
   11130:	07 dd       	rcall	.-1522   	; 0x10b40 <RTC_GetTimeDate>


	return ((DWORD)(20 + CurrTimeDate.Year) << 25) |
	             ((DWORD)CurrTimeDate.Month << 21) |
	               ((DWORD)CurrTimeDate.Day << 16) |
   11132:	2c 81       	ldd	r18, Y+4	; 0x04
   11134:	30 e0       	ldi	r19, 0x00	; 0
   11136:	40 e0       	ldi	r20, 0x00	; 0
   11138:	50 e0       	ldi	r21, 0x00	; 0
   1113a:	a9 01       	movw	r20, r18
   1113c:	33 27       	eor	r19, r19
   1113e:	22 27       	eor	r18, r18

	RTC_GetTimeDate(&CurrTimeDate);


	return ((DWORD)(20 + CurrTimeDate.Year) << 25) |
	             ((DWORD)CurrTimeDate.Month << 21) |
   11140:	8d 81       	ldd	r24, Y+5	; 0x05
   11142:	90 e0       	ldi	r25, 0x00	; 0
   11144:	a0 e0       	ldi	r26, 0x00	; 0
   11146:	b0 e0       	ldi	r27, 0x00	; 0
   11148:	f5 e1       	ldi	r31, 0x15	; 21
   1114a:	88 0f       	add	r24, r24
   1114c:	99 1f       	adc	r25, r25
   1114e:	aa 1f       	adc	r26, r26
   11150:	bb 1f       	adc	r27, r27
   11152:	fa 95       	dec	r31
   11154:	d1 f7       	brne	.-12     	; 0x1114a <get_fattime+0x2c>
	TimeDate_t CurrTimeDate;

	RTC_GetTimeDate(&CurrTimeDate);


	return ((DWORD)(20 + CurrTimeDate.Year) << 25) |
   11156:	28 2b       	or	r18, r24
   11158:	39 2b       	or	r19, r25
   1115a:	4a 2b       	or	r20, r26
   1115c:	5b 2b       	or	r21, r27
	             ((DWORD)CurrTimeDate.Month << 21) |
	               ((DWORD)CurrTimeDate.Day << 16) |
	              ((DWORD)CurrTimeDate.Hour << 11) |
   1115e:	89 81       	ldd	r24, Y+1	; 0x01
   11160:	90 e0       	ldi	r25, 0x00	; 0
   11162:	a0 e0       	ldi	r26, 0x00	; 0
   11164:	b0 e0       	ldi	r27, 0x00	; 0
   11166:	eb e0       	ldi	r30, 0x0B	; 11
   11168:	88 0f       	add	r24, r24
   1116a:	99 1f       	adc	r25, r25
   1116c:	aa 1f       	adc	r26, r26
   1116e:	bb 1f       	adc	r27, r27
   11170:	ea 95       	dec	r30
   11172:	d1 f7       	brne	.-12     	; 0x11168 <get_fattime+0x4a>

	RTC_GetTimeDate(&CurrTimeDate);


	return ((DWORD)(20 + CurrTimeDate.Year) << 25) |
	             ((DWORD)CurrTimeDate.Month << 21) |
   11174:	28 2b       	or	r18, r24
   11176:	39 2b       	or	r19, r25
   11178:	4a 2b       	or	r20, r26
   1117a:	5b 2b       	or	r21, r27
	               ((DWORD)CurrTimeDate.Day << 16) |
	              ((DWORD)CurrTimeDate.Hour << 11) |
	             ((DWORD)CurrTimeDate.Minute << 5) |
   1117c:	8a 81       	ldd	r24, Y+2	; 0x02
   1117e:	90 e0       	ldi	r25, 0x00	; 0
   11180:	a0 e0       	ldi	r26, 0x00	; 0
   11182:	b0 e0       	ldi	r27, 0x00	; 0
   11184:	75 e0       	ldi	r23, 0x05	; 5
   11186:	88 0f       	add	r24, r24
   11188:	99 1f       	adc	r25, r25
   1118a:	aa 1f       	adc	r26, r26
   1118c:	bb 1f       	adc	r27, r27
   1118e:	7a 95       	dec	r23
   11190:	d1 f7       	brne	.-12     	; 0x11186 <get_fattime+0x68>
	RTC_GetTimeDate(&CurrTimeDate);


	return ((DWORD)(20 + CurrTimeDate.Year) << 25) |
	             ((DWORD)CurrTimeDate.Month << 21) |
	               ((DWORD)CurrTimeDate.Day << 16) |
   11192:	28 2b       	or	r18, r24
   11194:	39 2b       	or	r19, r25
   11196:	4a 2b       	or	r20, r26
   11198:	5b 2b       	or	r21, r27
	              ((DWORD)CurrTimeDate.Hour << 11) |
	             ((DWORD)CurrTimeDate.Minute << 5) |
	      (((DWORD)CurrTimeDate.Second >> 1) << 0);
   1119a:	8b 81       	ldd	r24, Y+3	; 0x03
   1119c:	86 95       	lsr	r24
   1119e:	90 e0       	ldi	r25, 0x00	; 0
   111a0:	a0 e0       	ldi	r26, 0x00	; 0
   111a2:	b0 e0       	ldi	r27, 0x00	; 0


	return ((DWORD)(20 + CurrTimeDate.Year) << 25) |
	             ((DWORD)CurrTimeDate.Month << 21) |
	               ((DWORD)CurrTimeDate.Day << 16) |
	              ((DWORD)CurrTimeDate.Hour << 11) |
   111a4:	28 2b       	or	r18, r24
   111a6:	39 2b       	or	r19, r25
   111a8:	4a 2b       	or	r20, r26
   111aa:	5b 2b       	or	r21, r27
	TimeDate_t CurrTimeDate;

	RTC_GetTimeDate(&CurrTimeDate);


	return ((DWORD)(20 + CurrTimeDate.Year) << 25) |
   111ac:	8e 81       	ldd	r24, Y+6	; 0x06
   111ae:	90 e0       	ldi	r25, 0x00	; 0
   111b0:	44 96       	adiw	r24, 0x14	; 20
   111b2:	aa 27       	eor	r26, r26
   111b4:	97 fd       	sbrc	r25, 7
   111b6:	a0 95       	com	r26
   111b8:	ba 2f       	mov	r27, r26
   111ba:	69 e1       	ldi	r22, 0x19	; 25
   111bc:	88 0f       	add	r24, r24
   111be:	99 1f       	adc	r25, r25
   111c0:	aa 1f       	adc	r26, r26
   111c2:	bb 1f       	adc	r27, r27
   111c4:	6a 95       	dec	r22
   111c6:	d1 f7       	brne	.-12     	; 0x111bc <get_fattime+0x9e>
   111c8:	28 2b       	or	r18, r24
   111ca:	39 2b       	or	r19, r25
   111cc:	4a 2b       	or	r20, r26
   111ce:	5b 2b       	or	r21, r27
	             ((DWORD)CurrTimeDate.Month << 21) |
	               ((DWORD)CurrTimeDate.Day << 16) |
	              ((DWORD)CurrTimeDate.Hour << 11) |
	             ((DWORD)CurrTimeDate.Minute << 5) |
	      (((DWORD)CurrTimeDate.Second >> 1) << 0);
}
   111d0:	b9 01       	movw	r22, r18
   111d2:	ca 01       	movw	r24, r20
   111d4:	26 96       	adiw	r28, 0x06	; 6
   111d6:	0f b6       	in	r0, 0x3f	; 63
   111d8:	f8 94       	cli
   111da:	de bf       	out	0x3e, r29	; 62
   111dc:	0f be       	out	0x3f, r0	; 63
   111de:	cd bf       	out	0x3d, r28	; 61
   111e0:	cf 91       	pop	r28
   111e2:	df 91       	pop	r29
   111e4:	08 95       	ret

000111e6 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
   111e6:	cf 93       	push	r28
   111e8:	df 93       	push	r29
	BYTE *d = (BYTE*)dst;
   111ea:	9c 01       	movw	r18, r24
	const BYTE *s = (const BYTE*)src;
   111ec:	cb 01       	movw	r24, r22
   111ee:	db 01       	movw	r26, r22
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
   111f0:	f9 01       	movw	r30, r18
	const BYTE *s = (const BYTE*)src;

#if _WORD_ACCESS == 1
	while (cnt >= sizeof (int)) {
   111f2:	ba 01       	movw	r22, r20
   111f4:	06 c0       	rjmp	.+12     	; 0x11202 <mem_cpy+0x1c>
		*(int*)d = *(int*)s;
   111f6:	cd 91       	ld	r28, X+
   111f8:	dd 91       	ld	r29, X+
   111fa:	c1 93       	st	Z+, r28
   111fc:	d1 93       	st	Z+, r29
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
   111fe:	62 50       	subi	r22, 0x02	; 2
   11200:	70 40       	sbci	r23, 0x00	; 0
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;

#if _WORD_ACCESS == 1
	while (cnt >= sizeof (int)) {
   11202:	62 30       	cpi	r22, 0x02	; 2
   11204:	71 05       	cpc	r23, r1
   11206:	b8 f7       	brcc	.-18     	; 0x111f6 <mem_cpy+0x10>
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
   11208:	ba 01       	movw	r22, r20
   1120a:	6e 7f       	andi	r22, 0xFE	; 254
   1120c:	26 0f       	add	r18, r22
   1120e:	37 1f       	adc	r19, r23
   11210:	86 0f       	add	r24, r22
   11212:	97 1f       	adc	r25, r23
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
   11214:	40 ff       	sbrs	r20, 0
   11216:	04 c0       	rjmp	.+8      	; 0x11220 <mem_cpy+0x3a>
		*d++ = *s++;
   11218:	fc 01       	movw	r30, r24
   1121a:	80 81       	ld	r24, Z
   1121c:	f9 01       	movw	r30, r18
   1121e:	80 83       	st	Z, r24
}
   11220:	df 91       	pop	r29
   11222:	cf 91       	pop	r28
   11224:	08 95       	ret

00011226 <mem_set>:

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
   11226:	28 2f       	mov	r18, r24
   11228:	39 2f       	mov	r19, r25
   1122a:	f9 01       	movw	r30, r18

	while (cnt--)
   1122c:	03 c0       	rjmp	.+6      	; 0x11234 <mem_set+0xe>
		*d++ = (BYTE)val;
   1122e:	61 93       	st	Z+, r22
   11230:	41 50       	subi	r20, 0x01	; 1
   11232:	50 40       	sbci	r21, 0x00	; 0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
   11234:	41 15       	cp	r20, r1
   11236:	51 05       	cpc	r21, r1
   11238:	d1 f7       	brne	.-12     	; 0x1122e <mem_set+0x8>
		*d++ = (BYTE)val;
}
   1123a:	08 95       	ret

0001123c <st_clust>:
void st_clust (
	BYTE *dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
   1123c:	fc 01       	movw	r30, r24
   1123e:	53 8f       	std	Z+27, r21	; 0x1b
   11240:	42 8f       	std	Z+26, r20	; 0x1a
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   11242:	75 8b       	std	Z+21, r23	; 0x15
   11244:	64 8b       	std	Z+20, r22	; 0x14
}
   11246:	08 95       	ret

00011248 <validate>:
)
{
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
   11248:	fc 01       	movw	r30, r24
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
   1124a:	a0 81       	ld	r26, Z
   1124c:	b1 81       	ldd	r27, Z+1	; 0x01
   1124e:	10 97       	sbiw	r26, 0x00	; 0
   11250:	99 f0       	breq	.+38     	; 0x11278 <validate+0x30>
   11252:	8c 91       	ld	r24, X
   11254:	88 23       	and	r24, r24
   11256:	81 f0       	breq	.+32     	; 0x11278 <validate+0x30>
   11258:	16 96       	adiw	r26, 0x06	; 6
   1125a:	2d 91       	ld	r18, X+
   1125c:	3c 91       	ld	r19, X
   1125e:	17 97       	sbiw	r26, 0x07	; 7
   11260:	82 81       	ldd	r24, Z+2	; 0x02
   11262:	93 81       	ldd	r25, Z+3	; 0x03
   11264:	28 17       	cp	r18, r24
   11266:	39 07       	cpc	r19, r25
   11268:	39 f4       	brne	.+14     	; 0x11278 <validate+0x30>
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
   1126a:	11 96       	adiw	r26, 0x01	; 1
   1126c:	8c 91       	ld	r24, X
   1126e:	39 df       	rcall	.-398    	; 0x110e2 <disk_status>
   11270:	80 ff       	sbrs	r24, 0
   11272:	04 c0       	rjmp	.+8      	; 0x1127c <validate+0x34>
		return FR_NOT_READY;
   11274:	83 e0       	ldi	r24, 0x03	; 3
   11276:	08 95       	ret
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
		return FR_INVALID_OBJECT;
   11278:	89 e0       	ldi	r24, 0x09	; 9
   1127a:	08 95       	ret
	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
   1127c:	80 e0       	ldi	r24, 0x00	; 0
}
   1127e:	08 95       	ret

00011280 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
   11280:	ef 92       	push	r14
   11282:	ff 92       	push	r15
   11284:	0f 93       	push	r16
   11286:	cf 93       	push	r28
   11288:	df 93       	push	r29
   1128a:	ec 01       	movw	r28, r24
   1128c:	9a 01       	movw	r18, r20
   1128e:	ab 01       	movw	r20, r22
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   11290:	8e e2       	ldi	r24, 0x2E	; 46
   11292:	e8 2e       	mov	r14, r24
   11294:	f1 2c       	mov	r15, r1
   11296:	ec 0e       	add	r14, r28
   11298:	fd 1e       	adc	r15, r29
   1129a:	89 81       	ldd	r24, Y+1	; 0x01
   1129c:	b7 01       	movw	r22, r14
   1129e:	01 e0       	ldi	r16, 0x01	; 1
   112a0:	22 df       	rcall	.-444    	; 0x110e6 <disk_read>
   112a2:	88 23       	and	r24, r24
   112a4:	41 f5       	brne	.+80     	; 0x112f6 <check_fs+0x76>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
   112a6:	fe 01       	movw	r30, r28
   112a8:	e4 5d       	subi	r30, 0xD4	; 212
   112aa:	fd 4f       	sbci	r31, 0xFD	; 253
   112ac:	80 81       	ld	r24, Z
   112ae:	91 81       	ldd	r25, Z+1	; 0x01
   112b0:	2a ea       	ldi	r18, 0xAA	; 170
   112b2:	85 35       	cpi	r24, 0x55	; 85
   112b4:	92 07       	cpc	r25, r18
   112b6:	09 f5       	brne	.+66     	; 0x112fa <check_fs+0x7a>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   112b8:	f7 01       	movw	r30, r14
   112ba:	86 a9       	ldd	r24, Z+54	; 0x36
   112bc:	97 a9       	ldd	r25, Z+55	; 0x37
   112be:	a0 ad       	ldd	r26, Z+56	; 0x38
   112c0:	b1 ad       	ldd	r27, Z+57	; 0x39
   112c2:	b0 70       	andi	r27, 0x00	; 0
   112c4:	86 34       	cpi	r24, 0x46	; 70
   112c6:	f1 e4       	ldi	r31, 0x41	; 65
   112c8:	9f 07       	cpc	r25, r31
   112ca:	f4 e5       	ldi	r31, 0x54	; 84
   112cc:	af 07       	cpc	r26, r31
   112ce:	f0 e0       	ldi	r31, 0x00	; 0
   112d0:	bf 07       	cpc	r27, r31
   112d2:	a9 f0       	breq	.+42     	; 0x112fe <check_fs+0x7e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
   112d4:	c0 58       	subi	r28, 0x80	; 128
   112d6:	df 4f       	sbci	r29, 0xFF	; 255
   112d8:	28 81       	ld	r18, Y
   112da:	39 81       	ldd	r19, Y+1	; 0x01
   112dc:	4a 81       	ldd	r20, Y+2	; 0x02
   112de:	5b 81       	ldd	r21, Y+3	; 0x03
   112e0:	50 70       	andi	r21, 0x00	; 0
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
   112e2:	81 e0       	ldi	r24, 0x01	; 1
   112e4:	26 34       	cpi	r18, 0x46	; 70
   112e6:	91 e4       	ldi	r25, 0x41	; 65
   112e8:	39 07       	cpc	r19, r25
   112ea:	94 e5       	ldi	r25, 0x54	; 84
   112ec:	49 07       	cpc	r20, r25
   112ee:	90 e0       	ldi	r25, 0x00	; 0
   112f0:	59 07       	cpc	r21, r25
   112f2:	31 f4       	brne	.+12     	; 0x11300 <check_fs+0x80>
   112f4:	04 c0       	rjmp	.+8      	; 0x112fe <check_fs+0x7e>
   112f6:	83 e0       	ldi	r24, 0x03	; 3
   112f8:	03 c0       	rjmp	.+6      	; 0x11300 <check_fs+0x80>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
   112fa:	82 e0       	ldi	r24, 0x02	; 2
   112fc:	01 c0       	rjmp	.+2      	; 0x11300 <check_fs+0x80>

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
   112fe:	80 e0       	ldi	r24, 0x00	; 0
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
   11300:	df 91       	pop	r29
   11302:	cf 91       	pop	r28
   11304:	0f 91       	pop	r16
   11306:	ff 90       	pop	r15
   11308:	ef 90       	pop	r14
   1130a:	08 95       	ret

0001130c <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
   1130c:	2f 92       	push	r2
   1130e:	3f 92       	push	r3
   11310:	4f 92       	push	r4
   11312:	5f 92       	push	r5
   11314:	6f 92       	push	r6
   11316:	7f 92       	push	r7
   11318:	8f 92       	push	r8
   1131a:	9f 92       	push	r9
   1131c:	af 92       	push	r10
   1131e:	bf 92       	push	r11
   11320:	cf 92       	push	r12
   11322:	df 92       	push	r13
   11324:	ef 92       	push	r14
   11326:	ff 92       	push	r15
   11328:	0f 93       	push	r16
   1132a:	1f 93       	push	r17
   1132c:	df 93       	push	r29
   1132e:	cf 93       	push	r28
   11330:	cd b7       	in	r28, 0x3d	; 61
   11332:	de b7       	in	r29, 0x3e	; 62
   11334:	60 97       	sbiw	r28, 0x10	; 16
   11336:	0f b6       	in	r0, 0x3f	; 63
   11338:	f8 94       	cli
   1133a:	de bf       	out	0x3e, r29	; 62
   1133c:	0f be       	out	0x3f, r0	; 63
   1133e:	cd bf       	out	0x3d, r28	; 61
   11340:	7c 01       	movw	r14, r24
   11342:	db 01       	movw	r26, r22
   11344:	14 2f       	mov	r17, r20
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
   11346:	fc 01       	movw	r30, r24
   11348:	40 81       	ld	r20, Z
   1134a:	51 81       	ldd	r21, Z+1	; 0x01
	FATFS *fs;


	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
   1134c:	fa 01       	movw	r30, r20
   1134e:	80 81       	ld	r24, Z
   11350:	90 e0       	ldi	r25, 0x00	; 0
   11352:	c0 97       	sbiw	r24, 0x30	; 48
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
   11354:	8a 30       	cpi	r24, 0x0A	; 10
   11356:	91 05       	cpc	r25, r1
   11358:	48 f4       	brcc	.+18     	; 0x1136c <chk_mounted+0x60>
   1135a:	21 81       	ldd	r18, Z+1	; 0x01
   1135c:	2a 33       	cpi	r18, 0x3A	; 58
   1135e:	31 f4       	brne	.+12     	; 0x1136c <chk_mounted+0x60>
		p += 2; *path = p;				/* Return pointer to the path name */
   11360:	4e 5f       	subi	r20, 0xFE	; 254
   11362:	5f 4f       	sbci	r21, 0xFF	; 255
   11364:	f7 01       	movw	r30, r14
   11366:	51 83       	std	Z+1, r21	; 0x01
   11368:	40 83       	st	Z, r20
   1136a:	02 c0       	rjmp	.+4      	; 0x11370 <chk_mounted+0x64>
	} else {							/* No drive number is given */
#if _FS_RPATH
		vol = CurrVol;					/* Use current drive */
#else
		vol = 0;						/* Use drive 0 */
   1136c:	80 e0       	ldi	r24, 0x00	; 0
   1136e:	90 e0       	ldi	r25, 0x00	; 0
#endif
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
   11370:	11 96       	adiw	r26, 0x01	; 1
   11372:	1c 92       	st	X, r1
   11374:	1e 92       	st	-X, r1
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
   11376:	00 97       	sbiw	r24, 0x00	; 0
   11378:	09 f0       	breq	.+2      	; 0x1137c <chk_mounted+0x70>
   1137a:	1d c2       	rjmp	.+1082   	; 0x117b6 <chk_mounted+0x4aa>
		return FR_INVALID_DRIVE;
	fs = FatFs[vol];					/* Get corresponding file system object */
   1137c:	20 90 7f 09 	lds	r2, 0x097F
   11380:	30 90 80 09 	lds	r3, 0x0980
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   11384:	21 14       	cp	r2, r1
   11386:	31 04       	cpc	r3, r1
   11388:	09 f4       	brne	.+2      	; 0x1138c <chk_mounted+0x80>
   1138a:	17 c2       	rjmp	.+1070   	; 0x117ba <chk_mounted+0x4ae>

	ENTER_FF(fs);						/* Lock file system */

	*rfs = fs;							/* Return pointer to the corresponding file system object */
   1138c:	2d 92       	st	X+, r2
   1138e:	3c 92       	st	X, r3
	if (fs->fs_type) {					/* If the volume has been mounted */
   11390:	d1 01       	movw	r26, r2
   11392:	8c 91       	ld	r24, X
   11394:	88 23       	and	r24, r24
   11396:	59 f0       	breq	.+22     	; 0x113ae <chk_mounted+0xa2>
		stat = disk_status(fs->drv);
   11398:	11 96       	adiw	r26, 0x01	; 1
   1139a:	8c 91       	ld	r24, X
   1139c:	a2 de       	rcall	.-700    	; 0x110e2 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
   1139e:	80 fd       	sbrc	r24, 0
   113a0:	06 c0       	rjmp	.+12     	; 0x113ae <chk_mounted+0xa2>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
   113a2:	11 23       	and	r17, r17
   113a4:	09 f4       	brne	.+2      	; 0x113a8 <chk_mounted+0x9c>
   113a6:	0b c2       	rjmp	.+1046   	; 0x117be <chk_mounted+0x4b2>
   113a8:	82 ff       	sbrs	r24, 2
   113aa:	09 c2       	rjmp	.+1042   	; 0x117be <chk_mounted+0x4b2>
   113ac:	0c c2       	rjmp	.+1048   	; 0x117c6 <chk_mounted+0x4ba>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
   113ae:	f1 01       	movw	r30, r2
   113b0:	10 82       	st	Z, r1
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   113b2:	11 82       	std	Z+1, r1	; 0x01
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
   113b4:	80 e0       	ldi	r24, 0x00	; 0
   113b6:	93 de       	rcall	.-730    	; 0x110de <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
   113b8:	80 fd       	sbrc	r24, 0
   113ba:	03 c2       	rjmp	.+1030   	; 0x117c2 <chk_mounted+0x4b6>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   113bc:	11 23       	and	r17, r17
   113be:	11 f0       	breq	.+4      	; 0x113c4 <chk_mounted+0xb8>
   113c0:	82 fd       	sbrc	r24, 2
   113c2:	01 c2       	rjmp	.+1026   	; 0x117c6 <chk_mounted+0x4ba>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
   113c4:	c1 01       	movw	r24, r2
   113c6:	40 e0       	ldi	r20, 0x00	; 0
   113c8:	50 e0       	ldi	r21, 0x00	; 0
   113ca:	ba 01       	movw	r22, r20
   113cc:	59 df       	rcall	.-334    	; 0x11280 <check_fs>
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
   113ce:	81 30       	cpi	r24, 0x01	; 1
   113d0:	d9 f4       	brne	.+54     	; 0x11408 <chk_mounted+0xfc>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
   113d2:	f1 01       	movw	r30, r2
   113d4:	e0 51       	subi	r30, 0x10	; 16
   113d6:	fe 4f       	sbci	r31, 0xFE	; 254
   113d8:	80 81       	ld	r24, Z
   113da:	88 23       	and	r24, r24
   113dc:	09 f4       	brne	.+2      	; 0x113e0 <chk_mounted+0xd4>
   113de:	f7 c1       	rjmp	.+1006   	; 0x117ce <chk_mounted+0x4c2>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
   113e0:	91 01       	movw	r18, r2
   113e2:	2c 50       	subi	r18, 0x0C	; 12
   113e4:	3e 4f       	sbci	r19, 0xFE	; 254
   113e6:	d9 01       	movw	r26, r18
   113e8:	8d 91       	ld	r24, X+
   113ea:	9d 91       	ld	r25, X+
   113ec:	0d 90       	ld	r0, X+
   113ee:	bc 91       	ld	r27, X
   113f0:	a0 2d       	mov	r26, r0
   113f2:	89 83       	std	Y+1, r24	; 0x01
   113f4:	9a 83       	std	Y+2, r25	; 0x02
   113f6:	ab 83       	std	Y+3, r26	; 0x03
   113f8:	bc 83       	std	Y+4, r27	; 0x04
			fmt = check_fs(fs, bsect);		/* Check the partition */
   113fa:	c1 01       	movw	r24, r2
   113fc:	49 81       	ldd	r20, Y+1	; 0x01
   113fe:	5a 81       	ldd	r21, Y+2	; 0x02
   11400:	6b 81       	ldd	r22, Y+3	; 0x03
   11402:	7c 81       	ldd	r23, Y+4	; 0x04
   11404:	3d df       	rcall	.-390    	; 0x11280 <check_fs>
   11406:	04 c0       	rjmp	.+8      	; 0x11410 <chk_mounted+0x104>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
   11408:	19 82       	std	Y+1, r1	; 0x01
   1140a:	1a 82       	std	Y+2, r1	; 0x02
   1140c:	1b 82       	std	Y+3, r1	; 0x03
   1140e:	1c 82       	std	Y+4, r1	; 0x04
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
   11410:	83 30       	cpi	r24, 0x03	; 3
   11412:	09 f4       	brne	.+2      	; 0x11416 <chk_mounted+0x10a>
   11414:	da c1       	rjmp	.+948    	; 0x117ca <chk_mounted+0x4be>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   11416:	88 23       	and	r24, r24
   11418:	09 f0       	breq	.+2      	; 0x1141c <chk_mounted+0x110>
   1141a:	d9 c1       	rjmp	.+946    	; 0x117ce <chk_mounted+0x4c2>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
   1141c:	ae e2       	ldi	r26, 0x2E	; 46
   1141e:	ea 2e       	mov	r14, r26
   11420:	f1 2c       	mov	r15, r1
   11422:	e2 0c       	add	r14, r2
   11424:	f3 1c       	adc	r15, r3
   11426:	f7 01       	movw	r30, r14
   11428:	83 85       	ldd	r24, Z+11	; 0x0b
   1142a:	94 85       	ldd	r25, Z+12	; 0x0c
   1142c:	f2 e0       	ldi	r31, 0x02	; 2
   1142e:	80 30       	cpi	r24, 0x00	; 0
   11430:	9f 07       	cpc	r25, r31
   11432:	09 f0       	breq	.+2      	; 0x11436 <chk_mounted+0x12a>
   11434:	cc c1       	rjmp	.+920    	; 0x117ce <chk_mounted+0x4c2>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
   11436:	d7 01       	movw	r26, r14
   11438:	56 96       	adiw	r26, 0x16	; 22
   1143a:	8d 91       	ld	r24, X+
   1143c:	9c 91       	ld	r25, X
   1143e:	57 97       	sbiw	r26, 0x17	; 23
   11440:	9c 01       	movw	r18, r24
   11442:	40 e0       	ldi	r20, 0x00	; 0
   11444:	50 e0       	ldi	r21, 0x00	; 0
   11446:	2d 83       	std	Y+5, r18	; 0x05
   11448:	3e 83       	std	Y+6, r19	; 0x06
   1144a:	4f 83       	std	Y+7, r20	; 0x07
   1144c:	58 87       	std	Y+8, r21	; 0x08
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
   1144e:	21 15       	cp	r18, r1
   11450:	31 05       	cpc	r19, r1
   11452:	41 05       	cpc	r20, r1
   11454:	51 05       	cpc	r21, r1
   11456:	51 f4       	brne	.+20     	; 0x1146c <chk_mounted+0x160>
   11458:	94 96       	adiw	r26, 0x24	; 36
   1145a:	8d 91       	ld	r24, X+
   1145c:	9d 91       	ld	r25, X+
   1145e:	0d 90       	ld	r0, X+
   11460:	bc 91       	ld	r27, X
   11462:	a0 2d       	mov	r26, r0
   11464:	8d 83       	std	Y+5, r24	; 0x05
   11466:	9e 83       	std	Y+6, r25	; 0x06
   11468:	af 83       	std	Y+7, r26	; 0x07
   1146a:	b8 87       	std	Y+8, r27	; 0x08
	fs->fsize = fasize;
   1146c:	2d 81       	ldd	r18, Y+5	; 0x05
   1146e:	3e 81       	ldd	r19, Y+6	; 0x06
   11470:	4f 81       	ldd	r20, Y+7	; 0x07
   11472:	58 85       	ldd	r21, Y+8	; 0x08
   11474:	d1 01       	movw	r26, r2
   11476:	5a 96       	adiw	r26, 0x1a	; 26
   11478:	2d 93       	st	X+, r18
   1147a:	3d 93       	st	X+, r19
   1147c:	4d 93       	st	X+, r20
   1147e:	5c 93       	st	X, r21
   11480:	5d 97       	sbiw	r26, 0x1d	; 29

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
   11482:	de 96       	adiw	r26, 0x3e	; 62
   11484:	2c 91       	ld	r18, X
   11486:	de 97       	sbiw	r26, 0x3e	; 62
   11488:	13 96       	adiw	r26, 0x03	; 3
   1148a:	2c 93       	st	X, r18
   1148c:	13 97       	sbiw	r26, 0x03	; 3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
   1148e:	82 2f       	mov	r24, r18
   11490:	81 50       	subi	r24, 0x01	; 1
   11492:	82 30       	cpi	r24, 0x02	; 2
   11494:	08 f0       	brcs	.+2      	; 0x11498 <chk_mounted+0x18c>
   11496:	9b c1       	rjmp	.+822    	; 0x117ce <chk_mounted+0x4c2>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
   11498:	db 96       	adiw	r26, 0x3b	; 59
   1149a:	1c 91       	ld	r17, X
   1149c:	db 97       	sbiw	r26, 0x3b	; 59
   1149e:	12 96       	adiw	r26, 0x02	; 2
   114a0:	1c 93       	st	X, r17
   114a2:	12 97       	sbiw	r26, 0x02	; 2
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
   114a4:	11 23       	and	r17, r17
   114a6:	09 f4       	brne	.+2      	; 0x114aa <chk_mounted+0x19e>
   114a8:	92 c1       	rjmp	.+804    	; 0x117ce <chk_mounted+0x4c2>
   114aa:	41 2f       	mov	r20, r17
   114ac:	50 e0       	ldi	r21, 0x00	; 0
   114ae:	ca 01       	movw	r24, r20
   114b0:	01 97       	sbiw	r24, 0x01	; 1
   114b2:	84 23       	and	r24, r20
   114b4:	95 23       	and	r25, r21
   114b6:	00 97       	sbiw	r24, 0x00	; 0
   114b8:	09 f0       	breq	.+2      	; 0x114bc <chk_mounted+0x1b0>
   114ba:	89 c1       	rjmp	.+786    	; 0x117ce <chk_mounted+0x4c2>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
   114bc:	f7 01       	movw	r30, r14
   114be:	41 88       	ldd	r4, Z+17	; 0x11
   114c0:	52 88       	ldd	r5, Z+18	; 0x12
   114c2:	19 96       	adiw	r26, 0x09	; 9
   114c4:	5c 92       	st	X, r5
   114c6:	4e 92       	st	-X, r4
   114c8:	18 97       	sbiw	r26, 0x08	; 8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
   114ca:	c2 01       	movw	r24, r4
   114cc:	8f 70       	andi	r24, 0x0F	; 15
   114ce:	90 70       	andi	r25, 0x00	; 0
   114d0:	00 97       	sbiw	r24, 0x00	; 0
   114d2:	09 f0       	breq	.+2      	; 0x114d6 <chk_mounted+0x1ca>
   114d4:	7c c1       	rjmp	.+760    	; 0x117ce <chk_mounted+0x4c2>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
   114d6:	63 88       	ldd	r6, Z+19	; 0x13
   114d8:	74 88       	ldd	r7, Z+20	; 0x14
   114da:	88 24       	eor	r8, r8
   114dc:	99 24       	eor	r9, r9
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
   114de:	61 14       	cp	r6, r1
   114e0:	71 04       	cpc	r7, r1
   114e2:	81 04       	cpc	r8, r1
   114e4:	91 04       	cpc	r9, r1
   114e6:	21 f4       	brne	.+8      	; 0x114f0 <chk_mounted+0x1e4>
   114e8:	60 a0       	ldd	r6, Z+32	; 0x20
   114ea:	71 a0       	ldd	r7, Z+33	; 0x21
   114ec:	82 a0       	ldd	r8, Z+34	; 0x22
   114ee:	93 a0       	ldd	r9, Z+35	; 0x23

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
   114f0:	d7 01       	movw	r26, r14
   114f2:	1e 96       	adiw	r26, 0x0e	; 14
   114f4:	ad 90       	ld	r10, X+
   114f6:	bc 90       	ld	r11, X
   114f8:	1f 97       	sbiw	r26, 0x0f	; 15
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
   114fa:	a1 14       	cp	r10, r1
   114fc:	b1 04       	cpc	r11, r1
   114fe:	09 f4       	brne	.+2      	; 0x11502 <chk_mounted+0x1f6>
   11500:	66 c1       	rjmp	.+716    	; 0x117ce <chk_mounted+0x4c2>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
   11502:	30 e0       	ldi	r19, 0x00	; 0
   11504:	40 e0       	ldi	r20, 0x00	; 0
   11506:	50 e0       	ldi	r21, 0x00	; 0
   11508:	6d 81       	ldd	r22, Y+5	; 0x05
   1150a:	7e 81       	ldd	r23, Y+6	; 0x06
   1150c:	8f 81       	ldd	r24, Y+7	; 0x07
   1150e:	98 85       	ldd	r25, Y+8	; 0x08
   11510:	0e 94 9d ac 	call	0x1593a	; 0x1593a <__mulsi3>
   11514:	69 87       	std	Y+9, r22	; 0x09
   11516:	7a 87       	std	Y+10, r23	; 0x0a
   11518:	8b 87       	std	Y+11, r24	; 0x0b
   1151a:	9c 87       	std	Y+12, r25	; 0x0c

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
   1151c:	95 01       	movw	r18, r10
   1151e:	40 e0       	ldi	r20, 0x00	; 0
   11520:	50 e0       	ldi	r21, 0x00	; 0
   11522:	2d 87       	std	Y+13, r18	; 0x0d
   11524:	3e 87       	std	Y+14, r19	; 0x0e
   11526:	4f 87       	std	Y+15, r20	; 0x0f
   11528:	58 8b       	std	Y+16, r21	; 0x10
   1152a:	52 01       	movw	r10, r4
   1152c:	f4 e0       	ldi	r31, 0x04	; 4
   1152e:	b6 94       	lsr	r11
   11530:	a7 94       	ror	r10
   11532:	fa 95       	dec	r31
   11534:	e1 f7       	brne	.-8      	; 0x1152e <chk_mounted+0x222>
   11536:	cc 24       	eor	r12, r12
   11538:	dd 24       	eor	r13, r13
   1153a:	a2 0e       	add	r10, r18
   1153c:	b3 1e       	adc	r11, r19
   1153e:	c4 1e       	adc	r12, r20
   11540:	d5 1e       	adc	r13, r21
   11542:	a6 0e       	add	r10, r22
   11544:	b7 1e       	adc	r11, r23
   11546:	c8 1e       	adc	r12, r24
   11548:	d9 1e       	adc	r13, r25
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   1154a:	6a 14       	cp	r6, r10
   1154c:	7b 04       	cpc	r7, r11
   1154e:	8c 04       	cpc	r8, r12
   11550:	9d 04       	cpc	r9, r13
   11552:	08 f4       	brcc	.+2      	; 0x11556 <chk_mounted+0x24a>
   11554:	3c c1       	rjmp	.+632    	; 0x117ce <chk_mounted+0x4c2>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   11556:	c4 01       	movw	r24, r8
   11558:	b3 01       	movw	r22, r6
   1155a:	6a 19       	sub	r22, r10
   1155c:	7b 09       	sbc	r23, r11
   1155e:	8c 09       	sbc	r24, r12
   11560:	9d 09       	sbc	r25, r13
   11562:	21 2f       	mov	r18, r17
   11564:	30 e0       	ldi	r19, 0x00	; 0
   11566:	40 e0       	ldi	r20, 0x00	; 0
   11568:	50 e0       	ldi	r21, 0x00	; 0
   1156a:	0e 94 c8 ac 	call	0x15990	; 0x15990 <__udivmodsi4>
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   1156e:	21 15       	cp	r18, r1
   11570:	31 05       	cpc	r19, r1
   11572:	41 05       	cpc	r20, r1
   11574:	51 05       	cpc	r21, r1
   11576:	09 f4       	brne	.+2      	; 0x1157a <chk_mounted+0x26e>
   11578:	2a c1       	rjmp	.+596    	; 0x117ce <chk_mounted+0x4c2>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   1157a:	26 3f       	cpi	r18, 0xF6	; 246
   1157c:	8f e0       	ldi	r24, 0x0F	; 15
   1157e:	38 07       	cpc	r19, r24
   11580:	80 e0       	ldi	r24, 0x00	; 0
   11582:	48 07       	cpc	r20, r24
   11584:	80 e0       	ldi	r24, 0x00	; 0
   11586:	58 07       	cpc	r21, r24
   11588:	50 f0       	brcs	.+20     	; 0x1159e <chk_mounted+0x292>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   1158a:	26 3f       	cpi	r18, 0xF6	; 246
   1158c:	9f ef       	ldi	r25, 0xFF	; 255
   1158e:	39 07       	cpc	r19, r25
   11590:	90 e0       	ldi	r25, 0x00	; 0
   11592:	49 07       	cpc	r20, r25
   11594:	90 e0       	ldi	r25, 0x00	; 0
   11596:	59 07       	cpc	r21, r25
   11598:	20 f4       	brcc	.+8      	; 0x115a2 <chk_mounted+0x296>
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   1159a:	12 e0       	ldi	r17, 0x02	; 2
   1159c:	03 c0       	rjmp	.+6      	; 0x115a4 <chk_mounted+0x298>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
   1159e:	11 e0       	ldi	r17, 0x01	; 1
   115a0:	01 c0       	rjmp	.+2      	; 0x115a4 <chk_mounted+0x298>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   115a2:	13 e0       	ldi	r17, 0x03	; 3

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   115a4:	2e 5f       	subi	r18, 0xFE	; 254
   115a6:	3f 4f       	sbci	r19, 0xFF	; 255
   115a8:	4f 4f       	sbci	r20, 0xFF	; 255
   115aa:	5f 4f       	sbci	r21, 0xFF	; 255
   115ac:	d1 01       	movw	r26, r2
   115ae:	56 96       	adiw	r26, 0x16	; 22
   115b0:	2d 93       	st	X+, r18
   115b2:	3d 93       	st	X+, r19
   115b4:	4d 93       	st	X+, r20
   115b6:	5c 93       	st	X, r21
   115b8:	59 97       	sbiw	r26, 0x19	; 25
	fs->database = bsect + sysect;						/* Data start sector */
   115ba:	89 81       	ldd	r24, Y+1	; 0x01
   115bc:	9a 81       	ldd	r25, Y+2	; 0x02
   115be:	ab 81       	ldd	r26, Y+3	; 0x03
   115c0:	bc 81       	ldd	r27, Y+4	; 0x04
   115c2:	a8 0e       	add	r10, r24
   115c4:	b9 1e       	adc	r11, r25
   115c6:	ca 1e       	adc	r12, r26
   115c8:	db 1e       	adc	r13, r27
   115ca:	d1 01       	movw	r26, r2
   115cc:	96 96       	adiw	r26, 0x26	; 38
   115ce:	ad 92       	st	X+, r10
   115d0:	bd 92       	st	X+, r11
   115d2:	cd 92       	st	X+, r12
   115d4:	dc 92       	st	X, r13
   115d6:	99 97       	sbiw	r26, 0x29	; 41
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   115d8:	a9 80       	ldd	r10, Y+1	; 0x01
   115da:	ba 80       	ldd	r11, Y+2	; 0x02
   115dc:	cb 80       	ldd	r12, Y+3	; 0x03
   115de:	dc 80       	ldd	r13, Y+4	; 0x04
   115e0:	8d 85       	ldd	r24, Y+13	; 0x0d
   115e2:	9e 85       	ldd	r25, Y+14	; 0x0e
   115e4:	af 85       	ldd	r26, Y+15	; 0x0f
   115e6:	b8 89       	ldd	r27, Y+16	; 0x10
   115e8:	a8 0e       	add	r10, r24
   115ea:	b9 1e       	adc	r11, r25
   115ec:	ca 1e       	adc	r12, r26
   115ee:	db 1e       	adc	r13, r27
   115f0:	d1 01       	movw	r26, r2
   115f2:	5e 96       	adiw	r26, 0x1e	; 30
   115f4:	ad 92       	st	X+, r10
   115f6:	bd 92       	st	X+, r11
   115f8:	cd 92       	st	X+, r12
   115fa:	dc 92       	st	X, r13
   115fc:	91 97       	sbiw	r26, 0x21	; 33
	if (fmt == FS_FAT32) {
   115fe:	13 30       	cpi	r17, 0x03	; 3
   11600:	c1 f4       	brne	.+48     	; 0x11632 <chk_mounted+0x326>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   11602:	41 14       	cp	r4, r1
   11604:	51 04       	cpc	r5, r1
   11606:	09 f0       	breq	.+2      	; 0x1160a <chk_mounted+0x2fe>
   11608:	e2 c0       	rjmp	.+452    	; 0x117ce <chk_mounted+0x4c2>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
   1160a:	f7 01       	movw	r30, r14
   1160c:	84 a5       	ldd	r24, Z+44	; 0x2c
   1160e:	95 a5       	ldd	r25, Z+45	; 0x2d
   11610:	a6 a5       	ldd	r26, Z+46	; 0x2e
   11612:	b7 a5       	ldd	r27, Z+47	; 0x2f
   11614:	f1 01       	movw	r30, r2
   11616:	82 a3       	std	Z+34, r24	; 0x22
   11618:	93 a3       	std	Z+35, r25	; 0x23
   1161a:	a4 a3       	std	Z+36, r26	; 0x24
   1161c:	b5 a3       	std	Z+37, r27	; 0x25
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
   1161e:	da 01       	movw	r26, r20
   11620:	c9 01       	movw	r24, r18
   11622:	e2 e0       	ldi	r30, 0x02	; 2
   11624:	88 0f       	add	r24, r24
   11626:	99 1f       	adc	r25, r25
   11628:	aa 1f       	adc	r26, r26
   1162a:	bb 1f       	adc	r27, r27
   1162c:	ea 95       	dec	r30
   1162e:	d1 f7       	brne	.-12     	; 0x11624 <chk_mounted+0x318>
   11630:	29 c0       	rjmp	.+82     	; 0x11684 <chk_mounted+0x378>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   11632:	41 14       	cp	r4, r1
   11634:	51 04       	cpc	r5, r1
   11636:	09 f4       	brne	.+2      	; 0x1163a <chk_mounted+0x32e>
   11638:	ca c0       	rjmp	.+404    	; 0x117ce <chk_mounted+0x4c2>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   1163a:	89 85       	ldd	r24, Y+9	; 0x09
   1163c:	9a 85       	ldd	r25, Y+10	; 0x0a
   1163e:	ab 85       	ldd	r26, Y+11	; 0x0b
   11640:	bc 85       	ldd	r27, Y+12	; 0x0c
   11642:	8a 0d       	add	r24, r10
   11644:	9b 1d       	adc	r25, r11
   11646:	ac 1d       	adc	r26, r12
   11648:	bd 1d       	adc	r27, r13
   1164a:	f1 01       	movw	r30, r2
   1164c:	82 a3       	std	Z+34, r24	; 0x22
   1164e:	93 a3       	std	Z+35, r25	; 0x23
   11650:	a4 a3       	std	Z+36, r26	; 0x24
   11652:	b5 a3       	std	Z+37, r27	; 0x25
   11654:	da 01       	movw	r26, r20
   11656:	c9 01       	movw	r24, r18
   11658:	88 0f       	add	r24, r24
   1165a:	99 1f       	adc	r25, r25
   1165c:	aa 1f       	adc	r26, r26
   1165e:	bb 1f       	adc	r27, r27
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   11660:	12 30       	cpi	r17, 0x02	; 2
   11662:	81 f0       	breq	.+32     	; 0x11684 <chk_mounted+0x378>
   11664:	82 0f       	add	r24, r18
   11666:	93 1f       	adc	r25, r19
   11668:	a4 1f       	adc	r26, r20
   1166a:	b5 1f       	adc	r27, r21
   1166c:	b6 95       	lsr	r27
   1166e:	a7 95       	ror	r26
   11670:	97 95       	ror	r25
   11672:	87 95       	ror	r24
   11674:	21 70       	andi	r18, 0x01	; 1
   11676:	30 70       	andi	r19, 0x00	; 0
   11678:	40 70       	andi	r20, 0x00	; 0
   1167a:	50 70       	andi	r21, 0x00	; 0
   1167c:	82 0f       	add	r24, r18
   1167e:	93 1f       	adc	r25, r19
   11680:	a4 1f       	adc	r26, r20
   11682:	b5 1f       	adc	r27, r21
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
   11684:	81 50       	subi	r24, 0x01	; 1
   11686:	9e 4f       	sbci	r25, 0xFE	; 254
   11688:	af 4f       	sbci	r26, 0xFF	; 255
   1168a:	bf 4f       	sbci	r27, 0xFF	; 255
   1168c:	29 e0       	ldi	r18, 0x09	; 9
   1168e:	b6 95       	lsr	r27
   11690:	a7 95       	ror	r26
   11692:	97 95       	ror	r25
   11694:	87 95       	ror	r24
   11696:	2a 95       	dec	r18
   11698:	d1 f7       	brne	.-12     	; 0x1168e <chk_mounted+0x382>
   1169a:	2d 81       	ldd	r18, Y+5	; 0x05
   1169c:	3e 81       	ldd	r19, Y+6	; 0x06
   1169e:	4f 81       	ldd	r20, Y+7	; 0x07
   116a0:	58 85       	ldd	r21, Y+8	; 0x08
   116a2:	28 17       	cp	r18, r24
   116a4:	39 07       	cpc	r19, r25
   116a6:	4a 07       	cpc	r20, r26
   116a8:	5b 07       	cpc	r21, r27
   116aa:	08 f4       	brcc	.+2      	; 0x116ae <chk_mounted+0x3a2>
   116ac:	90 c0       	rjmp	.+288    	; 0x117ce <chk_mounted+0x4c2>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
   116ae:	8f ef       	ldi	r24, 0xFF	; 255
   116b0:	9f ef       	ldi	r25, 0xFF	; 255
   116b2:	dc 01       	movw	r26, r24
   116b4:	f1 01       	movw	r30, r2
   116b6:	86 87       	std	Z+14, r24	; 0x0e
   116b8:	97 87       	std	Z+15, r25	; 0x0f
   116ba:	a0 8b       	std	Z+16, r26	; 0x10
   116bc:	b1 8b       	std	Z+17, r27	; 0x11
	fs->last_clust = 0;
   116be:	d1 01       	movw	r26, r2
   116c0:	1a 96       	adiw	r26, 0x0a	; 10
   116c2:	1d 92       	st	X+, r1
   116c4:	1d 92       	st	X+, r1
   116c6:	1d 92       	st	X+, r1
   116c8:	1c 92       	st	X, r1
   116ca:	1d 97       	sbiw	r26, 0x0d	; 13

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
   116cc:	13 30       	cpi	r17, 0x03	; 3
   116ce:	09 f0       	breq	.+2      	; 0x116d2 <chk_mounted+0x3c6>
   116d0:	5c c0       	rjmp	.+184    	; 0x1178a <chk_mounted+0x47e>
	 	fs->fsi_flag = 0;
   116d2:	15 96       	adiw	r26, 0x05	; 5
   116d4:	1c 92       	st	X, r1
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
   116d6:	f7 01       	movw	r30, r14
   116d8:	20 a9       	ldd	r18, Z+48	; 0x30
   116da:	31 a9       	ldd	r19, Z+49	; 0x31
   116dc:	40 e0       	ldi	r20, 0x00	; 0
   116de:	50 e0       	ldi	r21, 0x00	; 0
   116e0:	89 81       	ldd	r24, Y+1	; 0x01
   116e2:	9a 81       	ldd	r25, Y+2	; 0x02
   116e4:	ab 81       	ldd	r26, Y+3	; 0x03
   116e6:	bc 81       	ldd	r27, Y+4	; 0x04
   116e8:	28 0f       	add	r18, r24
   116ea:	39 1f       	adc	r19, r25
   116ec:	4a 1f       	adc	r20, r26
   116ee:	5b 1f       	adc	r21, r27
   116f0:	d1 01       	movw	r26, r2
   116f2:	52 96       	adiw	r26, 0x12	; 18
   116f4:	2d 93       	st	X+, r18
   116f6:	3d 93       	st	X+, r19
   116f8:	4d 93       	st	X+, r20
   116fa:	5c 93       	st	X, r21
   116fc:	55 97       	sbiw	r26, 0x15	; 21
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   116fe:	b1 01       	movw	r22, r2
   11700:	62 5d       	subi	r22, 0xD2	; 210
   11702:	7f 4f       	sbci	r23, 0xFF	; 255
   11704:	11 96       	adiw	r26, 0x01	; 1
   11706:	8c 91       	ld	r24, X
   11708:	01 e0       	ldi	r16, 0x01	; 1
   1170a:	ed dc       	rcall	.-1574   	; 0x110e6 <disk_read>
   1170c:	88 23       	and	r24, r24
   1170e:	e9 f5       	brne	.+122    	; 0x1178a <chk_mounted+0x47e>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   11710:	f7 01       	movw	r30, r14
   11712:	e2 50       	subi	r30, 0x02	; 2
   11714:	fe 4f       	sbci	r31, 0xFE	; 254

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   11716:	80 81       	ld	r24, Z
   11718:	91 81       	ldd	r25, Z+1	; 0x01
   1171a:	ba ea       	ldi	r27, 0xAA	; 170
   1171c:	85 35       	cpi	r24, 0x55	; 85
   1171e:	9b 07       	cpc	r25, r27
   11720:	a1 f5       	brne	.+104    	; 0x1178a <chk_mounted+0x47e>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   11722:	f1 01       	movw	r30, r2
   11724:	86 a5       	ldd	r24, Z+46	; 0x2e
   11726:	97 a5       	ldd	r25, Z+47	; 0x2f
   11728:	a0 a9       	ldd	r26, Z+48	; 0x30
   1172a:	b1 a9       	ldd	r27, Z+49	; 0x31
   1172c:	82 35       	cpi	r24, 0x52	; 82
   1172e:	f2 e5       	ldi	r31, 0x52	; 82
   11730:	9f 07       	cpc	r25, r31
   11732:	f1 e6       	ldi	r31, 0x61	; 97
   11734:	af 07       	cpc	r26, r31
   11736:	f1 e4       	ldi	r31, 0x41	; 65
   11738:	bf 07       	cpc	r27, r31
   1173a:	39 f5       	brne	.+78     	; 0x1178a <chk_mounted+0x47e>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
   1173c:	f7 01       	movw	r30, r14
   1173e:	ec 51       	subi	r30, 0x1C	; 28
   11740:	fe 4f       	sbci	r31, 0xFE	; 254
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
   11742:	80 81       	ld	r24, Z
   11744:	91 81       	ldd	r25, Z+1	; 0x01
   11746:	a2 81       	ldd	r26, Z+2	; 0x02
   11748:	b3 81       	ldd	r27, Z+3	; 0x03
   1174a:	82 37       	cpi	r24, 0x72	; 114
   1174c:	22 e7       	ldi	r18, 0x72	; 114
   1174e:	92 07       	cpc	r25, r18
   11750:	21 e4       	ldi	r18, 0x41	; 65
   11752:	a2 07       	cpc	r26, r18
   11754:	21 e6       	ldi	r18, 0x61	; 97
   11756:	b2 07       	cpc	r27, r18
   11758:	c1 f4       	brne	.+48     	; 0x1178a <chk_mounted+0x47e>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   1175a:	f7 01       	movw	r30, r14
   1175c:	e4 51       	subi	r30, 0x14	; 20
   1175e:	fe 4f       	sbci	r31, 0xFE	; 254
   11760:	80 81       	ld	r24, Z
   11762:	91 81       	ldd	r25, Z+1	; 0x01
   11764:	a2 81       	ldd	r26, Z+2	; 0x02
   11766:	b3 81       	ldd	r27, Z+3	; 0x03
   11768:	f1 01       	movw	r30, r2
   1176a:	82 87       	std	Z+10, r24	; 0x0a
   1176c:	93 87       	std	Z+11, r25	; 0x0b
   1176e:	a4 87       	std	Z+12, r26	; 0x0c
   11770:	b5 87       	std	Z+13, r27	; 0x0d
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   11772:	f7 01       	movw	r30, r14
   11774:	e8 51       	subi	r30, 0x18	; 24
   11776:	fe 4f       	sbci	r31, 0xFE	; 254
   11778:	80 81       	ld	r24, Z
   1177a:	91 81       	ldd	r25, Z+1	; 0x01
   1177c:	a2 81       	ldd	r26, Z+2	; 0x02
   1177e:	b3 81       	ldd	r27, Z+3	; 0x03
   11780:	f1 01       	movw	r30, r2
   11782:	86 87       	std	Z+14, r24	; 0x0e
   11784:	97 87       	std	Z+15, r25	; 0x0f
   11786:	a0 8b       	std	Z+16, r26	; 0x10
   11788:	b1 8b       	std	Z+17, r27	; 0x11
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
   1178a:	d1 01       	movw	r26, r2
   1178c:	1c 93       	st	X, r17
	fs->id = ++Fsid;		/* File system mount ID */
   1178e:	80 91 81 09 	lds	r24, 0x0981
   11792:	90 91 82 09 	lds	r25, 0x0982
   11796:	01 96       	adiw	r24, 0x01	; 1
   11798:	90 93 82 09 	sts	0x0982, r25
   1179c:	80 93 81 09 	sts	0x0981, r24
   117a0:	17 96       	adiw	r26, 0x07	; 7
   117a2:	9c 93       	st	X, r25
   117a4:	8e 93       	st	-X, r24
   117a6:	16 97       	sbiw	r26, 0x06	; 6
	fs->winsect = 0;		/* Invalidate sector cache */
   117a8:	f1 01       	movw	r30, r2
   117aa:	12 a6       	std	Z+42, r1	; 0x2a
   117ac:	13 a6       	std	Z+43, r1	; 0x2b
   117ae:	14 a6       	std	Z+44, r1	; 0x2c
   117b0:	15 a6       	std	Z+45, r1	; 0x2d
	fs->wflag = 0;
   117b2:	14 82       	std	Z+4, r1	; 0x04
   117b4:	04 c0       	rjmp	.+8      	; 0x117be <chk_mounted+0x4b2>
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
   117b6:	8b e0       	ldi	r24, 0x0B	; 11
   117b8:	0b c0       	rjmp	.+22     	; 0x117d0 <chk_mounted+0x4c4>
	fs = FatFs[vol];					/* Get corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   117ba:	8c e0       	ldi	r24, 0x0C	; 12
   117bc:	09 c0       	rjmp	.+18     	; 0x117d0 <chk_mounted+0x4c4>
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
   117be:	80 e0       	ldi	r24, 0x00	; 0
   117c0:	07 c0       	rjmp	.+14     	; 0x117d0 <chk_mounted+0x4c4>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
   117c2:	83 e0       	ldi	r24, 0x03	; 3
   117c4:	05 c0       	rjmp	.+10     	; 0x117d0 <chk_mounted+0x4c4>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
   117c6:	8a e0       	ldi	r24, 0x0A	; 10
   117c8:	03 c0       	rjmp	.+6      	; 0x117d0 <chk_mounted+0x4c4>
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
   117ca:	81 e0       	ldi	r24, 0x01	; 1
   117cc:	01 c0       	rjmp	.+2      	; 0x117d0 <chk_mounted+0x4c4>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;
   117ce:	8d e0       	ldi	r24, 0x0D	; 13
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
   117d0:	60 96       	adiw	r28, 0x10	; 16
   117d2:	0f b6       	in	r0, 0x3f	; 63
   117d4:	f8 94       	cli
   117d6:	de bf       	out	0x3e, r29	; 62
   117d8:	0f be       	out	0x3f, r0	; 63
   117da:	cd bf       	out	0x3d, r28	; 61
   117dc:	cf 91       	pop	r28
   117de:	df 91       	pop	r29
   117e0:	1f 91       	pop	r17
   117e2:	0f 91       	pop	r16
   117e4:	ff 90       	pop	r15
   117e6:	ef 90       	pop	r14
   117e8:	df 90       	pop	r13
   117ea:	cf 90       	pop	r12
   117ec:	bf 90       	pop	r11
   117ee:	af 90       	pop	r10
   117f0:	9f 90       	pop	r9
   117f2:	8f 90       	pop	r8
   117f4:	7f 90       	pop	r7
   117f6:	6f 90       	pop	r6
   117f8:	5f 90       	pop	r5
   117fa:	4f 90       	pop	r4
   117fc:	3f 90       	pop	r3
   117fe:	2f 90       	pop	r2
   11800:	08 95       	ret

00011802 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
   11802:	6f 92       	push	r6
   11804:	7f 92       	push	r7
   11806:	8f 92       	push	r8
   11808:	9f 92       	push	r9
   1180a:	af 92       	push	r10
   1180c:	bf 92       	push	r11
   1180e:	cf 92       	push	r12
   11810:	df 92       	push	r13
   11812:	ef 92       	push	r14
   11814:	ff 92       	push	r15
   11816:	0f 93       	push	r16
   11818:	1f 93       	push	r17
   1181a:	cf 93       	push	r28
   1181c:	df 93       	push	r29
   1181e:	ec 01       	movw	r28, r24
   11820:	4a 01       	movw	r8, r20
   11822:	5b 01       	movw	r10, r22
	DWORD wsect;


	wsect = fs->winsect;
   11824:	ca a4       	ldd	r12, Y+42	; 0x2a
   11826:	db a4       	ldd	r13, Y+43	; 0x2b
   11828:	ec a4       	ldd	r14, Y+44	; 0x2c
   1182a:	fd a4       	ldd	r15, Y+45	; 0x2d
	if (wsect != sector) {	/* Changed current window */
   1182c:	c4 16       	cp	r12, r20
   1182e:	d5 06       	cpc	r13, r21
   11830:	e6 06       	cpc	r14, r22
   11832:	f7 06       	cpc	r15, r23
   11834:	09 f4       	brne	.+2      	; 0x11838 <move_window+0x36>
   11836:	49 c0       	rjmp	.+146    	; 0x118ca <move_window+0xc8>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
   11838:	8c 81       	ldd	r24, Y+4	; 0x04
   1183a:	88 23       	and	r24, r24
   1183c:	91 f1       	breq	.+100    	; 0x118a2 <move_window+0xa0>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
   1183e:	be e2       	ldi	r27, 0x2E	; 46
   11840:	6b 2e       	mov	r6, r27
   11842:	71 2c       	mov	r7, r1
   11844:	6c 0e       	add	r6, r28
   11846:	7d 1e       	adc	r7, r29
   11848:	89 81       	ldd	r24, Y+1	; 0x01
   1184a:	b3 01       	movw	r22, r6
   1184c:	a7 01       	movw	r20, r14
   1184e:	96 01       	movw	r18, r12
   11850:	01 e0       	ldi	r16, 0x01	; 1
   11852:	54 dc       	rcall	.-1880   	; 0x110fc <disk_write>
   11854:	88 23       	and	r24, r24
   11856:	d9 f5       	brne	.+118    	; 0x118ce <move_window+0xcc>
				return FR_DISK_ERR;
			fs->wflag = 0;
   11858:	1c 82       	std	Y+4, r1	; 0x04
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
   1185a:	8a 8d       	ldd	r24, Y+26	; 0x1a
   1185c:	9b 8d       	ldd	r25, Y+27	; 0x1b
   1185e:	ac 8d       	ldd	r26, Y+28	; 0x1c
   11860:	bd 8d       	ldd	r27, Y+29	; 0x1d
   11862:	2e 8d       	ldd	r18, Y+30	; 0x1e
   11864:	3f 8d       	ldd	r19, Y+31	; 0x1f
   11866:	48 a1       	ldd	r20, Y+32	; 0x20
   11868:	59 a1       	ldd	r21, Y+33	; 0x21
   1186a:	82 0f       	add	r24, r18
   1186c:	93 1f       	adc	r25, r19
   1186e:	a4 1f       	adc	r26, r20
   11870:	b5 1f       	adc	r27, r21
   11872:	c8 16       	cp	r12, r24
   11874:	d9 06       	cpc	r13, r25
   11876:	ea 06       	cpc	r14, r26
   11878:	fb 06       	cpc	r15, r27
   1187a:	98 f4       	brcc	.+38     	; 0x118a2 <move_window+0xa0>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
   1187c:	1b 81       	ldd	r17, Y+3	; 0x03
   1187e:	0f c0       	rjmp	.+30     	; 0x1189e <move_window+0x9c>
					wsect += fs->fsize;
   11880:	8a 8d       	ldd	r24, Y+26	; 0x1a
   11882:	9b 8d       	ldd	r25, Y+27	; 0x1b
   11884:	ac 8d       	ldd	r26, Y+28	; 0x1c
   11886:	bd 8d       	ldd	r27, Y+29	; 0x1d
   11888:	c8 0e       	add	r12, r24
   1188a:	d9 1e       	adc	r13, r25
   1188c:	ea 1e       	adc	r14, r26
   1188e:	fb 1e       	adc	r15, r27
					disk_write(fs->drv, fs->win, wsect, 1);
   11890:	89 81       	ldd	r24, Y+1	; 0x01
   11892:	b3 01       	movw	r22, r6
   11894:	a7 01       	movw	r20, r14
   11896:	96 01       	movw	r18, r12
   11898:	01 e0       	ldi	r16, 0x01	; 1
   1189a:	30 dc       	rcall	.-1952   	; 0x110fc <disk_write>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
   1189c:	11 50       	subi	r17, 0x01	; 1
   1189e:	12 30       	cpi	r17, 0x02	; 2
   118a0:	78 f7       	brcc	.-34     	; 0x11880 <move_window+0x7e>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
   118a2:	81 14       	cp	r8, r1
   118a4:	91 04       	cpc	r9, r1
   118a6:	a1 04       	cpc	r10, r1
   118a8:	b1 04       	cpc	r11, r1
   118aa:	79 f0       	breq	.+30     	; 0x118ca <move_window+0xc8>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
   118ac:	be 01       	movw	r22, r28
   118ae:	62 5d       	subi	r22, 0xD2	; 210
   118b0:	7f 4f       	sbci	r23, 0xFF	; 255
   118b2:	89 81       	ldd	r24, Y+1	; 0x01
   118b4:	a5 01       	movw	r20, r10
   118b6:	94 01       	movw	r18, r8
   118b8:	01 e0       	ldi	r16, 0x01	; 1
   118ba:	15 dc       	rcall	.-2006   	; 0x110e6 <disk_read>
   118bc:	88 23       	and	r24, r24
   118be:	39 f4       	brne	.+14     	; 0x118ce <move_window+0xcc>
				return FR_DISK_ERR;
			fs->winsect = sector;
   118c0:	8a a6       	std	Y+42, r8	; 0x2a
   118c2:	9b a6       	std	Y+43, r9	; 0x2b
   118c4:	ac a6       	std	Y+44, r10	; 0x2c
   118c6:	bd a6       	std	Y+45, r11	; 0x2d
   118c8:	03 c0       	rjmp	.+6      	; 0x118d0 <move_window+0xce>
		}
	}

	return FR_OK;
   118ca:	80 e0       	ldi	r24, 0x00	; 0
   118cc:	01 c0       	rjmp	.+2      	; 0x118d0 <move_window+0xce>
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
   118ce:	81 e0       	ldi	r24, 0x01	; 1
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
   118d0:	df 91       	pop	r29
   118d2:	cf 91       	pop	r28
   118d4:	1f 91       	pop	r17
   118d6:	0f 91       	pop	r16
   118d8:	ff 90       	pop	r15
   118da:	ef 90       	pop	r14
   118dc:	df 90       	pop	r13
   118de:	cf 90       	pop	r12
   118e0:	bf 90       	pop	r11
   118e2:	af 90       	pop	r10
   118e4:	9f 90       	pop	r9
   118e6:	8f 90       	pop	r8
   118e8:	7f 90       	pop	r7
   118ea:	6f 90       	pop	r6
   118ec:	08 95       	ret

000118ee <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
   118ee:	0f 93       	push	r16
   118f0:	1f 93       	push	r17
   118f2:	cf 93       	push	r28
   118f4:	df 93       	push	r29
   118f6:	ec 01       	movw	r28, r24
	FRESULT res;


	res = move_window(fs, 0);
   118f8:	40 e0       	ldi	r20, 0x00	; 0
   118fa:	50 e0       	ldi	r21, 0x00	; 0
   118fc:	ba 01       	movw	r22, r20
   118fe:	81 df       	rcall	.-254    	; 0x11802 <move_window>
   11900:	98 2f       	mov	r25, r24
	if (res == FR_OK) {
   11902:	88 23       	and	r24, r24
   11904:	09 f0       	breq	.+2      	; 0x11908 <sync+0x1a>
   11906:	57 c0       	rjmp	.+174    	; 0x119b6 <sync+0xc8>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
   11908:	88 81       	ld	r24, Y
   1190a:	83 30       	cpi	r24, 0x03	; 3
   1190c:	09 f0       	breq	.+2      	; 0x11910 <sync+0x22>
   1190e:	4a c0       	rjmp	.+148    	; 0x119a4 <sync+0xb6>
   11910:	8d 81       	ldd	r24, Y+5	; 0x05
   11912:	88 23       	and	r24, r24
   11914:	09 f4       	brne	.+2      	; 0x11918 <sync+0x2a>
   11916:	46 c0       	rjmp	.+140    	; 0x119a4 <sync+0xb6>
			fs->winsect = 0;
   11918:	1a a6       	std	Y+42, r1	; 0x2a
   1191a:	1b a6       	std	Y+43, r1	; 0x2b
   1191c:	1c a6       	std	Y+44, r1	; 0x2c
   1191e:	1d a6       	std	Y+45, r1	; 0x2d
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
   11920:	8e 01       	movw	r16, r28
   11922:	02 5d       	subi	r16, 0xD2	; 210
   11924:	1f 4f       	sbci	r17, 0xFF	; 255
   11926:	c8 01       	movw	r24, r16
   11928:	60 e0       	ldi	r22, 0x00	; 0
   1192a:	70 e0       	ldi	r23, 0x00	; 0
   1192c:	40 e0       	ldi	r20, 0x00	; 0
   1192e:	52 e0       	ldi	r21, 0x02	; 2
   11930:	7a dc       	rcall	.-1804   	; 0x11226 <mem_set>
			ST_WORD(fs->win+BS_55AA, 0xAA55);
   11932:	fe 01       	movw	r30, r28
   11934:	e4 5d       	subi	r30, 0xD4	; 212
   11936:	fd 4f       	sbci	r31, 0xFD	; 253
   11938:	85 e5       	ldi	r24, 0x55	; 85
   1193a:	9a ea       	ldi	r25, 0xAA	; 170
   1193c:	91 83       	std	Z+1, r25	; 0x01
   1193e:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
   11940:	82 e5       	ldi	r24, 0x52	; 82
   11942:	92 e5       	ldi	r25, 0x52	; 82
   11944:	a1 e6       	ldi	r26, 0x61	; 97
   11946:	b1 e4       	ldi	r27, 0x41	; 65
   11948:	8e a7       	std	Y+46, r24	; 0x2e
   1194a:	9f a7       	std	Y+47, r25	; 0x2f
   1194c:	a8 ab       	std	Y+48, r26	; 0x30
   1194e:	b9 ab       	std	Y+49, r27	; 0x31
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
   11950:	fe 01       	movw	r30, r28
   11952:	ee 5e       	subi	r30, 0xEE	; 238
   11954:	fd 4f       	sbci	r31, 0xFD	; 253
   11956:	82 e7       	ldi	r24, 0x72	; 114
   11958:	92 e7       	ldi	r25, 0x72	; 114
   1195a:	a1 e4       	ldi	r26, 0x41	; 65
   1195c:	b1 e6       	ldi	r27, 0x61	; 97
   1195e:	80 83       	st	Z, r24
   11960:	91 83       	std	Z+1, r25	; 0x01
   11962:	a2 83       	std	Z+2, r26	; 0x02
   11964:	b3 83       	std	Z+3, r27	; 0x03
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
   11966:	fe 01       	movw	r30, r28
   11968:	ea 5e       	subi	r30, 0xEA	; 234
   1196a:	fd 4f       	sbci	r31, 0xFD	; 253
   1196c:	8e 85       	ldd	r24, Y+14	; 0x0e
   1196e:	9f 85       	ldd	r25, Y+15	; 0x0f
   11970:	a8 89       	ldd	r26, Y+16	; 0x10
   11972:	b9 89       	ldd	r27, Y+17	; 0x11
   11974:	80 83       	st	Z, r24
   11976:	91 83       	std	Z+1, r25	; 0x01
   11978:	a2 83       	std	Z+2, r26	; 0x02
   1197a:	b3 83       	std	Z+3, r27	; 0x03
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
   1197c:	fe 01       	movw	r30, r28
   1197e:	e6 5e       	subi	r30, 0xE6	; 230
   11980:	fd 4f       	sbci	r31, 0xFD	; 253
   11982:	8a 85       	ldd	r24, Y+10	; 0x0a
   11984:	9b 85       	ldd	r25, Y+11	; 0x0b
   11986:	ac 85       	ldd	r26, Y+12	; 0x0c
   11988:	bd 85       	ldd	r27, Y+13	; 0x0d
   1198a:	80 83       	st	Z, r24
   1198c:	91 83       	std	Z+1, r25	; 0x01
   1198e:	a2 83       	std	Z+2, r26	; 0x02
   11990:	b3 83       	std	Z+3, r27	; 0x03
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
   11992:	2a 89       	ldd	r18, Y+18	; 0x12
   11994:	3b 89       	ldd	r19, Y+19	; 0x13
   11996:	4c 89       	ldd	r20, Y+20	; 0x14
   11998:	5d 89       	ldd	r21, Y+21	; 0x15
   1199a:	89 81       	ldd	r24, Y+1	; 0x01
   1199c:	b8 01       	movw	r22, r16
   1199e:	01 e0       	ldi	r16, 0x01	; 1
   119a0:	ad db       	rcall	.-2214   	; 0x110fc <disk_write>
			fs->fsi_flag = 0;
   119a2:	1d 82       	std	Y+5, r1	; 0x05
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
   119a4:	89 81       	ldd	r24, Y+1	; 0x01
   119a6:	60 e0       	ldi	r22, 0x00	; 0
   119a8:	40 e0       	ldi	r20, 0x00	; 0
   119aa:	50 e0       	ldi	r21, 0x00	; 0
   119ac:	b2 db       	rcall	.-2204   	; 0x11112 <disk_ioctl>
   119ae:	91 e0       	ldi	r25, 0x01	; 1
   119b0:	88 23       	and	r24, r24
   119b2:	09 f4       	brne	.+2      	; 0x119b6 <sync+0xc8>
   119b4:	90 e0       	ldi	r25, 0x00	; 0
			res = FR_DISK_ERR;
	}

	return res;
}
   119b6:	89 2f       	mov	r24, r25
   119b8:	df 91       	pop	r29
   119ba:	cf 91       	pop	r28
   119bc:	1f 91       	pop	r17
   119be:	0f 91       	pop	r16
   119c0:	08 95       	ret

000119c2 <ld_clust.clone.0>:
	BYTE *dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
   119c2:	fb 01       	movw	r30, r22
   119c4:	22 8d       	ldd	r18, Z+26	; 0x1a
   119c6:	33 8d       	ldd	r19, Z+27	; 0x1b
   119c8:	40 e0       	ldi	r20, 0x00	; 0
   119ca:	50 e0       	ldi	r21, 0x00	; 0
	if (fs->fs_type == FS_FAT32)
   119cc:	83 30       	cpi	r24, 0x03	; 3
   119ce:	59 f4       	brne	.+22     	; 0x119e6 <ld_clust.clone.0+0x24>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
   119d0:	84 89       	ldd	r24, Z+20	; 0x14
   119d2:	95 89       	ldd	r25, Z+21	; 0x15
   119d4:	a0 e0       	ldi	r26, 0x00	; 0
   119d6:	b0 e0       	ldi	r27, 0x00	; 0
   119d8:	dc 01       	movw	r26, r24
   119da:	99 27       	eor	r25, r25
   119dc:	88 27       	eor	r24, r24
   119de:	28 2b       	or	r18, r24
   119e0:	39 2b       	or	r19, r25
   119e2:	4a 2b       	or	r20, r26
   119e4:	5b 2b       	or	r21, r27

	return cl;
}
   119e6:	b9 01       	movw	r22, r18
   119e8:	ca 01       	movw	r24, r20
   119ea:	08 95       	ret

000119ec <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
   119ec:	cf 93       	push	r28
   119ee:	df 93       	push	r29
   119f0:	ec 01       	movw	r28, r24
   119f2:	cb 01       	movw	r24, r22
   119f4:	ba 01       	movw	r22, r20
	clst -= 2;
   119f6:	62 50       	subi	r22, 0x02	; 2
   119f8:	70 40       	sbci	r23, 0x00	; 0
   119fa:	80 40       	sbci	r24, 0x00	; 0
   119fc:	90 40       	sbci	r25, 0x00	; 0
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
   119fe:	2e 89       	ldd	r18, Y+22	; 0x16
   11a00:	3f 89       	ldd	r19, Y+23	; 0x17
   11a02:	48 8d       	ldd	r20, Y+24	; 0x18
   11a04:	59 8d       	ldd	r21, Y+25	; 0x19
   11a06:	22 50       	subi	r18, 0x02	; 2
   11a08:	30 40       	sbci	r19, 0x00	; 0
   11a0a:	40 40       	sbci	r20, 0x00	; 0
   11a0c:	50 40       	sbci	r21, 0x00	; 0
   11a0e:	62 17       	cp	r22, r18
   11a10:	73 07       	cpc	r23, r19
   11a12:	84 07       	cpc	r24, r20
   11a14:	95 07       	cpc	r25, r21
   11a16:	88 f4       	brcc	.+34     	; 0x11a3a <clust2sect+0x4e>
	return clst * fs->csize + fs->database;
   11a18:	2a 81       	ldd	r18, Y+2	; 0x02
   11a1a:	30 e0       	ldi	r19, 0x00	; 0
   11a1c:	40 e0       	ldi	r20, 0x00	; 0
   11a1e:	50 e0       	ldi	r21, 0x00	; 0
   11a20:	0e 94 9d ac 	call	0x1593a	; 0x1593a <__mulsi3>
   11a24:	9b 01       	movw	r18, r22
   11a26:	ac 01       	movw	r20, r24
   11a28:	8e a1       	ldd	r24, Y+38	; 0x26
   11a2a:	9f a1       	ldd	r25, Y+39	; 0x27
   11a2c:	a8 a5       	ldd	r26, Y+40	; 0x28
   11a2e:	b9 a5       	ldd	r27, Y+41	; 0x29
   11a30:	28 0f       	add	r18, r24
   11a32:	39 1f       	adc	r19, r25
   11a34:	4a 1f       	adc	r20, r26
   11a36:	5b 1f       	adc	r21, r27
   11a38:	03 c0       	rjmp	.+6      	; 0x11a40 <clust2sect+0x54>
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
   11a3a:	20 e0       	ldi	r18, 0x00	; 0
   11a3c:	30 e0       	ldi	r19, 0x00	; 0
   11a3e:	a9 01       	movw	r20, r18
	return clst * fs->csize + fs->database;
}
   11a40:	b9 01       	movw	r22, r18
   11a42:	ca 01       	movw	r24, r20
   11a44:	df 91       	pop	r29
   11a46:	cf 91       	pop	r28
   11a48:	08 95       	ret

00011a4a <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
   11a4a:	bf 92       	push	r11
   11a4c:	cf 92       	push	r12
   11a4e:	df 92       	push	r13
   11a50:	ef 92       	push	r14
   11a52:	ff 92       	push	r15
   11a54:	0f 93       	push	r16
   11a56:	1f 93       	push	r17
   11a58:	cf 93       	push	r28
   11a5a:	df 93       	push	r29
   11a5c:	ec 01       	movw	r28, r24
   11a5e:	6a 01       	movw	r12, r20
   11a60:	7b 01       	movw	r14, r22
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
   11a62:	42 30       	cpi	r20, 0x02	; 2
   11a64:	51 05       	cpc	r21, r1
   11a66:	61 05       	cpc	r22, r1
   11a68:	71 05       	cpc	r23, r1
   11a6a:	08 f4       	brcc	.+2      	; 0x11a6e <get_fat+0x24>
   11a6c:	9e c0       	rjmp	.+316    	; 0x11baa <get_fat+0x160>
   11a6e:	8e 89       	ldd	r24, Y+22	; 0x16
   11a70:	9f 89       	ldd	r25, Y+23	; 0x17
   11a72:	a8 8d       	ldd	r26, Y+24	; 0x18
   11a74:	b9 8d       	ldd	r27, Y+25	; 0x19
   11a76:	48 17       	cp	r20, r24
   11a78:	59 07       	cpc	r21, r25
   11a7a:	6a 07       	cpc	r22, r26
   11a7c:	7b 07       	cpc	r23, r27
   11a7e:	08 f0       	brcs	.+2      	; 0x11a82 <get_fat+0x38>
   11a80:	94 c0       	rjmp	.+296    	; 0x11baa <get_fat+0x160>
		return 1;

	switch (fs->fs_type) {
   11a82:	88 81       	ld	r24, Y
   11a84:	82 30       	cpi	r24, 0x02	; 2
   11a86:	09 f4       	brne	.+2      	; 0x11a8a <get_fat+0x40>
   11a88:	54 c0       	rjmp	.+168    	; 0x11b32 <get_fat+0xe8>
   11a8a:	83 30       	cpi	r24, 0x03	; 3
   11a8c:	09 f4       	brne	.+2      	; 0x11a90 <get_fat+0x46>
   11a8e:	6c c0       	rjmp	.+216    	; 0x11b68 <get_fat+0x11e>
   11a90:	81 30       	cpi	r24, 0x01	; 1
   11a92:	09 f0       	breq	.+2      	; 0x11a96 <get_fat+0x4c>
   11a94:	8f c0       	rjmp	.+286    	; 0x11bb4 <get_fat+0x16a>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
   11a96:	8a 01       	movw	r16, r20
   11a98:	16 95       	lsr	r17
   11a9a:	07 95       	ror	r16
   11a9c:	04 0f       	add	r16, r20
   11a9e:	15 1f       	adc	r17, r21
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   11aa0:	a8 01       	movw	r20, r16
   11aa2:	45 2f       	mov	r20, r21
   11aa4:	55 27       	eor	r21, r21
   11aa6:	46 95       	lsr	r20
   11aa8:	60 e0       	ldi	r22, 0x00	; 0
   11aaa:	70 e0       	ldi	r23, 0x00	; 0
   11aac:	8e 8d       	ldd	r24, Y+30	; 0x1e
   11aae:	9f 8d       	ldd	r25, Y+31	; 0x1f
   11ab0:	a8 a1       	ldd	r26, Y+32	; 0x20
   11ab2:	b9 a1       	ldd	r27, Y+33	; 0x21
   11ab4:	48 0f       	add	r20, r24
   11ab6:	59 1f       	adc	r21, r25
   11ab8:	6a 1f       	adc	r22, r26
   11aba:	7b 1f       	adc	r23, r27
   11abc:	ce 01       	movw	r24, r28
   11abe:	a1 de       	rcall	.-702    	; 0x11802 <move_window>
   11ac0:	88 23       	and	r24, r24
   11ac2:	09 f0       	breq	.+2      	; 0x11ac6 <get_fat+0x7c>
   11ac4:	77 c0       	rjmp	.+238    	; 0x11bb4 <get_fat+0x16a>
		wc = fs->win[bc % SS(fs)]; bc++;
   11ac6:	f8 01       	movw	r30, r16
   11ac8:	f1 70       	andi	r31, 0x01	; 1
   11aca:	ec 0f       	add	r30, r28
   11acc:	fd 1f       	adc	r31, r29
   11ace:	b6 a4       	ldd	r11, Z+46	; 0x2e
   11ad0:	0f 5f       	subi	r16, 0xFF	; 255
   11ad2:	1f 4f       	sbci	r17, 0xFF	; 255
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   11ad4:	a8 01       	movw	r20, r16
   11ad6:	45 2f       	mov	r20, r21
   11ad8:	55 27       	eor	r21, r21
   11ada:	46 95       	lsr	r20
   11adc:	60 e0       	ldi	r22, 0x00	; 0
   11ade:	70 e0       	ldi	r23, 0x00	; 0
   11ae0:	8e 8d       	ldd	r24, Y+30	; 0x1e
   11ae2:	9f 8d       	ldd	r25, Y+31	; 0x1f
   11ae4:	a8 a1       	ldd	r26, Y+32	; 0x20
   11ae6:	b9 a1       	ldd	r27, Y+33	; 0x21
   11ae8:	48 0f       	add	r20, r24
   11aea:	59 1f       	adc	r21, r25
   11aec:	6a 1f       	adc	r22, r26
   11aee:	7b 1f       	adc	r23, r27
   11af0:	ce 01       	movw	r24, r28
   11af2:	87 de       	rcall	.-754    	; 0x11802 <move_window>
   11af4:	88 23       	and	r24, r24
   11af6:	09 f0       	breq	.+2      	; 0x11afa <get_fat+0xb0>
   11af8:	5d c0       	rjmp	.+186    	; 0x11bb4 <get_fat+0x16a>

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
   11afa:	2b 2d       	mov	r18, r11
   11afc:	30 e0       	ldi	r19, 0x00	; 0
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
   11afe:	11 70       	andi	r17, 0x01	; 1
   11b00:	0c 0f       	add	r16, r28
   11b02:	1d 1f       	adc	r17, r29
   11b04:	f8 01       	movw	r30, r16
   11b06:	96 a5       	ldd	r25, Z+46	; 0x2e
   11b08:	80 e0       	ldi	r24, 0x00	; 0
   11b0a:	28 2b       	or	r18, r24
   11b0c:	39 2b       	or	r19, r25
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
   11b0e:	f1 e0       	ldi	r31, 0x01	; 1
   11b10:	cf 22       	and	r12, r31
   11b12:	dd 24       	eor	r13, r13
   11b14:	c1 14       	cp	r12, r1
   11b16:	d1 04       	cpc	r13, r1
   11b18:	31 f0       	breq	.+12     	; 0x11b26 <get_fat+0xdc>
   11b1a:	14 e0       	ldi	r17, 0x04	; 4
   11b1c:	36 95       	lsr	r19
   11b1e:	27 95       	ror	r18
   11b20:	1a 95       	dec	r17
   11b22:	e1 f7       	brne	.-8      	; 0x11b1c <get_fat+0xd2>
   11b24:	1e c0       	rjmp	.+60     	; 0x11b62 <get_fat+0x118>
   11b26:	40 e0       	ldi	r20, 0x00	; 0
   11b28:	50 e0       	ldi	r21, 0x00	; 0
   11b2a:	3f 70       	andi	r19, 0x0F	; 15
   11b2c:	40 70       	andi	r20, 0x00	; 0
   11b2e:	50 70       	andi	r21, 0x00	; 0
   11b30:	44 c0       	rjmp	.+136    	; 0x11bba <get_fat+0x170>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
   11b32:	45 2f       	mov	r20, r21
   11b34:	56 2f       	mov	r21, r22
   11b36:	67 2f       	mov	r22, r23
   11b38:	77 27       	eor	r23, r23
   11b3a:	8e 8d       	ldd	r24, Y+30	; 0x1e
   11b3c:	9f 8d       	ldd	r25, Y+31	; 0x1f
   11b3e:	a8 a1       	ldd	r26, Y+32	; 0x20
   11b40:	b9 a1       	ldd	r27, Y+33	; 0x21
   11b42:	48 0f       	add	r20, r24
   11b44:	59 1f       	adc	r21, r25
   11b46:	6a 1f       	adc	r22, r26
   11b48:	7b 1f       	adc	r23, r27
   11b4a:	ce 01       	movw	r24, r28
   11b4c:	5a de       	rcall	.-844    	; 0x11802 <move_window>
   11b4e:	88 23       	and	r24, r24
   11b50:	89 f5       	brne	.+98     	; 0x11bb4 <get_fat+0x16a>
		p = &fs->win[clst * 2 % SS(fs)];
   11b52:	f6 01       	movw	r30, r12
   11b54:	ee 0f       	add	r30, r30
   11b56:	ff 1f       	adc	r31, r31
   11b58:	f1 70       	andi	r31, 0x01	; 1
		return LD_WORD(p);
   11b5a:	ec 0f       	add	r30, r28
   11b5c:	fd 1f       	adc	r31, r29
   11b5e:	26 a5       	ldd	r18, Z+46	; 0x2e
   11b60:	37 a5       	ldd	r19, Z+47	; 0x2f
   11b62:	40 e0       	ldi	r20, 0x00	; 0
   11b64:	50 e0       	ldi	r21, 0x00	; 0
   11b66:	29 c0       	rjmp	.+82     	; 0x11bba <get_fat+0x170>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
   11b68:	e7 e0       	ldi	r30, 0x07	; 7
   11b6a:	76 95       	lsr	r23
   11b6c:	67 95       	ror	r22
   11b6e:	57 95       	ror	r21
   11b70:	47 95       	ror	r20
   11b72:	ea 95       	dec	r30
   11b74:	d1 f7       	brne	.-12     	; 0x11b6a <get_fat+0x120>
   11b76:	8e 8d       	ldd	r24, Y+30	; 0x1e
   11b78:	9f 8d       	ldd	r25, Y+31	; 0x1f
   11b7a:	a8 a1       	ldd	r26, Y+32	; 0x20
   11b7c:	b9 a1       	ldd	r27, Y+33	; 0x21
   11b7e:	48 0f       	add	r20, r24
   11b80:	59 1f       	adc	r21, r25
   11b82:	6a 1f       	adc	r22, r26
   11b84:	7b 1f       	adc	r23, r27
   11b86:	ce 01       	movw	r24, r28
   11b88:	3c de       	rcall	.-904    	; 0x11802 <move_window>
   11b8a:	88 23       	and	r24, r24
   11b8c:	99 f4       	brne	.+38     	; 0x11bb4 <get_fat+0x16a>
		p = &fs->win[clst * 4 % SS(fs)];
   11b8e:	f6 01       	movw	r30, r12
   11b90:	ee 0f       	add	r30, r30
   11b92:	ff 1f       	adc	r31, r31
   11b94:	ee 0f       	add	r30, r30
   11b96:	ff 1f       	adc	r31, r31
   11b98:	f1 70       	andi	r31, 0x01	; 1
		return LD_DWORD(p) & 0x0FFFFFFF;
   11b9a:	ec 0f       	add	r30, r28
   11b9c:	fd 1f       	adc	r31, r29
   11b9e:	26 a5       	ldd	r18, Z+46	; 0x2e
   11ba0:	37 a5       	ldd	r19, Z+47	; 0x2f
   11ba2:	40 a9       	ldd	r20, Z+48	; 0x30
   11ba4:	51 a9       	ldd	r21, Z+49	; 0x31
   11ba6:	5f 70       	andi	r21, 0x0F	; 15
   11ba8:	08 c0       	rjmp	.+16     	; 0x11bba <get_fat+0x170>
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;
   11baa:	21 e0       	ldi	r18, 0x01	; 1
   11bac:	30 e0       	ldi	r19, 0x00	; 0
   11bae:	40 e0       	ldi	r20, 0x00	; 0
   11bb0:	50 e0       	ldi	r21, 0x00	; 0
   11bb2:	03 c0       	rjmp	.+6      	; 0x11bba <get_fat+0x170>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
   11bb4:	2f ef       	ldi	r18, 0xFF	; 255
   11bb6:	3f ef       	ldi	r19, 0xFF	; 255
   11bb8:	a9 01       	movw	r20, r18
}
   11bba:	b9 01       	movw	r22, r18
   11bbc:	ca 01       	movw	r24, r20
   11bbe:	df 91       	pop	r29
   11bc0:	cf 91       	pop	r28
   11bc2:	1f 91       	pop	r17
   11bc4:	0f 91       	pop	r16
   11bc6:	ff 90       	pop	r15
   11bc8:	ef 90       	pop	r14
   11bca:	df 90       	pop	r13
   11bcc:	cf 90       	pop	r12
   11bce:	bf 90       	pop	r11
   11bd0:	08 95       	ret

00011bd2 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Index of directory table */
)
{
   11bd2:	ef 92       	push	r14
   11bd4:	ff 92       	push	r15
   11bd6:	0f 93       	push	r16
   11bd8:	1f 93       	push	r17
   11bda:	cf 93       	push	r28
   11bdc:	df 93       	push	r29
   11bde:	ec 01       	movw	r28, r24
   11be0:	8b 01       	movw	r16, r22
	DWORD clst;
	WORD ic;


	dj->index = idx;
   11be2:	7d 83       	std	Y+5, r23	; 0x05
   11be4:	6c 83       	std	Y+4, r22	; 0x04
	clst = dj->sclust;
   11be6:	4e 81       	ldd	r20, Y+6	; 0x06
   11be8:	5f 81       	ldd	r21, Y+7	; 0x07
   11bea:	68 85       	ldd	r22, Y+8	; 0x08
   11bec:	79 85       	ldd	r23, Y+9	; 0x09
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
   11bee:	41 30       	cpi	r20, 0x01	; 1
   11bf0:	51 05       	cpc	r21, r1
   11bf2:	61 05       	cpc	r22, r1
   11bf4:	71 05       	cpc	r23, r1
   11bf6:	09 f4       	brne	.+2      	; 0x11bfa <dir_sdi+0x28>
   11bf8:	88 c0       	rjmp	.+272    	; 0x11d0a <dir_sdi+0x138>
   11bfa:	e8 81       	ld	r30, Y
   11bfc:	f9 81       	ldd	r31, Y+1	; 0x01
   11bfe:	86 89       	ldd	r24, Z+22	; 0x16
   11c00:	97 89       	ldd	r25, Z+23	; 0x17
   11c02:	a0 8d       	ldd	r26, Z+24	; 0x18
   11c04:	b1 8d       	ldd	r27, Z+25	; 0x19
   11c06:	48 17       	cp	r20, r24
   11c08:	59 07       	cpc	r21, r25
   11c0a:	6a 07       	cpc	r22, r26
   11c0c:	7b 07       	cpc	r23, r27
   11c0e:	08 f0       	brcs	.+2      	; 0x11c12 <dir_sdi+0x40>
   11c10:	7c c0       	rjmp	.+248    	; 0x11d0a <dir_sdi+0x138>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   11c12:	41 15       	cp	r20, r1
   11c14:	51 05       	cpc	r21, r1
   11c16:	61 05       	cpc	r22, r1
   11c18:	71 05       	cpc	r23, r1
   11c1a:	19 f5       	brne	.+70     	; 0x11c62 <dir_sdi+0x90>
   11c1c:	80 81       	ld	r24, Z
   11c1e:	83 30       	cpi	r24, 0x03	; 3
   11c20:	49 f4       	brne	.+18     	; 0x11c34 <dir_sdi+0x62>
		clst = dj->fs->dirbase;
   11c22:	42 a1       	ldd	r20, Z+34	; 0x22
   11c24:	53 a1       	ldd	r21, Z+35	; 0x23
   11c26:	64 a1       	ldd	r22, Z+36	; 0x24
   11c28:	75 a1       	ldd	r23, Z+37	; 0x25

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
   11c2a:	41 15       	cp	r20, r1
   11c2c:	51 05       	cpc	r21, r1
   11c2e:	61 05       	cpc	r22, r1
   11c30:	71 05       	cpc	r23, r1
   11c32:	b9 f4       	brne	.+46     	; 0x11c62 <dir_sdi+0x90>
		dj->clust = clst;
   11c34:	1a 86       	std	Y+10, r1	; 0x0a
   11c36:	1b 86       	std	Y+11, r1	; 0x0b
   11c38:	1c 86       	std	Y+12, r1	; 0x0c
   11c3a:	1d 86       	std	Y+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
   11c3c:	80 85       	ldd	r24, Z+8	; 0x08
   11c3e:	91 85       	ldd	r25, Z+9	; 0x09
   11c40:	08 17       	cp	r16, r24
   11c42:	19 07       	cpc	r17, r25
   11c44:	08 f0       	brcs	.+2      	; 0x11c48 <dir_sdi+0x76>
   11c46:	61 c0       	rjmp	.+194    	; 0x11d0a <dir_sdi+0x138>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   11c48:	c8 01       	movw	r24, r16
   11c4a:	a4 e0       	ldi	r26, 0x04	; 4
   11c4c:	96 95       	lsr	r25
   11c4e:	87 95       	ror	r24
   11c50:	aa 95       	dec	r26
   11c52:	e1 f7       	brne	.-8      	; 0x11c4c <dir_sdi+0x7a>
   11c54:	a0 e0       	ldi	r26, 0x00	; 0
   11c56:	b0 e0       	ldi	r27, 0x00	; 0
   11c58:	22 a1       	ldd	r18, Z+34	; 0x22
   11c5a:	33 a1       	ldd	r19, Z+35	; 0x23
   11c5c:	44 a1       	ldd	r20, Z+36	; 0x24
   11c5e:	55 a1       	ldd	r21, Z+37	; 0x25
   11c60:	3a c0       	rjmp	.+116    	; 0x11cd6 <dir_sdi+0x104>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
   11c62:	e2 80       	ldd	r14, Z+2	; 0x02
   11c64:	ff 24       	eor	r15, r15
   11c66:	e4 e0       	ldi	r30, 0x04	; 4
   11c68:	ee 0c       	add	r14, r14
   11c6a:	ff 1c       	adc	r15, r15
   11c6c:	ea 95       	dec	r30
   11c6e:	e1 f7       	brne	.-8      	; 0x11c68 <dir_sdi+0x96>
		while (idx >= ic) {	/* Follow cluster chain */
   11c70:	1e c0       	rjmp	.+60     	; 0x11cae <dir_sdi+0xdc>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
   11c72:	eb de       	rcall	.-554    	; 0x11a4a <get_fat>
   11c74:	ab 01       	movw	r20, r22
   11c76:	bc 01       	movw	r22, r24
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   11c78:	4f 3f       	cpi	r20, 0xFF	; 255
   11c7a:	8f ef       	ldi	r24, 0xFF	; 255
   11c7c:	58 07       	cpc	r21, r24
   11c7e:	8f ef       	ldi	r24, 0xFF	; 255
   11c80:	68 07       	cpc	r22, r24
   11c82:	8f ef       	ldi	r24, 0xFF	; 255
   11c84:	78 07       	cpc	r23, r24
   11c86:	09 f4       	brne	.+2      	; 0x11c8a <dir_sdi+0xb8>
   11c88:	3e c0       	rjmp	.+124    	; 0x11d06 <dir_sdi+0x134>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
   11c8a:	42 30       	cpi	r20, 0x02	; 2
   11c8c:	51 05       	cpc	r21, r1
   11c8e:	61 05       	cpc	r22, r1
   11c90:	71 05       	cpc	r23, r1
   11c92:	d8 f1       	brcs	.+118    	; 0x11d0a <dir_sdi+0x138>
   11c94:	e8 81       	ld	r30, Y
   11c96:	f9 81       	ldd	r31, Y+1	; 0x01
   11c98:	86 89       	ldd	r24, Z+22	; 0x16
   11c9a:	97 89       	ldd	r25, Z+23	; 0x17
   11c9c:	a0 8d       	ldd	r26, Z+24	; 0x18
   11c9e:	b1 8d       	ldd	r27, Z+25	; 0x19
   11ca0:	48 17       	cp	r20, r24
   11ca2:	59 07       	cpc	r21, r25
   11ca4:	6a 07       	cpc	r22, r26
   11ca6:	7b 07       	cpc	r23, r27
   11ca8:	80 f5       	brcc	.+96     	; 0x11d0a <dir_sdi+0x138>
				return FR_INT_ERR;
			idx -= ic;
   11caa:	0e 19       	sub	r16, r14
   11cac:	1f 09       	sbc	r17, r15
   11cae:	88 81       	ld	r24, Y
   11cb0:	99 81       	ldd	r25, Y+1	; 0x01
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
   11cb2:	0e 15       	cp	r16, r14
   11cb4:	1f 05       	cpc	r17, r15
   11cb6:	e8 f6       	brcc	.-70     	; 0x11c72 <dir_sdi+0xa0>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
   11cb8:	4a 87       	std	Y+10, r20	; 0x0a
   11cba:	5b 87       	std	Y+11, r21	; 0x0b
   11cbc:	6c 87       	std	Y+12, r22	; 0x0c
   11cbe:	7d 87       	std	Y+13, r23	; 0x0d
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   11cc0:	95 de       	rcall	.-726    	; 0x119ec <clust2sect>
   11cc2:	9b 01       	movw	r18, r22
   11cc4:	ac 01       	movw	r20, r24
   11cc6:	c8 01       	movw	r24, r16
   11cc8:	64 e0       	ldi	r22, 0x04	; 4
   11cca:	96 95       	lsr	r25
   11ccc:	87 95       	ror	r24
   11cce:	6a 95       	dec	r22
   11cd0:	e1 f7       	brne	.-8      	; 0x11cca <dir_sdi+0xf8>
   11cd2:	a0 e0       	ldi	r26, 0x00	; 0
   11cd4:	b0 e0       	ldi	r27, 0x00	; 0
   11cd6:	82 0f       	add	r24, r18
   11cd8:	93 1f       	adc	r25, r19
   11cda:	a4 1f       	adc	r26, r20
   11cdc:	b5 1f       	adc	r27, r21
   11cde:	8e 87       	std	Y+14, r24	; 0x0e
   11ce0:	9f 87       	std	Y+15, r25	; 0x0f
   11ce2:	a8 8b       	std	Y+16, r26	; 0x10
   11ce4:	b9 8b       	std	Y+17, r27	; 0x11
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
   11ce6:	88 81       	ld	r24, Y
   11ce8:	99 81       	ldd	r25, Y+1	; 0x01
   11cea:	8e 96       	adiw	r24, 0x2e	; 46
   11cec:	0f 70       	andi	r16, 0x0F	; 15
   11cee:	10 70       	andi	r17, 0x00	; 0
   11cf0:	35 e0       	ldi	r19, 0x05	; 5
   11cf2:	00 0f       	add	r16, r16
   11cf4:	11 1f       	adc	r17, r17
   11cf6:	3a 95       	dec	r19
   11cf8:	e1 f7       	brne	.-8      	; 0x11cf2 <dir_sdi+0x120>
   11cfa:	80 0f       	add	r24, r16
   11cfc:	91 1f       	adc	r25, r17
   11cfe:	9b 8b       	std	Y+19, r25	; 0x13
   11d00:	8a 8b       	std	Y+18, r24	; 0x12

	return FR_OK;	/* Seek succeeded */
   11d02:	80 e0       	ldi	r24, 0x00	; 0
   11d04:	03 c0       	rjmp	.+6      	; 0x11d0c <dir_sdi+0x13a>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   11d06:	81 e0       	ldi	r24, 0x01	; 1
   11d08:	01 c0       	rjmp	.+2      	; 0x11d0c <dir_sdi+0x13a>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
   11d0a:	82 e0       	ldi	r24, 0x02	; 2
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
   11d0c:	df 91       	pop	r29
   11d0e:	cf 91       	pop	r28
   11d10:	1f 91       	pop	r17
   11d12:	0f 91       	pop	r16
   11d14:	ff 90       	pop	r15
   11d16:	ef 90       	pop	r14
   11d18:	08 95       	ret

00011d1a <put_fat>:
FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
   11d1a:	8f 92       	push	r8
   11d1c:	9f 92       	push	r9
   11d1e:	af 92       	push	r10
   11d20:	bf 92       	push	r11
   11d22:	cf 92       	push	r12
   11d24:	df 92       	push	r13
   11d26:	ef 92       	push	r14
   11d28:	ff 92       	push	r15
   11d2a:	0f 93       	push	r16
   11d2c:	1f 93       	push	r17
   11d2e:	cf 93       	push	r28
   11d30:	df 93       	push	r29
   11d32:	ec 01       	movw	r28, r24
   11d34:	6a 01       	movw	r12, r20
   11d36:	7b 01       	movw	r14, r22
   11d38:	48 01       	movw	r8, r16
   11d3a:	59 01       	movw	r10, r18
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   11d3c:	42 30       	cpi	r20, 0x02	; 2
   11d3e:	51 05       	cpc	r21, r1
   11d40:	61 05       	cpc	r22, r1
   11d42:	71 05       	cpc	r23, r1
   11d44:	08 f4       	brcc	.+2      	; 0x11d48 <put_fat+0x2e>
   11d46:	bf c0       	rjmp	.+382    	; 0x11ec6 <put_fat+0x1ac>
   11d48:	8e 89       	ldd	r24, Y+22	; 0x16
   11d4a:	9f 89       	ldd	r25, Y+23	; 0x17
   11d4c:	a8 8d       	ldd	r26, Y+24	; 0x18
   11d4e:	b9 8d       	ldd	r27, Y+25	; 0x19
   11d50:	48 17       	cp	r20, r24
   11d52:	59 07       	cpc	r21, r25
   11d54:	6a 07       	cpc	r22, r26
   11d56:	7b 07       	cpc	r23, r27
   11d58:	08 f0       	brcs	.+2      	; 0x11d5c <put_fat+0x42>
   11d5a:	b5 c0       	rjmp	.+362    	; 0x11ec6 <put_fat+0x1ac>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
   11d5c:	88 81       	ld	r24, Y
   11d5e:	82 30       	cpi	r24, 0x02	; 2
   11d60:	09 f4       	brne	.+2      	; 0x11d64 <put_fat+0x4a>
   11d62:	66 c0       	rjmp	.+204    	; 0x11e30 <put_fat+0x116>
   11d64:	83 30       	cpi	r24, 0x03	; 3
   11d66:	09 f4       	brne	.+2      	; 0x11d6a <put_fat+0x50>
   11d68:	7d c0       	rjmp	.+250    	; 0x11e64 <put_fat+0x14a>
   11d6a:	81 30       	cpi	r24, 0x01	; 1
   11d6c:	09 f0       	breq	.+2      	; 0x11d70 <put_fat+0x56>
   11d6e:	a7 c0       	rjmp	.+334    	; 0x11ebe <put_fat+0x1a4>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
   11d70:	8a 01       	movw	r16, r20
   11d72:	16 95       	lsr	r17
   11d74:	07 95       	ror	r16
   11d76:	0c 0d       	add	r16, r12
   11d78:	1d 1d       	adc	r17, r13
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   11d7a:	a8 01       	movw	r20, r16
   11d7c:	45 2f       	mov	r20, r21
   11d7e:	55 27       	eor	r21, r21
   11d80:	46 95       	lsr	r20
   11d82:	60 e0       	ldi	r22, 0x00	; 0
   11d84:	70 e0       	ldi	r23, 0x00	; 0
   11d86:	8e 8d       	ldd	r24, Y+30	; 0x1e
   11d88:	9f 8d       	ldd	r25, Y+31	; 0x1f
   11d8a:	a8 a1       	ldd	r26, Y+32	; 0x20
   11d8c:	b9 a1       	ldd	r27, Y+33	; 0x21
   11d8e:	48 0f       	add	r20, r24
   11d90:	59 1f       	adc	r21, r25
   11d92:	6a 1f       	adc	r22, r26
   11d94:	7b 1f       	adc	r23, r27
   11d96:	ce 01       	movw	r24, r28
   11d98:	34 dd       	rcall	.-1432   	; 0x11802 <move_window>
			if (res != FR_OK) break;
   11d9a:	88 23       	and	r24, r24
   11d9c:	09 f0       	breq	.+2      	; 0x11da0 <put_fat+0x86>
   11d9e:	90 c0       	rjmp	.+288    	; 0x11ec0 <put_fat+0x1a6>
			p = &fs->win[bc % SS(fs)];
   11da0:	c8 01       	movw	r24, r16
   11da2:	91 70       	andi	r25, 0x01	; 1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   11da4:	e1 e0       	ldi	r30, 0x01	; 1
   11da6:	ce 22       	and	r12, r30
   11da8:	dd 24       	eor	r13, r13
   11daa:	c1 14       	cp	r12, r1
   11dac:	d1 04       	cpc	r13, r1
   11dae:	51 f0       	breq	.+20     	; 0x11dc4 <put_fat+0xaa>
   11db0:	fe 01       	movw	r30, r28
   11db2:	e8 0f       	add	r30, r24
   11db4:	f9 1f       	adc	r31, r25
   11db6:	36 a5       	ldd	r19, Z+46	; 0x2e
   11db8:	3f 70       	andi	r19, 0x0F	; 15
   11dba:	28 2d       	mov	r18, r8
   11dbc:	22 95       	swap	r18
   11dbe:	20 7f       	andi	r18, 0xF0	; 240
   11dc0:	23 2b       	or	r18, r19
   11dc2:	01 c0       	rjmp	.+2      	; 0x11dc6 <put_fat+0xac>
   11dc4:	28 2d       	mov	r18, r8
   11dc6:	8c 0f       	add	r24, r28
   11dc8:	9d 1f       	adc	r25, r29
   11dca:	fc 01       	movw	r30, r24
   11dcc:	26 a7       	std	Z+46, r18	; 0x2e
			bc++;
   11dce:	0f 5f       	subi	r16, 0xFF	; 255
   11dd0:	1f 4f       	sbci	r17, 0xFF	; 255
			fs->wflag = 1;
   11dd2:	81 e0       	ldi	r24, 0x01	; 1
   11dd4:	8c 83       	std	Y+4, r24	; 0x04
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   11dd6:	a8 01       	movw	r20, r16
   11dd8:	45 2f       	mov	r20, r21
   11dda:	55 27       	eor	r21, r21
   11ddc:	46 95       	lsr	r20
   11dde:	60 e0       	ldi	r22, 0x00	; 0
   11de0:	70 e0       	ldi	r23, 0x00	; 0
   11de2:	8e 8d       	ldd	r24, Y+30	; 0x1e
   11de4:	9f 8d       	ldd	r25, Y+31	; 0x1f
   11de6:	a8 a1       	ldd	r26, Y+32	; 0x20
   11de8:	b9 a1       	ldd	r27, Y+33	; 0x21
   11dea:	48 0f       	add	r20, r24
   11dec:	59 1f       	adc	r21, r25
   11dee:	6a 1f       	adc	r22, r26
   11df0:	7b 1f       	adc	r23, r27
   11df2:	ce 01       	movw	r24, r28
   11df4:	06 dd       	rcall	.-1524   	; 0x11802 <move_window>
			if (res != FR_OK) break;
   11df6:	88 23       	and	r24, r24
   11df8:	09 f0       	breq	.+2      	; 0x11dfc <put_fat+0xe2>
   11dfa:	62 c0       	rjmp	.+196    	; 0x11ec0 <put_fat+0x1a6>
			p = &fs->win[bc % SS(fs)];
   11dfc:	11 70       	andi	r17, 0x01	; 1
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   11dfe:	c1 14       	cp	r12, r1
   11e00:	d1 04       	cpc	r13, r1
   11e02:	49 f0       	breq	.+18     	; 0x11e16 <put_fat+0xfc>
   11e04:	94 e0       	ldi	r25, 0x04	; 4
   11e06:	b6 94       	lsr	r11
   11e08:	a7 94       	ror	r10
   11e0a:	97 94       	ror	r9
   11e0c:	87 94       	ror	r8
   11e0e:	9a 95       	dec	r25
   11e10:	d1 f7       	brne	.-12     	; 0x11e06 <put_fat+0xec>
   11e12:	98 2d       	mov	r25, r8
   11e14:	08 c0       	rjmp	.+16     	; 0x11e26 <put_fat+0x10c>
   11e16:	fe 01       	movw	r30, r28
   11e18:	e0 0f       	add	r30, r16
   11e1a:	f1 1f       	adc	r31, r17
   11e1c:	96 a5       	ldd	r25, Z+46	; 0x2e
   11e1e:	90 7f       	andi	r25, 0xF0	; 240
   11e20:	29 2d       	mov	r18, r9
   11e22:	2f 70       	andi	r18, 0x0F	; 15
   11e24:	92 2b       	or	r25, r18
   11e26:	0c 0f       	add	r16, r28
   11e28:	1d 1f       	adc	r17, r29
   11e2a:	f8 01       	movw	r30, r16
   11e2c:	96 a7       	std	Z+46, r25	; 0x2e
			break;
   11e2e:	48 c0       	rjmp	.+144    	; 0x11ec0 <put_fat+0x1a6>

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   11e30:	45 2f       	mov	r20, r21
   11e32:	56 2f       	mov	r21, r22
   11e34:	67 2f       	mov	r22, r23
   11e36:	77 27       	eor	r23, r23
   11e38:	8e 8d       	ldd	r24, Y+30	; 0x1e
   11e3a:	9f 8d       	ldd	r25, Y+31	; 0x1f
   11e3c:	a8 a1       	ldd	r26, Y+32	; 0x20
   11e3e:	b9 a1       	ldd	r27, Y+33	; 0x21
   11e40:	48 0f       	add	r20, r24
   11e42:	59 1f       	adc	r21, r25
   11e44:	6a 1f       	adc	r22, r26
   11e46:	7b 1f       	adc	r23, r27
   11e48:	ce 01       	movw	r24, r28
   11e4a:	db dc       	rcall	.-1610   	; 0x11802 <move_window>
			if (res != FR_OK) break;
   11e4c:	88 23       	and	r24, r24
   11e4e:	c1 f5       	brne	.+112    	; 0x11ec0 <put_fat+0x1a6>
			p = &fs->win[clst * 2 % SS(fs)];
   11e50:	f6 01       	movw	r30, r12
   11e52:	ee 0f       	add	r30, r30
   11e54:	ff 1f       	adc	r31, r31
   11e56:	f1 70       	andi	r31, 0x01	; 1
   11e58:	be 96       	adiw	r30, 0x2e	; 46
			ST_WORD(p, (WORD)val);
   11e5a:	ec 0f       	add	r30, r28
   11e5c:	fd 1f       	adc	r31, r29
   11e5e:	91 82       	std	Z+1, r9	; 0x01
   11e60:	80 82       	st	Z, r8
			break;
   11e62:	2e c0       	rjmp	.+92     	; 0x11ec0 <put_fat+0x1a6>

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   11e64:	17 e0       	ldi	r17, 0x07	; 7
   11e66:	76 95       	lsr	r23
   11e68:	67 95       	ror	r22
   11e6a:	57 95       	ror	r21
   11e6c:	47 95       	ror	r20
   11e6e:	1a 95       	dec	r17
   11e70:	d1 f7       	brne	.-12     	; 0x11e66 <put_fat+0x14c>
   11e72:	8e 8d       	ldd	r24, Y+30	; 0x1e
   11e74:	9f 8d       	ldd	r25, Y+31	; 0x1f
   11e76:	a8 a1       	ldd	r26, Y+32	; 0x20
   11e78:	b9 a1       	ldd	r27, Y+33	; 0x21
   11e7a:	48 0f       	add	r20, r24
   11e7c:	59 1f       	adc	r21, r25
   11e7e:	6a 1f       	adc	r22, r26
   11e80:	7b 1f       	adc	r23, r27
   11e82:	ce 01       	movw	r24, r28
   11e84:	be dc       	rcall	.-1668   	; 0x11802 <move_window>
			if (res != FR_OK) break;
   11e86:	88 23       	and	r24, r24
   11e88:	d9 f4       	brne	.+54     	; 0x11ec0 <put_fat+0x1a6>
			p = &fs->win[clst * 4 % SS(fs)];
   11e8a:	f6 01       	movw	r30, r12
   11e8c:	ee 0f       	add	r30, r30
   11e8e:	ff 1f       	adc	r31, r31
   11e90:	ee 0f       	add	r30, r30
   11e92:	ff 1f       	adc	r31, r31
   11e94:	f1 70       	andi	r31, 0x01	; 1
   11e96:	be 96       	adiw	r30, 0x2e	; 46
   11e98:	ec 0f       	add	r30, r28
   11e9a:	fd 1f       	adc	r31, r29
			val |= LD_DWORD(p) & 0xF0000000;
   11e9c:	20 81       	ld	r18, Z
   11e9e:	31 81       	ldd	r19, Z+1	; 0x01
   11ea0:	42 81       	ldd	r20, Z+2	; 0x02
   11ea2:	53 81       	ldd	r21, Z+3	; 0x03
   11ea4:	20 70       	andi	r18, 0x00	; 0
   11ea6:	30 70       	andi	r19, 0x00	; 0
   11ea8:	40 70       	andi	r20, 0x00	; 0
   11eaa:	50 7f       	andi	r21, 0xF0	; 240
   11eac:	28 29       	or	r18, r8
   11eae:	39 29       	or	r19, r9
   11eb0:	4a 29       	or	r20, r10
   11eb2:	5b 29       	or	r21, r11
			ST_DWORD(p, val);
   11eb4:	20 83       	st	Z, r18
   11eb6:	31 83       	std	Z+1, r19	; 0x01
   11eb8:	42 83       	std	Z+2, r20	; 0x02
   11eba:	53 83       	std	Z+3, r21	; 0x03
			break;
   11ebc:	01 c0       	rjmp	.+2      	; 0x11ec0 <put_fat+0x1a6>

		default :
			res = FR_INT_ERR;
   11ebe:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
   11ec0:	91 e0       	ldi	r25, 0x01	; 1
   11ec2:	9c 83       	std	Y+4, r25	; 0x04
   11ec4:	01 c0       	rjmp	.+2      	; 0x11ec8 <put_fat+0x1ae>
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
   11ec6:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
	}

	return res;
}
   11ec8:	df 91       	pop	r29
   11eca:	cf 91       	pop	r28
   11ecc:	1f 91       	pop	r17
   11ece:	0f 91       	pop	r16
   11ed0:	ff 90       	pop	r15
   11ed2:	ef 90       	pop	r14
   11ed4:	df 90       	pop	r13
   11ed6:	cf 90       	pop	r12
   11ed8:	bf 90       	pop	r11
   11eda:	af 90       	pop	r10
   11edc:	9f 90       	pop	r9
   11ede:	8f 90       	pop	r8
   11ee0:	08 95       	ret

00011ee2 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
   11ee2:	4f 92       	push	r4
   11ee4:	5f 92       	push	r5
   11ee6:	6f 92       	push	r6
   11ee8:	7f 92       	push	r7
   11eea:	8f 92       	push	r8
   11eec:	9f 92       	push	r9
   11eee:	af 92       	push	r10
   11ef0:	bf 92       	push	r11
   11ef2:	cf 92       	push	r12
   11ef4:	df 92       	push	r13
   11ef6:	ef 92       	push	r14
   11ef8:	ff 92       	push	r15
   11efa:	0f 93       	push	r16
   11efc:	1f 93       	push	r17
   11efe:	cf 93       	push	r28
   11f00:	df 93       	push	r29
   11f02:	ec 01       	movw	r28, r24
   11f04:	2a 01       	movw	r4, r20
   11f06:	3b 01       	movw	r6, r22
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
   11f08:	41 15       	cp	r20, r1
   11f0a:	51 05       	cpc	r21, r1
   11f0c:	61 05       	cpc	r22, r1
   11f0e:	71 05       	cpc	r23, r1
   11f10:	99 f4       	brne	.+38     	; 0x11f38 <create_chain+0x56>
		scl = fs->last_clust;			/* Get suggested start point */
   11f12:	8a 84       	ldd	r8, Y+10	; 0x0a
   11f14:	9b 84       	ldd	r9, Y+11	; 0x0b
   11f16:	ac 84       	ldd	r10, Y+12	; 0x0c
   11f18:	bd 84       	ldd	r11, Y+13	; 0x0d
		if (!scl || scl >= fs->n_fatent) scl = 1;
   11f1a:	81 14       	cp	r8, r1
   11f1c:	91 04       	cpc	r9, r1
   11f1e:	a1 04       	cpc	r10, r1
   11f20:	b1 04       	cpc	r11, r1
   11f22:	01 f1       	breq	.+64     	; 0x11f64 <create_chain+0x82>
   11f24:	8e 89       	ldd	r24, Y+22	; 0x16
   11f26:	9f 89       	ldd	r25, Y+23	; 0x17
   11f28:	a8 8d       	ldd	r26, Y+24	; 0x18
   11f2a:	b9 8d       	ldd	r27, Y+25	; 0x19
   11f2c:	88 16       	cp	r8, r24
   11f2e:	99 06       	cpc	r9, r25
   11f30:	aa 06       	cpc	r10, r26
   11f32:	bb 06       	cpc	r11, r27
   11f34:	b8 f4       	brcc	.+46     	; 0x11f64 <create_chain+0x82>
   11f36:	1b c0       	rjmp	.+54     	; 0x11f6e <create_chain+0x8c>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
   11f38:	88 dd       	rcall	.-1264   	; 0x11a4a <get_fat>
   11f3a:	9b 01       	movw	r18, r22
   11f3c:	ac 01       	movw	r20, r24
		if (cs < 2) return 1;			/* It is an invalid cluster */
   11f3e:	62 30       	cpi	r22, 0x02	; 2
   11f40:	71 05       	cpc	r23, r1
   11f42:	81 05       	cpc	r24, r1
   11f44:	91 05       	cpc	r25, r1
   11f46:	08 f4       	brcc	.+2      	; 0x11f4a <create_chain+0x68>
   11f48:	90 c0       	rjmp	.+288    	; 0x1206a <create_chain+0x188>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   11f4a:	8e 89       	ldd	r24, Y+22	; 0x16
   11f4c:	9f 89       	ldd	r25, Y+23	; 0x17
   11f4e:	a8 8d       	ldd	r26, Y+24	; 0x18
   11f50:	b9 8d       	ldd	r27, Y+25	; 0x19
   11f52:	28 17       	cp	r18, r24
   11f54:	39 07       	cpc	r19, r25
   11f56:	4a 07       	cpc	r20, r26
   11f58:	5b 07       	cpc	r21, r27
   11f5a:	08 f4       	brcc	.+2      	; 0x11f5e <create_chain+0x7c>
   11f5c:	8a c0       	rjmp	.+276    	; 0x12072 <create_chain+0x190>
   11f5e:	53 01       	movw	r10, r6
   11f60:	42 01       	movw	r8, r4
   11f62:	05 c0       	rjmp	.+10     	; 0x11f6e <create_chain+0x8c>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
   11f64:	61 e0       	ldi	r22, 0x01	; 1
   11f66:	86 2e       	mov	r8, r22
   11f68:	91 2c       	mov	r9, r1
   11f6a:	a1 2c       	mov	r10, r1
   11f6c:	b1 2c       	mov	r11, r1
   11f6e:	75 01       	movw	r14, r10
   11f70:	64 01       	movw	r12, r8
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
   11f72:	08 94       	sec
   11f74:	c1 1c       	adc	r12, r1
   11f76:	d1 1c       	adc	r13, r1
   11f78:	e1 1c       	adc	r14, r1
   11f7a:	f1 1c       	adc	r15, r1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
   11f7c:	8e 89       	ldd	r24, Y+22	; 0x16
   11f7e:	9f 89       	ldd	r25, Y+23	; 0x17
   11f80:	a8 8d       	ldd	r26, Y+24	; 0x18
   11f82:	b9 8d       	ldd	r27, Y+25	; 0x19
   11f84:	c8 16       	cp	r12, r24
   11f86:	d9 06       	cpc	r13, r25
   11f88:	ea 06       	cpc	r14, r26
   11f8a:	fb 06       	cpc	r15, r27
   11f8c:	60 f0       	brcs	.+24     	; 0x11fa6 <create_chain+0xc4>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
   11f8e:	22 e0       	ldi	r18, 0x02	; 2
   11f90:	82 16       	cp	r8, r18
   11f92:	91 04       	cpc	r9, r1
   11f94:	a1 04       	cpc	r10, r1
   11f96:	b1 04       	cpc	r11, r1
   11f98:	08 f4       	brcc	.+2      	; 0x11f9c <create_chain+0xba>
   11f9a:	60 c0       	rjmp	.+192    	; 0x1205c <create_chain+0x17a>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
   11f9c:	52 e0       	ldi	r21, 0x02	; 2
   11f9e:	c5 2e       	mov	r12, r21
   11fa0:	d1 2c       	mov	r13, r1
   11fa2:	e1 2c       	mov	r14, r1
   11fa4:	f1 2c       	mov	r15, r1
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
   11fa6:	ce 01       	movw	r24, r28
   11fa8:	b7 01       	movw	r22, r14
   11faa:	a6 01       	movw	r20, r12
   11fac:	4e dd       	rcall	.-1380   	; 0x11a4a <get_fat>
   11fae:	9b 01       	movw	r18, r22
   11fb0:	ac 01       	movw	r20, r24
		if (cs == 0) break;				/* Found a free cluster */
   11fb2:	61 15       	cp	r22, r1
   11fb4:	71 05       	cpc	r23, r1
   11fb6:	81 05       	cpc	r24, r1
   11fb8:	91 05       	cpc	r25, r1
   11fba:	a9 f0       	breq	.+42     	; 0x11fe6 <create_chain+0x104>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   11fbc:	2f 3f       	cpi	r18, 0xFF	; 255
   11fbe:	8f ef       	ldi	r24, 0xFF	; 255
   11fc0:	38 07       	cpc	r19, r24
   11fc2:	8f ef       	ldi	r24, 0xFF	; 255
   11fc4:	48 07       	cpc	r20, r24
   11fc6:	8f ef       	ldi	r24, 0xFF	; 255
   11fc8:	58 07       	cpc	r21, r24
   11fca:	09 f4       	brne	.+2      	; 0x11fce <create_chain+0xec>
   11fcc:	52 c0       	rjmp	.+164    	; 0x12072 <create_chain+0x190>
   11fce:	21 30       	cpi	r18, 0x01	; 1
   11fd0:	31 05       	cpc	r19, r1
   11fd2:	41 05       	cpc	r20, r1
   11fd4:	51 05       	cpc	r21, r1
   11fd6:	09 f4       	brne	.+2      	; 0x11fda <create_chain+0xf8>
   11fd8:	4c c0       	rjmp	.+152    	; 0x12072 <create_chain+0x190>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
   11fda:	c8 14       	cp	r12, r8
   11fdc:	d9 04       	cpc	r13, r9
   11fde:	ea 04       	cpc	r14, r10
   11fe0:	fb 04       	cpc	r15, r11
   11fe2:	39 f6       	brne	.-114    	; 0x11f72 <create_chain+0x90>
   11fe4:	3b c0       	rjmp	.+118    	; 0x1205c <create_chain+0x17a>
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
   11fe6:	8c 2c       	mov	r8, r12
   11fe8:	bd 2c       	mov	r11, r13
   11fea:	ae 2c       	mov	r10, r14
   11fec:	9f 2c       	mov	r9, r15
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
   11fee:	ce 01       	movw	r24, r28
   11ff0:	a6 01       	movw	r20, r12
   11ff2:	b7 01       	movw	r22, r14
   11ff4:	0f ef       	ldi	r16, 0xFF	; 255
   11ff6:	1f ef       	ldi	r17, 0xFF	; 255
   11ff8:	2f ef       	ldi	r18, 0xFF	; 255
   11ffa:	3f e0       	ldi	r19, 0x0F	; 15
   11ffc:	8e de       	rcall	.-740    	; 0x11d1a <put_fat>
	if (res == FR_OK && clst != 0) {
   11ffe:	88 23       	and	r24, r24
   12000:	39 f5       	brne	.+78     	; 0x12050 <create_chain+0x16e>
   12002:	41 14       	cp	r4, r1
   12004:	51 04       	cpc	r5, r1
   12006:	61 04       	cpc	r6, r1
   12008:	71 04       	cpc	r7, r1
   1200a:	41 f0       	breq	.+16     	; 0x1201c <create_chain+0x13a>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
   1200c:	ce 01       	movw	r24, r28
   1200e:	b3 01       	movw	r22, r6
   12010:	a2 01       	movw	r20, r4
   12012:	86 01       	movw	r16, r12
   12014:	97 01       	movw	r18, r14
   12016:	81 de       	rcall	.-766    	; 0x11d1a <put_fat>
	}
	if (res == FR_OK) {
   12018:	88 23       	and	r24, r24
   1201a:	d1 f4       	brne	.+52     	; 0x12050 <create_chain+0x16e>
		fs->last_clust = ncl;			/* Update FSINFO */
   1201c:	8a 86       	std	Y+10, r8	; 0x0a
   1201e:	bb 86       	std	Y+11, r11	; 0x0b
   12020:	ac 86       	std	Y+12, r10	; 0x0c
   12022:	9d 86       	std	Y+13, r9	; 0x0d
		if (fs->free_clust != 0xFFFFFFFF) {
   12024:	8e 85       	ldd	r24, Y+14	; 0x0e
   12026:	9f 85       	ldd	r25, Y+15	; 0x0f
   12028:	a8 89       	ldd	r26, Y+16	; 0x10
   1202a:	b9 89       	ldd	r27, Y+17	; 0x11
   1202c:	8f 3f       	cpi	r24, 0xFF	; 255
   1202e:	2f ef       	ldi	r18, 0xFF	; 255
   12030:	92 07       	cpc	r25, r18
   12032:	2f ef       	ldi	r18, 0xFF	; 255
   12034:	a2 07       	cpc	r26, r18
   12036:	2f ef       	ldi	r18, 0xFF	; 255
   12038:	b2 07       	cpc	r27, r18
   1203a:	a1 f0       	breq	.+40     	; 0x12064 <create_chain+0x182>
			fs->free_clust--;
   1203c:	01 97       	sbiw	r24, 0x01	; 1
   1203e:	a1 09       	sbc	r26, r1
   12040:	b1 09       	sbc	r27, r1
   12042:	8e 87       	std	Y+14, r24	; 0x0e
   12044:	9f 87       	std	Y+15, r25	; 0x0f
   12046:	a8 8b       	std	Y+16, r26	; 0x10
   12048:	b9 8b       	std	Y+17, r27	; 0x11
			fs->fsi_flag = 1;
   1204a:	81 e0       	ldi	r24, 0x01	; 1
   1204c:	8d 83       	std	Y+5, r24	; 0x05
   1204e:	0a c0       	rjmp	.+20     	; 0x12064 <create_chain+0x182>
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   12050:	81 30       	cpi	r24, 0x01	; 1
   12052:	59 f4       	brne	.+22     	; 0x1206a <create_chain+0x188>
   12054:	2f ef       	ldi	r18, 0xFF	; 255
   12056:	3f ef       	ldi	r19, 0xFF	; 255
   12058:	a9 01       	movw	r20, r18
   1205a:	0b c0       	rjmp	.+22     	; 0x12072 <create_chain+0x190>
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
   1205c:	20 e0       	ldi	r18, 0x00	; 0
   1205e:	30 e0       	ldi	r19, 0x00	; 0
   12060:	a9 01       	movw	r20, r18
   12062:	07 c0       	rjmp	.+14     	; 0x12072 <create_chain+0x190>
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
   12064:	a7 01       	movw	r20, r14
   12066:	96 01       	movw	r18, r12
   12068:	04 c0       	rjmp	.+8      	; 0x12072 <create_chain+0x190>
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   1206a:	21 e0       	ldi	r18, 0x01	; 1
   1206c:	30 e0       	ldi	r19, 0x00	; 0
   1206e:	40 e0       	ldi	r20, 0x00	; 0
   12070:	50 e0       	ldi	r21, 0x00	; 0
	}

	return ncl;		/* Return new cluster number or error code */
}
   12072:	b9 01       	movw	r22, r18
   12074:	ca 01       	movw	r24, r20
   12076:	df 91       	pop	r29
   12078:	cf 91       	pop	r28
   1207a:	1f 91       	pop	r17
   1207c:	0f 91       	pop	r16
   1207e:	ff 90       	pop	r15
   12080:	ef 90       	pop	r14
   12082:	df 90       	pop	r13
   12084:	cf 90       	pop	r12
   12086:	bf 90       	pop	r11
   12088:	af 90       	pop	r10
   1208a:	9f 90       	pop	r9
   1208c:	8f 90       	pop	r8
   1208e:	7f 90       	pop	r7
   12090:	6f 90       	pop	r6
   12092:	5f 90       	pop	r5
   12094:	4f 90       	pop	r4
   12096:	08 95       	ret

00012098 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
   12098:	8f 92       	push	r8
   1209a:	9f 92       	push	r9
   1209c:	af 92       	push	r10
   1209e:	bf 92       	push	r11
   120a0:	cf 92       	push	r12
   120a2:	df 92       	push	r13
   120a4:	ef 92       	push	r14
   120a6:	ff 92       	push	r15
   120a8:	0f 93       	push	r16
   120aa:	1f 93       	push	r17
   120ac:	cf 93       	push	r28
   120ae:	df 93       	push	r29
   120b0:	ec 01       	movw	r28, r24
   120b2:	5b 01       	movw	r10, r22
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
   120b4:	cc 80       	ldd	r12, Y+4	; 0x04
   120b6:	dd 80       	ldd	r13, Y+5	; 0x05
   120b8:	08 94       	sec
   120ba:	c1 1c       	adc	r12, r1
   120bc:	d1 1c       	adc	r13, r1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
   120be:	c1 14       	cp	r12, r1
   120c0:	d1 04       	cpc	r13, r1
   120c2:	09 f4       	brne	.+2      	; 0x120c6 <dir_next+0x2e>
   120c4:	e4 c0       	rjmp	.+456    	; 0x1228e <dir_next+0x1f6>
   120c6:	8e 85       	ldd	r24, Y+14	; 0x0e
   120c8:	9f 85       	ldd	r25, Y+15	; 0x0f
   120ca:	a8 89       	ldd	r26, Y+16	; 0x10
   120cc:	b9 89       	ldd	r27, Y+17	; 0x11
   120ce:	00 97       	sbiw	r24, 0x00	; 0
   120d0:	a1 05       	cpc	r26, r1
   120d2:	b1 05       	cpc	r27, r1
   120d4:	09 f4       	brne	.+2      	; 0x120d8 <dir_next+0x40>
   120d6:	db c0       	rjmp	.+438    	; 0x1228e <dir_next+0x1f6>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
   120d8:	1f e0       	ldi	r17, 0x0F	; 15
   120da:	81 2e       	mov	r8, r17
   120dc:	91 2c       	mov	r9, r1
   120de:	8c 20       	and	r8, r12
   120e0:	9d 20       	and	r9, r13
   120e2:	81 14       	cp	r8, r1
   120e4:	91 04       	cpc	r9, r1
   120e6:	09 f0       	breq	.+2      	; 0x120ea <dir_next+0x52>
   120e8:	c2 c0       	rjmp	.+388    	; 0x1226e <dir_next+0x1d6>
		dj->sect++;					/* Next sector */
   120ea:	01 96       	adiw	r24, 0x01	; 1
   120ec:	a1 1d       	adc	r26, r1
   120ee:	b1 1d       	adc	r27, r1
   120f0:	8e 87       	std	Y+14, r24	; 0x0e
   120f2:	9f 87       	std	Y+15, r25	; 0x0f
   120f4:	a8 8b       	std	Y+16, r26	; 0x10
   120f6:	b9 8b       	std	Y+17, r27	; 0x11

		if (dj->clust == 0) {	/* Static table */
   120f8:	4a 85       	ldd	r20, Y+10	; 0x0a
   120fa:	5b 85       	ldd	r21, Y+11	; 0x0b
   120fc:	6c 85       	ldd	r22, Y+12	; 0x0c
   120fe:	7d 85       	ldd	r23, Y+13	; 0x0d
   12100:	88 81       	ld	r24, Y
   12102:	99 81       	ldd	r25, Y+1	; 0x01
   12104:	41 15       	cp	r20, r1
   12106:	51 05       	cpc	r21, r1
   12108:	61 05       	cpc	r22, r1
   1210a:	71 05       	cpc	r23, r1
   1210c:	41 f4       	brne	.+16     	; 0x1211e <dir_next+0x86>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
   1210e:	fc 01       	movw	r30, r24
   12110:	80 85       	ldd	r24, Z+8	; 0x08
   12112:	91 85       	ldd	r25, Z+9	; 0x09
   12114:	c8 16       	cp	r12, r24
   12116:	d9 06       	cpc	r13, r25
   12118:	08 f4       	brcc	.+2      	; 0x1211c <dir_next+0x84>
   1211a:	a9 c0       	rjmp	.+338    	; 0x1226e <dir_next+0x1d6>
   1211c:	b8 c0       	rjmp	.+368    	; 0x1228e <dir_next+0x1f6>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
   1211e:	fc 01       	movw	r30, r24
   12120:	22 81       	ldd	r18, Z+2	; 0x02
   12122:	30 e0       	ldi	r19, 0x00	; 0
   12124:	21 50       	subi	r18, 0x01	; 1
   12126:	30 40       	sbci	r19, 0x00	; 0
   12128:	f6 01       	movw	r30, r12
   1212a:	a4 e0       	ldi	r26, 0x04	; 4
   1212c:	f6 95       	lsr	r31
   1212e:	e7 95       	ror	r30
   12130:	aa 95       	dec	r26
   12132:	e1 f7       	brne	.-8      	; 0x1212c <dir_next+0x94>
   12134:	2e 23       	and	r18, r30
   12136:	3f 23       	and	r19, r31
   12138:	21 15       	cp	r18, r1
   1213a:	31 05       	cpc	r19, r1
   1213c:	09 f0       	breq	.+2      	; 0x12140 <dir_next+0xa8>
   1213e:	97 c0       	rjmp	.+302    	; 0x1226e <dir_next+0x1d6>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
   12140:	84 dc       	rcall	.-1784   	; 0x11a4a <get_fat>
   12142:	7b 01       	movw	r14, r22
   12144:	8c 01       	movw	r16, r24
				if (clst <= 1) return FR_INT_ERR;
   12146:	62 30       	cpi	r22, 0x02	; 2
   12148:	71 05       	cpc	r23, r1
   1214a:	81 05       	cpc	r24, r1
   1214c:	91 05       	cpc	r25, r1
   1214e:	08 f4       	brcc	.+2      	; 0x12152 <dir_next+0xba>
   12150:	a2 c0       	rjmp	.+324    	; 0x12296 <dir_next+0x1fe>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   12152:	8f ef       	ldi	r24, 0xFF	; 255
   12154:	e8 16       	cp	r14, r24
   12156:	8f ef       	ldi	r24, 0xFF	; 255
   12158:	f8 06       	cpc	r15, r24
   1215a:	8f ef       	ldi	r24, 0xFF	; 255
   1215c:	08 07       	cpc	r16, r24
   1215e:	8f ef       	ldi	r24, 0xFF	; 255
   12160:	18 07       	cpc	r17, r24
   12162:	09 f4       	brne	.+2      	; 0x12166 <dir_next+0xce>
   12164:	9a c0       	rjmp	.+308    	; 0x1229a <dir_next+0x202>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
   12166:	88 81       	ld	r24, Y
   12168:	99 81       	ldd	r25, Y+1	; 0x01
   1216a:	fc 01       	movw	r30, r24
   1216c:	26 89       	ldd	r18, Z+22	; 0x16
   1216e:	37 89       	ldd	r19, Z+23	; 0x17
   12170:	40 8d       	ldd	r20, Z+24	; 0x18
   12172:	51 8d       	ldd	r21, Z+25	; 0x19
   12174:	e2 16       	cp	r14, r18
   12176:	f3 06       	cpc	r15, r19
   12178:	04 07       	cpc	r16, r20
   1217a:	15 07       	cpc	r17, r21
   1217c:	08 f4       	brcc	.+2      	; 0x12180 <dir_next+0xe8>
   1217e:	6a c0       	rjmp	.+212    	; 0x12254 <dir_next+0x1bc>
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
   12180:	a1 14       	cp	r10, r1
   12182:	b1 04       	cpc	r11, r1
   12184:	09 f4       	brne	.+2      	; 0x12188 <dir_next+0xf0>
   12186:	83 c0       	rjmp	.+262    	; 0x1228e <dir_next+0x1f6>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
   12188:	4a 85       	ldd	r20, Y+10	; 0x0a
   1218a:	5b 85       	ldd	r21, Y+11	; 0x0b
   1218c:	6c 85       	ldd	r22, Y+12	; 0x0c
   1218e:	7d 85       	ldd	r23, Y+13	; 0x0d
   12190:	a8 de       	rcall	.-688    	; 0x11ee2 <create_chain>
   12192:	7b 01       	movw	r14, r22
   12194:	8c 01       	movw	r16, r24
					if (clst == 0) return FR_DENIED;			/* No free cluster */
   12196:	61 15       	cp	r22, r1
   12198:	71 05       	cpc	r23, r1
   1219a:	81 05       	cpc	r24, r1
   1219c:	91 05       	cpc	r25, r1
   1219e:	09 f4       	brne	.+2      	; 0x121a2 <dir_next+0x10a>
   121a0:	78 c0       	rjmp	.+240    	; 0x12292 <dir_next+0x1fa>
					if (clst == 1) return FR_INT_ERR;
   121a2:	61 30       	cpi	r22, 0x01	; 1
   121a4:	71 05       	cpc	r23, r1
   121a6:	81 05       	cpc	r24, r1
   121a8:	91 05       	cpc	r25, r1
   121aa:	09 f4       	brne	.+2      	; 0x121ae <dir_next+0x116>
   121ac:	74 c0       	rjmp	.+232    	; 0x12296 <dir_next+0x1fe>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   121ae:	8f ef       	ldi	r24, 0xFF	; 255
   121b0:	e8 16       	cp	r14, r24
   121b2:	8f ef       	ldi	r24, 0xFF	; 255
   121b4:	f8 06       	cpc	r15, r24
   121b6:	8f ef       	ldi	r24, 0xFF	; 255
   121b8:	08 07       	cpc	r16, r24
   121ba:	8f ef       	ldi	r24, 0xFF	; 255
   121bc:	18 07       	cpc	r17, r24
   121be:	09 f4       	brne	.+2      	; 0x121c2 <dir_next+0x12a>
   121c0:	6c c0       	rjmp	.+216    	; 0x1229a <dir_next+0x202>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
   121c2:	88 81       	ld	r24, Y
   121c4:	99 81       	ldd	r25, Y+1	; 0x01
   121c6:	40 e0       	ldi	r20, 0x00	; 0
   121c8:	50 e0       	ldi	r21, 0x00	; 0
   121ca:	ba 01       	movw	r22, r20
   121cc:	1a db       	rcall	.-2508   	; 0x11802 <move_window>
   121ce:	88 23       	and	r24, r24
   121d0:	09 f0       	breq	.+2      	; 0x121d4 <dir_next+0x13c>
   121d2:	63 c0       	rjmp	.+198    	; 0x1229a <dir_next+0x202>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
   121d4:	88 81       	ld	r24, Y
   121d6:	99 81       	ldd	r25, Y+1	; 0x01
   121d8:	8e 96       	adiw	r24, 0x2e	; 46
   121da:	60 e0       	ldi	r22, 0x00	; 0
   121dc:	70 e0       	ldi	r23, 0x00	; 0
   121de:	40 e0       	ldi	r20, 0x00	; 0
   121e0:	52 e0       	ldi	r21, 0x02	; 2
   121e2:	21 d8       	rcall	.-4030   	; 0x11226 <mem_set>
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
   121e4:	a8 80       	ld	r10, Y
   121e6:	b9 80       	ldd	r11, Y+1	; 0x01
   121e8:	c5 01       	movw	r24, r10
   121ea:	b8 01       	movw	r22, r16
   121ec:	a7 01       	movw	r20, r14
   121ee:	fe db       	rcall	.-2052   	; 0x119ec <clust2sect>
   121f0:	f5 01       	movw	r30, r10
   121f2:	62 a7       	std	Z+42, r22	; 0x2a
   121f4:	73 a7       	std	Z+43, r23	; 0x2b
   121f6:	84 a7       	std	Z+44, r24	; 0x2c
   121f8:	95 a7       	std	Z+45, r25	; 0x2d
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   121fa:	bb 24       	eor	r11, r11
						dj->fs->wflag = 1;
   121fc:	aa 24       	eor	r10, r10
   121fe:	a3 94       	inc	r10
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   12200:	18 c0       	rjmp	.+48     	; 0x12232 <dir_next+0x19a>
						dj->fs->wflag = 1;
   12202:	a4 82       	std	Z+4, r10	; 0x04
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
   12204:	88 81       	ld	r24, Y
   12206:	99 81       	ldd	r25, Y+1	; 0x01
   12208:	40 e0       	ldi	r20, 0x00	; 0
   1220a:	50 e0       	ldi	r21, 0x00	; 0
   1220c:	ba 01       	movw	r22, r20
   1220e:	f9 da       	rcall	.-2574   	; 0x11802 <move_window>
   12210:	88 23       	and	r24, r24
   12212:	09 f0       	breq	.+2      	; 0x12216 <dir_next+0x17e>
   12214:	42 c0       	rjmp	.+132    	; 0x1229a <dir_next+0x202>
						dj->fs->winsect++;
   12216:	e8 81       	ld	r30, Y
   12218:	f9 81       	ldd	r31, Y+1	; 0x01
   1221a:	82 a5       	ldd	r24, Z+42	; 0x2a
   1221c:	93 a5       	ldd	r25, Z+43	; 0x2b
   1221e:	a4 a5       	ldd	r26, Z+44	; 0x2c
   12220:	b5 a5       	ldd	r27, Z+45	; 0x2d
   12222:	01 96       	adiw	r24, 0x01	; 1
   12224:	a1 1d       	adc	r26, r1
   12226:	b1 1d       	adc	r27, r1
   12228:	82 a7       	std	Z+42, r24	; 0x2a
   1222a:	93 a7       	std	Z+43, r25	; 0x2b
   1222c:	a4 a7       	std	Z+44, r26	; 0x2c
   1222e:	b5 a7       	std	Z+45, r27	; 0x2d
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   12230:	b3 94       	inc	r11
   12232:	e8 81       	ld	r30, Y
   12234:	f9 81       	ldd	r31, Y+1	; 0x01
   12236:	82 81       	ldd	r24, Z+2	; 0x02
   12238:	b8 16       	cp	r11, r24
   1223a:	18 f3       	brcs	.-58     	; 0x12202 <dir_next+0x16a>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
   1223c:	82 a5       	ldd	r24, Z+42	; 0x2a
   1223e:	93 a5       	ldd	r25, Z+43	; 0x2b
   12240:	a4 a5       	ldd	r26, Z+44	; 0x2c
   12242:	b5 a5       	ldd	r27, Z+45	; 0x2d
   12244:	8b 19       	sub	r24, r11
   12246:	91 09       	sbc	r25, r1
   12248:	a1 09       	sbc	r26, r1
   1224a:	b1 09       	sbc	r27, r1
   1224c:	82 a7       	std	Z+42, r24	; 0x2a
   1224e:	93 a7       	std	Z+43, r25	; 0x2b
   12250:	a4 a7       	std	Z+44, r26	; 0x2c
   12252:	b5 a7       	std	Z+45, r27	; 0x2d
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
   12254:	ea 86       	std	Y+10, r14	; 0x0a
   12256:	fb 86       	std	Y+11, r15	; 0x0b
   12258:	0c 87       	std	Y+12, r16	; 0x0c
   1225a:	1d 87       	std	Y+13, r17	; 0x0d
				dj->sect = clust2sect(dj->fs, clst);
   1225c:	88 81       	ld	r24, Y
   1225e:	99 81       	ldd	r25, Y+1	; 0x01
   12260:	b8 01       	movw	r22, r16
   12262:	a7 01       	movw	r20, r14
   12264:	c3 db       	rcall	.-2170   	; 0x119ec <clust2sect>
   12266:	6e 87       	std	Y+14, r22	; 0x0e
   12268:	7f 87       	std	Y+15, r23	; 0x0f
   1226a:	88 8b       	std	Y+16, r24	; 0x10
   1226c:	99 8b       	std	Y+17, r25	; 0x11
			}
		}
	}

	dj->index = i;
   1226e:	dd 82       	std	Y+5, r13	; 0x05
   12270:	cc 82       	std	Y+4, r12	; 0x04
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
   12272:	88 81       	ld	r24, Y
   12274:	99 81       	ldd	r25, Y+1	; 0x01
   12276:	8e 96       	adiw	r24, 0x2e	; 46
   12278:	75 e0       	ldi	r23, 0x05	; 5
   1227a:	88 0c       	add	r8, r8
   1227c:	99 1c       	adc	r9, r9
   1227e:	7a 95       	dec	r23
   12280:	e1 f7       	brne	.-8      	; 0x1227a <dir_next+0x1e2>
   12282:	88 0d       	add	r24, r8
   12284:	99 1d       	adc	r25, r9
   12286:	9b 8b       	std	Y+19, r25	; 0x13
   12288:	8a 8b       	std	Y+18, r24	; 0x12

	return FR_OK;
   1228a:	80 e0       	ldi	r24, 0x00	; 0
   1228c:	07 c0       	rjmp	.+14     	; 0x1229c <dir_next+0x204>
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
   1228e:	84 e0       	ldi	r24, 0x04	; 4
   12290:	05 c0       	rjmp	.+10     	; 0x1229c <dir_next+0x204>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
   12292:	87 e0       	ldi	r24, 0x07	; 7
   12294:	03 c0       	rjmp	.+6      	; 0x1229c <dir_next+0x204>
					if (clst == 1) return FR_INT_ERR;
   12296:	82 e0       	ldi	r24, 0x02	; 2
   12298:	01 c0       	rjmp	.+2      	; 0x1229c <dir_next+0x204>
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
   1229a:	81 e0       	ldi	r24, 0x01	; 1

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
   1229c:	df 91       	pop	r29
   1229e:	cf 91       	pop	r28
   122a0:	1f 91       	pop	r17
   122a2:	0f 91       	pop	r16
   122a4:	ff 90       	pop	r15
   122a6:	ef 90       	pop	r14
   122a8:	df 90       	pop	r13
   122aa:	cf 90       	pop	r12
   122ac:	bf 90       	pop	r11
   122ae:	af 90       	pop	r10
   122b0:	9f 90       	pop	r9
   122b2:	8f 90       	pop	r8
   122b4:	08 95       	ret

000122b6 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
   122b6:	bf 92       	push	r11
   122b8:	cf 92       	push	r12
   122ba:	df 92       	push	r13
   122bc:	ef 92       	push	r14
   122be:	ff 92       	push	r15
   122c0:	0f 93       	push	r16
   122c2:	1f 93       	push	r17
   122c4:	cf 93       	push	r28
   122c6:	df 93       	push	r29
   122c8:	ec 01       	movw	r28, r24
   122ca:	8b 01       	movw	r16, r22
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
   122cc:	fb 01       	movw	r30, r22
   122ce:	80 81       	ld	r24, Z
   122d0:	8f 32       	cpi	r24, 0x2F	; 47
   122d2:	11 f0       	breq	.+4      	; 0x122d8 <follow_path+0x22>
   122d4:	8c 35       	cpi	r24, 0x5C	; 92
   122d6:	11 f4       	brne	.+4      	; 0x122dc <follow_path+0x26>
		path++;
   122d8:	0f 5f       	subi	r16, 0xFF	; 255
   122da:	1f 4f       	sbci	r17, 0xFF	; 255
	dj->sclust = 0;						/* Start from the root dir */
   122dc:	1e 82       	std	Y+6, r1	; 0x06
   122de:	1f 82       	std	Y+7, r1	; 0x07
   122e0:	18 86       	std	Y+8, r1	; 0x08
   122e2:	19 86       	std	Y+9, r1	; 0x09
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
   122e4:	f8 01       	movw	r30, r16
   122e6:	80 81       	ld	r24, Z
   122e8:	80 32       	cpi	r24, 0x20	; 32
   122ea:	38 f4       	brcc	.+14     	; 0x122fa <follow_path+0x44>
		res = dir_sdi(dj, 0);
   122ec:	ce 01       	movw	r24, r28
   122ee:	60 e0       	ldi	r22, 0x00	; 0
   122f0:	70 e0       	ldi	r23, 0x00	; 0
   122f2:	6f dc       	rcall	.-1826   	; 0x11bd2 <dir_sdi>
		dj->dir = 0;
   122f4:	1b 8a       	std	Y+19, r1	; 0x13
   122f6:	1a 8a       	std	Y+18, r1	; 0x12
   122f8:	ef c0       	rjmp	.+478    	; 0x124d8 <follow_path+0x222>
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
   122fa:	85 e0       	ldi	r24, 0x05	; 5
   122fc:	b8 2e       	mov	r11, r24
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
		res = dir_sdi(dj, 0);
		dj->dir = 0;
   122fe:	68 01       	movw	r12, r16
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   12300:	f8 01       	movw	r30, r16
   12302:	80 81       	ld	r24, Z
   12304:	0f 5f       	subi	r16, 0xFF	; 255
   12306:	1f 4f       	sbci	r17, 0xFF	; 255
   12308:	8f 32       	cpi	r24, 0x2F	; 47
   1230a:	c9 f3       	breq	.-14     	; 0x122fe <follow_path+0x48>
   1230c:	8c 35       	cpi	r24, 0x5C	; 92
   1230e:	b9 f3       	breq	.-18     	; 0x122fe <follow_path+0x48>
	sfn = dj->fn;
   12310:	0c 89       	ldd	r16, Y+20	; 0x14
   12312:	1d 89       	ldd	r17, Y+21	; 0x15
	mem_set(sfn, ' ', 11);
   12314:	c8 01       	movw	r24, r16
   12316:	60 e2       	ldi	r22, 0x20	; 32
   12318:	70 e0       	ldi	r23, 0x00	; 0
   1231a:	4b e0       	ldi	r20, 0x0B	; 11
   1231c:	50 e0       	ldi	r21, 0x00	; 0
   1231e:	0e 94 13 89 	call	0x11226	; 0x11226 <mem_set>
	si = i = b = 0; ni = 8;
   12322:	80 e0       	ldi	r24, 0x00	; 0
   12324:	90 e0       	ldi	r25, 0x00	; 0
   12326:	ee 24       	eor	r14, r14
   12328:	ff 24       	eor	r15, r15
   1232a:	28 e0       	ldi	r18, 0x08	; 8
   1232c:	30 e0       	ldi	r19, 0x00	; 0
   1232e:	a0 e0       	ldi	r26, 0x00	; 0
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
   12330:	f6 01       	movw	r30, r12
   12332:	ee 0d       	add	r30, r14
   12334:	ff 1d       	adc	r31, r15
   12336:	b0 81       	ld	r27, Z
   12338:	08 94       	sec
   1233a:	e1 1c       	adc	r14, r1
   1233c:	f1 1c       	adc	r15, r1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
   1233e:	b1 32       	cpi	r27, 0x21	; 33
   12340:	08 f4       	brcc	.+2      	; 0x12344 <follow_path+0x8e>
   12342:	60 c0       	rjmp	.+192    	; 0x12404 <follow_path+0x14e>
   12344:	bf 32       	cpi	r27, 0x2F	; 47
   12346:	09 f4       	brne	.+2      	; 0x1234a <follow_path+0x94>
   12348:	5f c0       	rjmp	.+190    	; 0x12408 <follow_path+0x152>
   1234a:	bc 35       	cpi	r27, 0x5C	; 92
   1234c:	09 f4       	brne	.+2      	; 0x12350 <follow_path+0x9a>
   1234e:	5c c0       	rjmp	.+184    	; 0x12408 <follow_path+0x152>
		if (c == '.' || i >= ni) {
   12350:	be 32       	cpi	r27, 0x2E	; 46
   12352:	19 f0       	breq	.+6      	; 0x1235a <follow_path+0xa4>
   12354:	82 17       	cp	r24, r18
   12356:	93 07       	cpc	r25, r19
   12358:	70 f0       	brcs	.+28     	; 0x12376 <follow_path+0xc0>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   1235a:	28 30       	cpi	r18, 0x08	; 8
   1235c:	31 05       	cpc	r19, r1
   1235e:	09 f0       	breq	.+2      	; 0x12362 <follow_path+0xac>
   12360:	b8 c0       	rjmp	.+368    	; 0x124d2 <follow_path+0x21c>
   12362:	be 32       	cpi	r27, 0x2E	; 46
   12364:	09 f0       	breq	.+2      	; 0x12368 <follow_path+0xb2>
   12366:	b5 c0       	rjmp	.+362    	; 0x124d2 <follow_path+0x21c>
			i = 8; ni = 11;
			b <<= 2; continue;
   12368:	aa 0f       	add	r26, r26
   1236a:	aa 0f       	add	r26, r26
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
   1236c:	88 e0       	ldi	r24, 0x08	; 8
   1236e:	90 e0       	ldi	r25, 0x00	; 0
   12370:	2b e0       	ldi	r18, 0x0B	; 11
   12372:	30 e0       	ldi	r19, 0x00	; 0
   12374:	dd cf       	rjmp	.-70     	; 0x12330 <follow_path+0x7a>
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
   12376:	b7 fd       	sbrc	r27, 7
			b |= 3;						/* Eliminate NT flag */
   12378:	a3 60       	ori	r26, 0x03	; 3
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1237a:	4b 2f       	mov	r20, r27
   1237c:	41 58       	subi	r20, 0x81	; 129
   1237e:	4f 31       	cpi	r20, 0x1F	; 31
   12380:	18 f0       	brcs	.+6      	; 0x12388 <follow_path+0xd2>
   12382:	4f 55       	subi	r20, 0x5F	; 95
   12384:	4d 31       	cpi	r20, 0x1D	; 29
   12386:	00 f5       	brcc	.+64     	; 0x123c8 <follow_path+0x112>
			d = (BYTE)p[si++];			/* Get 2nd byte */
   12388:	f6 01       	movw	r30, r12
   1238a:	ee 0d       	add	r30, r14
   1238c:	ff 1d       	adc	r31, r15
   1238e:	60 81       	ld	r22, Z
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
   12390:	46 2f       	mov	r20, r22
   12392:	40 54       	subi	r20, 0x40	; 64
   12394:	4f 33       	cpi	r20, 0x3F	; 63
   12396:	20 f0       	brcs	.+8      	; 0x123a0 <follow_path+0xea>
   12398:	40 54       	subi	r20, 0x40	; 64
   1239a:	4d 37       	cpi	r20, 0x7D	; 125
   1239c:	08 f0       	brcs	.+2      	; 0x123a0 <follow_path+0xea>
   1239e:	99 c0       	rjmp	.+306    	; 0x124d2 <follow_path+0x21c>
   123a0:	a9 01       	movw	r20, r18
   123a2:	41 50       	subi	r20, 0x01	; 1
   123a4:	50 40       	sbci	r21, 0x00	; 0
   123a6:	84 17       	cp	r24, r20
   123a8:	95 07       	cpc	r25, r21
   123aa:	08 f0       	brcs	.+2      	; 0x123ae <follow_path+0xf8>
   123ac:	92 c0       	rjmp	.+292    	; 0x124d2 <follow_path+0x21c>
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
   123ae:	08 94       	sec
   123b0:	e1 1c       	adc	r14, r1
   123b2:	f1 1c       	adc	r15, r1
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
   123b4:	f8 01       	movw	r30, r16
   123b6:	e8 0f       	add	r30, r24
   123b8:	f9 1f       	adc	r31, r25
   123ba:	b0 83       	st	Z, r27
   123bc:	01 96       	adiw	r24, 0x01	; 1
			sfn[i++] = d;
   123be:	f8 01       	movw	r30, r16
   123c0:	e8 0f       	add	r30, r24
   123c2:	f9 1f       	adc	r31, r25
   123c4:	60 83       	st	Z, r22
   123c6:	1c c0       	rjmp	.+56     	; 0x12400 <follow_path+0x14a>
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
   123c8:	6b 2f       	mov	r22, r27
   123ca:	70 e0       	ldi	r23, 0x00	; 0
   123cc:	e3 e3       	ldi	r30, 0x33	; 51
   123ce:	f9 e0       	ldi	r31, 0x09	; 9
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
   123d0:	41 91       	ld	r20, Z+
   123d2:	44 23       	and	r20, r20
   123d4:	29 f0       	breq	.+10     	; 0x123e0 <follow_path+0x12a>
   123d6:	50 e0       	ldi	r21, 0x00	; 0
   123d8:	46 17       	cp	r20, r22
   123da:	57 07       	cpc	r21, r23
   123dc:	c9 f7       	brne	.-14     	; 0x123d0 <follow_path+0x11a>
   123de:	79 c0       	rjmp	.+242    	; 0x124d2 <follow_path+0x21c>
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
   123e0:	4b 2f       	mov	r20, r27
   123e2:	41 54       	subi	r20, 0x41	; 65
   123e4:	4a 31       	cpi	r20, 0x1A	; 26
   123e6:	10 f4       	brcc	.+4      	; 0x123ec <follow_path+0x136>
				b |= 2;
   123e8:	a2 60       	ori	r26, 0x02	; 2
   123ea:	06 c0       	rjmp	.+12     	; 0x123f8 <follow_path+0x142>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
   123ec:	4b 2f       	mov	r20, r27
   123ee:	41 56       	subi	r20, 0x61	; 97
   123f0:	4a 31       	cpi	r20, 0x1A	; 26
   123f2:	10 f4       	brcc	.+4      	; 0x123f8 <follow_path+0x142>
					b |= 1; c -= 0x20;
   123f4:	a1 60       	ori	r26, 0x01	; 1
   123f6:	b0 52       	subi	r27, 0x20	; 32
				}
			}
			sfn[i++] = c;
   123f8:	f8 01       	movw	r30, r16
   123fa:	e8 0f       	add	r30, r24
   123fc:	f9 1f       	adc	r31, r25
   123fe:	b0 83       	st	Z, r27
   12400:	01 96       	adiw	r24, 0x01	; 1
   12402:	96 cf       	rjmp	.-212    	; 0x12330 <follow_path+0x7a>
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   12404:	44 e0       	ldi	r20, 0x04	; 4
   12406:	01 c0       	rjmp	.+2      	; 0x1240a <follow_path+0x154>
   12408:	40 e0       	ldi	r20, 0x00	; 0

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
   1240a:	00 97       	sbiw	r24, 0x00	; 0
   1240c:	09 f4       	brne	.+2      	; 0x12410 <follow_path+0x15a>
   1240e:	61 c0       	rjmp	.+194    	; 0x124d2 <follow_path+0x21c>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
   12410:	f8 01       	movw	r30, r16
   12412:	80 81       	ld	r24, Z
   12414:	85 3e       	cpi	r24, 0xE5	; 229
   12416:	09 f4       	brne	.+2      	; 0x1241a <follow_path+0x164>
   12418:	b0 82       	st	Z, r11

	if (ni == 8) b <<= 2;
   1241a:	28 30       	cpi	r18, 0x08	; 8
   1241c:	31 05       	cpc	r19, r1
   1241e:	11 f4       	brne	.+4      	; 0x12424 <follow_path+0x16e>
   12420:	aa 0f       	add	r26, r26
   12422:	aa 0f       	add	r26, r26
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
   12424:	b0 e0       	ldi	r27, 0x00	; 0
   12426:	cd 01       	movw	r24, r26
   12428:	83 70       	andi	r24, 0x03	; 3
   1242a:	90 70       	andi	r25, 0x00	; 0
   1242c:	81 30       	cpi	r24, 0x01	; 1
   1242e:	91 05       	cpc	r25, r1
   12430:	09 f4       	brne	.+2      	; 0x12434 <follow_path+0x17e>
   12432:	40 61       	ori	r20, 0x10	; 16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
   12434:	ac 70       	andi	r26, 0x0C	; 12
   12436:	b0 70       	andi	r27, 0x00	; 0
   12438:	a4 30       	cpi	r26, 0x04	; 4
   1243a:	b1 05       	cpc	r27, r1
   1243c:	09 f4       	brne	.+2      	; 0x12440 <follow_path+0x18a>
   1243e:	48 60       	ori	r20, 0x08	; 8

	sfn[NS] = c;		/* Store NT flag, File name is created */
   12440:	f8 01       	movw	r30, r16
   12442:	43 87       	std	Z+11, r20	; 0x0b
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
   12444:	ce 01       	movw	r24, r28
   12446:	60 e0       	ldi	r22, 0x00	; 0
   12448:	70 e0       	ldi	r23, 0x00	; 0
   1244a:	c3 db       	rcall	.-2170   	; 0x11bd2 <dir_sdi>
	if (res != FR_OK) return res;
   1244c:	88 23       	and	r24, r24
   1244e:	19 f5       	brne	.+70     	; 0x12496 <follow_path+0x1e0>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
   12450:	4e 85       	ldd	r20, Y+14	; 0x0e
   12452:	5f 85       	ldd	r21, Y+15	; 0x0f
   12454:	68 89       	ldd	r22, Y+16	; 0x10
   12456:	79 89       	ldd	r23, Y+17	; 0x11
   12458:	88 81       	ld	r24, Y
   1245a:	99 81       	ldd	r25, Y+1	; 0x01
   1245c:	d2 d9       	rcall	.-3164   	; 0x11802 <move_window>
		if (res != FR_OK) break;
   1245e:	88 23       	and	r24, r24
   12460:	d1 f4       	brne	.+52     	; 0x12496 <follow_path+0x1e0>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
   12462:	ea 89       	ldd	r30, Y+18	; 0x12
   12464:	fb 89       	ldd	r31, Y+19	; 0x13
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   12466:	90 81       	ld	r25, Z
   12468:	99 23       	and	r25, r25
   1246a:	a1 f0       	breq	.+40     	; 0x12494 <follow_path+0x1de>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
   1246c:	93 85       	ldd	r25, Z+11	; 0x0b
   1246e:	93 fd       	sbrc	r25, 3
   12470:	0c c0       	rjmp	.+24     	; 0x1248a <follow_path+0x1d4>
   12472:	ac 89       	ldd	r26, Y+20	; 0x14
   12474:	bd 89       	ldd	r27, Y+21	; 0x15
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
   12476:	9f 01       	movw	r18, r30
   12478:	25 5f       	subi	r18, 0xF5	; 245
   1247a:	3f 4f       	sbci	r19, 0xFF	; 255
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
   1247c:	e2 17       	cp	r30, r18
   1247e:	f3 07       	cpc	r31, r19
   12480:	51 f0       	breq	.+20     	; 0x12496 <follow_path+0x1e0>
   12482:	41 91       	ld	r20, Z+
   12484:	9d 91       	ld	r25, X+
   12486:	49 17       	cp	r20, r25
   12488:	c9 f3       	breq	.-14     	; 0x1247c <follow_path+0x1c6>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
   1248a:	ce 01       	movw	r24, r28
   1248c:	60 e0       	ldi	r22, 0x00	; 0
   1248e:	70 e0       	ldi	r23, 0x00	; 0
   12490:	03 de       	rcall	.-1018   	; 0x12098 <dir_next>
   12492:	dc cf       	rjmp	.-72     	; 0x1244c <follow_path+0x196>
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   12494:	84 e0       	ldi	r24, 0x04	; 4
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
   12496:	ec 89       	ldd	r30, Y+20	; 0x14
   12498:	fd 89       	ldd	r31, Y+21	; 0x15
   1249a:	93 85       	ldd	r25, Z+11	; 0x0b
			if (res != FR_OK) {				/* Failed to find the object */
   1249c:	88 23       	and	r24, r24
   1249e:	29 f0       	breq	.+10     	; 0x124aa <follow_path+0x1f4>
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
   124a0:	84 30       	cpi	r24, 0x04	; 4
   124a2:	d1 f4       	brne	.+52     	; 0x124d8 <follow_path+0x222>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
   124a4:	92 ff       	sbrs	r25, 2
   124a6:	17 c0       	rjmp	.+46     	; 0x124d6 <follow_path+0x220>
   124a8:	17 c0       	rjmp	.+46     	; 0x124d8 <follow_path+0x222>
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
   124aa:	92 fd       	sbrc	r25, 2
   124ac:	15 c0       	rjmp	.+42     	; 0x124d8 <follow_path+0x222>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
   124ae:	6a 89       	ldd	r22, Y+18	; 0x12
   124b0:	7b 89       	ldd	r23, Y+19	; 0x13
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
   124b2:	fb 01       	movw	r30, r22
   124b4:	83 85       	ldd	r24, Z+11	; 0x0b
   124b6:	84 ff       	sbrs	r24, 4
   124b8:	0e c0       	rjmp	.+28     	; 0x124d6 <follow_path+0x220>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
   124ba:	86 01       	movw	r16, r12
   124bc:	0e 0d       	add	r16, r14
   124be:	1f 1d       	adc	r17, r15
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(djo.fs, res);
}
   124c0:	e8 81       	ld	r30, Y
   124c2:	f9 81       	ldd	r31, Y+1	; 0x01
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
			}
			dj->sclust = ld_clust(dj->fs, dir);
   124c4:	80 81       	ld	r24, Z
   124c6:	7d da       	rcall	.-2822   	; 0x119c2 <ld_clust.clone.0>
   124c8:	6e 83       	std	Y+6, r22	; 0x06
   124ca:	7f 83       	std	Y+7, r23	; 0x07
   124cc:	88 87       	std	Y+8, r24	; 0x08
   124ce:	99 87       	std	Y+9, r25	; 0x09
		}
   124d0:	16 cf       	rjmp	.-468    	; 0x122fe <follow_path+0x48>
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
   124d2:	86 e0       	ldi	r24, 0x06	; 6
   124d4:	01 c0       	rjmp	.+2      	; 0x124d8 <follow_path+0x222>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
   124d6:	85 e0       	ldi	r24, 0x05	; 5
			dj->sclust = ld_clust(dj->fs, dir);
		}
	}

	return res;
}
   124d8:	df 91       	pop	r29
   124da:	cf 91       	pop	r28
   124dc:	1f 91       	pop	r17
   124de:	0f 91       	pop	r16
   124e0:	ff 90       	pop	r15
   124e2:	ef 90       	pop	r14
   124e4:	df 90       	pop	r13
   124e6:	cf 90       	pop	r12
   124e8:	bf 90       	pop	r11
   124ea:	08 95       	ret

000124ec <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
   124ec:	ff 92       	push	r15
   124ee:	0f 93       	push	r16
   124f0:	1f 93       	push	r17
   124f2:	cf 93       	push	r28
   124f4:	df 93       	push	r29
   124f6:	ec 01       	movw	r28, r24
			} while (res == FR_OK && --ne);
		}
	}

#else	/* Non LFN configuration */
	res = dir_sdi(dj, 0);
   124f8:	60 e0       	ldi	r22, 0x00	; 0
   124fa:	70 e0       	ldi	r23, 0x00	; 0
   124fc:	6a db       	rcall	.-2348   	; 0x11bd2 <dir_sdi>
   124fe:	f8 2e       	mov	r15, r24
	if (res == FR_OK) {
   12500:	88 23       	and	r24, r24
   12502:	51 f5       	brne	.+84     	; 0x12558 <dir_register+0x6c>
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
   12504:	4e 85       	ldd	r20, Y+14	; 0x0e
   12506:	5f 85       	ldd	r21, Y+15	; 0x0f
   12508:	68 89       	ldd	r22, Y+16	; 0x10
   1250a:	79 89       	ldd	r23, Y+17	; 0x11
   1250c:	88 81       	ld	r24, Y
   1250e:	99 81       	ldd	r25, Y+1	; 0x01
   12510:	78 d9       	rcall	.-3344   	; 0x11802 <move_window>
   12512:	f8 2e       	mov	r15, r24
			if (res != FR_OK) break;
   12514:	88 23       	and	r24, r24
   12516:	01 f5       	brne	.+64     	; 0x12558 <dir_register+0x6c>
			c = *dj->dir;
   12518:	ea 89       	ldd	r30, Y+18	; 0x12
   1251a:	fb 89       	ldd	r31, Y+19	; 0x13
   1251c:	80 81       	ld	r24, Z
			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
   1251e:	85 3e       	cpi	r24, 0xE5	; 229
   12520:	11 f1       	breq	.+68     	; 0x12566 <dir_register+0x7a>
   12522:	88 23       	and	r24, r24
   12524:	01 f1       	breq	.+64     	; 0x12566 <dir_register+0x7a>
			res = dir_next(dj, 1);			/* Next entry with table stretch */
   12526:	ce 01       	movw	r24, r28
   12528:	61 e0       	ldi	r22, 0x01	; 1
   1252a:	70 e0       	ldi	r23, 0x00	; 0
   1252c:	b5 dd       	rcall	.-1174   	; 0x12098 <dir_next>
   1252e:	e7 cf       	rjmp	.-50     	; 0x124fe <dir_register+0x12>
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
   12530:	0a 89       	ldd	r16, Y+18	; 0x12
   12532:	1b 89       	ldd	r17, Y+19	; 0x13
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
   12534:	c8 01       	movw	r24, r16
   12536:	60 e0       	ldi	r22, 0x00	; 0
   12538:	70 e0       	ldi	r23, 0x00	; 0
   1253a:	40 e2       	ldi	r20, 0x20	; 32
   1253c:	50 e0       	ldi	r21, 0x00	; 0
   1253e:	0e 94 13 89 	call	0x11226	; 0x11226 <mem_set>
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
   12542:	6c 89       	ldd	r22, Y+20	; 0x14
   12544:	7d 89       	ldd	r23, Y+21	; 0x15
   12546:	c8 01       	movw	r24, r16
   12548:	4b e0       	ldi	r20, 0x0B	; 11
   1254a:	50 e0       	ldi	r21, 0x00	; 0
   1254c:	0e 94 f3 88 	call	0x111e6	; 0x111e6 <mem_cpy>
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dj->fs->wflag = 1;
   12550:	e8 81       	ld	r30, Y
   12552:	f9 81       	ldd	r31, Y+1	; 0x01
   12554:	81 e0       	ldi	r24, 0x01	; 1
   12556:	84 83       	std	Z+4, r24	; 0x04
		}
	}

	return res;
}
   12558:	8f 2d       	mov	r24, r15
   1255a:	df 91       	pop	r29
   1255c:	cf 91       	pop	r28
   1255e:	1f 91       	pop	r17
   12560:	0f 91       	pop	r16
   12562:	ff 90       	pop	r15
   12564:	08 95       	ret
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
   12566:	4e 85       	ldd	r20, Y+14	; 0x0e
   12568:	5f 85       	ldd	r21, Y+15	; 0x0f
   1256a:	68 89       	ldd	r22, Y+16	; 0x10
   1256c:	79 89       	ldd	r23, Y+17	; 0x11
   1256e:	88 81       	ld	r24, Y
   12570:	99 81       	ldd	r25, Y+1	; 0x01
   12572:	47 d9       	rcall	.-3442   	; 0x11802 <move_window>
   12574:	f8 2e       	mov	r15, r24
		if (res == FR_OK) {
   12576:	88 23       	and	r24, r24
   12578:	79 f7       	brne	.-34     	; 0x12558 <dir_register+0x6c>
   1257a:	da cf       	rjmp	.-76     	; 0x12530 <dir_register+0x44>

0001257c <remove_chain>:
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
   1257c:	9f 92       	push	r9
   1257e:	af 92       	push	r10
   12580:	bf 92       	push	r11
   12582:	cf 92       	push	r12
   12584:	df 92       	push	r13
   12586:	ef 92       	push	r14
   12588:	ff 92       	push	r15
   1258a:	0f 93       	push	r16
   1258c:	1f 93       	push	r17
   1258e:	cf 93       	push	r28
   12590:	df 93       	push	r29
   12592:	ec 01       	movw	r28, r24
   12594:	7a 01       	movw	r14, r20
   12596:	8b 01       	movw	r16, r22
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   12598:	42 30       	cpi	r20, 0x02	; 2
   1259a:	51 05       	cpc	r21, r1
   1259c:	61 05       	cpc	r22, r1
   1259e:	71 05       	cpc	r23, r1
   125a0:	08 f4       	brcc	.+2      	; 0x125a4 <remove_chain+0x28>
   125a2:	52 c0       	rjmp	.+164    	; 0x12648 <remove_chain+0xcc>
   125a4:	8e 89       	ldd	r24, Y+22	; 0x16
   125a6:	9f 89       	ldd	r25, Y+23	; 0x17
   125a8:	a8 8d       	ldd	r26, Y+24	; 0x18
   125aa:	b9 8d       	ldd	r27, Y+25	; 0x19
   125ac:	48 17       	cp	r20, r24
   125ae:	59 07       	cpc	r21, r25
   125b0:	6a 07       	cpc	r22, r26
   125b2:	7b 07       	cpc	r23, r27
   125b4:	d8 f1       	brcs	.+118    	; 0x1262c <remove_chain+0xb0>
   125b6:	48 c0       	rjmp	.+144    	; 0x12648 <remove_chain+0xcc>
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
   125b8:	ce 01       	movw	r24, r28
   125ba:	b8 01       	movw	r22, r16
   125bc:	a7 01       	movw	r20, r14
   125be:	45 da       	rcall	.-2934   	; 0x11a4a <get_fat>
   125c0:	5b 01       	movw	r10, r22
   125c2:	6c 01       	movw	r12, r24
			if (nxt == 0) break;				/* Empty cluster? */
   125c4:	61 15       	cp	r22, r1
   125c6:	71 05       	cpc	r23, r1
   125c8:	81 05       	cpc	r24, r1
   125ca:	91 05       	cpc	r25, r1
   125cc:	d9 f1       	breq	.+118    	; 0x12644 <remove_chain+0xc8>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
   125ce:	81 e0       	ldi	r24, 0x01	; 1
   125d0:	a8 16       	cp	r10, r24
   125d2:	b1 04       	cpc	r11, r1
   125d4:	c1 04       	cpc	r12, r1
   125d6:	d1 04       	cpc	r13, r1
   125d8:	b9 f1       	breq	.+110    	; 0x12648 <remove_chain+0xcc>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
   125da:	2f ef       	ldi	r18, 0xFF	; 255
   125dc:	a2 16       	cp	r10, r18
   125de:	2f ef       	ldi	r18, 0xFF	; 255
   125e0:	b2 06       	cpc	r11, r18
   125e2:	2f ef       	ldi	r18, 0xFF	; 255
   125e4:	c2 06       	cpc	r12, r18
   125e6:	2f ef       	ldi	r18, 0xFF	; 255
   125e8:	d2 06       	cpc	r13, r18
   125ea:	81 f1       	breq	.+96     	; 0x1264c <remove_chain+0xd0>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
   125ec:	ce 01       	movw	r24, r28
   125ee:	b8 01       	movw	r22, r16
   125f0:	a7 01       	movw	r20, r14
   125f2:	00 e0       	ldi	r16, 0x00	; 0
   125f4:	10 e0       	ldi	r17, 0x00	; 0
   125f6:	98 01       	movw	r18, r16
   125f8:	90 db       	rcall	.-2272   	; 0x11d1a <put_fat>
			if (res != FR_OK) break;
   125fa:	88 23       	and	r24, r24
   125fc:	41 f5       	brne	.+80     	; 0x1264e <remove_chain+0xd2>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
   125fe:	8e 85       	ldd	r24, Y+14	; 0x0e
   12600:	9f 85       	ldd	r25, Y+15	; 0x0f
   12602:	a8 89       	ldd	r26, Y+16	; 0x10
   12604:	b9 89       	ldd	r27, Y+17	; 0x11
   12606:	8f 3f       	cpi	r24, 0xFF	; 255
   12608:	2f ef       	ldi	r18, 0xFF	; 255
   1260a:	92 07       	cpc	r25, r18
   1260c:	2f ef       	ldi	r18, 0xFF	; 255
   1260e:	a2 07       	cpc	r26, r18
   12610:	2f ef       	ldi	r18, 0xFF	; 255
   12612:	b2 07       	cpc	r27, r18
   12614:	41 f0       	breq	.+16     	; 0x12626 <remove_chain+0xaa>
				fs->free_clust++;
   12616:	01 96       	adiw	r24, 0x01	; 1
   12618:	a1 1d       	adc	r26, r1
   1261a:	b1 1d       	adc	r27, r1
   1261c:	8e 87       	std	Y+14, r24	; 0x0e
   1261e:	9f 87       	std	Y+15, r25	; 0x0f
   12620:	a8 8b       	std	Y+16, r26	; 0x10
   12622:	b9 8b       	std	Y+17, r27	; 0x11
				fs->fsi_flag = 1;
   12624:	9d 82       	std	Y+5, r9	; 0x05
   12626:	86 01       	movw	r16, r12
   12628:	75 01       	movw	r14, r10
   1262a:	02 c0       	rjmp	.+4      	; 0x12630 <remove_chain+0xb4>
   1262c:	99 24       	eor	r9, r9
   1262e:	93 94       	inc	r9
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
   12630:	8e 89       	ldd	r24, Y+22	; 0x16
   12632:	9f 89       	ldd	r25, Y+23	; 0x17
   12634:	a8 8d       	ldd	r26, Y+24	; 0x18
   12636:	b9 8d       	ldd	r27, Y+25	; 0x19
   12638:	e8 16       	cp	r14, r24
   1263a:	f9 06       	cpc	r15, r25
   1263c:	0a 07       	cpc	r16, r26
   1263e:	1b 07       	cpc	r17, r27
   12640:	08 f4       	brcc	.+2      	; 0x12644 <remove_chain+0xc8>
   12642:	ba cf       	rjmp	.-140    	; 0x125b8 <remove_chain+0x3c>
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
   12644:	80 e0       	ldi	r24, 0x00	; 0
   12646:	03 c0       	rjmp	.+6      	; 0x1264e <remove_chain+0xd2>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
   12648:	82 e0       	ldi	r24, 0x02	; 2
   1264a:	01 c0       	rjmp	.+2      	; 0x1264e <remove_chain+0xd2>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
   1264c:	81 e0       	ldi	r24, 0x01	; 1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
   1264e:	df 91       	pop	r29
   12650:	cf 91       	pop	r28
   12652:	1f 91       	pop	r17
   12654:	0f 91       	pop	r16
   12656:	ff 90       	pop	r15
   12658:	ef 90       	pop	r14
   1265a:	df 90       	pop	r13
   1265c:	cf 90       	pop	r12
   1265e:	bf 90       	pop	r11
   12660:	af 90       	pop	r10
   12662:	9f 90       	pop	r9
   12664:	08 95       	ret

00012666 <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
   12666:	88 23       	and	r24, r24
   12668:	91 f4       	brne	.+36     	; 0x1268e <f_mount+0x28>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
   1266a:	e0 91 7f 09 	lds	r30, 0x097F
   1266e:	f0 91 80 09 	lds	r31, 0x0980

	if (rfs) {
   12672:	30 97       	sbiw	r30, 0x00	; 0
   12674:	09 f0       	breq	.+2      	; 0x12678 <f_mount+0x12>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
   12676:	10 82       	st	Z, r1
	}

	if (fs) {
   12678:	61 15       	cp	r22, r1
   1267a:	71 05       	cpc	r23, r1
   1267c:	11 f0       	breq	.+4      	; 0x12682 <f_mount+0x1c>
		fs->fs_type = 0;		/* Clear new fs object */
   1267e:	fb 01       	movw	r30, r22
   12680:	10 82       	st	Z, r1
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
   12682:	70 93 80 09 	sts	0x0980, r23
   12686:	60 93 7f 09 	sts	0x097F, r22

	return FR_OK;
   1268a:	80 e0       	ldi	r24, 0x00	; 0
   1268c:	08 95       	ret
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
   1268e:	8b e0       	ldi	r24, 0x0B	; 11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
   12690:	08 95       	ret

00012692 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
   12692:	2f 92       	push	r2
   12694:	3f 92       	push	r3
   12696:	4f 92       	push	r4
   12698:	5f 92       	push	r5
   1269a:	6f 92       	push	r6
   1269c:	7f 92       	push	r7
   1269e:	8f 92       	push	r8
   126a0:	9f 92       	push	r9
   126a2:	af 92       	push	r10
   126a4:	bf 92       	push	r11
   126a6:	cf 92       	push	r12
   126a8:	df 92       	push	r13
   126aa:	ef 92       	push	r14
   126ac:	ff 92       	push	r15
   126ae:	0f 93       	push	r16
   126b0:	1f 93       	push	r17
   126b2:	df 93       	push	r29
   126b4:	cf 93       	push	r28
   126b6:	cd b7       	in	r28, 0x3d	; 61
   126b8:	de b7       	in	r29, 0x3e	; 62
   126ba:	a4 97       	sbiw	r28, 0x24	; 36
   126bc:	0f b6       	in	r0, 0x3f	; 63
   126be:	f8 94       	cli
   126c0:	de bf       	out	0x3e, r29	; 62
   126c2:	0f be       	out	0x3f, r0	; 63
   126c4:	cd bf       	out	0x3d, r28	; 61
   126c6:	7c 01       	movw	r14, r24
   126c8:	7c a3       	std	Y+36, r23	; 0x24
   126ca:	6b a3       	std	Y+35, r22	; 0x23
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
   126cc:	00 97       	sbiw	r24, 0x00	; 0
   126ce:	09 f4       	brne	.+2      	; 0x126d2 <f_open+0x40>
   126d0:	c7 c0       	rjmp	.+398    	; 0x12860 <f_open+0x1ce>
	fp->fs = 0;			/* Clear file object */
   126d2:	fc 01       	movw	r30, r24
   126d4:	11 82       	std	Z+1, r1	; 0x01
   126d6:	10 82       	st	Z, r1

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   126d8:	2f e1       	ldi	r18, 0x1F	; 31
   126da:	b2 2e       	mov	r11, r18
   126dc:	b4 22       	and	r11, r20
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
   126de:	8e 01       	movw	r16, r28
   126e0:	03 5f       	subi	r16, 0xF3	; 243
   126e2:	1f 4f       	sbci	r17, 0xFF	; 255
   126e4:	4e 71       	andi	r20, 0x1E	; 30
   126e6:	ce 01       	movw	r24, r28
   126e8:	83 96       	adiw	r24, 0x23	; 35
   126ea:	b8 01       	movw	r22, r16
   126ec:	0e 94 86 89 	call	0x1130c	; 0x1130c <chk_mounted>
   126f0:	a8 2e       	mov	r10, r24
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
   126f2:	88 23       	and	r24, r24
   126f4:	09 f0       	breq	.+2      	; 0x126f8 <f_open+0x66>
   126f6:	b6 c0       	rjmp	.+364    	; 0x12864 <f_open+0x1d2>
		INIT_BUF(dj);
   126f8:	ce 01       	movw	r24, r28
   126fa:	01 96       	adiw	r24, 0x01	; 1
   126fc:	9a a3       	std	Y+34, r25	; 0x22
   126fe:	89 a3       	std	Y+33, r24	; 0x21
		res = follow_path(&dj, path);	/* Follow the file path */
   12700:	6b a1       	ldd	r22, Y+35	; 0x23
   12702:	7c a1       	ldd	r23, Y+36	; 0x24
   12704:	c8 01       	movw	r24, r16
   12706:	d7 dd       	rcall	.-1106   	; 0x122b6 <follow_path>
		dir = dj.dir;
   12708:	0f 8d       	ldd	r16, Y+31	; 0x1f
   1270a:	18 a1       	ldd	r17, Y+32	; 0x20
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
   1270c:	88 23       	and	r24, r24
   1270e:	21 f4       	brne	.+8      	; 0x12718 <f_open+0x86>
			if (!dir)	/* Current dir itself */
   12710:	01 15       	cp	r16, r1
   12712:	11 05       	cpc	r17, r1
   12714:	09 f4       	brne	.+2      	; 0x12718 <f_open+0x86>
				res = FR_INVALID_NAME;
   12716:	86 e0       	ldi	r24, 0x06	; 6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   12718:	2b 2d       	mov	r18, r11
   1271a:	30 e0       	ldi	r19, 0x00	; 0
   1271c:	a9 01       	movw	r20, r18
   1271e:	4c 71       	andi	r20, 0x1C	; 28
   12720:	50 70       	andi	r21, 0x00	; 0
   12722:	41 15       	cp	r20, r1
   12724:	51 05       	cpc	r21, r1
   12726:	09 f4       	brne	.+2      	; 0x1272a <f_open+0x98>
   12728:	57 c0       	rjmp	.+174    	; 0x127d8 <f_open+0x146>
			DWORD dw, cl;

			if (res != FR_OK) {					/* No file, create new */
   1272a:	88 23       	and	r24, r24
   1272c:	69 f0       	breq	.+26     	; 0x12748 <f_open+0xb6>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   1272e:	84 30       	cpi	r24, 0x04	; 4
   12730:	19 f4       	brne	.+6      	; 0x12738 <f_open+0xa6>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
   12732:	ce 01       	movw	r24, r28
   12734:	0d 96       	adiw	r24, 0x0d	; 13
   12736:	da de       	rcall	.-588    	; 0x124ec <dir_register>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
   12738:	0f 8d       	ldd	r16, Y+31	; 0x1f
   1273a:	18 a1       	ldd	r17, Y+32	; 0x20
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   1273c:	88 23       	and	r24, r24
   1273e:	09 f0       	breq	.+2      	; 0x12742 <f_open+0xb0>
   12740:	8d c0       	rjmp	.+282    	; 0x1285c <f_open+0x1ca>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
   12742:	f8 e0       	ldi	r31, 0x08	; 8
   12744:	bf 2a       	or	r11, r31
   12746:	07 c0       	rjmp	.+14     	; 0x12756 <f_open+0xc4>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
   12748:	f8 01       	movw	r30, r16
   1274a:	83 85       	ldd	r24, Z+11	; 0x0b
   1274c:	81 71       	andi	r24, 0x11	; 17
   1274e:	09 f0       	breq	.+2      	; 0x12752 <f_open+0xc0>
   12750:	a7 c0       	rjmp	.+334    	; 0x128a0 <f_open+0x20e>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
   12752:	b2 fc       	sbrc	r11, 2
   12754:	a1 c0       	rjmp	.+322    	; 0x12898 <f_open+0x206>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   12756:	b3 fe       	sbrs	r11, 3
   12758:	4a c0       	rjmp	.+148    	; 0x127ee <f_open+0x15c>
				dw = get_fattime();					/* Created time */
   1275a:	0e 94 8f 88 	call	0x1111e	; 0x1111e <get_fattime>
				ST_DWORD(dir+DIR_CrtTime, dw);
   1275e:	f8 01       	movw	r30, r16
   12760:	66 87       	std	Z+14, r22	; 0x0e
   12762:	77 87       	std	Z+15, r23	; 0x0f
   12764:	80 8b       	std	Z+16, r24	; 0x10
   12766:	91 8b       	std	Z+17, r25	; 0x11
				dir[DIR_Attr] = 0;					/* Reset attribute */
   12768:	13 86       	std	Z+11, r1	; 0x0b
				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
   1276a:	14 8e       	std	Z+28, r1	; 0x1c
   1276c:	15 8e       	std	Z+29, r1	; 0x1d
   1276e:	16 8e       	std	Z+30, r1	; 0x1e
   12770:	17 8e       	std	Z+31, r1	; 0x1f
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(djo.fs, res);
}
   12772:	ed 85       	ldd	r30, Y+13	; 0x0d
   12774:	fe 85       	ldd	r31, Y+14	; 0x0e
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
				dw = get_fattime();					/* Created time */
				ST_DWORD(dir+DIR_CrtTime, dw);
				dir[DIR_Attr] = 0;					/* Reset attribute */
				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
   12776:	80 81       	ld	r24, Z
   12778:	b8 01       	movw	r22, r16
   1277a:	23 d9       	rcall	.-3514   	; 0x119c2 <ld_clust.clone.0>
   1277c:	3b 01       	movw	r6, r22
   1277e:	4c 01       	movw	r8, r24
				st_clust(dir, 0);					/* cluster = 0 */
   12780:	c8 01       	movw	r24, r16
   12782:	40 e0       	ldi	r20, 0x00	; 0
   12784:	50 e0       	ldi	r21, 0x00	; 0
   12786:	ba 01       	movw	r22, r20
   12788:	0e 94 1e 89 	call	0x1123c	; 0x1123c <st_clust>
				dj.fs->wflag = 1;
   1278c:	8d 85       	ldd	r24, Y+13	; 0x0d
   1278e:	9e 85       	ldd	r25, Y+14	; 0x0e
   12790:	21 e0       	ldi	r18, 0x01	; 1
   12792:	fc 01       	movw	r30, r24
   12794:	24 83       	std	Z+4, r18	; 0x04
				if (cl) {							/* Remove the cluster chain if exist */
   12796:	61 14       	cp	r6, r1
   12798:	71 04       	cpc	r7, r1
   1279a:	81 04       	cpc	r8, r1
   1279c:	91 04       	cpc	r9, r1
   1279e:	39 f1       	breq	.+78     	; 0x127ee <f_open+0x15c>
					dw = dj.fs->winsect;
   127a0:	22 a4       	ldd	r2, Z+42	; 0x2a
   127a2:	33 a4       	ldd	r3, Z+43	; 0x2b
   127a4:	44 a4       	ldd	r4, Z+44	; 0x2c
   127a6:	55 a4       	ldd	r5, Z+45	; 0x2d
					res = remove_chain(dj.fs, cl);
   127a8:	b4 01       	movw	r22, r8
   127aa:	a3 01       	movw	r20, r6
   127ac:	e7 de       	rcall	.-562    	; 0x1257c <remove_chain>
					if (res == FR_OK) {
   127ae:	88 23       	and	r24, r24
   127b0:	09 f0       	breq	.+2      	; 0x127b4 <f_open+0x122>
   127b2:	54 c0       	rjmp	.+168    	; 0x1285c <f_open+0x1ca>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   127b4:	8d 85       	ldd	r24, Y+13	; 0x0d
   127b6:	9e 85       	ldd	r25, Y+14	; 0x0e
   127b8:	08 94       	sec
   127ba:	61 08       	sbc	r6, r1
   127bc:	71 08       	sbc	r7, r1
   127be:	81 08       	sbc	r8, r1
   127c0:	91 08       	sbc	r9, r1
   127c2:	fc 01       	movw	r30, r24
   127c4:	62 86       	std	Z+10, r6	; 0x0a
   127c6:	73 86       	std	Z+11, r7	; 0x0b
   127c8:	84 86       	std	Z+12, r8	; 0x0c
   127ca:	95 86       	std	Z+13, r9	; 0x0d
						res = move_window(dj.fs, dw);
   127cc:	b2 01       	movw	r22, r4
   127ce:	a1 01       	movw	r20, r2
   127d0:	18 d8       	rcall	.-4048   	; 0x11802 <move_window>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
   127d2:	88 23       	and	r24, r24
   127d4:	61 f0       	breq	.+24     	; 0x127ee <f_open+0x15c>
   127d6:	42 c0       	rjmp	.+132    	; 0x1285c <f_open+0x1ca>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
   127d8:	88 23       	and	r24, r24
   127da:	09 f0       	breq	.+2      	; 0x127de <f_open+0x14c>
   127dc:	3f c0       	rjmp	.+126    	; 0x1285c <f_open+0x1ca>
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
   127de:	f8 01       	movw	r30, r16
   127e0:	83 85       	ldd	r24, Z+11	; 0x0b
   127e2:	84 fd       	sbrc	r24, 4
   127e4:	5b c0       	rjmp	.+182    	; 0x1289c <f_open+0x20a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   127e6:	b1 fe       	sbrs	r11, 1
   127e8:	02 c0       	rjmp	.+4      	; 0x127ee <f_open+0x15c>
   127ea:	80 fd       	sbrc	r24, 0
   127ec:	59 c0       	rjmp	.+178    	; 0x128a0 <f_open+0x20e>
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
   127ee:	b3 fe       	sbrs	r11, 3
   127f0:	02 c0       	rjmp	.+4      	; 0x127f6 <f_open+0x164>
				mode |= FA__WRITTEN;
   127f2:	f0 e2       	ldi	r31, 0x20	; 32
   127f4:	bf 2a       	or	r11, r31
			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
   127f6:	cd 84       	ldd	r12, Y+13	; 0x0d
   127f8:	de 84       	ldd	r13, Y+14	; 0x0e
   127fa:	f6 01       	movw	r30, r12
   127fc:	82 a5       	ldd	r24, Z+42	; 0x2a
   127fe:	93 a5       	ldd	r25, Z+43	; 0x2b
   12800:	a4 a5       	ldd	r26, Z+44	; 0x2c
   12802:	b5 a5       	ldd	r27, Z+45	; 0x2d
   12804:	f7 01       	movw	r30, r14
   12806:	82 8f       	std	Z+26, r24	; 0x1a
   12808:	93 8f       	std	Z+27, r25	; 0x1b
   1280a:	a4 8f       	std	Z+28, r26	; 0x1c
   1280c:	b5 8f       	std	Z+29, r27	; 0x1d
			fp->dir_ptr = dir;
   1280e:	17 8f       	std	Z+31, r17	; 0x1f
   12810:	06 8f       	std	Z+30, r16	; 0x1e
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
   12812:	b4 82       	std	Z+4, r11	; 0x04
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
   12814:	f6 01       	movw	r30, r12
   12816:	80 81       	ld	r24, Z
   12818:	b8 01       	movw	r22, r16
   1281a:	d3 d8       	rcall	.-3674   	; 0x119c2 <ld_clust.clone.0>
   1281c:	f7 01       	movw	r30, r14
   1281e:	66 87       	std	Z+14, r22	; 0x0e
   12820:	77 87       	std	Z+15, r23	; 0x0f
   12822:	80 8b       	std	Z+16, r24	; 0x10
   12824:	91 8b       	std	Z+17, r25	; 0x11
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
   12826:	f8 01       	movw	r30, r16
   12828:	84 8d       	ldd	r24, Z+28	; 0x1c
   1282a:	95 8d       	ldd	r25, Z+29	; 0x1d
   1282c:	a6 8d       	ldd	r26, Z+30	; 0x1e
   1282e:	b7 8d       	ldd	r27, Z+31	; 0x1f
   12830:	f7 01       	movw	r30, r14
   12832:	82 87       	std	Z+10, r24	; 0x0a
   12834:	93 87       	std	Z+11, r25	; 0x0b
   12836:	a4 87       	std	Z+12, r26	; 0x0c
   12838:	b5 87       	std	Z+13, r27	; 0x0d
			fp->fptr = 0;						/* File pointer */
   1283a:	16 82       	std	Z+6, r1	; 0x06
   1283c:	17 82       	std	Z+7, r1	; 0x07
   1283e:	10 86       	std	Z+8, r1	; 0x08
   12840:	11 86       	std	Z+9, r1	; 0x09
			fp->dsect = 0;
   12842:	16 8a       	std	Z+22, r1	; 0x16
   12844:	17 8a       	std	Z+23, r1	; 0x17
   12846:	10 8e       	std	Z+24, r1	; 0x18
   12848:	11 8e       	std	Z+25, r1	; 0x19
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
   1284a:	d1 82       	std	Z+1, r13	; 0x01
   1284c:	c0 82       	st	Z, r12
   1284e:	f6 01       	movw	r30, r12
   12850:	86 81       	ldd	r24, Z+6	; 0x06
   12852:	97 81       	ldd	r25, Z+7	; 0x07
   12854:	f7 01       	movw	r30, r14
   12856:	93 83       	std	Z+3, r25	; 0x03
   12858:	82 83       	std	Z+2, r24	; 0x02
   1285a:	04 c0       	rjmp	.+8      	; 0x12864 <f_open+0x1d2>
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
   1285c:	a8 2e       	mov	r10, r24
   1285e:	02 c0       	rjmp	.+4      	; 0x12864 <f_open+0x1d2>
   12860:	99 e0       	ldi	r25, 0x09	; 9
   12862:	a9 2e       	mov	r10, r25
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
		}
	}

	LEAVE_FF(dj.fs, res);
}
   12864:	8a 2d       	mov	r24, r10
   12866:	a4 96       	adiw	r28, 0x24	; 36
   12868:	0f b6       	in	r0, 0x3f	; 63
   1286a:	f8 94       	cli
   1286c:	de bf       	out	0x3e, r29	; 62
   1286e:	0f be       	out	0x3f, r0	; 63
   12870:	cd bf       	out	0x3d, r28	; 61
   12872:	cf 91       	pop	r28
   12874:	df 91       	pop	r29
   12876:	1f 91       	pop	r17
   12878:	0f 91       	pop	r16
   1287a:	ff 90       	pop	r15
   1287c:	ef 90       	pop	r14
   1287e:	df 90       	pop	r13
   12880:	cf 90       	pop	r12
   12882:	bf 90       	pop	r11
   12884:	af 90       	pop	r10
   12886:	9f 90       	pop	r9
   12888:	8f 90       	pop	r8
   1288a:	7f 90       	pop	r7
   1288c:	6f 90       	pop	r6
   1288e:	5f 90       	pop	r5
   12890:	4f 90       	pop	r4
   12892:	3f 90       	pop	r3
   12894:	2f 90       	pop	r2
   12896:	08 95       	ret
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
   12898:	88 e0       	ldi	r24, 0x08	; 8
   1289a:	e0 cf       	rjmp	.-64     	; 0x1285c <f_open+0x1ca>
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
					res = FR_NO_FILE;
   1289c:	84 e0       	ldi	r24, 0x04	; 4
   1289e:	de cf       	rjmp	.-68     	; 0x1285c <f_open+0x1ca>
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
   128a0:	87 e0       	ldi	r24, 0x07	; 7
   128a2:	dc cf       	rjmp	.-72     	; 0x1285c <f_open+0x1ca>

000128a4 <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
   128a4:	2f 92       	push	r2
   128a6:	3f 92       	push	r3
   128a8:	4f 92       	push	r4
   128aa:	5f 92       	push	r5
   128ac:	6f 92       	push	r6
   128ae:	7f 92       	push	r7
   128b0:	8f 92       	push	r8
   128b2:	9f 92       	push	r9
   128b4:	af 92       	push	r10
   128b6:	bf 92       	push	r11
   128b8:	cf 92       	push	r12
   128ba:	df 92       	push	r13
   128bc:	ef 92       	push	r14
   128be:	ff 92       	push	r15
   128c0:	0f 93       	push	r16
   128c2:	1f 93       	push	r17
   128c4:	df 93       	push	r29
   128c6:	cf 93       	push	r28
   128c8:	cd b7       	in	r28, 0x3d	; 61
   128ca:	de b7       	in	r29, 0x3e	; 62
   128cc:	28 97       	sbiw	r28, 0x08	; 8
   128ce:	0f b6       	in	r0, 0x3f	; 63
   128d0:	f8 94       	cli
   128d2:	de bf       	out	0x3e, r29	; 62
   128d4:	0f be       	out	0x3f, r0	; 63
   128d6:	cd bf       	out	0x3d, r28	; 61
   128d8:	98 87       	std	Y+8, r25	; 0x08
   128da:	8f 83       	std	Y+7, r24	; 0x07
   128dc:	6a 01       	movw	r12, r20
   128de:	3c 83       	std	Y+4, r19	; 0x04
   128e0:	2b 83       	std	Y+3, r18	; 0x03
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
   128e2:	d9 01       	movw	r26, r18
   128e4:	1d 92       	st	X+, r1
   128e6:	1c 92       	st	X, r1

	res = validate(fp);						/* Check validity */
   128e8:	8f 81       	ldd	r24, Y+7	; 0x07
   128ea:	98 85       	ldd	r25, Y+8	; 0x08
   128ec:	6d 83       	std	Y+5, r22	; 0x05
   128ee:	7e 83       	std	Y+6, r23	; 0x06
   128f0:	0e 94 24 89 	call	0x11248	; 0x11248 <validate>
   128f4:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   128f6:	6d 81       	ldd	r22, Y+5	; 0x05
   128f8:	7e 81       	ldd	r23, Y+6	; 0x06
   128fa:	88 23       	and	r24, r24
   128fc:	09 f0       	breq	.+2      	; 0x12900 <f_write+0x5c>
   128fe:	b9 c1       	rjmp	.+882    	; 0x12c72 <f_write+0x3ce>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
   12900:	ef 81       	ldd	r30, Y+7	; 0x07
   12902:	f8 85       	ldd	r31, Y+8	; 0x08
   12904:	84 81       	ldd	r24, Z+4	; 0x04
   12906:	87 fd       	sbrc	r24, 7
   12908:	cf c0       	rjmp	.+414    	; 0x12aa8 <f_write+0x204>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
   1290a:	81 ff       	sbrs	r24, 1
   1290c:	b1 c1       	rjmp	.+866    	; 0x12c70 <f_write+0x3cc>
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
   1290e:	22 85       	ldd	r18, Z+10	; 0x0a
   12910:	33 85       	ldd	r19, Z+11	; 0x0b
   12912:	44 85       	ldd	r20, Z+12	; 0x0c
   12914:	55 85       	ldd	r21, Z+13	; 0x0d
   12916:	c6 01       	movw	r24, r12
   12918:	a0 e0       	ldi	r26, 0x00	; 0
   1291a:	b0 e0       	ldi	r27, 0x00	; 0
   1291c:	82 0f       	add	r24, r18
   1291e:	93 1f       	adc	r25, r19
   12920:	a4 1f       	adc	r26, r20
   12922:	b5 1f       	adc	r27, r21
   12924:	82 17       	cp	r24, r18
   12926:	93 07       	cpc	r25, r19
   12928:	a4 07       	cpc	r26, r20
   1292a:	b5 07       	cpc	r27, r21
   1292c:	10 f4       	brcc	.+4      	; 0x12932 <f_write+0x8e>
   1292e:	cc 24       	eor	r12, r12
   12930:	dd 24       	eor	r13, r13
)
{
	FRESULT res;
	DWORD clst, sect;
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
   12932:	26 2e       	mov	r2, r22
   12934:	37 2e       	mov	r3, r23
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   12936:	2f 81       	ldd	r18, Y+7	; 0x07
   12938:	38 85       	ldd	r19, Y+8	; 0x08
   1293a:	20 5e       	subi	r18, 0xE0	; 224
   1293c:	3f 4f       	sbci	r19, 0xFF	; 255
   1293e:	3a 83       	std	Y+2, r19	; 0x02
   12940:	29 83       	std	Y+1, r18	; 0x01
   12942:	75 c1       	rjmp	.+746    	; 0x12c2e <f_write+0x38a>
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
   12944:	af 81       	ldd	r26, Y+7	; 0x07
   12946:	b8 85       	ldd	r27, Y+8	; 0x08
   12948:	16 96       	adiw	r26, 0x06	; 6
   1294a:	2d 91       	ld	r18, X+
   1294c:	3d 91       	ld	r19, X+
   1294e:	4d 91       	ld	r20, X+
   12950:	5c 91       	ld	r21, X
   12952:	19 97       	sbiw	r26, 0x09	; 9
   12954:	da 01       	movw	r26, r20
   12956:	c9 01       	movw	r24, r18
   12958:	91 70       	andi	r25, 0x01	; 1
   1295a:	a0 70       	andi	r26, 0x00	; 0
   1295c:	b0 70       	andi	r27, 0x00	; 0
   1295e:	00 97       	sbiw	r24, 0x00	; 0
   12960:	a1 05       	cpc	r26, r1
   12962:	b1 05       	cpc	r27, r1
   12964:	09 f0       	breq	.+2      	; 0x12968 <f_write+0xc4>
   12966:	25 c1       	rjmp	.+586    	; 0x12bb2 <f_write+0x30e>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   12968:	ef 81       	ldd	r30, Y+7	; 0x07
   1296a:	f8 85       	ldd	r31, Y+8	; 0x08
   1296c:	80 81       	ld	r24, Z
   1296e:	91 81       	ldd	r25, Z+1	; 0x01
   12970:	49 01       	movw	r8, r18
   12972:	5a 01       	movw	r10, r20
   12974:	a9 e0       	ldi	r26, 0x09	; 9
   12976:	b6 94       	lsr	r11
   12978:	a7 94       	ror	r10
   1297a:	97 94       	ror	r9
   1297c:	87 94       	ror	r8
   1297e:	aa 95       	dec	r26
   12980:	d1 f7       	brne	.-12     	; 0x12976 <f_write+0xd2>
   12982:	dc 01       	movw	r26, r24
   12984:	12 96       	adiw	r26, 0x02	; 2
   12986:	ec 90       	ld	r14, X
   12988:	12 97       	sbiw	r26, 0x02	; 2
   1298a:	ea 94       	dec	r14
   1298c:	e8 20       	and	r14, r8
			if (!csect) {					/* On the cluster boundary? */
   1298e:	09 f0       	breq	.+2      	; 0x12992 <f_write+0xee>
   12990:	4f c0       	rjmp	.+158    	; 0x12a30 <f_write+0x18c>
				if (fp->fptr == 0) {		/* On the top of the file? */
   12992:	21 15       	cp	r18, r1
   12994:	31 05       	cpc	r19, r1
   12996:	41 05       	cpc	r20, r1
   12998:	51 05       	cpc	r21, r1
   1299a:	b1 f4       	brne	.+44     	; 0x129c8 <f_write+0x124>
					clst = fp->sclust;		/* Follow from the origin */
   1299c:	26 85       	ldd	r18, Z+14	; 0x0e
   1299e:	37 85       	ldd	r19, Z+15	; 0x0f
   129a0:	40 89       	ldd	r20, Z+16	; 0x10
   129a2:	51 89       	ldd	r21, Z+17	; 0x11
					if (clst == 0)			/* When no cluster is allocated, */
   129a4:	21 15       	cp	r18, r1
   129a6:	31 05       	cpc	r19, r1
   129a8:	41 05       	cpc	r20, r1
   129aa:	51 05       	cpc	r21, r1
   129ac:	f1 f4       	brne	.+60     	; 0x129ea <f_write+0x146>
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   129ae:	40 e0       	ldi	r20, 0x00	; 0
   129b0:	50 e0       	ldi	r21, 0x00	; 0
   129b2:	ba 01       	movw	r22, r20
   129b4:	96 da       	rcall	.-2772   	; 0x11ee2 <create_chain>
   129b6:	9b 01       	movw	r18, r22
   129b8:	ac 01       	movw	r20, r24
   129ba:	ef 81       	ldd	r30, Y+7	; 0x07
   129bc:	f8 85       	ldd	r31, Y+8	; 0x08
   129be:	66 87       	std	Z+14, r22	; 0x0e
   129c0:	77 87       	std	Z+15, r23	; 0x0f
   129c2:	80 8b       	std	Z+16, r24	; 0x10
   129c4:	91 8b       	std	Z+17, r25	; 0x11
   129c6:	0b c0       	rjmp	.+22     	; 0x129de <f_write+0x13a>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   129c8:	af 81       	ldd	r26, Y+7	; 0x07
   129ca:	b8 85       	ldd	r27, Y+8	; 0x08
   129cc:	52 96       	adiw	r26, 0x12	; 18
   129ce:	4d 91       	ld	r20, X+
   129d0:	5d 91       	ld	r21, X+
   129d2:	6d 91       	ld	r22, X+
   129d4:	7c 91       	ld	r23, X
   129d6:	55 97       	sbiw	r26, 0x15	; 21
   129d8:	84 da       	rcall	.-2808   	; 0x11ee2 <create_chain>
   129da:	9b 01       	movw	r18, r22
   129dc:	ac 01       	movw	r20, r24
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   129de:	21 15       	cp	r18, r1
   129e0:	31 05       	cpc	r19, r1
   129e2:	41 05       	cpc	r20, r1
   129e4:	51 05       	cpc	r21, r1
   129e6:	09 f4       	brne	.+2      	; 0x129ea <f_write+0x146>
   129e8:	26 c1       	rjmp	.+588    	; 0x12c36 <f_write+0x392>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   129ea:	21 30       	cpi	r18, 0x01	; 1
   129ec:	31 05       	cpc	r19, r1
   129ee:	41 05       	cpc	r20, r1
   129f0:	51 05       	cpc	r21, r1
   129f2:	31 f4       	brne	.+12     	; 0x12a00 <f_write+0x15c>
   129f4:	ef 81       	ldd	r30, Y+7	; 0x07
   129f6:	f8 85       	ldd	r31, Y+8	; 0x08
   129f8:	84 81       	ldd	r24, Z+4	; 0x04
   129fa:	80 68       	ori	r24, 0x80	; 128
   129fc:	84 83       	std	Z+4, r24	; 0x04
   129fe:	54 c0       	rjmp	.+168    	; 0x12aa8 <f_write+0x204>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   12a00:	2f 3f       	cpi	r18, 0xFF	; 255
   12a02:	ff ef       	ldi	r31, 0xFF	; 255
   12a04:	3f 07       	cpc	r19, r31
   12a06:	ff ef       	ldi	r31, 0xFF	; 255
   12a08:	4f 07       	cpc	r20, r31
   12a0a:	ff ef       	ldi	r31, 0xFF	; 255
   12a0c:	5f 07       	cpc	r21, r31
   12a0e:	51 f4       	brne	.+20     	; 0x12a24 <f_write+0x180>
   12a10:	af 81       	ldd	r26, Y+7	; 0x07
   12a12:	b8 85       	ldd	r27, Y+8	; 0x08
   12a14:	14 96       	adiw	r26, 0x04	; 4
   12a16:	8c 91       	ld	r24, X
   12a18:	14 97       	sbiw	r26, 0x04	; 4
   12a1a:	80 68       	ori	r24, 0x80	; 128
   12a1c:	14 96       	adiw	r26, 0x04	; 4
   12a1e:	8c 93       	st	X, r24
   12a20:	14 97       	sbiw	r26, 0x04	; 4
   12a22:	bd c0       	rjmp	.+378    	; 0x12b9e <f_write+0x2fa>
				fp->clust = clst;			/* Update current cluster */
   12a24:	ef 81       	ldd	r30, Y+7	; 0x07
   12a26:	f8 85       	ldd	r31, Y+8	; 0x08
   12a28:	22 8b       	std	Z+18, r18	; 0x12
   12a2a:	33 8b       	std	Z+19, r19	; 0x13
   12a2c:	44 8b       	std	Z+20, r20	; 0x14
   12a2e:	55 8b       	std	Z+21, r21	; 0x15
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
   12a30:	af 81       	ldd	r26, Y+7	; 0x07
   12a32:	b8 85       	ldd	r27, Y+8	; 0x08
   12a34:	14 96       	adiw	r26, 0x04	; 4
   12a36:	8c 91       	ld	r24, X
   12a38:	14 97       	sbiw	r26, 0x04	; 4
   12a3a:	86 ff       	sbrs	r24, 6
   12a3c:	1c c0       	rjmp	.+56     	; 0x12a76 <f_write+0x1d2>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   12a3e:	ed 91       	ld	r30, X+
   12a40:	fc 91       	ld	r31, X
   12a42:	11 97       	sbiw	r26, 0x01	; 1
   12a44:	56 96       	adiw	r26, 0x16	; 22
   12a46:	2d 91       	ld	r18, X+
   12a48:	3d 91       	ld	r19, X+
   12a4a:	4d 91       	ld	r20, X+
   12a4c:	5c 91       	ld	r21, X
   12a4e:	59 97       	sbiw	r26, 0x19	; 25
   12a50:	81 81       	ldd	r24, Z+1	; 0x01
   12a52:	69 81       	ldd	r22, Y+1	; 0x01
   12a54:	7a 81       	ldd	r23, Y+2	; 0x02
   12a56:	01 e0       	ldi	r16, 0x01	; 1
   12a58:	0e 94 7e 88 	call	0x110fc	; 0x110fc <disk_write>
   12a5c:	ef 81       	ldd	r30, Y+7	; 0x07
   12a5e:	f8 85       	ldd	r31, Y+8	; 0x08
   12a60:	94 81       	ldd	r25, Z+4	; 0x04
   12a62:	88 23       	and	r24, r24
   12a64:	19 f0       	breq	.+6      	; 0x12a6c <f_write+0x1c8>
					ABORT(fp->fs, FR_DISK_ERR);
   12a66:	90 68       	ori	r25, 0x80	; 128
   12a68:	94 83       	std	Z+4, r25	; 0x04
   12a6a:	99 c0       	rjmp	.+306    	; 0x12b9e <f_write+0x2fa>
				fp->flag &= ~FA__DIRTY;
   12a6c:	9f 7b       	andi	r25, 0xBF	; 191
   12a6e:	af 81       	ldd	r26, Y+7	; 0x07
   12a70:	b8 85       	ldd	r27, Y+8	; 0x08
   12a72:	14 96       	adiw	r26, 0x04	; 4
   12a74:	9c 93       	st	X, r25
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   12a76:	ef 81       	ldd	r30, Y+7	; 0x07
   12a78:	f8 85       	ldd	r31, Y+8	; 0x08
   12a7a:	40 80       	ld	r4, Z
   12a7c:	51 80       	ldd	r5, Z+1	; 0x01
   12a7e:	42 89       	ldd	r20, Z+18	; 0x12
   12a80:	53 89       	ldd	r21, Z+19	; 0x13
   12a82:	64 89       	ldd	r22, Z+20	; 0x14
   12a84:	75 89       	ldd	r23, Z+21	; 0x15
   12a86:	c2 01       	movw	r24, r4
   12a88:	0e 94 f6 8c 	call	0x119ec	; 0x119ec <clust2sect>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   12a8c:	61 15       	cp	r22, r1
   12a8e:	71 05       	cpc	r23, r1
   12a90:	81 05       	cpc	r24, r1
   12a92:	91 05       	cpc	r25, r1
   12a94:	59 f4       	brne	.+22     	; 0x12aac <f_write+0x208>
   12a96:	af 81       	ldd	r26, Y+7	; 0x07
   12a98:	b8 85       	ldd	r27, Y+8	; 0x08
   12a9a:	14 96       	adiw	r26, 0x04	; 4
   12a9c:	8c 91       	ld	r24, X
   12a9e:	14 97       	sbiw	r26, 0x04	; 4
   12aa0:	80 68       	ori	r24, 0x80	; 128
   12aa2:	14 96       	adiw	r26, 0x04	; 4
   12aa4:	8c 93       	st	X, r24
   12aa6:	14 97       	sbiw	r26, 0x04	; 4
   12aa8:	12 e0       	ldi	r17, 0x02	; 2
   12aaa:	e3 c0       	rjmp	.+454    	; 0x12c72 <f_write+0x3ce>
			sect += csect;
   12aac:	4b 01       	movw	r8, r22
   12aae:	5c 01       	movw	r10, r24
   12ab0:	8e 0c       	add	r8, r14
   12ab2:	91 1c       	adc	r9, r1
   12ab4:	a1 1c       	adc	r10, r1
   12ab6:	b1 1c       	adc	r11, r1
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
   12ab8:	36 01       	movw	r6, r12
   12aba:	67 2c       	mov	r6, r7
   12abc:	77 24       	eor	r7, r7
   12abe:	66 94       	lsr	r6
			if (cc) {						/* Write maximum contiguous sectors directly */
   12ac0:	61 14       	cp	r6, r1
   12ac2:	71 04       	cpc	r7, r1
   12ac4:	09 f4       	brne	.+2      	; 0x12ac8 <f_write+0x224>
   12ac6:	42 c0       	rjmp	.+132    	; 0x12b4c <f_write+0x2a8>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   12ac8:	f2 01       	movw	r30, r4
   12aca:	82 81       	ldd	r24, Z+2	; 0x02
   12acc:	ff 24       	eor	r15, r15
   12ace:	93 01       	movw	r18, r6
   12ad0:	2e 0d       	add	r18, r14
   12ad2:	3f 1d       	adc	r19, r15
   12ad4:	90 e0       	ldi	r25, 0x00	; 0
   12ad6:	82 17       	cp	r24, r18
   12ad8:	93 07       	cpc	r25, r19
   12ada:	18 f4       	brcc	.+6      	; 0x12ae2 <f_write+0x23e>
					cc = fp->fs->csize - csect;
   12adc:	3c 01       	movw	r6, r24
   12ade:	6e 18       	sub	r6, r14
   12ae0:	7f 08       	sbc	r7, r15
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
   12ae2:	d2 01       	movw	r26, r4
   12ae4:	11 96       	adiw	r26, 0x01	; 1
   12ae6:	8c 91       	ld	r24, X
   12ae8:	b1 01       	movw	r22, r2
   12aea:	a5 01       	movw	r20, r10
   12aec:	94 01       	movw	r18, r8
   12aee:	06 2d       	mov	r16, r6
   12af0:	0e 94 7e 88 	call	0x110fc	; 0x110fc <disk_write>
   12af4:	88 23       	and	r24, r24
   12af6:	09 f0       	breq	.+2      	; 0x12afa <f_write+0x256>
   12af8:	4d c0       	rjmp	.+154    	; 0x12b94 <f_write+0x2f0>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   12afa:	af 81       	ldd	r26, Y+7	; 0x07
   12afc:	b8 85       	ldd	r27, Y+8	; 0x08
   12afe:	56 96       	adiw	r26, 0x16	; 22
   12b00:	6d 91       	ld	r22, X+
   12b02:	7d 91       	ld	r23, X+
   12b04:	8d 91       	ld	r24, X+
   12b06:	9c 91       	ld	r25, X
   12b08:	59 97       	sbiw	r26, 0x19	; 25
   12b0a:	68 19       	sub	r22, r8
   12b0c:	79 09       	sbc	r23, r9
   12b0e:	8a 09       	sbc	r24, r10
   12b10:	9b 09       	sbc	r25, r11
   12b12:	93 01       	movw	r18, r6
   12b14:	40 e0       	ldi	r20, 0x00	; 0
   12b16:	50 e0       	ldi	r21, 0x00	; 0
   12b18:	62 17       	cp	r22, r18
   12b1a:	73 07       	cpc	r23, r19
   12b1c:	84 07       	cpc	r24, r20
   12b1e:	95 07       	cpc	r25, r21
   12b20:	80 f4       	brcc	.+32     	; 0x12b42 <f_write+0x29e>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   12b22:	76 2f       	mov	r23, r22
   12b24:	66 27       	eor	r22, r22
   12b26:	77 0f       	add	r23, r23
   12b28:	62 0d       	add	r22, r2
   12b2a:	73 1d       	adc	r23, r3
   12b2c:	89 81       	ldd	r24, Y+1	; 0x01
   12b2e:	9a 81       	ldd	r25, Y+2	; 0x02
   12b30:	40 e0       	ldi	r20, 0x00	; 0
   12b32:	52 e0       	ldi	r21, 0x02	; 2
   12b34:	0e 94 f3 88 	call	0x111e6	; 0x111e6 <mem_cpy>
					fp->flag &= ~FA__DIRTY;
   12b38:	ef 81       	ldd	r30, Y+7	; 0x07
   12b3a:	f8 85       	ldd	r31, Y+8	; 0x08
   12b3c:	84 81       	ldd	r24, Z+4	; 0x04
   12b3e:	8f 7b       	andi	r24, 0xBF	; 191
   12b40:	84 83       	std	Z+4, r24	; 0x04
				}
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
   12b42:	73 01       	movw	r14, r6
   12b44:	fe 2c       	mov	r15, r14
   12b46:	ee 24       	eor	r14, r14
   12b48:	ff 0c       	add	r15, r15
				continue;
   12b4a:	52 c0       	rjmp	.+164    	; 0x12bf0 <f_write+0x34c>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
   12b4c:	ef 81       	ldd	r30, Y+7	; 0x07
   12b4e:	f8 85       	ldd	r31, Y+8	; 0x08
   12b50:	86 89       	ldd	r24, Z+22	; 0x16
   12b52:	97 89       	ldd	r25, Z+23	; 0x17
   12b54:	a0 8d       	ldd	r26, Z+24	; 0x18
   12b56:	b1 8d       	ldd	r27, Z+25	; 0x19
   12b58:	88 15       	cp	r24, r8
   12b5a:	99 05       	cpc	r25, r9
   12b5c:	aa 05       	cpc	r26, r10
   12b5e:	bb 05       	cpc	r27, r11
   12b60:	01 f1       	breq	.+64     	; 0x12ba2 <f_write+0x2fe>
				if (fp->fptr < fp->fsize &&
   12b62:	26 81       	ldd	r18, Z+6	; 0x06
   12b64:	37 81       	ldd	r19, Z+7	; 0x07
   12b66:	40 85       	ldd	r20, Z+8	; 0x08
   12b68:	51 85       	ldd	r21, Z+9	; 0x09
   12b6a:	82 85       	ldd	r24, Z+10	; 0x0a
   12b6c:	93 85       	ldd	r25, Z+11	; 0x0b
   12b6e:	a4 85       	ldd	r26, Z+12	; 0x0c
   12b70:	b5 85       	ldd	r27, Z+13	; 0x0d
   12b72:	28 17       	cp	r18, r24
   12b74:	39 07       	cpc	r19, r25
   12b76:	4a 07       	cpc	r20, r26
   12b78:	5b 07       	cpc	r21, r27
   12b7a:	98 f4       	brcc	.+38     	; 0x12ba2 <f_write+0x2fe>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
   12b7c:	d2 01       	movw	r26, r4
   12b7e:	11 96       	adiw	r26, 0x01	; 1
   12b80:	8c 91       	ld	r24, X
   12b82:	69 81       	ldd	r22, Y+1	; 0x01
   12b84:	7a 81       	ldd	r23, Y+2	; 0x02
   12b86:	a5 01       	movw	r20, r10
   12b88:	94 01       	movw	r18, r8
   12b8a:	01 e0       	ldi	r16, 0x01	; 1
   12b8c:	0e 94 73 88 	call	0x110e6	; 0x110e6 <disk_read>
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
   12b90:	88 23       	and	r24, r24
   12b92:	39 f0       	breq	.+14     	; 0x12ba2 <f_write+0x2fe>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
   12b94:	ef 81       	ldd	r30, Y+7	; 0x07
   12b96:	f8 85       	ldd	r31, Y+8	; 0x08
   12b98:	84 81       	ldd	r24, Z+4	; 0x04
   12b9a:	80 68       	ori	r24, 0x80	; 128
   12b9c:	84 83       	std	Z+4, r24	; 0x04
   12b9e:	11 e0       	ldi	r17, 0x01	; 1
   12ba0:	68 c0       	rjmp	.+208    	; 0x12c72 <f_write+0x3ce>
			}
#endif
			fp->dsect = sect;
   12ba2:	af 81       	ldd	r26, Y+7	; 0x07
   12ba4:	b8 85       	ldd	r27, Y+8	; 0x08
   12ba6:	56 96       	adiw	r26, 0x16	; 22
   12ba8:	8d 92       	st	X+, r8
   12baa:	9d 92       	st	X+, r9
   12bac:	ad 92       	st	X+, r10
   12bae:	bc 92       	st	X, r11
   12bb0:	59 97       	sbiw	r26, 0x19	; 25
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
   12bb2:	ef 81       	ldd	r30, Y+7	; 0x07
   12bb4:	f8 85       	ldd	r31, Y+8	; 0x08
   12bb6:	86 81       	ldd	r24, Z+6	; 0x06
   12bb8:	97 81       	ldd	r25, Z+7	; 0x07
   12bba:	a0 85       	ldd	r26, Z+8	; 0x08
   12bbc:	b1 85       	ldd	r27, Z+9	; 0x09
   12bbe:	9c 01       	movw	r18, r24
   12bc0:	31 70       	andi	r19, 0x01	; 1
   12bc2:	40 e0       	ldi	r20, 0x00	; 0
   12bc4:	52 e0       	ldi	r21, 0x02	; 2
   12bc6:	42 1b       	sub	r20, r18
   12bc8:	53 0b       	sbc	r21, r19
   12bca:	76 01       	movw	r14, r12
   12bcc:	4c 15       	cp	r20, r12
   12bce:	5d 05       	cpc	r21, r13
   12bd0:	08 f4       	brcc	.+2      	; 0x12bd4 <f_write+0x330>
   12bd2:	7a 01       	movw	r14, r20
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   12bd4:	91 70       	andi	r25, 0x01	; 1
   12bd6:	a9 81       	ldd	r26, Y+1	; 0x01
   12bd8:	ba 81       	ldd	r27, Y+2	; 0x02
   12bda:	8a 0f       	add	r24, r26
   12bdc:	9b 1f       	adc	r25, r27
   12bde:	b1 01       	movw	r22, r2
   12be0:	a7 01       	movw	r20, r14
   12be2:	0e 94 f3 88 	call	0x111e6	; 0x111e6 <mem_cpy>
		fp->flag |= FA__DIRTY;
   12be6:	ef 81       	ldd	r30, Y+7	; 0x07
   12be8:	f8 85       	ldd	r31, Y+8	; 0x08
   12bea:	84 81       	ldd	r24, Z+4	; 0x04
   12bec:	80 64       	ori	r24, 0x40	; 64
   12bee:	84 83       	std	Z+4, r24	; 0x04
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   12bf0:	2e 0c       	add	r2, r14
   12bf2:	3f 1c       	adc	r3, r15
   12bf4:	97 01       	movw	r18, r14
   12bf6:	40 e0       	ldi	r20, 0x00	; 0
   12bf8:	50 e0       	ldi	r21, 0x00	; 0
   12bfa:	ef 81       	ldd	r30, Y+7	; 0x07
   12bfc:	f8 85       	ldd	r31, Y+8	; 0x08
   12bfe:	86 81       	ldd	r24, Z+6	; 0x06
   12c00:	97 81       	ldd	r25, Z+7	; 0x07
   12c02:	a0 85       	ldd	r26, Z+8	; 0x08
   12c04:	b1 85       	ldd	r27, Z+9	; 0x09
   12c06:	82 0f       	add	r24, r18
   12c08:	93 1f       	adc	r25, r19
   12c0a:	a4 1f       	adc	r26, r20
   12c0c:	b5 1f       	adc	r27, r21
   12c0e:	86 83       	std	Z+6, r24	; 0x06
   12c10:	97 83       	std	Z+7, r25	; 0x07
   12c12:	a0 87       	std	Z+8, r26	; 0x08
   12c14:	b1 87       	std	Z+9, r27	; 0x09
   12c16:	ab 81       	ldd	r26, Y+3	; 0x03
   12c18:	bc 81       	ldd	r27, Y+4	; 0x04
   12c1a:	8d 91       	ld	r24, X+
   12c1c:	9c 91       	ld	r25, X
   12c1e:	11 97       	sbiw	r26, 0x01	; 1
   12c20:	8e 0d       	add	r24, r14
   12c22:	9f 1d       	adc	r25, r15
   12c24:	11 96       	adiw	r26, 0x01	; 1
   12c26:	9c 93       	st	X, r25
   12c28:	8e 93       	st	-X, r24
   12c2a:	ce 18       	sub	r12, r14
   12c2c:	df 08       	sbc	r13, r15
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
   12c2e:	c1 14       	cp	r12, r1
   12c30:	d1 04       	cpc	r13, r1
   12c32:	09 f0       	breq	.+2      	; 0x12c36 <f_write+0x392>
   12c34:	87 ce       	rjmp	.-754    	; 0x12944 <f_write+0xa0>
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   12c36:	ef 81       	ldd	r30, Y+7	; 0x07
   12c38:	f8 85       	ldd	r31, Y+8	; 0x08
   12c3a:	86 81       	ldd	r24, Z+6	; 0x06
   12c3c:	97 81       	ldd	r25, Z+7	; 0x07
   12c3e:	a0 85       	ldd	r26, Z+8	; 0x08
   12c40:	b1 85       	ldd	r27, Z+9	; 0x09
   12c42:	22 85       	ldd	r18, Z+10	; 0x0a
   12c44:	33 85       	ldd	r19, Z+11	; 0x0b
   12c46:	44 85       	ldd	r20, Z+12	; 0x0c
   12c48:	55 85       	ldd	r21, Z+13	; 0x0d
   12c4a:	28 17       	cp	r18, r24
   12c4c:	39 07       	cpc	r19, r25
   12c4e:	4a 07       	cpc	r20, r26
   12c50:	5b 07       	cpc	r21, r27
   12c52:	20 f4       	brcc	.+8      	; 0x12c5c <f_write+0x3b8>
   12c54:	82 87       	std	Z+10, r24	; 0x0a
   12c56:	93 87       	std	Z+11, r25	; 0x0b
   12c58:	a4 87       	std	Z+12, r26	; 0x0c
   12c5a:	b5 87       	std	Z+13, r27	; 0x0d
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
   12c5c:	af 81       	ldd	r26, Y+7	; 0x07
   12c5e:	b8 85       	ldd	r27, Y+8	; 0x08
   12c60:	14 96       	adiw	r26, 0x04	; 4
   12c62:	8c 91       	ld	r24, X
   12c64:	14 97       	sbiw	r26, 0x04	; 4
   12c66:	80 62       	ori	r24, 0x20	; 32
   12c68:	14 96       	adiw	r26, 0x04	; 4
   12c6a:	8c 93       	st	X, r24
   12c6c:	14 97       	sbiw	r26, 0x04	; 4

	LEAVE_FF(fp->fs, FR_OK);
   12c6e:	01 c0       	rjmp	.+2      	; 0x12c72 <f_write+0x3ce>
	res = validate(fp);						/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)				/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
   12c70:	17 e0       	ldi	r17, 0x07	; 7

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
   12c72:	81 2f       	mov	r24, r17
   12c74:	28 96       	adiw	r28, 0x08	; 8
   12c76:	0f b6       	in	r0, 0x3f	; 63
   12c78:	f8 94       	cli
   12c7a:	de bf       	out	0x3e, r29	; 62
   12c7c:	0f be       	out	0x3f, r0	; 63
   12c7e:	cd bf       	out	0x3d, r28	; 61
   12c80:	cf 91       	pop	r28
   12c82:	df 91       	pop	r29
   12c84:	1f 91       	pop	r17
   12c86:	0f 91       	pop	r16
   12c88:	ff 90       	pop	r15
   12c8a:	ef 90       	pop	r14
   12c8c:	df 90       	pop	r13
   12c8e:	cf 90       	pop	r12
   12c90:	bf 90       	pop	r11
   12c92:	af 90       	pop	r10
   12c94:	9f 90       	pop	r9
   12c96:	8f 90       	pop	r8
   12c98:	7f 90       	pop	r7
   12c9a:	6f 90       	pop	r6
   12c9c:	5f 90       	pop	r5
   12c9e:	4f 90       	pop	r4
   12ca0:	3f 90       	pop	r3
   12ca2:	2f 90       	pop	r2
   12ca4:	08 95       	ret

00012ca6 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
   12ca6:	0f 93       	push	r16
   12ca8:	1f 93       	push	r17
   12caa:	cf 93       	push	r28
   12cac:	df 93       	push	r29
   12cae:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
   12cb0:	0e 94 24 89 	call	0x11248	; 0x11248 <validate>
	if (res == FR_OK) {
   12cb4:	88 23       	and	r24, r24
   12cb6:	09 f0       	breq	.+2      	; 0x12cba <f_sync+0x14>
   12cb8:	4c c0       	rjmp	.+152    	; 0x12d52 <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
   12cba:	9c 81       	ldd	r25, Y+4	; 0x04
   12cbc:	95 ff       	sbrs	r25, 5
   12cbe:	49 c0       	rjmp	.+146    	; 0x12d52 <f_sync+0xac>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
   12cc0:	96 ff       	sbrs	r25, 6
   12cc2:	12 c0       	rjmp	.+36     	; 0x12ce8 <f_sync+0x42>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   12cc4:	e8 81       	ld	r30, Y
   12cc6:	f9 81       	ldd	r31, Y+1	; 0x01
   12cc8:	be 01       	movw	r22, r28
   12cca:	60 5e       	subi	r22, 0xE0	; 224
   12ccc:	7f 4f       	sbci	r23, 0xFF	; 255
   12cce:	2e 89       	ldd	r18, Y+22	; 0x16
   12cd0:	3f 89       	ldd	r19, Y+23	; 0x17
   12cd2:	48 8d       	ldd	r20, Y+24	; 0x18
   12cd4:	59 8d       	ldd	r21, Y+25	; 0x19
   12cd6:	81 81       	ldd	r24, Z+1	; 0x01
   12cd8:	01 e0       	ldi	r16, 0x01	; 1
   12cda:	0e 94 7e 88 	call	0x110fc	; 0x110fc <disk_write>
   12cde:	88 23       	and	r24, r24
   12ce0:	b9 f5       	brne	.+110    	; 0x12d50 <f_sync+0xaa>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
   12ce2:	8c 81       	ldd	r24, Y+4	; 0x04
   12ce4:	8f 7b       	andi	r24, 0xBF	; 191
   12ce6:	8c 83       	std	Y+4, r24	; 0x04
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
   12ce8:	4a 8d       	ldd	r20, Y+26	; 0x1a
   12cea:	5b 8d       	ldd	r21, Y+27	; 0x1b
   12cec:	6c 8d       	ldd	r22, Y+28	; 0x1c
   12cee:	7d 8d       	ldd	r23, Y+29	; 0x1d
   12cf0:	88 81       	ld	r24, Y
   12cf2:	99 81       	ldd	r25, Y+1	; 0x01
   12cf4:	0e 94 01 8c 	call	0x11802	; 0x11802 <move_window>
			if (res == FR_OK) {
   12cf8:	88 23       	and	r24, r24
   12cfa:	59 f5       	brne	.+86     	; 0x12d52 <f_sync+0xac>
				dir = fp->dir_ptr;
   12cfc:	0e 8d       	ldd	r16, Y+30	; 0x1e
   12cfe:	1f 8d       	ldd	r17, Y+31	; 0x1f
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   12d00:	f8 01       	movw	r30, r16
   12d02:	83 85       	ldd	r24, Z+11	; 0x0b
   12d04:	80 62       	ori	r24, 0x20	; 32
   12d06:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
   12d08:	8a 85       	ldd	r24, Y+10	; 0x0a
   12d0a:	9b 85       	ldd	r25, Y+11	; 0x0b
   12d0c:	ac 85       	ldd	r26, Y+12	; 0x0c
   12d0e:	bd 85       	ldd	r27, Y+13	; 0x0d
   12d10:	84 8f       	std	Z+28, r24	; 0x1c
   12d12:	95 8f       	std	Z+29, r25	; 0x1d
   12d14:	a6 8f       	std	Z+30, r26	; 0x1e
   12d16:	b7 8f       	std	Z+31, r27	; 0x1f
				st_clust(dir, fp->sclust);					/* Update start cluster */
   12d18:	4e 85       	ldd	r20, Y+14	; 0x0e
   12d1a:	5f 85       	ldd	r21, Y+15	; 0x0f
   12d1c:	68 89       	ldd	r22, Y+16	; 0x10
   12d1e:	79 89       	ldd	r23, Y+17	; 0x11
   12d20:	c8 01       	movw	r24, r16
   12d22:	0e 94 1e 89 	call	0x1123c	; 0x1123c <st_clust>
				tim = get_fattime();						/* Update updated time */
   12d26:	0e 94 8f 88 	call	0x1111e	; 0x1111e <get_fattime>
				ST_DWORD(dir+DIR_WrtTime, tim);
   12d2a:	f8 01       	movw	r30, r16
   12d2c:	66 8b       	std	Z+22, r22	; 0x16
   12d2e:	77 8b       	std	Z+23, r23	; 0x17
   12d30:	80 8f       	std	Z+24, r24	; 0x18
   12d32:	91 8f       	std	Z+25, r25	; 0x19
				ST_WORD(dir+DIR_LstAccDate, 0);
   12d34:	13 8a       	std	Z+19, r1	; 0x13
   12d36:	12 8a       	std	Z+18, r1	; 0x12
				fp->flag &= ~FA__WRITTEN;
   12d38:	8c 81       	ldd	r24, Y+4	; 0x04
   12d3a:	8f 7d       	andi	r24, 0xDF	; 223
   12d3c:	8c 83       	std	Y+4, r24	; 0x04
				fp->fs->wflag = 1;
   12d3e:	e8 81       	ld	r30, Y
   12d40:	f9 81       	ldd	r31, Y+1	; 0x01
   12d42:	81 e0       	ldi	r24, 0x01	; 1
   12d44:	84 83       	std	Z+4, r24	; 0x04
				res = sync(fp->fs);
   12d46:	88 81       	ld	r24, Y
   12d48:	99 81       	ldd	r25, Y+1	; 0x01
   12d4a:	0e 94 77 8c 	call	0x118ee	; 0x118ee <sync>
   12d4e:	01 c0       	rjmp	.+2      	; 0x12d52 <f_sync+0xac>
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
   12d50:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
   12d52:	df 91       	pop	r29
   12d54:	cf 91       	pop	r28
   12d56:	1f 91       	pop	r17
   12d58:	0f 91       	pop	r16
   12d5a:	08 95       	ret

00012d5c <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
   12d5c:	cf 93       	push	r28
   12d5e:	df 93       	push	r29
   12d60:	ec 01       	movw	r28, r24
#endif
		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
		LEAVE_FF(fs, res);
	}
#else
	res = f_sync(fp);		/* Flush cached data */
   12d62:	a1 df       	rcall	.-190    	; 0x12ca6 <f_sync>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   12d64:	88 23       	and	r24, r24
   12d66:	11 f4       	brne	.+4      	; 0x12d6c <f_close+0x10>
   12d68:	19 82       	std	Y+1, r1	; 0x01
   12d6a:	18 82       	st	Y, r1
	return res;
#endif
}
   12d6c:	df 91       	pop	r29
   12d6e:	cf 91       	pop	r28
   12d70:	08 95       	ret

00012d72 <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
   12d72:	2f 92       	push	r2
   12d74:	3f 92       	push	r3
   12d76:	4f 92       	push	r4
   12d78:	5f 92       	push	r5
   12d7a:	6f 92       	push	r6
   12d7c:	7f 92       	push	r7
   12d7e:	8f 92       	push	r8
   12d80:	9f 92       	push	r9
   12d82:	af 92       	push	r10
   12d84:	bf 92       	push	r11
   12d86:	cf 92       	push	r12
   12d88:	df 92       	push	r13
   12d8a:	ef 92       	push	r14
   12d8c:	ff 92       	push	r15
   12d8e:	0f 93       	push	r16
   12d90:	1f 93       	push	r17
   12d92:	df 93       	push	r29
   12d94:	cf 93       	push	r28
   12d96:	00 d0       	rcall	.+0      	; 0x12d98 <f_lseek+0x26>
   12d98:	00 d0       	rcall	.+0      	; 0x12d9a <f_lseek+0x28>
   12d9a:	00 d0       	rcall	.+0      	; 0x12d9c <f_lseek+0x2a>
   12d9c:	cd b7       	in	r28, 0x3d	; 61
   12d9e:	de b7       	in	r29, 0x3e	; 62
   12da0:	9e 83       	std	Y+6, r25	; 0x06
   12da2:	8d 83       	std	Y+5, r24	; 0x05
   12da4:	6a 01       	movw	r12, r20
   12da6:	7b 01       	movw	r14, r22
	FRESULT res;


	res = validate(fp);					/* Check validity of the object */
   12da8:	0e 94 24 89 	call	0x11248	; 0x11248 <validate>
   12dac:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   12dae:	88 23       	and	r24, r24
   12db0:	09 f0       	breq	.+2      	; 0x12db4 <f_lseek+0x42>
   12db2:	bf c1       	rjmp	.+894    	; 0x13132 <f_lseek+0x3c0>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
   12db4:	ad 81       	ldd	r26, Y+5	; 0x05
   12db6:	be 81       	ldd	r27, Y+6	; 0x06
   12db8:	14 96       	adiw	r26, 0x04	; 4
   12dba:	2c 91       	ld	r18, X
   12dbc:	14 97       	sbiw	r26, 0x04	; 4
   12dbe:	27 fd       	sbrc	r18, 7
   12dc0:	b7 c1       	rjmp	.+878    	; 0x13130 <f_lseek+0x3be>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
   12dc2:	1a 96       	adiw	r26, 0x0a	; 10
   12dc4:	8d 91       	ld	r24, X+
   12dc6:	9d 91       	ld	r25, X+
   12dc8:	0d 90       	ld	r0, X+
   12dca:	bc 91       	ld	r27, X
   12dcc:	a0 2d       	mov	r26, r0
   12dce:	8c 15       	cp	r24, r12
   12dd0:	9d 05       	cpc	r25, r13
   12dd2:	ae 05       	cpc	r26, r14
   12dd4:	bf 05       	cpc	r27, r15
   12dd6:	20 f4       	brcc	.+8      	; 0x12de0 <f_lseek+0x6e>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
   12dd8:	21 fd       	sbrc	r18, 1
   12dda:	02 c0       	rjmp	.+4      	; 0x12de0 <f_lseek+0x6e>
   12ddc:	6c 01       	movw	r12, r24
   12dde:	7d 01       	movw	r14, r26
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
   12de0:	ed 81       	ldd	r30, Y+5	; 0x05
   12de2:	fe 81       	ldd	r31, Y+6	; 0x06
   12de4:	86 81       	ldd	r24, Z+6	; 0x06
   12de6:	97 81       	ldd	r25, Z+7	; 0x07
   12de8:	a0 85       	ldd	r26, Z+8	; 0x08
   12dea:	b1 85       	ldd	r27, Z+9	; 0x09
		fp->fptr = nsect = 0;
   12dec:	16 82       	std	Z+6, r1	; 0x06
   12dee:	17 82       	std	Z+7, r1	; 0x07
   12df0:	10 86       	std	Z+8, r1	; 0x08
   12df2:	11 86       	std	Z+9, r1	; 0x09
		if (ofs) {
   12df4:	c1 14       	cp	r12, r1
   12df6:	d1 04       	cpc	r13, r1
   12df8:	e1 04       	cpc	r14, r1
   12dfa:	f1 04       	cpc	r15, r1
   12dfc:	09 f4       	brne	.+2      	; 0x12e00 <f_lseek+0x8e>
   12dfe:	2a c1       	rjmp	.+596    	; 0x13054 <f_lseek+0x2e2>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
   12e00:	20 80       	ld	r2, Z
   12e02:	31 80       	ldd	r3, Z+1	; 0x01
   12e04:	f1 01       	movw	r30, r2
   12e06:	82 80       	ldd	r8, Z+2	; 0x02
   12e08:	99 24       	eor	r9, r9
   12e0a:	aa 24       	eor	r10, r10
   12e0c:	bb 24       	eor	r11, r11
   12e0e:	09 e0       	ldi	r16, 0x09	; 9
   12e10:	88 0c       	add	r8, r8
   12e12:	99 1c       	adc	r9, r9
   12e14:	aa 1c       	adc	r10, r10
   12e16:	bb 1c       	adc	r11, r11
   12e18:	0a 95       	dec	r16
   12e1a:	d1 f7       	brne	.-12     	; 0x12e10 <f_lseek+0x9e>
			if (ifptr > 0 &&
   12e1c:	00 97       	sbiw	r24, 0x00	; 0
   12e1e:	a1 05       	cpc	r26, r1
   12e20:	b1 05       	cpc	r27, r1
   12e22:	f1 f1       	breq	.+124    	; 0x12ea0 <f_lseek+0x12e>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   12e24:	2c 01       	movw	r4, r24
   12e26:	3d 01       	movw	r6, r26
   12e28:	08 94       	sec
   12e2a:	41 08       	sbc	r4, r1
   12e2c:	51 08       	sbc	r5, r1
   12e2e:	61 08       	sbc	r6, r1
   12e30:	71 08       	sbc	r7, r1
   12e32:	c7 01       	movw	r24, r14
   12e34:	b6 01       	movw	r22, r12
   12e36:	61 50       	subi	r22, 0x01	; 1
   12e38:	70 40       	sbci	r23, 0x00	; 0
   12e3a:	80 40       	sbci	r24, 0x00	; 0
   12e3c:	90 40       	sbci	r25, 0x00	; 0
   12e3e:	a5 01       	movw	r20, r10
   12e40:	94 01       	movw	r18, r8
   12e42:	0e 94 c8 ac 	call	0x15990	; 0x15990 <__udivmodsi4>
   12e46:	29 83       	std	Y+1, r18	; 0x01
   12e48:	3a 83       	std	Y+2, r19	; 0x02
   12e4a:	4b 83       	std	Y+3, r20	; 0x03
   12e4c:	5c 83       	std	Y+4, r21	; 0x04
   12e4e:	c3 01       	movw	r24, r6
   12e50:	b2 01       	movw	r22, r4
   12e52:	a5 01       	movw	r20, r10
   12e54:	94 01       	movw	r18, r8
   12e56:	0e 94 c8 ac 	call	0x15990	; 0x15990 <__udivmodsi4>

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
   12e5a:	89 81       	ldd	r24, Y+1	; 0x01
   12e5c:	9a 81       	ldd	r25, Y+2	; 0x02
   12e5e:	ab 81       	ldd	r26, Y+3	; 0x03
   12e60:	bc 81       	ldd	r27, Y+4	; 0x04
   12e62:	82 17       	cp	r24, r18
   12e64:	93 07       	cpc	r25, r19
   12e66:	a4 07       	cpc	r26, r20
   12e68:	b5 07       	cpc	r27, r21
   12e6a:	d0 f0       	brcs	.+52     	; 0x12ea0 <f_lseek+0x12e>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   12e6c:	88 27       	eor	r24, r24
   12e6e:	99 27       	eor	r25, r25
   12e70:	dc 01       	movw	r26, r24
   12e72:	88 19       	sub	r24, r8
   12e74:	99 09       	sbc	r25, r9
   12e76:	aa 09       	sbc	r26, r10
   12e78:	bb 09       	sbc	r27, r11
   12e7a:	84 21       	and	r24, r4
   12e7c:	95 21       	and	r25, r5
   12e7e:	a6 21       	and	r26, r6
   12e80:	b7 21       	and	r27, r7
   12e82:	ed 81       	ldd	r30, Y+5	; 0x05
   12e84:	fe 81       	ldd	r31, Y+6	; 0x06
   12e86:	86 83       	std	Z+6, r24	; 0x06
   12e88:	97 83       	std	Z+7, r25	; 0x07
   12e8a:	a0 87       	std	Z+8, r26	; 0x08
   12e8c:	b1 87       	std	Z+9, r27	; 0x09
				ofs -= fp->fptr;
   12e8e:	c8 1a       	sub	r12, r24
   12e90:	d9 0a       	sbc	r13, r25
   12e92:	ea 0a       	sbc	r14, r26
   12e94:	fb 0a       	sbc	r15, r27
				clst = fp->clust;
   12e96:	42 89       	ldd	r20, Z+18	; 0x12
   12e98:	53 89       	ldd	r21, Z+19	; 0x13
   12e9a:	64 89       	ldd	r22, Z+20	; 0x14
   12e9c:	75 89       	ldd	r23, Z+21	; 0x15
   12e9e:	35 c0       	rjmp	.+106    	; 0x12f0a <f_lseek+0x198>
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
   12ea0:	ad 81       	ldd	r26, Y+5	; 0x05
   12ea2:	be 81       	ldd	r27, Y+6	; 0x06
   12ea4:	1e 96       	adiw	r26, 0x0e	; 14
   12ea6:	4d 91       	ld	r20, X+
   12ea8:	5d 91       	ld	r21, X+
   12eaa:	6d 91       	ld	r22, X+
   12eac:	7c 91       	ld	r23, X
   12eae:	51 97       	sbiw	r26, 0x11	; 17
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
   12eb0:	41 15       	cp	r20, r1
   12eb2:	51 05       	cpc	r21, r1
   12eb4:	61 05       	cpc	r22, r1
   12eb6:	71 05       	cpc	r23, r1
   12eb8:	01 f5       	brne	.+64     	; 0x12efa <f_lseek+0x188>
					clst = create_chain(fp->fs, 0);
   12eba:	c1 01       	movw	r24, r2
   12ebc:	40 e0       	ldi	r20, 0x00	; 0
   12ebe:	50 e0       	ldi	r21, 0x00	; 0
   12ec0:	ba 01       	movw	r22, r20
   12ec2:	0f d8       	rcall	.-4066   	; 0x11ee2 <create_chain>
   12ec4:	ab 01       	movw	r20, r22
   12ec6:	bc 01       	movw	r22, r24
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   12ec8:	41 30       	cpi	r20, 0x01	; 1
   12eca:	51 05       	cpc	r21, r1
   12ecc:	61 05       	cpc	r22, r1
   12ece:	71 05       	cpc	r23, r1
   12ed0:	19 f4       	brne	.+6      	; 0x12ed8 <f_lseek+0x166>
   12ed2:	ed 81       	ldd	r30, Y+5	; 0x05
   12ed4:	fe 81       	ldd	r31, Y+6	; 0x06
   12ed6:	5d c0       	rjmp	.+186    	; 0x12f92 <f_lseek+0x220>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   12ed8:	4f 3f       	cpi	r20, 0xFF	; 255
   12eda:	ff ef       	ldi	r31, 0xFF	; 255
   12edc:	5f 07       	cpc	r21, r31
   12ede:	ff ef       	ldi	r31, 0xFF	; 255
   12ee0:	6f 07       	cpc	r22, r31
   12ee2:	ff ef       	ldi	r31, 0xFF	; 255
   12ee4:	7f 07       	cpc	r23, r31
   12ee6:	19 f4       	brne	.+6      	; 0x12eee <f_lseek+0x17c>
   12ee8:	ad 81       	ldd	r26, Y+5	; 0x05
   12eea:	be 81       	ldd	r27, Y+6	; 0x06
   12eec:	36 c0       	rjmp	.+108    	; 0x12f5a <f_lseek+0x1e8>
					fp->sclust = clst;
   12eee:	ed 81       	ldd	r30, Y+5	; 0x05
   12ef0:	fe 81       	ldd	r31, Y+6	; 0x06
   12ef2:	46 87       	std	Z+14, r20	; 0x0e
   12ef4:	57 87       	std	Z+15, r21	; 0x0f
   12ef6:	60 8b       	std	Z+16, r22	; 0x10
   12ef8:	71 8b       	std	Z+17, r23	; 0x11
				}
#endif
				fp->clust = clst;
   12efa:	ad 81       	ldd	r26, Y+5	; 0x05
   12efc:	be 81       	ldd	r27, Y+6	; 0x06
   12efe:	52 96       	adiw	r26, 0x12	; 18
   12f00:	4d 93       	st	X+, r20
   12f02:	5d 93       	st	X+, r21
   12f04:	6d 93       	st	X+, r22
   12f06:	7c 93       	st	X, r23
   12f08:	55 97       	sbiw	r26, 0x15	; 21
			}
			if (clst != 0) {
   12f0a:	41 15       	cp	r20, r1
   12f0c:	51 05       	cpc	r21, r1
   12f0e:	61 05       	cpc	r22, r1
   12f10:	71 05       	cpc	r23, r1
   12f12:	09 f4       	brne	.+2      	; 0x12f16 <f_lseek+0x1a4>
   12f14:	9f c0       	rjmp	.+318    	; 0x13054 <f_lseek+0x2e2>
   12f16:	4d 80       	ldd	r4, Y+5	; 0x05
   12f18:	5e 80       	ldd	r5, Y+6	; 0x06
   12f1a:	59 c0       	rjmp	.+178    	; 0x12fce <f_lseek+0x25c>
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   12f1c:	f2 01       	movw	r30, r4
   12f1e:	24 81       	ldd	r18, Z+4	; 0x04
   12f20:	80 81       	ld	r24, Z
   12f22:	91 81       	ldd	r25, Z+1	; 0x01
   12f24:	21 ff       	sbrs	r18, 1
   12f26:	0a c0       	rjmp	.+20     	; 0x12f3c <f_lseek+0x1ca>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
   12f28:	0e 94 71 8f 	call	0x11ee2	; 0x11ee2 <create_chain>
   12f2c:	ab 01       	movw	r20, r22
   12f2e:	bc 01       	movw	r22, r24
						if (clst == 0) {				/* When disk gets full, clip file size */
   12f30:	41 15       	cp	r20, r1
   12f32:	51 05       	cpc	r21, r1
   12f34:	61 05       	cpc	r22, r1
   12f36:	71 05       	cpc	r23, r1
   12f38:	29 f4       	brne	.+10     	; 0x12f44 <f_lseek+0x1d2>
   12f3a:	52 c0       	rjmp	.+164    	; 0x12fe0 <f_lseek+0x26e>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
   12f3c:	0e 94 25 8d 	call	0x11a4a	; 0x11a4a <get_fat>
   12f40:	ab 01       	movw	r20, r22
   12f42:	bc 01       	movw	r22, r24
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   12f44:	4f 3f       	cpi	r20, 0xFF	; 255
   12f46:	ff ef       	ldi	r31, 0xFF	; 255
   12f48:	5f 07       	cpc	r21, r31
   12f4a:	ff ef       	ldi	r31, 0xFF	; 255
   12f4c:	6f 07       	cpc	r22, r31
   12f4e:	ff ef       	ldi	r31, 0xFF	; 255
   12f50:	7f 07       	cpc	r23, r31
   12f52:	59 f4       	brne	.+22     	; 0x12f6a <f_lseek+0x1f8>
   12f54:	5e 82       	std	Y+6, r5	; 0x06
   12f56:	4d 82       	std	Y+5, r4	; 0x05
   12f58:	d2 01       	movw	r26, r4
   12f5a:	14 96       	adiw	r26, 0x04	; 4
   12f5c:	8c 91       	ld	r24, X
   12f5e:	14 97       	sbiw	r26, 0x04	; 4
   12f60:	80 68       	ori	r24, 0x80	; 128
   12f62:	14 96       	adiw	r26, 0x04	; 4
   12f64:	8c 93       	st	X, r24
   12f66:	14 97       	sbiw	r26, 0x04	; 4
   12f68:	c2 c0       	rjmp	.+388    	; 0x130ee <f_lseek+0x37c>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
   12f6a:	42 30       	cpi	r20, 0x02	; 2
   12f6c:	51 05       	cpc	r21, r1
   12f6e:	61 05       	cpc	r22, r1
   12f70:	71 05       	cpc	r23, r1
   12f72:	60 f0       	brcs	.+24     	; 0x12f8c <f_lseek+0x21a>
   12f74:	d2 01       	movw	r26, r4
   12f76:	ed 91       	ld	r30, X+
   12f78:	fc 91       	ld	r31, X
   12f7a:	86 89       	ldd	r24, Z+22	; 0x16
   12f7c:	97 89       	ldd	r25, Z+23	; 0x17
   12f7e:	a0 8d       	ldd	r26, Z+24	; 0x18
   12f80:	b1 8d       	ldd	r27, Z+25	; 0x19
   12f82:	48 17       	cp	r20, r24
   12f84:	59 07       	cpc	r21, r25
   12f86:	6a 07       	cpc	r22, r26
   12f88:	7b 07       	cpc	r23, r27
   12f8a:	38 f0       	brcs	.+14     	; 0x12f9a <f_lseek+0x228>
   12f8c:	5e 82       	std	Y+6, r5	; 0x06
   12f8e:	4d 82       	std	Y+5, r4	; 0x05
   12f90:	f2 01       	movw	r30, r4
   12f92:	84 81       	ldd	r24, Z+4	; 0x04
   12f94:	80 68       	ori	r24, 0x80	; 128
   12f96:	84 83       	std	Z+4, r24	; 0x04
   12f98:	cb c0       	rjmp	.+406    	; 0x13130 <f_lseek+0x3be>
					fp->clust = clst;
   12f9a:	d2 01       	movw	r26, r4
   12f9c:	52 96       	adiw	r26, 0x12	; 18
   12f9e:	4d 93       	st	X+, r20
   12fa0:	5d 93       	st	X+, r21
   12fa2:	6d 93       	st	X+, r22
   12fa4:	7c 93       	st	X, r23
   12fa6:	55 97       	sbiw	r26, 0x15	; 21
					fp->fptr += bcs;
   12fa8:	16 96       	adiw	r26, 0x06	; 6
   12faa:	8d 91       	ld	r24, X+
   12fac:	9d 91       	ld	r25, X+
   12fae:	0d 90       	ld	r0, X+
   12fb0:	bc 91       	ld	r27, X
   12fb2:	a0 2d       	mov	r26, r0
   12fb4:	88 0d       	add	r24, r8
   12fb6:	99 1d       	adc	r25, r9
   12fb8:	aa 1d       	adc	r26, r10
   12fba:	bb 1d       	adc	r27, r11
   12fbc:	f2 01       	movw	r30, r4
   12fbe:	86 83       	std	Z+6, r24	; 0x06
   12fc0:	97 83       	std	Z+7, r25	; 0x07
   12fc2:	a0 87       	std	Z+8, r26	; 0x08
   12fc4:	b1 87       	std	Z+9, r27	; 0x09
					ofs -= bcs;
   12fc6:	c8 18       	sub	r12, r8
   12fc8:	d9 08       	sbc	r13, r9
   12fca:	ea 08       	sbc	r14, r10
   12fcc:	fb 08       	sbc	r15, r11
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
   12fce:	8c 14       	cp	r8, r12
   12fd0:	9d 04       	cpc	r9, r13
   12fd2:	ae 04       	cpc	r10, r14
   12fd4:	bf 04       	cpc	r11, r15
   12fd6:	08 f4       	brcc	.+2      	; 0x12fda <f_lseek+0x268>
   12fd8:	a1 cf       	rjmp	.-190    	; 0x12f1c <f_lseek+0x1aa>
   12fda:	5e 82       	std	Y+6, r5	; 0x06
   12fdc:	4d 82       	std	Y+5, r4	; 0x05
   12fde:	04 c0       	rjmp	.+8      	; 0x12fe8 <f_lseek+0x276>
   12fe0:	5e 82       	std	Y+6, r5	; 0x06
   12fe2:	4d 82       	std	Y+5, r4	; 0x05
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
						if (clst == 0) {				/* When disk gets full, clip file size */
   12fe4:	75 01       	movw	r14, r10
   12fe6:	64 01       	movw	r12, r8
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
   12fe8:	ed 81       	ldd	r30, Y+5	; 0x05
   12fea:	fe 81       	ldd	r31, Y+6	; 0x06
   12fec:	86 81       	ldd	r24, Z+6	; 0x06
   12fee:	97 81       	ldd	r25, Z+7	; 0x07
   12ff0:	a0 85       	ldd	r26, Z+8	; 0x08
   12ff2:	b1 85       	ldd	r27, Z+9	; 0x09
   12ff4:	8c 0d       	add	r24, r12
   12ff6:	9d 1d       	adc	r25, r13
   12ff8:	ae 1d       	adc	r26, r14
   12ffa:	bf 1d       	adc	r27, r15
   12ffc:	86 83       	std	Z+6, r24	; 0x06
   12ffe:	97 83       	std	Z+7, r25	; 0x07
   13000:	a0 87       	std	Z+8, r26	; 0x08
   13002:	b1 87       	std	Z+9, r27	; 0x09
				if (ofs % SS(fp->fs)) {
   13004:	d7 01       	movw	r26, r14
   13006:	c6 01       	movw	r24, r12
   13008:	91 70       	andi	r25, 0x01	; 1
   1300a:	a0 70       	andi	r26, 0x00	; 0
   1300c:	b0 70       	andi	r27, 0x00	; 0
   1300e:	00 97       	sbiw	r24, 0x00	; 0
   13010:	a1 05       	cpc	r26, r1
   13012:	b1 05       	cpc	r27, r1
   13014:	f9 f0       	breq	.+62     	; 0x13054 <f_lseek+0x2e2>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
   13016:	80 81       	ld	r24, Z
   13018:	91 81       	ldd	r25, Z+1	; 0x01
   1301a:	0e 94 f6 8c 	call	0x119ec	; 0x119ec <clust2sect>
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   1301e:	61 15       	cp	r22, r1
   13020:	71 05       	cpc	r23, r1
   13022:	81 05       	cpc	r24, r1
   13024:	91 05       	cpc	r25, r1
   13026:	51 f4       	brne	.+20     	; 0x1303c <f_lseek+0x2ca>
   13028:	ad 81       	ldd	r26, Y+5	; 0x05
   1302a:	be 81       	ldd	r27, Y+6	; 0x06
   1302c:	14 96       	adiw	r26, 0x04	; 4
   1302e:	8c 91       	ld	r24, X
   13030:	14 97       	sbiw	r26, 0x04	; 4
   13032:	80 68       	ori	r24, 0x80	; 128
   13034:	14 96       	adiw	r26, 0x04	; 4
   13036:	8c 93       	st	X, r24
   13038:	14 97       	sbiw	r26, 0x04	; 4
   1303a:	7a c0       	rjmp	.+244    	; 0x13130 <f_lseek+0x3be>
					nsect += ofs / SS(fp->fs);
   1303c:	b9 e0       	ldi	r27, 0x09	; 9
   1303e:	f6 94       	lsr	r15
   13040:	e7 94       	ror	r14
   13042:	d7 94       	ror	r13
   13044:	c7 94       	ror	r12
   13046:	ba 95       	dec	r27
   13048:	d1 f7       	brne	.-12     	; 0x1303e <f_lseek+0x2cc>
   1304a:	c6 0e       	add	r12, r22
   1304c:	d7 1e       	adc	r13, r23
   1304e:	e8 1e       	adc	r14, r24
   13050:	f9 1e       	adc	r15, r25
   13052:	03 c0       	rjmp	.+6      	; 0x1305a <f_lseek+0x2e8>
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
   13054:	cc 24       	eor	r12, r12
   13056:	dd 24       	eor	r13, r13
   13058:	76 01       	movw	r14, r12
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
   1305a:	ed 81       	ldd	r30, Y+5	; 0x05
   1305c:	fe 81       	ldd	r31, Y+6	; 0x06
   1305e:	86 81       	ldd	r24, Z+6	; 0x06
   13060:	97 81       	ldd	r25, Z+7	; 0x07
   13062:	a0 85       	ldd	r26, Z+8	; 0x08
   13064:	b1 85       	ldd	r27, Z+9	; 0x09
   13066:	91 70       	andi	r25, 0x01	; 1
   13068:	a0 70       	andi	r26, 0x00	; 0
   1306a:	b0 70       	andi	r27, 0x00	; 0
   1306c:	00 97       	sbiw	r24, 0x00	; 0
   1306e:	a1 05       	cpc	r26, r1
   13070:	b1 05       	cpc	r27, r1
   13072:	09 f4       	brne	.+2      	; 0x13076 <f_lseek+0x304>
   13074:	46 c0       	rjmp	.+140    	; 0x13102 <f_lseek+0x390>
   13076:	26 89       	ldd	r18, Z+22	; 0x16
   13078:	37 89       	ldd	r19, Z+23	; 0x17
   1307a:	40 8d       	ldd	r20, Z+24	; 0x18
   1307c:	51 8d       	ldd	r21, Z+25	; 0x19
   1307e:	c2 16       	cp	r12, r18
   13080:	d3 06       	cpc	r13, r19
   13082:	e4 06       	cpc	r14, r20
   13084:	f5 06       	cpc	r15, r21
   13086:	e9 f1       	breq	.+122    	; 0x13102 <f_lseek+0x390>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
   13088:	84 81       	ldd	r24, Z+4	; 0x04
   1308a:	86 ff       	sbrs	r24, 6
   1308c:	1b c0       	rjmp	.+54     	; 0x130c4 <f_lseek+0x352>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   1308e:	01 90       	ld	r0, Z+
   13090:	f0 81       	ld	r31, Z
   13092:	e0 2d       	mov	r30, r0
   13094:	6d 81       	ldd	r22, Y+5	; 0x05
   13096:	7e 81       	ldd	r23, Y+6	; 0x06
   13098:	60 5e       	subi	r22, 0xE0	; 224
   1309a:	7f 4f       	sbci	r23, 0xFF	; 255
   1309c:	81 81       	ldd	r24, Z+1	; 0x01
   1309e:	01 e0       	ldi	r16, 0x01	; 1
   130a0:	0e 94 7e 88 	call	0x110fc	; 0x110fc <disk_write>
   130a4:	ad 81       	ldd	r26, Y+5	; 0x05
   130a6:	be 81       	ldd	r27, Y+6	; 0x06
   130a8:	14 96       	adiw	r26, 0x04	; 4
   130aa:	9c 91       	ld	r25, X
   130ac:	14 97       	sbiw	r26, 0x04	; 4
   130ae:	88 23       	and	r24, r24
   130b0:	29 f0       	breq	.+10     	; 0x130bc <f_lseek+0x34a>
					ABORT(fp->fs, FR_DISK_ERR);
   130b2:	90 68       	ori	r25, 0x80	; 128
   130b4:	14 96       	adiw	r26, 0x04	; 4
   130b6:	9c 93       	st	X, r25
   130b8:	14 97       	sbiw	r26, 0x04	; 4
   130ba:	19 c0       	rjmp	.+50     	; 0x130ee <f_lseek+0x37c>
				fp->flag &= ~FA__DIRTY;
   130bc:	9f 7b       	andi	r25, 0xBF	; 191
   130be:	ed 81       	ldd	r30, Y+5	; 0x05
   130c0:	fe 81       	ldd	r31, Y+6	; 0x06
   130c2:	94 83       	std	Z+4, r25	; 0x04
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
   130c4:	ad 81       	ldd	r26, Y+5	; 0x05
   130c6:	be 81       	ldd	r27, Y+6	; 0x06
   130c8:	ed 91       	ld	r30, X+
   130ca:	fc 91       	ld	r31, X
   130cc:	11 97       	sbiw	r26, 0x01	; 1
   130ce:	bd 01       	movw	r22, r26
   130d0:	60 5e       	subi	r22, 0xE0	; 224
   130d2:	7f 4f       	sbci	r23, 0xFF	; 255
   130d4:	81 81       	ldd	r24, Z+1	; 0x01
   130d6:	a7 01       	movw	r20, r14
   130d8:	96 01       	movw	r18, r12
   130da:	01 e0       	ldi	r16, 0x01	; 1
   130dc:	0e 94 73 88 	call	0x110e6	; 0x110e6 <disk_read>
   130e0:	88 23       	and	r24, r24
   130e2:	39 f0       	breq	.+14     	; 0x130f2 <f_lseek+0x380>
				ABORT(fp->fs, FR_DISK_ERR);
   130e4:	ed 81       	ldd	r30, Y+5	; 0x05
   130e6:	fe 81       	ldd	r31, Y+6	; 0x06
   130e8:	84 81       	ldd	r24, Z+4	; 0x04
   130ea:	80 68       	ori	r24, 0x80	; 128
   130ec:	84 83       	std	Z+4, r24	; 0x04
   130ee:	11 e0       	ldi	r17, 0x01	; 1
   130f0:	20 c0       	rjmp	.+64     	; 0x13132 <f_lseek+0x3c0>
#endif
			fp->dsect = nsect;
   130f2:	ad 81       	ldd	r26, Y+5	; 0x05
   130f4:	be 81       	ldd	r27, Y+6	; 0x06
   130f6:	56 96       	adiw	r26, 0x16	; 22
   130f8:	cd 92       	st	X+, r12
   130fa:	dd 92       	st	X+, r13
   130fc:	ed 92       	st	X+, r14
   130fe:	fc 92       	st	X, r15
   13100:	59 97       	sbiw	r26, 0x19	; 25
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
   13102:	ed 81       	ldd	r30, Y+5	; 0x05
   13104:	fe 81       	ldd	r31, Y+6	; 0x06
   13106:	86 81       	ldd	r24, Z+6	; 0x06
   13108:	97 81       	ldd	r25, Z+7	; 0x07
   1310a:	a0 85       	ldd	r26, Z+8	; 0x08
   1310c:	b1 85       	ldd	r27, Z+9	; 0x09
   1310e:	22 85       	ldd	r18, Z+10	; 0x0a
   13110:	33 85       	ldd	r19, Z+11	; 0x0b
   13112:	44 85       	ldd	r20, Z+12	; 0x0c
   13114:	55 85       	ldd	r21, Z+13	; 0x0d
   13116:	28 17       	cp	r18, r24
   13118:	39 07       	cpc	r19, r25
   1311a:	4a 07       	cpc	r20, r26
   1311c:	5b 07       	cpc	r21, r27
   1311e:	48 f4       	brcc	.+18     	; 0x13132 <f_lseek+0x3c0>
			fp->fsize = fp->fptr;
   13120:	82 87       	std	Z+10, r24	; 0x0a
   13122:	93 87       	std	Z+11, r25	; 0x0b
   13124:	a4 87       	std	Z+12, r26	; 0x0c
   13126:	b5 87       	std	Z+13, r27	; 0x0d
			fp->flag |= FA__WRITTEN;
   13128:	84 81       	ldd	r24, Z+4	; 0x04
   1312a:	80 62       	ori	r24, 0x20	; 32
   1312c:	84 83       	std	Z+4, r24	; 0x04
   1312e:	01 c0       	rjmp	.+2      	; 0x13132 <f_lseek+0x3c0>


	res = validate(fp);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
   13130:	12 e0       	ldi	r17, 0x02	; 2
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
   13132:	81 2f       	mov	r24, r17
   13134:	26 96       	adiw	r28, 0x06	; 6
   13136:	0f b6       	in	r0, 0x3f	; 63
   13138:	f8 94       	cli
   1313a:	de bf       	out	0x3e, r29	; 62
   1313c:	0f be       	out	0x3f, r0	; 63
   1313e:	cd bf       	out	0x3d, r28	; 61
   13140:	cf 91       	pop	r28
   13142:	df 91       	pop	r29
   13144:	1f 91       	pop	r17
   13146:	0f 91       	pop	r16
   13148:	ff 90       	pop	r15
   1314a:	ef 90       	pop	r14
   1314c:	df 90       	pop	r13
   1314e:	cf 90       	pop	r12
   13150:	bf 90       	pop	r11
   13152:	af 90       	pop	r10
   13154:	9f 90       	pop	r9
   13156:	8f 90       	pop	r8
   13158:	7f 90       	pop	r7
   1315a:	6f 90       	pop	r6
   1315c:	5f 90       	pop	r5
   1315e:	4f 90       	pop	r4
   13160:	3f 90       	pop	r3
   13162:	2f 90       	pop	r2
   13164:	08 95       	ret

00013166 <f_getfree>:
FRESULT f_getfree (
	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
   13166:	2f 92       	push	r2
   13168:	3f 92       	push	r3
   1316a:	4f 92       	push	r4
   1316c:	5f 92       	push	r5
   1316e:	6f 92       	push	r6
   13170:	7f 92       	push	r7
   13172:	8f 92       	push	r8
   13174:	9f 92       	push	r9
   13176:	af 92       	push	r10
   13178:	bf 92       	push	r11
   1317a:	cf 92       	push	r12
   1317c:	df 92       	push	r13
   1317e:	ef 92       	push	r14
   13180:	ff 92       	push	r15
   13182:	0f 93       	push	r16
   13184:	1f 93       	push	r17
   13186:	df 93       	push	r29
   13188:	cf 93       	push	r28
   1318a:	00 d0       	rcall	.+0      	; 0x1318c <f_getfree+0x26>
   1318c:	00 d0       	rcall	.+0      	; 0x1318e <f_getfree+0x28>
   1318e:	00 d0       	rcall	.+0      	; 0x13190 <f_getfree+0x2a>
   13190:	cd b7       	in	r28, 0x3d	; 61
   13192:	de b7       	in	r29, 0x3e	; 62
   13194:	9a 83       	std	Y+2, r25	; 0x02
   13196:	89 83       	std	Y+1, r24	; 0x01
   13198:	7c 83       	std	Y+4, r23	; 0x04
   1319a:	6b 83       	std	Y+3, r22	; 0x03
   1319c:	7a 01       	movw	r14, r20
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
   1319e:	ce 01       	movw	r24, r28
   131a0:	01 96       	adiw	r24, 0x01	; 1
   131a2:	ba 01       	movw	r22, r20
   131a4:	40 e0       	ldi	r20, 0x00	; 0
   131a6:	0e 94 86 89 	call	0x1130c	; 0x1130c <chk_mounted>
   131aa:	38 2e       	mov	r3, r24
	fs = *fatfs;
   131ac:	f7 01       	movw	r30, r14
   131ae:	c0 80       	ld	r12, Z
   131b0:	d1 80       	ldd	r13, Z+1	; 0x01
	if (res == FR_OK) {
   131b2:	88 23       	and	r24, r24
   131b4:	09 f0       	breq	.+2      	; 0x131b8 <f_getfree+0x52>
   131b6:	bd c0       	rjmp	.+378    	; 0x13332 <f_getfree+0x1cc>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
   131b8:	f6 01       	movw	r30, r12
   131ba:	86 85       	ldd	r24, Z+14	; 0x0e
   131bc:	97 85       	ldd	r25, Z+15	; 0x0f
   131be:	a0 89       	ldd	r26, Z+16	; 0x10
   131c0:	b1 89       	ldd	r27, Z+17	; 0x11
   131c2:	46 88       	ldd	r4, Z+22	; 0x16
   131c4:	57 88       	ldd	r5, Z+23	; 0x17
   131c6:	60 8c       	ldd	r6, Z+24	; 0x18
   131c8:	71 8c       	ldd	r7, Z+25	; 0x19
   131ca:	a3 01       	movw	r20, r6
   131cc:	92 01       	movw	r18, r4
   131ce:	22 50       	subi	r18, 0x02	; 2
   131d0:	30 40       	sbci	r19, 0x00	; 0
   131d2:	40 40       	sbci	r20, 0x00	; 0
   131d4:	50 40       	sbci	r21, 0x00	; 0
   131d6:	28 17       	cp	r18, r24
   131d8:	39 07       	cpc	r19, r25
   131da:	4a 07       	cpc	r20, r26
   131dc:	5b 07       	cpc	r21, r27
   131de:	38 f0       	brcs	.+14     	; 0x131ee <f_getfree+0x88>
			*nclst = fs->free_clust;
   131e0:	eb 81       	ldd	r30, Y+3	; 0x03
   131e2:	fc 81       	ldd	r31, Y+4	; 0x04
   131e4:	80 83       	st	Z, r24
   131e6:	91 83       	std	Z+1, r25	; 0x01
   131e8:	a2 83       	std	Z+2, r26	; 0x02
   131ea:	b3 83       	std	Z+3, r27	; 0x03
   131ec:	a2 c0       	rjmp	.+324    	; 0x13332 <f_getfree+0x1cc>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
   131ee:	f6 01       	movw	r30, r12
   131f0:	20 80       	ld	r2, Z
			n = 0;
			if (fat == FS_FAT12) {
   131f2:	f2 2d       	mov	r31, r2
   131f4:	f1 30       	cpi	r31, 0x01	; 1
   131f6:	b1 f5       	brne	.+108    	; 0x13264 <f_getfree+0xfe>
   131f8:	22 e0       	ldi	r18, 0x02	; 2
   131fa:	82 2e       	mov	r8, r18
   131fc:	91 2c       	mov	r9, r1
   131fe:	a1 2c       	mov	r10, r1
   13200:	b1 2c       	mov	r11, r1
   13202:	ee 24       	eor	r14, r14
   13204:	ff 24       	eor	r15, r15
   13206:	87 01       	movw	r16, r14
				clst = 2;
				do {
					stat = get_fat(fs, clst);
   13208:	c6 01       	movw	r24, r12
   1320a:	b5 01       	movw	r22, r10
   1320c:	a4 01       	movw	r20, r8
   1320e:	0e 94 25 8d 	call	0x11a4a	; 0x11a4a <get_fat>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   13212:	6f 3f       	cpi	r22, 0xFF	; 255
   13214:	2f ef       	ldi	r18, 0xFF	; 255
   13216:	72 07       	cpc	r23, r18
   13218:	2f ef       	ldi	r18, 0xFF	; 255
   1321a:	82 07       	cpc	r24, r18
   1321c:	2f ef       	ldi	r18, 0xFF	; 255
   1321e:	92 07       	cpc	r25, r18
   13220:	09 f4       	brne	.+2      	; 0x13224 <f_getfree+0xbe>
   13222:	6f c0       	rjmp	.+222    	; 0x13302 <f_getfree+0x19c>
					if (stat == 1) { res = FR_INT_ERR; break; }
   13224:	61 30       	cpi	r22, 0x01	; 1
   13226:	71 05       	cpc	r23, r1
   13228:	81 05       	cpc	r24, r1
   1322a:	91 05       	cpc	r25, r1
   1322c:	09 f4       	brne	.+2      	; 0x13230 <f_getfree+0xca>
   1322e:	6c c0       	rjmp	.+216    	; 0x13308 <f_getfree+0x1a2>
					if (stat == 0) n++;
   13230:	61 15       	cp	r22, r1
   13232:	71 05       	cpc	r23, r1
   13234:	81 05       	cpc	r24, r1
   13236:	91 05       	cpc	r25, r1
   13238:	29 f4       	brne	.+10     	; 0x13244 <f_getfree+0xde>
   1323a:	08 94       	sec
   1323c:	e1 1c       	adc	r14, r1
   1323e:	f1 1c       	adc	r15, r1
   13240:	01 1d       	adc	r16, r1
   13242:	11 1d       	adc	r17, r1
				} while (++clst < fs->n_fatent);
   13244:	08 94       	sec
   13246:	81 1c       	adc	r8, r1
   13248:	91 1c       	adc	r9, r1
   1324a:	a1 1c       	adc	r10, r1
   1324c:	b1 1c       	adc	r11, r1
   1324e:	f6 01       	movw	r30, r12
   13250:	86 89       	ldd	r24, Z+22	; 0x16
   13252:	97 89       	ldd	r25, Z+23	; 0x17
   13254:	a0 8d       	ldd	r26, Z+24	; 0x18
   13256:	b1 8d       	ldd	r27, Z+25	; 0x19
   13258:	88 16       	cp	r8, r24
   1325a:	99 06       	cpc	r9, r25
   1325c:	aa 06       	cpc	r10, r26
   1325e:	bb 06       	cpc	r11, r27
   13260:	98 f2       	brcs	.-90     	; 0x13208 <f_getfree+0xa2>
   13262:	56 c0       	rjmp	.+172    	; 0x13310 <f_getfree+0x1aa>
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
   13264:	f6 01       	movw	r30, r12
   13266:	86 8c       	ldd	r8, Z+30	; 0x1e
   13268:	97 8c       	ldd	r9, Z+31	; 0x1f
   1326a:	a0 a0       	ldd	r10, Z+32	; 0x20
   1326c:	b1 a0       	ldd	r11, Z+33	; 0x21
				i = 0; p = 0;
   1326e:	e0 e0       	ldi	r30, 0x00	; 0
   13270:	f0 e0       	ldi	r31, 0x00	; 0
   13272:	20 e0       	ldi	r18, 0x00	; 0
   13274:	30 e0       	ldi	r19, 0x00	; 0
		if (fs->free_clust <= fs->n_fatent - 2) {
			*nclst = fs->free_clust;
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
			n = 0;
   13276:	ee 24       	eor	r14, r14
   13278:	ff 24       	eor	r15, r15
   1327a:	87 01       	movw	r16, r14
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
   1327c:	c6 01       	movw	r24, r12
   1327e:	8e 96       	adiw	r24, 0x2e	; 46
   13280:	9e 83       	std	Y+6, r25	; 0x06
   13282:	8d 83       	std	Y+5, r24	; 0x05
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
   13284:	21 15       	cp	r18, r1
   13286:	31 05       	cpc	r19, r1
   13288:	81 f4       	brne	.+32     	; 0x132aa <f_getfree+0x144>
						res = move_window(fs, sect++);
   1328a:	c6 01       	movw	r24, r12
   1328c:	b5 01       	movw	r22, r10
   1328e:	a4 01       	movw	r20, r8
   13290:	0e 94 01 8c 	call	0x11802	; 0x11802 <move_window>
						if (res != FR_OK) break;
   13294:	88 23       	and	r24, r24
   13296:	d9 f5       	brne	.+118    	; 0x1330e <f_getfree+0x1a8>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
   13298:	08 94       	sec
   1329a:	81 1c       	adc	r8, r1
   1329c:	91 1c       	adc	r9, r1
   1329e:	a1 1c       	adc	r10, r1
   132a0:	b1 1c       	adc	r11, r1
						if (res != FR_OK) break;
						p = fs->win;
   132a2:	ed 81       	ldd	r30, Y+5	; 0x05
   132a4:	fe 81       	ldd	r31, Y+6	; 0x06
						i = SS(fs);
   132a6:	20 e0       	ldi	r18, 0x00	; 0
   132a8:	32 e0       	ldi	r19, 0x02	; 2
					}
					if (fat == FS_FAT16) {
   132aa:	92 2d       	mov	r25, r2
   132ac:	92 30       	cpi	r25, 0x02	; 2
   132ae:	69 f4       	brne	.+26     	; 0x132ca <f_getfree+0x164>
						if (LD_WORD(p) == 0) n++;
   132b0:	80 81       	ld	r24, Z
   132b2:	91 81       	ldd	r25, Z+1	; 0x01
   132b4:	00 97       	sbiw	r24, 0x00	; 0
   132b6:	29 f4       	brne	.+10     	; 0x132c2 <f_getfree+0x15c>
   132b8:	08 94       	sec
   132ba:	e1 1c       	adc	r14, r1
   132bc:	f1 1c       	adc	r15, r1
   132be:	01 1d       	adc	r16, r1
   132c0:	11 1d       	adc	r17, r1
						p += 2; i -= 2;
   132c2:	32 96       	adiw	r30, 0x02	; 2
   132c4:	22 50       	subi	r18, 0x02	; 2
   132c6:	30 40       	sbci	r19, 0x00	; 0
   132c8:	11 c0       	rjmp	.+34     	; 0x132ec <f_getfree+0x186>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
   132ca:	80 81       	ld	r24, Z
   132cc:	91 81       	ldd	r25, Z+1	; 0x01
   132ce:	a2 81       	ldd	r26, Z+2	; 0x02
   132d0:	b3 81       	ldd	r27, Z+3	; 0x03
   132d2:	bf 70       	andi	r27, 0x0F	; 15
   132d4:	00 97       	sbiw	r24, 0x00	; 0
   132d6:	a1 05       	cpc	r26, r1
   132d8:	b1 05       	cpc	r27, r1
   132da:	29 f4       	brne	.+10     	; 0x132e6 <f_getfree+0x180>
   132dc:	08 94       	sec
   132de:	e1 1c       	adc	r14, r1
   132e0:	f1 1c       	adc	r15, r1
   132e2:	01 1d       	adc	r16, r1
   132e4:	11 1d       	adc	r17, r1
						p += 4; i -= 4;
   132e6:	34 96       	adiw	r30, 0x04	; 4
   132e8:	24 50       	subi	r18, 0x04	; 4
   132ea:	30 40       	sbci	r19, 0x00	; 0
					}
				} while (--clst);
   132ec:	08 94       	sec
   132ee:	41 08       	sbc	r4, r1
   132f0:	51 08       	sbc	r5, r1
   132f2:	61 08       	sbc	r6, r1
   132f4:	71 08       	sbc	r7, r1
   132f6:	41 14       	cp	r4, r1
   132f8:	51 04       	cpc	r5, r1
   132fa:	61 04       	cpc	r6, r1
   132fc:	71 04       	cpc	r7, r1
   132fe:	11 f6       	brne	.-124    	; 0x13284 <f_getfree+0x11e>
   13300:	07 c0       	rjmp	.+14     	; 0x13310 <f_getfree+0x1aa>
			n = 0;
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(fs, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   13302:	33 24       	eor	r3, r3
   13304:	33 94       	inc	r3
   13306:	04 c0       	rjmp	.+8      	; 0x13310 <f_getfree+0x1aa>
					if (stat == 1) { res = FR_INT_ERR; break; }
   13308:	92 e0       	ldi	r25, 0x02	; 2
   1330a:	39 2e       	mov	r3, r25
   1330c:	01 c0       	rjmp	.+2      	; 0x13310 <f_getfree+0x1aa>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
   1330e:	38 2e       	mov	r3, r24
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
   13310:	f6 01       	movw	r30, r12
   13312:	e6 86       	std	Z+14, r14	; 0x0e
   13314:	f7 86       	std	Z+15, r15	; 0x0f
   13316:	00 8b       	std	Z+16, r16	; 0x10
   13318:	11 8b       	std	Z+17, r17	; 0x11
			if (fat == FS_FAT32) fs->fsi_flag = 1;
   1331a:	f2 2d       	mov	r31, r2
   1331c:	f3 30       	cpi	r31, 0x03	; 3
   1331e:	19 f4       	brne	.+6      	; 0x13326 <f_getfree+0x1c0>
   13320:	81 e0       	ldi	r24, 0x01	; 1
   13322:	f6 01       	movw	r30, r12
   13324:	85 83       	std	Z+5, r24	; 0x05
			*nclst = n;
   13326:	eb 81       	ldd	r30, Y+3	; 0x03
   13328:	fc 81       	ldd	r31, Y+4	; 0x04
   1332a:	e0 82       	st	Z, r14
   1332c:	f1 82       	std	Z+1, r15	; 0x01
   1332e:	02 83       	std	Z+2, r16	; 0x02
   13330:	13 83       	std	Z+3, r17	; 0x03
		}
	}
	LEAVE_FF(fs, res);
}
   13332:	83 2d       	mov	r24, r3
   13334:	26 96       	adiw	r28, 0x06	; 6
   13336:	0f b6       	in	r0, 0x3f	; 63
   13338:	f8 94       	cli
   1333a:	de bf       	out	0x3e, r29	; 62
   1333c:	0f be       	out	0x3f, r0	; 63
   1333e:	cd bf       	out	0x3d, r28	; 61
   13340:	cf 91       	pop	r28
   13342:	df 91       	pop	r29
   13344:	1f 91       	pop	r17
   13346:	0f 91       	pop	r16
   13348:	ff 90       	pop	r15
   1334a:	ef 90       	pop	r14
   1334c:	df 90       	pop	r13
   1334e:	cf 90       	pop	r12
   13350:	bf 90       	pop	r11
   13352:	af 90       	pop	r10
   13354:	9f 90       	pop	r9
   13356:	8f 90       	pop	r8
   13358:	7f 90       	pop	r7
   1335a:	6f 90       	pop	r6
   1335c:	5f 90       	pop	r5
   1335e:	4f 90       	pop	r4
   13360:	3f 90       	pop	r3
   13362:	2f 90       	pop	r2
   13364:	08 95       	ret

00013366 <Spi16>:
   13366:	11 98       	cbi	0x02, 1	; 2
   13368:	bc 01       	movw	r22, r24
   1336a:	20 e0       	ldi	r18, 0x00	; 0
   1336c:	30 e0       	ldi	r19, 0x00	; 0
   1336e:	41 e0       	ldi	r20, 0x01	; 1
   13370:	50 e0       	ldi	r21, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
   13372:	ed e0       	ldi	r30, 0x0D	; 13
   13374:	cb 01       	movw	r24, r22
   13376:	80 70       	andi	r24, 0x00	; 0
   13378:	90 78       	andi	r25, 0x80	; 128
   1337a:	89 2b       	or	r24, r25
   1337c:	11 f4       	brne	.+4      	; 0x13382 <Spi16+0x1c>
   1337e:	10 98       	cbi	0x02, 0	; 2
   13380:	01 c0       	rjmp	.+2      	; 0x13384 <Spi16+0x1e>
   13382:	10 9a       	sbi	0x02, 0	; 2
   13384:	22 0f       	add	r18, r18
   13386:	33 1f       	adc	r19, r19
   13388:	02 9b       	sbis	0x00, 2	; 0
   1338a:	02 c0       	rjmp	.+4      	; 0x13390 <Spi16+0x2a>
   1338c:	2f 5f       	subi	r18, 0xFF	; 255
   1338e:	3f 4f       	sbci	r19, 0xFF	; 255
   13390:	13 9a       	sbi	0x02, 3	; 2
   13392:	8e 2f       	mov	r24, r30
   13394:	8a 95       	dec	r24
   13396:	f1 f7       	brne	.-4      	; 0x13394 <Spi16+0x2e>
   13398:	13 98       	cbi	0x02, 3	; 2
   1339a:	4f 5f       	subi	r20, 0xFF	; 255
   1339c:	5f 4f       	sbci	r21, 0xFF	; 255
   1339e:	41 31       	cpi	r20, 0x11	; 17
   133a0:	51 05       	cpc	r21, r1
   133a2:	19 f0       	breq	.+6      	; 0x133aa <Spi16+0x44>
   133a4:	66 0f       	add	r22, r22
   133a6:	77 1f       	adc	r23, r23
   133a8:	e5 cf       	rjmp	.-54     	; 0x13374 <Spi16+0xe>
   133aa:	11 9a       	sbi	0x02, 1	; 2
   133ac:	c9 01       	movw	r24, r18
   133ae:	08 95       	ret

000133b0 <RFM12_Init>:
   133b0:	81 b1       	in	r24, 0x01	; 1
   133b2:	8b 61       	ori	r24, 0x1B	; 27
   133b4:	81 b9       	out	0x01, r24	; 1
   133b6:	14 9a       	sbi	0x02, 4	; 2
   133b8:	80 e1       	ldi	r24, 0x10	; 16
   133ba:	97 e2       	ldi	r25, 0x27	; 39
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
   133bc:	28 ec       	ldi	r18, 0xC8	; 200
   133be:	30 e0       	ldi	r19, 0x00	; 0
   133c0:	f9 01       	movw	r30, r18
   133c2:	31 97       	sbiw	r30, 0x01	; 1
   133c4:	f1 f7       	brne	.-4      	; 0x133c2 <RFM12_Init+0x12>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   133c6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   133c8:	d9 f7       	brne	.-10     	; 0x133c0 <RFM12_Init+0x10>
   133ca:	11 9a       	sbi	0x02, 1	; 2
   133cc:	13 98       	cbi	0x02, 3	; 2
   133ce:	87 ee       	ldi	r24, 0xE7	; 231
   133d0:	90 e8       	ldi	r25, 0x80	; 128
   133d2:	c9 df       	rcall	.-110    	; 0x13366 <Spi16>
   133d4:	89 ed       	ldi	r24, 0xD9	; 217
   133d6:	92 e8       	ldi	r25, 0x82	; 130
   133d8:	c6 df       	rcall	.-116    	; 0x13366 <Spi16>
   133da:	80 e4       	ldi	r24, 0x40	; 64
   133dc:	96 ea       	ldi	r25, 0xA6	; 166
   133de:	c3 df       	rcall	.-122    	; 0x13366 <Spi16>
   133e0:	87 e4       	ldi	r24, 0x47	; 71
   133e2:	96 ec       	ldi	r25, 0xC6	; 198
   133e4:	c0 df       	rcall	.-128    	; 0x13366 <Spi16>
   133e6:	81 ea       	ldi	r24, 0xA1	; 161
   133e8:	94 e9       	ldi	r25, 0x94	; 148
   133ea:	bd df       	rcall	.-134    	; 0x13366 <Spi16>
   133ec:	89 ea       	ldi	r24, 0xA9	; 169
   133ee:	92 ec       	ldi	r25, 0xC2	; 194
   133f0:	ba df       	rcall	.-140    	; 0x13366 <Spi16>
   133f2:	81 e8       	ldi	r24, 0x81	; 129
   133f4:	9a ec       	ldi	r25, 0xCA	; 202
   133f6:	b7 df       	rcall	.-146    	; 0x13366 <Spi16>
   133f8:	83 e8       	ldi	r24, 0x83	; 131
   133fa:	94 ec       	ldi	r25, 0xC4	; 196
   133fc:	b4 df       	rcall	.-152    	; 0x13366 <Spi16>
   133fe:	80 e5       	ldi	r24, 0x50	; 80
   13400:	98 e9       	ldi	r25, 0x98	; 152
   13402:	b1 df       	rcall	.-158    	; 0x13366 <Spi16>
   13404:	80 e0       	ldi	r24, 0x00	; 0
   13406:	90 ee       	ldi	r25, 0xE0	; 224
   13408:	ae df       	rcall	.-164    	; 0x13366 <Spi16>
   1340a:	80 e0       	ldi	r24, 0x00	; 0
   1340c:	98 ec       	ldi	r25, 0xC8	; 200
   1340e:	ab df       	rcall	.-170    	; 0x13366 <Spi16>
   13410:	80 e0       	ldi	r24, 0x00	; 0
   13412:	90 ec       	ldi	r25, 0xC0	; 192
   13414:	a8 df       	rcall	.-176    	; 0x13366 <Spi16>
   13416:	80 e0       	ldi	r24, 0x00	; 0
   13418:	90 e0       	ldi	r25, 0x00	; 0
   1341a:	a5 cf       	rjmp	.-182    	; 0x13366 <Spi16>

0001341c <Enable_receiver>:
   1341c:	11 98       	cbi	0x02, 1	; 2
   1341e:	88 ec       	ldi	r24, 0xC8	; 200
   13420:	92 e8       	ldi	r25, 0x82	; 130
   13422:	a1 df       	rcall	.-190    	; 0x13366 <Spi16>
   13424:	83 e8       	ldi	r24, 0x83	; 131
   13426:	9a ec       	ldi	r25, 0xCA	; 202
   13428:	9e cf       	rjmp	.-196    	; 0x13366 <Spi16>

0001342a <RestartFifoFill_receiver>:
   1342a:	81 e8       	ldi	r24, 0x81	; 129
   1342c:	9a ec       	ldi	r25, 0xCA	; 202
   1342e:	9b df       	rcall	.-202    	; 0x13366 <Spi16>
   13430:	80 e1       	ldi	r24, 0x10	; 16
   13432:	97 e2       	ldi	r25, 0x27	; 39
   13434:	01 97       	sbiw	r24, 0x01	; 1
   13436:	f1 f7       	brne	.-4      	; 0x13434 <RestartFifoFill_receiver+0xa>
   13438:	83 e8       	ldi	r24, 0x83	; 131
   1343a:	9a ec       	ldi	r25, 0xCA	; 202
   1343c:	94 cf       	rjmp	.-216    	; 0x13366 <Spi16>

0001343e <HYT321_GetData>:

#include "HYT321.h"

void HYT321_GetData(int8_t* const Humidity,
                    int8_t* const Temperature)
{
   1343e:	6f 92       	push	r6
   13440:	7f 92       	push	r7
   13442:	8f 92       	push	r8
   13444:	9f 92       	push	r9
   13446:	af 92       	push	r10
   13448:	bf 92       	push	r11
   1344a:	cf 92       	push	r12
   1344c:	df 92       	push	r13
   1344e:	ef 92       	push	r14
   13450:	ff 92       	push	r15
   13452:	0f 93       	push	r16
   13454:	1f 93       	push	r17
   13456:	df 93       	push	r29
   13458:	cf 93       	push	r28
   1345a:	00 d0       	rcall	.+0      	; 0x1345c <HYT321_GetData+0x1e>
   1345c:	00 d0       	rcall	.+0      	; 0x1345e <HYT321_GetData+0x20>
   1345e:	cd b7       	in	r28, 0x3d	; 61
   13460:	de b7       	in	r29, 0x3e	; 62
   13462:	4c 01       	movw	r8, r24
   13464:	3b 01       	movw	r6, r22
    uint32_t Calc_Humidity = 0;
    int32_t Calc_Temperature = 0;
    HYT321_DataRegs_t CurrentHYTData;
    CurrentHYTData.TemperatureMSB = 0;
   13466:	1c 82       	std	Y+4, r1	; 0x04
    CurrentHYTData.HumidityLSB = 0;
   13468:	1b 82       	std	Y+3, r1	; 0x03

    if (TWI_StartTransmission(HYT321_ADDRESS_WRITE | TWI_ADDRESS_WRITE, 25)== TWI_ERROR_NoError)    // Measurement Request
   1346a:	80 e5       	ldi	r24, 0x50	; 80
   1346c:	69 e1       	ldi	r22, 0x19	; 25
   1346e:	0e 94 7f ab 	call	0x156fe	; 0x156fe <TWI_StartTransmission>
   13472:	88 23       	and	r24, r24
   13474:	19 f4       	brne	.+6      	; 0x1347c <HYT321_GetData+0x3e>

			/** Sends a TWI STOP onto the TWI bus, terminating communication with the currently addressed device. */
			static inline void TWI_StopTransmission(void) ATTR_ALWAYS_INLINE;
			static inline void TWI_StopTransmission(void)
			{
				TWCR = ((1 << TWINT) | (1 << TWSTO) | (1 << TWEN));
   13476:	84 e9       	ldi	r24, 0x94	; 148
   13478:	80 93 bc 00 	sts	0x00BC, r24
    {
        TWI_StopTransmission();
    }

    if (TWI_StartTransmission(HYT321_ADDRESS_READ | TWI_ADDRESS_READ, 25)== TWI_ERROR_NoError)      // Data Fetcb
   1347c:	81 e5       	ldi	r24, 0x51	; 81
   1347e:	69 e1       	ldi	r22, 0x19	; 25
   13480:	0e 94 7f ab 	call	0x156fe	; 0x156fe <TWI_StartTransmission>
   13484:	88 23       	and	r24, r24
   13486:	b9 f4       	brne	.+46     	; 0x134b6 <HYT321_GetData+0x78>
	{

	    TWI_ReceiveByte(&CurrentHYTData.Byte1.IntVal, false);
   13488:	ce 01       	movw	r24, r28
   1348a:	01 96       	adiw	r24, 0x01	; 1
   1348c:	60 e0       	ldi	r22, 0x00	; 0
   1348e:	0e 94 ef ab 	call	0x157de	; 0x157de <TWI_ReceiveByte>
	    TWI_ReceiveByte(&CurrentHYTData.HumidityLSB, false);
   13492:	ce 01       	movw	r24, r28
   13494:	03 96       	adiw	r24, 0x03	; 3
   13496:	60 e0       	ldi	r22, 0x00	; 0
   13498:	0e 94 ef ab 	call	0x157de	; 0x157de <TWI_ReceiveByte>
		TWI_ReceiveByte(&CurrentHYTData.TemperatureMSB, false);
   1349c:	ce 01       	movw	r24, r28
   1349e:	04 96       	adiw	r24, 0x04	; 4
   134a0:	60 e0       	ldi	r22, 0x00	; 0
   134a2:	0e 94 ef ab 	call	0x157de	; 0x157de <TWI_ReceiveByte>
		TWI_ReceiveByte(&CurrentHYTData.Byte2.IntVal, true);
   134a6:	ce 01       	movw	r24, r28
   134a8:	02 96       	adiw	r24, 0x02	; 2
   134aa:	61 e0       	ldi	r22, 0x01	; 1
   134ac:	0e 94 ef ab 	call	0x157de	; 0x157de <TWI_ReceiveByte>
   134b0:	84 e9       	ldi	r24, 0x94	; 148
   134b2:	80 93 bc 00 	sts	0x00BC, r24

		TWI_StopTransmission();
	}

	Calc_Humidity = ((uint32_t) CurrentHYTData.Byte1.Fields.HumidityMSB << 8) + CurrentHYTData.HumidityLSB;
   134b6:	69 81       	ldd	r22, Y+1	; 0x01
   134b8:	6f 73       	andi	r22, 0x3F	; 63
   134ba:	70 e0       	ldi	r23, 0x00	; 0
   134bc:	80 e0       	ldi	r24, 0x00	; 0
   134be:	90 e0       	ldi	r25, 0x00	; 0
   134c0:	98 2f       	mov	r25, r24
   134c2:	87 2f       	mov	r24, r23
   134c4:	76 2f       	mov	r23, r22
   134c6:	66 27       	eor	r22, r22
   134c8:	2b 81       	ldd	r18, Y+3	; 0x03
   134ca:	62 0f       	add	r22, r18
   134cc:	71 1d       	adc	r23, r1
   134ce:	81 1d       	adc	r24, r1
   134d0:	91 1d       	adc	r25, r1
	Calc_Humidity = (Calc_Humidity * 100) / 16384;
   134d2:	24 e6       	ldi	r18, 0x64	; 100
   134d4:	30 e0       	ldi	r19, 0x00	; 0
   134d6:	40 e0       	ldi	r20, 0x00	; 0
   134d8:	50 e0       	ldi	r21, 0x00	; 0
   134da:	0e 94 9d ac 	call	0x1593a	; 0x1593a <__mulsi3>
   134de:	3e e0       	ldi	r19, 0x0E	; 14
   134e0:	96 95       	lsr	r25
   134e2:	87 95       	ror	r24
   134e4:	77 95       	ror	r23
   134e6:	67 95       	ror	r22
   134e8:	3a 95       	dec	r19
   134ea:	d1 f7       	brne	.-12     	; 0x134e0 <HYT321_GetData+0xa2>

	Calc_Humidity = (Calc_Humidity * 106) + 156;        // Correct values based on result of climate chamber test
   134ec:	2a e6       	ldi	r18, 0x6A	; 106
   134ee:	30 e0       	ldi	r19, 0x00	; 0
   134f0:	40 e0       	ldi	r20, 0x00	; 0
   134f2:	50 e0       	ldi	r21, 0x00	; 0
   134f4:	0e 94 9d ac 	call	0x1593a	; 0x1593a <__mulsi3>
   134f8:	7b 01       	movw	r14, r22
   134fa:	8c 01       	movw	r16, r24
   134fc:	8c e9       	ldi	r24, 0x9C	; 156
   134fe:	90 e0       	ldi	r25, 0x00	; 0
   13500:	a0 e0       	ldi	r26, 0x00	; 0
   13502:	b0 e0       	ldi	r27, 0x00	; 0
   13504:	e8 0e       	add	r14, r24
   13506:	f9 1e       	adc	r15, r25
   13508:	0a 1f       	adc	r16, r26
   1350a:	1b 1f       	adc	r17, r27
	Calc_Humidity /= 100;

	Calc_Temperature = ((int32_t) CurrentHYTData.TemperatureMSB << 6) + CurrentHYTData.Byte2.Fields.TemperatureLSB;
   1350c:	6c 81       	ldd	r22, Y+4	; 0x04
   1350e:	70 e0       	ldi	r23, 0x00	; 0
   13510:	80 e0       	ldi	r24, 0x00	; 0
   13512:	90 e0       	ldi	r25, 0x00	; 0
   13514:	26 e0       	ldi	r18, 0x06	; 6
   13516:	66 0f       	add	r22, r22
   13518:	77 1f       	adc	r23, r23
   1351a:	88 1f       	adc	r24, r24
   1351c:	99 1f       	adc	r25, r25
   1351e:	2a 95       	dec	r18
   13520:	d1 f7       	brne	.-12     	; 0x13516 <HYT321_GetData+0xd8>
   13522:	2a 81       	ldd	r18, Y+2	; 0x02
   13524:	26 95       	lsr	r18
   13526:	26 95       	lsr	r18
   13528:	62 0f       	add	r22, r18
   1352a:	71 1d       	adc	r23, r1
   1352c:	81 1d       	adc	r24, r1
   1352e:	91 1d       	adc	r25, r1
	Calc_Temperature = (Calc_Temperature * 165) / 16384 - 40;
   13530:	25 ea       	ldi	r18, 0xA5	; 165
   13532:	30 e0       	ldi	r19, 0x00	; 0
   13534:	40 e0       	ldi	r20, 0x00	; 0
   13536:	50 e0       	ldi	r21, 0x00	; 0
   13538:	0e 94 9d ac 	call	0x1593a	; 0x1593a <__mulsi3>
   1353c:	20 e0       	ldi	r18, 0x00	; 0
   1353e:	30 e4       	ldi	r19, 0x40	; 64
   13540:	40 e0       	ldi	r20, 0x00	; 0
   13542:	50 e0       	ldi	r21, 0x00	; 0
   13544:	0e 94 ea ac 	call	0x159d4	; 0x159d4 <__divmodsi4>
   13548:	59 01       	movw	r10, r18
   1354a:	6a 01       	movw	r12, r20

	Calc_Humidity = ((uint32_t) CurrentHYTData.Byte1.Fields.HumidityMSB << 8) + CurrentHYTData.HumidityLSB;
	Calc_Humidity = (Calc_Humidity * 100) / 16384;

	Calc_Humidity = (Calc_Humidity * 106) + 156;        // Correct values based on result of climate chamber test
	Calc_Humidity /= 100;
   1354c:	c8 01       	movw	r24, r16
   1354e:	b7 01       	movw	r22, r14
   13550:	24 e6       	ldi	r18, 0x64	; 100
   13552:	30 e0       	ldi	r19, 0x00	; 0
   13554:	40 e0       	ldi	r20, 0x00	; 0
   13556:	50 e0       	ldi	r21, 0x00	; 0
   13558:	0e 94 c8 ac 	call	0x15990	; 0x15990 <__udivmodsi4>

	Calc_Temperature = ((int32_t) CurrentHYTData.TemperatureMSB << 6) + CurrentHYTData.Byte2.Fields.TemperatureLSB;
	Calc_Temperature = (Calc_Temperature * 165) / 16384 - 40;

    *Humidity = (int8_t) Calc_Humidity;
   1355c:	d4 01       	movw	r26, r8
   1355e:	2c 93       	st	X, r18

	Calc_Humidity = (Calc_Humidity * 106) + 156;        // Correct values based on result of climate chamber test
	Calc_Humidity /= 100;

	Calc_Temperature = ((int32_t) CurrentHYTData.TemperatureMSB << 6) + CurrentHYTData.Byte2.Fields.TemperatureLSB;
	Calc_Temperature = (Calc_Temperature * 165) / 16384 - 40;
   13560:	88 ed       	ldi	r24, 0xD8	; 216
   13562:	9f ef       	ldi	r25, 0xFF	; 255
   13564:	af ef       	ldi	r26, 0xFF	; 255
   13566:	bf ef       	ldi	r27, 0xFF	; 255
   13568:	a8 0e       	add	r10, r24
   1356a:	b9 1e       	adc	r11, r25
   1356c:	ca 1e       	adc	r12, r26
   1356e:	db 1e       	adc	r13, r27

    *Humidity = (int8_t) Calc_Humidity;
	*Temperature = (int8_t) Calc_Temperature;
   13570:	d3 01       	movw	r26, r6
   13572:	ac 92       	st	X, r10
}
   13574:	0f 90       	pop	r0
   13576:	0f 90       	pop	r0
   13578:	0f 90       	pop	r0
   1357a:	0f 90       	pop	r0
   1357c:	cf 91       	pop	r28
   1357e:	df 91       	pop	r29
   13580:	1f 91       	pop	r17
   13582:	0f 91       	pop	r16
   13584:	ff 90       	pop	r15
   13586:	ef 90       	pop	r14
   13588:	df 90       	pop	r13
   1358a:	cf 90       	pop	r12
   1358c:	bf 90       	pop	r11
   1358e:	af 90       	pop	r10
   13590:	9f 90       	pop	r9
   13592:	8f 90       	pop	r8
   13594:	7f 90       	pop	r7
   13596:	6f 90       	pop	r6
   13598:	08 95       	ret

0001359a <ili9341_select_chip>:
#define LCD_WIDTH 320
#define LCD_HEIGHT 240

void ili9341_select_chip(void)
{
	PORTB &= ~CONF_ILI9341_CS_PIN;
   1359a:	28 98       	cbi	0x05, 0	; 5
}
   1359c:	08 95       	ret

0001359e <ili9341_deselect_chip>:
void ili9341_deselect_chip(void)
{
	PORTB |= CONF_ILI9341_CS_PIN;
   1359e:	28 9a       	sbi	0x05, 0	; 5
}
   135a0:	08 95       	ret

000135a2 <ili9341_select_command_mode>:
void ili9341_select_command_mode(void)
{
	PORTB &= ~CONF_ILI9341_DC_PIN;
   135a2:	2e 98       	cbi	0x05, 6	; 5
}
   135a4:	08 95       	ret

000135a6 <ili9341_select_data_mode>:
void ili9341_select_data_mode(void)
{
	PORTB |= CONF_ILI9341_DC_PIN;
   135a6:	2e 9a       	sbi	0x05, 6	; 5
}
   135a8:	08 95       	ret

000135aa <ili9341_send_byte>:
			 *  \return Response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_TransferByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline uint8_t SPI_TransferByte(const uint8_t Byte)
			{
				SPDR = Byte;
   135aa:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   135ac:	0d b4       	in	r0, 0x2d	; 45
   135ae:	07 fe       	sbrs	r0, 7
   135b0:	fd cf       	rjmp	.-6      	; 0x135ac <ili9341_send_byte+0x2>
				return SPDR;
   135b2:	8e b5       	in	r24, 0x2e	; 46
void ili9341_send_byte(uint8_t data)
{
    //ili9341_select_chip();
	SPI_TransferByte(data);
	//ili9341_deselect_chip();
}
   135b4:	08 95       	ret

000135b6 <ili9341_send_word>:
			 *  \return Response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_TransferByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline uint8_t SPI_TransferByte(const uint8_t Byte)
			{
				SPDR = Byte;
   135b6:	9e bd       	out	0x2e, r25	; 46
				while (!(SPSR & (1 << SPIF)));
   135b8:	0d b4       	in	r0, 0x2d	; 45
   135ba:	07 fe       	sbrs	r0, 7
   135bc:	fd cf       	rjmp	.-6      	; 0x135b8 <ili9341_send_word+0x2>
				return SPDR;
   135be:	9e b5       	in	r25, 0x2e	; 46
			 *  \return Response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_TransferByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline uint8_t SPI_TransferByte(const uint8_t Byte)
			{
				SPDR = Byte;
   135c0:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   135c2:	0d b4       	in	r0, 0x2d	; 45
   135c4:	07 fe       	sbrs	r0, 7
   135c6:	fd cf       	rjmp	.-6      	; 0x135c2 <ili9341_send_word+0xc>
				return SPDR;
   135c8:	8e b5       	in	r24, 0x2e	; 46
void ili9341_send_word(uint16_t data)
{
	SPI_TransferByte(data >> 8);
	SPI_TransferByte(data );
}
   135ca:	08 95       	ret

000135cc <ili9341_read_byte>:
uint8_t ili9341_read_byte(void)
{
	ili9341_select_chip();
   135cc:	e6 df       	rcall	.-52     	; 0x1359a <ili9341_select_chip>
			 *  \return Response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_TransferByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline uint8_t SPI_TransferByte(const uint8_t Byte)
			{
				SPDR = Byte;
   135ce:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   135d0:	0d b4       	in	r0, 0x2d	; 45
   135d2:	07 fe       	sbrs	r0, 7
   135d4:	fd cf       	rjmp	.-6      	; 0x135d0 <ili9341_read_byte+0x4>
				return SPDR;
   135d6:	8e b5       	in	r24, 0x2e	; 46
	return SPI_TransferByte(0);
}
   135d8:	08 95       	ret

000135da <ili9341_send_command>:
void ili9341_send_command(uint8_t command)
{
   135da:	df 93       	push	r29
   135dc:	cf 93       	push	r28
   135de:	0f 92       	push	r0
   135e0:	cd b7       	in	r28, 0x3d	; 61
   135e2:	de b7       	in	r29, 0x3e	; 62
    ili9341_select_command_mode();
   135e4:	89 83       	std	Y+1, r24	; 0x01
   135e6:	dd df       	rcall	.-70     	; 0x135a2 <ili9341_select_command_mode>
    ili9341_select_chip();
   135e8:	d8 df       	rcall	.-80     	; 0x1359a <ili9341_select_chip>
    ili9341_send_byte(command);
   135ea:	89 81       	ldd	r24, Y+1	; 0x01
   135ec:	de df       	rcall	.-68     	; 0x135aa <ili9341_send_byte>
    ili9341_select_data_mode();
   135ee:	db df       	rcall	.-74     	; 0x135a6 <ili9341_select_data_mode>
}
   135f0:	0f 90       	pop	r0
   135f2:	cf 91       	pop	r28
   135f4:	df 91       	pop	r29
   135f6:	08 95       	ret

000135f8 <ili9341_interface_init>:
void ili9341_interface_init(void)
{
	DDRB |= CONF_ILI9341_RESET_PIN | CONF_ILI9341_DC_PIN | CONF_ILI9341_CS_PIN;
   135f8:	84 b1       	in	r24, 0x04	; 4
   135fa:	81 6c       	ori	r24, 0xC1	; 193
   135fc:	84 b9       	out	0x04, r24	; 4
	ili9341_deselect_chip();
   135fe:	cf df       	rcall	.-98     	; 0x1359e <ili9341_deselect_chip>
			 *  \return Response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_TransferByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline uint8_t SPI_TransferByte(const uint8_t Byte)
			{
				SPDR = Byte;
   13600:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
   13602:	0d b4       	in	r0, 0x2d	; 45
   13604:	07 fe       	sbrs	r0, 7
   13606:	fd cf       	rjmp	.-6      	; 0x13602 <ili9341_interface_init+0xa>
				return SPDR;
   13608:	8e b5       	in	r24, 0x2e	; 46
	SPI_TransferByte(0);
}
   1360a:	08 95       	ret

0001360c <ili9341_read_register>:

}


uint8_t ili9341_read_register(uint8_t addr, uint8_t xparam)
{
   1360c:	1f 93       	push	r17
   1360e:	df 93       	push	r29
   13610:	cf 93       	push	r28
   13612:	0f 92       	push	r0
   13614:	cd b7       	in	r28, 0x3d	; 61
   13616:	de b7       	in	r29, 0x3e	; 62
   13618:	18 2f       	mov	r17, r24
    uint8_t data;
	ili9341_send_command(0xD9); /* ext command                  */
   1361a:	89 ed       	ldi	r24, 0xD9	; 217
   1361c:	69 83       	std	Y+1, r22	; 0x01
   1361e:	dd df       	rcall	.-70     	; 0x135da <ili9341_send_command>
	ili9341_send_byte(0x10+xparam); /* 0x11 is the first Parameter  */
   13620:	69 81       	ldd	r22, Y+1	; 0x01
   13622:	86 2f       	mov	r24, r22
   13624:	80 5f       	subi	r24, 0xF0	; 240
   13626:	c1 df       	rcall	.-126    	; 0x135aa <ili9341_send_byte>
	ili9341_select_command_mode();
   13628:	bc df       	rcall	.-136    	; 0x135a2 <ili9341_select_command_mode>
	ili9341_select_chip();
   1362a:	b7 df       	rcall	.-146    	; 0x1359a <ili9341_select_chip>
	ili9341_send_byte(addr);
   1362c:	81 2f       	mov	r24, r17
   1362e:	bd df       	rcall	.-134    	; 0x135aa <ili9341_send_byte>
	ili9341_select_data_mode();
   13630:	ba df       	rcall	.-140    	; 0x135a6 <ili9341_select_data_mode>
	data=ili9341_read_byte();
   13632:	cc df       	rcall	.-104    	; 0x135cc <ili9341_read_byte>
	ili9341_deselect_chip();
   13634:	89 83       	std	Y+1, r24	; 0x01
   13636:	b3 df       	rcall	.-154    	; 0x1359e <ili9341_deselect_chip>
	return data;
}
   13638:	89 81       	ldd	r24, Y+1	; 0x01
   1363a:	0f 90       	pop	r0
   1363c:	cf 91       	pop	r28
   1363e:	df 91       	pop	r29
   13640:	1f 91       	pop	r17
   13642:	08 95       	ret

00013644 <ili9341_read_ID>:

//INT8U TFT::readID(void)
uint8_t ili9341_read_ID(void)
{
   13644:	0f 93       	push	r16
   13646:	1f 93       	push	r17
   13648:	df 93       	push	r29
   1364a:	cf 93       	push	r28
   1364c:	00 d0       	rcall	.+0      	; 0x1364e <ili9341_read_ID+0xa>
   1364e:	00 d0       	rcall	.+0      	; 0x13650 <ili9341_read_ID+0xc>
   13650:	0f 92       	push	r0
   13652:	cd b7       	in	r28, 0x3d	; 61
   13654:	de b7       	in	r29, 0x3e	; 62
uint8_t i;
uint8_t data[3];
uint8_t id[3]= {0x00, 0x93, 0x41};
   13656:	de 01       	movw	r26, r28
   13658:	11 96       	adiw	r26, 0x01	; 1
   1365a:	e2 e4       	ldi	r30, 0x42	; 66
   1365c:	f9 e0       	ldi	r31, 0x09	; 9
   1365e:	83 e0       	ldi	r24, 0x03	; 3
   13660:	01 90       	ld	r0, Z+
   13662:	0d 92       	st	X+, r0
   13664:	81 50       	subi	r24, 0x01	; 1
   13666:	e1 f7       	brne	.-8      	; 0x13660 <ili9341_read_ID+0x1c>
   13668:	8e 01       	movw	r16, r28
   1366a:	0f 5f       	subi	r16, 0xFF	; 255
   1366c:	1f 4f       	sbci	r17, 0xFF	; 255
uint8_t ToF=0xFF;
   1366e:	2f ef       	ldi	r18, 0xFF	; 255
    for(i=0;i<3;i++)
   13670:	90 e0       	ldi	r25, 0x00	; 0
    {
        data[i]=ili9341_read_register(0xd3,i+1);
   13672:	9f 5f       	subi	r25, 0xFF	; 255
   13674:	83 ed       	ldi	r24, 0xD3	; 211
   13676:	69 2f       	mov	r22, r25
   13678:	2c 83       	std	Y+4, r18	; 0x04
   1367a:	9d 83       	std	Y+5, r25	; 0x05
   1367c:	c7 df       	rcall	.-114    	; 0x1360c <ili9341_read_register>
        if(data[i] != id[i])
   1367e:	f8 01       	movw	r30, r16
   13680:	31 91       	ld	r19, Z+
   13682:	8f 01       	movw	r16, r30
   13684:	2c 81       	ldd	r18, Y+4	; 0x04
   13686:	9d 81       	ldd	r25, Y+5	; 0x05
   13688:	83 13       	cpse	r24, r19
        {
            ToF=0;
   1368a:	20 e0       	ldi	r18, 0x00	; 0
{
uint8_t i;
uint8_t data[3];
uint8_t id[3]= {0x00, 0x93, 0x41};
uint8_t ToF=0xFF;
    for(i=0;i<3;i++)
   1368c:	93 30       	cpi	r25, 0x03	; 3
   1368e:	89 f7       	brne	.-30     	; 0x13672 <ili9341_read_ID+0x2e>
        {
            ToF=0;
        }
    }

    if(!ToF)                                                            /* data!=ID                     */
   13690:	22 23       	and	r18, r18
   13692:	09 f4       	brne	.+2      	; 0x13696 <ili9341_read_ID+0x52>
   13694:	ff cf       	rjmp	.-2      	; 0x13694 <ili9341_read_ID+0x50>
//       }
//        Serial.println();
		while(1){}
	}
   return ToF;
}
   13696:	82 2f       	mov	r24, r18
   13698:	0f 90       	pop	r0
   1369a:	0f 90       	pop	r0
   1369c:	0f 90       	pop	r0
   1369e:	0f 90       	pop	r0
   136a0:	0f 90       	pop	r0
   136a2:	cf 91       	pop	r28
   136a4:	df 91       	pop	r29
   136a6:	1f 91       	pop	r17
   136a8:	0f 91       	pop	r16
   136aa:	08 95       	ret

000136ac <ili9341_reset_display>:
    ili9341_send_byte(0x07);
}

void ili9341_reset_display(void)
{
	PORTB |= CONF_ILI9341_RESET_PIN;
   136ac:	2f 9a       	sbi	0x05, 7	; 5
   136ae:	8f e0       	ldi	r24, 0x0F	; 15
   136b0:	97 e2       	ldi	r25, 0x27	; 39
   136b2:	01 97       	sbiw	r24, 0x01	; 1
   136b4:	f1 f7       	brne	.-4      	; 0x136b2 <ili9341_reset_display+0x6>
   136b6:	00 c0       	rjmp	.+0      	; 0x136b8 <ili9341_reset_display+0xc>
   136b8:	00 00       	nop
	_delay_ms(5);
	PORTB &= ~CONF_ILI9341_RESET_PIN;
   136ba:	2f 98       	cbi	0x05, 7	; 5
   136bc:	8f e0       	ldi	r24, 0x0F	; 15
   136be:	97 e2       	ldi	r25, 0x27	; 39
   136c0:	01 97       	sbiw	r24, 0x01	; 1
   136c2:	f1 f7       	brne	.-4      	; 0x136c0 <ili9341_reset_display+0x14>
   136c4:	00 c0       	rjmp	.+0      	; 0x136c6 <ili9341_reset_display+0x1a>
   136c6:	00 00       	nop
	_delay_ms(5);
	PORTB |= CONF_ILI9341_RESET_PIN;
   136c8:	2f 9a       	sbi	0x05, 7	; 5
   136ca:	8f e0       	ldi	r24, 0x0F	; 15
   136cc:	97 e2       	ldi	r25, 0x27	; 39
   136ce:	01 97       	sbiw	r24, 0x01	; 1
   136d0:	f1 f7       	brne	.-4      	; 0x136ce <ili9341_reset_display+0x22>
   136d2:	00 c0       	rjmp	.+0      	; 0x136d4 <ili9341_reset_display+0x28>
   136d4:	00 00       	nop
	_delay_ms(5);
}
   136d6:	08 95       	ret

000136d8 <ili9341_exit_standby>:
void ili9341_exit_standby(void)
{
    ili9341_send_command(ILI9341_CMD_SLEEP_OUT);
   136d8:	81 e1       	ldi	r24, 0x11	; 17
   136da:	7f df       	rcall	.-258    	; 0x135da <ili9341_send_command>
   136dc:	8f ef       	ldi	r24, 0xFF	; 255
   136de:	90 e7       	ldi	r25, 0x70	; 112
   136e0:	a2 e0       	ldi	r26, 0x02	; 2
   136e2:	81 50       	subi	r24, 0x01	; 1
   136e4:	90 40       	sbci	r25, 0x00	; 0
   136e6:	a0 40       	sbci	r26, 0x00	; 0
   136e8:	e1 f7       	brne	.-8      	; 0x136e2 <ili9341_exit_standby+0xa>
   136ea:	00 c0       	rjmp	.+0      	; 0x136ec <ili9341_exit_standby+0x14>
   136ec:	00 00       	nop
    _delay_ms(100);
    ili9341_send_command(ILI9341_CMD_DISPLAY_ON);
   136ee:	89 e2       	ldi	r24, 0x29	; 41
   136f0:	74 df       	rcall	.-280    	; 0x135da <ili9341_send_command>
   136f2:	8f ef       	ldi	r24, 0xFF	; 255
   136f4:	90 e7       	ldi	r25, 0x70	; 112
   136f6:	a2 e0       	ldi	r26, 0x02	; 2
   136f8:	81 50       	subi	r24, 0x01	; 1
   136fa:	90 40       	sbci	r25, 0x00	; 0
   136fc:	a0 40       	sbci	r26, 0x00	; 0
   136fe:	e1 f7       	brne	.-8      	; 0x136f8 <ili9341_exit_standby+0x20>
   13700:	00 c0       	rjmp	.+0      	; 0x13702 <ili9341_exit_standby+0x2a>
   13702:	00 00       	nop
    _delay_ms(100);
}
   13704:	08 95       	ret

00013706 <ili9341_setCol>:
}



void ili9341_setCol(uint16_t x0,uint16_t x1)
{
   13706:	0f 93       	push	r16
   13708:	1f 93       	push	r17
   1370a:	cf 93       	push	r28
   1370c:	df 93       	push	r29
   1370e:	ec 01       	movw	r28, r24
   13710:	8b 01       	movw	r16, r22
    ili9341_send_command(0x2A);                                                      /* Column Command address       */
   13712:	8a e2       	ldi	r24, 0x2A	; 42
   13714:	62 df       	rcall	.-316    	; 0x135da <ili9341_send_command>
    ili9341_send_word(x0);
   13716:	ce 01       	movw	r24, r28
   13718:	4e df       	rcall	.-356    	; 0x135b6 <ili9341_send_word>
    ili9341_send_word(x1);
   1371a:	c8 01       	movw	r24, r16
   1371c:	4c df       	rcall	.-360    	; 0x135b6 <ili9341_send_word>
}
   1371e:	df 91       	pop	r29
   13720:	cf 91       	pop	r28
   13722:	1f 91       	pop	r17
   13724:	0f 91       	pop	r16
   13726:	08 95       	ret

00013728 <ili9341_setPage>:

void ili9341_setPage(uint16_t y0,uint16_t y1)
{
   13728:	0f 93       	push	r16
   1372a:	1f 93       	push	r17
   1372c:	cf 93       	push	r28
   1372e:	df 93       	push	r29
   13730:	ec 01       	movw	r28, r24
   13732:	8b 01       	movw	r16, r22
    ili9341_send_command(0x2B);                                                      /* Column Command address       */
   13734:	8b e2       	ldi	r24, 0x2B	; 43
   13736:	51 df       	rcall	.-350    	; 0x135da <ili9341_send_command>
    ili9341_send_word(y0);
   13738:	ce 01       	movw	r24, r28
   1373a:	3d df       	rcall	.-390    	; 0x135b6 <ili9341_send_word>
    ili9341_send_word(y1);
   1373c:	c8 01       	movw	r24, r16
   1373e:	3b df       	rcall	.-394    	; 0x135b6 <ili9341_send_word>
}
   13740:	df 91       	pop	r29
   13742:	cf 91       	pop	r28
   13744:	1f 91       	pop	r17
   13746:	0f 91       	pop	r16
   13748:	08 95       	ret

0001374a <ili9341_controller_init_registers>:
void ili9341_controller_init_registers(void)
{
    uint8_t i=0, TFTDriver=0;
    for(i=0;i<3;i++)
	{
		TFTDriver = ili9341_read_ID();
   1374a:	7c df       	rcall	.-264    	; 0x13644 <ili9341_read_ID>
   1374c:	7b df       	rcall	.-266    	; 0x13644 <ili9341_read_ID>
   1374e:	7a df       	rcall	.-268    	; 0x13644 <ili9341_read_ID>
   13750:	8f e1       	ldi	r24, 0x1F	; 31
   13752:	9e e4       	ldi	r25, 0x4E	; 78
   13754:	01 97       	sbiw	r24, 0x01	; 1
   13756:	f1 f7       	brne	.-4      	; 0x13754 <ili9341_controller_init_registers+0xa>
   13758:	00 c0       	rjmp	.+0      	; 0x1375a <ili9341_controller_init_registers+0x10>
   1375a:	00 00       	nop
	}
	_delay_ms(10);

	ili9341_send_command(ILI9341_CMD_SOFTWARE_RESET);
   1375c:	81 e0       	ldi	r24, 0x01	; 1
   1375e:	3d df       	rcall	.-390    	; 0x135da <ili9341_send_command>
   13760:	8f e0       	ldi	r24, 0x0F	; 15
   13762:	97 e2       	ldi	r25, 0x27	; 39
   13764:	01 97       	sbiw	r24, 0x01	; 1
   13766:	f1 f7       	brne	.-4      	; 0x13764 <ili9341_controller_init_registers+0x1a>
   13768:	00 c0       	rjmp	.+0      	; 0x1376a <ili9341_controller_init_registers+0x20>
   1376a:	00 00       	nop
	_delay_ms(5);

    ili9341_send_command(ILI9341_CMD_DISPLAY_OFF);
   1376c:	88 e2       	ldi	r24, 0x28	; 40
   1376e:	35 df       	rcall	.-406    	; 0x135da <ili9341_send_command>
   13770:	8f e0       	ldi	r24, 0x0F	; 15
   13772:	97 e2       	ldi	r25, 0x27	; 39
   13774:	01 97       	sbiw	r24, 0x01	; 1
   13776:	f1 f7       	brne	.-4      	; 0x13774 <ili9341_controller_init_registers+0x2a>
   13778:	00 c0       	rjmp	.+0      	; 0x1377a <ili9341_controller_init_registers+0x30>
   1377a:	00 00       	nop
    _delay_ms(5);

	ili9341_send_command(ILI9341_CMD_SLEEP_OUT);
   1377c:	81 e1       	ldi	r24, 0x11	; 17
   1377e:	2d df       	rcall	.-422    	; 0x135da <ili9341_send_command>
	ili9341_deselect_chip();
   13780:	0e df       	rcall	.-484    	; 0x1359e <ili9341_deselect_chip>
   13782:	8f e0       	ldi	r24, 0x0F	; 15
   13784:	97 e2       	ldi	r25, 0x27	; 39
   13786:	01 97       	sbiw	r24, 0x01	; 1
   13788:	f1 f7       	brne	.-4      	; 0x13786 <ili9341_controller_init_registers+0x3c>
   1378a:	00 c0       	rjmp	.+0      	; 0x1378c <ili9341_controller_init_registers+0x42>
   1378c:	00 00       	nop
    _delay_ms(5);

	ili9341_send_command(ILI9341_CMD_POWER_CONTROL_B);
   1378e:	8f ec       	ldi	r24, 0xCF	; 207
   13790:	24 df       	rcall	.-440    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x00);
   13792:	80 e0       	ldi	r24, 0x00	; 0
   13794:	0a df       	rcall	.-492    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x83); //8B
   13796:	83 e8       	ldi	r24, 0x83	; 131
   13798:	08 df       	rcall	.-496    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0X30);
   1379a:	80 e3       	ldi	r24, 0x30	; 48
   1379c:	06 df       	rcall	.-500    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_POWER_SEQUENCE_CONTROL);
   1379e:	8d ee       	ldi	r24, 0xED	; 237
   137a0:	1c df       	rcall	.-456    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x64); //67
   137a2:	84 e6       	ldi	r24, 0x64	; 100
   137a4:	02 df       	rcall	.-508    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x03);
   137a6:	83 e0       	ldi	r24, 0x03	; 3
   137a8:	00 df       	rcall	.-512    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0X12);
   137aa:	82 e1       	ldi	r24, 0x12	; 18
   137ac:	fe de       	rcall	.-516    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0X81);
   137ae:	81 e8       	ldi	r24, 0x81	; 129
   137b0:	fc de       	rcall	.-520    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_DRIVER_TIMING_CONTROL_A);
   137b2:	88 ee       	ldi	r24, 0xE8	; 232
   137b4:	12 df       	rcall	.-476    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x85);
   137b6:	85 e8       	ldi	r24, 0x85	; 133
   137b8:	f8 de       	rcall	.-528    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x01); //10
   137ba:	81 e0       	ldi	r24, 0x01	; 1
   137bc:	f6 de       	rcall	.-532    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x79); //7A
   137be:	89 e7       	ldi	r24, 0x79	; 121
   137c0:	f4 de       	rcall	.-536    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_POWER_ON_SEQ_CONTROL);
   137c2:	8b ec       	ldi	r24, 0xCB	; 203
   137c4:	0a df       	rcall	.-492    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x39);
   137c6:	89 e3       	ldi	r24, 0x39	; 57
   137c8:	f0 de       	rcall	.-544    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x2C);
   137ca:	8c e2       	ldi	r24, 0x2C	; 44
   137cc:	ee de       	rcall	.-548    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x00);
   137ce:	80 e0       	ldi	r24, 0x00	; 0
   137d0:	ec de       	rcall	.-552    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x34);
   137d2:	84 e3       	ldi	r24, 0x34	; 52
   137d4:	ea de       	rcall	.-556    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x02);
   137d6:	82 e0       	ldi	r24, 0x02	; 2
   137d8:	e8 de       	rcall	.-560    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_PUMP_RATIO_CONTROL);
   137da:	87 ef       	ldi	r24, 0xF7	; 247
   137dc:	fe de       	rcall	.-516    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x20);
   137de:	80 e2       	ldi	r24, 0x20	; 32
   137e0:	e4 de       	rcall	.-568    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_DRIVER_TIMING_CONTROL_B);
   137e2:	8a ee       	ldi	r24, 0xEA	; 234
   137e4:	fa de       	rcall	.-524    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x00);
   137e6:	80 e0       	ldi	r24, 0x00	; 0
   137e8:	e0 de       	rcall	.-576    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x00);
   137ea:	80 e0       	ldi	r24, 0x00	; 0
   137ec:	de de       	rcall	.-580    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_POWER_CONTROL_1 );
   137ee:	80 ec       	ldi	r24, 0xC0	; 192
   137f0:	f4 de       	rcall	.-536    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x26); //1B
   137f2:	86 e2       	ldi	r24, 0x26	; 38
   137f4:	da de       	rcall	.-588    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_POWER_CONTROL_2);
   137f6:	81 ec       	ldi	r24, 0xC1	; 193
   137f8:	f0 de       	rcall	.-544    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x11); //10
   137fa:	81 e1       	ldi	r24, 0x11	; 17
   137fc:	d6 de       	rcall	.-596    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_VCOM_CONTROL_1);
   137fe:	85 ec       	ldi	r24, 0xC5	; 197
   13800:	ec de       	rcall	.-552    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x35); //3F
   13802:	85 e3       	ldi	r24, 0x35	; 53
   13804:	d2 de       	rcall	.-604    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x3E); //3C
   13806:	8e e3       	ldi	r24, 0x3E	; 62
   13808:	d0 de       	rcall	.-608    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_VCOM_CONTROL_2);
   1380a:	87 ec       	ldi	r24, 0xC7	; 199
   1380c:	e6 de       	rcall	.-564    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0xBE); //B7
   1380e:	8e eb       	ldi	r24, 0xBE	; 190
   13810:	cc de       	rcall	.-616    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_MEMORY_ACCESS_CONTROL);
   13812:	86 e3       	ldi	r24, 0x36	; 54
   13814:	e2 de       	rcall	.-572    	; 0x135da <ili9341_send_command>
    switch (ORIENTATION) {
        case 0:
            ili9341_send_byte(0x48);
            break;
        case 1:
            ili9341_send_byte(0x28);
   13816:	88 e2       	ldi	r24, 0x28	; 40
   13818:	c8 de       	rcall	.-624    	; 0x135aa <ili9341_send_byte>
            ili9341_send_byte(0xE8);
            break;
    }


    ili9341_send_command(ILI9341_CMD_COLMOD_PIXEL_FORMAT_SET);
   1381a:	8a e3       	ldi	r24, 0x3A	; 58
   1381c:	de de       	rcall	.-580    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x55);
   1381e:	85 e5       	ldi	r24, 0x55	; 85
   13820:	c4 de       	rcall	.-632    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_FRAME_RATE_CONTROL_NORMAL);
   13822:	81 eb       	ldi	r24, 0xB1	; 177
   13824:	da de       	rcall	.-588    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x00);
   13826:	80 e0       	ldi	r24, 0x00	; 0
   13828:	c0 de       	rcall	.-640    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x1B);
   1382a:	8b e1       	ldi	r24, 0x1B	; 27
   1382c:	be de       	rcall	.-644    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_DISPLAY_FUNCTION_CONTROL);	// Display Function Control
   1382e:	86 eb       	ldi	r24, 0xB6	; 182
   13830:	d4 de       	rcall	.-600    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x0A);
   13832:	8a e0       	ldi	r24, 0x0A	; 10
   13834:	ba de       	rcall	.-652    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x82);
   13836:	82 e8       	ldi	r24, 0x82	; 130
   13838:	b8 de       	rcall	.-656    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x27);
   1383a:	87 e2       	ldi	r24, 0x27	; 39
   1383c:	b6 de       	rcall	.-660    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x00);
   1383e:	80 e0       	ldi	r24, 0x00	; 0
   13840:	b4 de       	rcall	.-664    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_ENABLE_3_GAMMA_CONTROL);	// 3Gamma Function Disable
   13842:	82 ef       	ldi	r24, 0xF2	; 242
   13844:	ca de       	rcall	.-620    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x08);
   13846:	88 e0       	ldi	r24, 0x08	; 8
   13848:	b0 de       	rcall	.-672    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_GAMMA_SET); 				// Gamma curve selected
   1384a:	86 e2       	ldi	r24, 0x26	; 38
   1384c:	c6 de       	rcall	.-628    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x01);
   1384e:	81 e0       	ldi	r24, 0x01	; 1
   13850:	ac de       	rcall	.-680    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_POSITIVE_GAMMA_CORRECTION);	// Set Gamma
   13852:	80 ee       	ldi	r24, 0xE0	; 224
   13854:	c2 de       	rcall	.-636    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x1F);
   13856:	8f e1       	ldi	r24, 0x1F	; 31
   13858:	a8 de       	rcall	.-688    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x1A);
   1385a:	8a e1       	ldi	r24, 0x1A	; 26
   1385c:	a6 de       	rcall	.-692    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x18);
   1385e:	88 e1       	ldi	r24, 0x18	; 24
   13860:	a4 de       	rcall	.-696    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x0A);
   13862:	8a e0       	ldi	r24, 0x0A	; 10
   13864:	a2 de       	rcall	.-700    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x0F);
   13866:	8f e0       	ldi	r24, 0x0F	; 15
   13868:	a0 de       	rcall	.-704    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x06);
   1386a:	86 e0       	ldi	r24, 0x06	; 6
   1386c:	9e de       	rcall	.-708    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x45);
   1386e:	85 e4       	ldi	r24, 0x45	; 69
   13870:	9c de       	rcall	.-712    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0X87);
   13872:	87 e8       	ldi	r24, 0x87	; 135
   13874:	9a de       	rcall	.-716    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x32);
   13876:	82 e3       	ldi	r24, 0x32	; 50
   13878:	98 de       	rcall	.-720    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x0A);
   1387a:	8a e0       	ldi	r24, 0x0A	; 10
   1387c:	96 de       	rcall	.-724    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x07);
   1387e:	87 e0       	ldi	r24, 0x07	; 7
   13880:	94 de       	rcall	.-728    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x02);
   13882:	82 e0       	ldi	r24, 0x02	; 2
   13884:	92 de       	rcall	.-732    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x07);
   13886:	87 e0       	ldi	r24, 0x07	; 7
   13888:	90 de       	rcall	.-736    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x05);
   1388a:	85 e0       	ldi	r24, 0x05	; 5
   1388c:	8e de       	rcall	.-740    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x00);
   1388e:	80 e0       	ldi	r24, 0x00	; 0
   13890:	8c de       	rcall	.-744    	; 0x135aa <ili9341_send_byte>

    ili9341_send_command(ILI9341_CMD_NEGATIVE_GAMMA_CORRECTION);	// Set Gamma
   13892:	81 ee       	ldi	r24, 0xE1	; 225
   13894:	a2 de       	rcall	.-700    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x00);
   13896:	80 e0       	ldi	r24, 0x00	; 0
   13898:	88 de       	rcall	.-752    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x25);
   1389a:	85 e2       	ldi	r24, 0x25	; 37
   1389c:	86 de       	rcall	.-756    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x27);
   1389e:	87 e2       	ldi	r24, 0x27	; 39
   138a0:	84 de       	rcall	.-760    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x05);
   138a2:	85 e0       	ldi	r24, 0x05	; 5
   138a4:	82 de       	rcall	.-764    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x10);
   138a6:	80 e1       	ldi	r24, 0x10	; 16
   138a8:	80 de       	rcall	.-768    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x09);
   138aa:	89 e0       	ldi	r24, 0x09	; 9
   138ac:	7e de       	rcall	.-772    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x3A);
   138ae:	8a e3       	ldi	r24, 0x3A	; 58
   138b0:	7c de       	rcall	.-776    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x78);
   138b2:	88 e7       	ldi	r24, 0x78	; 120
   138b4:	7a de       	rcall	.-780    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x4D);
   138b6:	8d e4       	ldi	r24, 0x4D	; 77
   138b8:	78 de       	rcall	.-784    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x05);
   138ba:	85 e0       	ldi	r24, 0x05	; 5
   138bc:	76 de       	rcall	.-788    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x18);
   138be:	88 e1       	ldi	r24, 0x18	; 24
   138c0:	74 de       	rcall	.-792    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x0D);
   138c2:	8d e0       	ldi	r24, 0x0D	; 13
   138c4:	72 de       	rcall	.-796    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x38);
   138c6:	88 e3       	ldi	r24, 0x38	; 56
   138c8:	70 de       	rcall	.-800    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x3A);
   138ca:	8a e3       	ldi	r24, 0x3A	; 58
   138cc:	6e de       	rcall	.-804    	; 0x135aa <ili9341_send_byte>
    ili9341_send_byte(0x1F);
   138ce:	8f e1       	ldi	r24, 0x1F	; 31
   138d0:	6c de       	rcall	.-808    	; 0x135aa <ili9341_send_byte>

    ili9341_setCol( 0, LCD_WIDTH);
   138d2:	80 e0       	ldi	r24, 0x00	; 0
   138d4:	90 e0       	ldi	r25, 0x00	; 0
   138d6:	60 e4       	ldi	r22, 0x40	; 64
   138d8:	71 e0       	ldi	r23, 0x01	; 1
   138da:	15 df       	rcall	.-470    	; 0x13706 <ili9341_setCol>
    ili9341_setPage(0, LCD_HEIGHT);
   138dc:	80 e0       	ldi	r24, 0x00	; 0
   138de:	90 e0       	ldi	r25, 0x00	; 0
   138e0:	60 ef       	ldi	r22, 0xF0	; 240
   138e2:	70 e0       	ldi	r23, 0x00	; 0
   138e4:	21 df       	rcall	.-446    	; 0x13728 <ili9341_setPage>

    ili9341_send_command(ILI9341_CMD_ENTRY_MODE_SET);	// Set Gamma
   138e6:	87 eb       	ldi	r24, 0xB7	; 183
   138e8:	78 de       	rcall	.-784    	; 0x135da <ili9341_send_command>
    ili9341_send_byte(0x07);
   138ea:	87 e0       	ldi	r24, 0x07	; 7
}
   138ec:	5e ce       	rjmp	.-836    	; 0x135aa <ili9341_send_byte>

000138ee <ili9341_init>:
    _delay_ms(100);
}
void ili9341_init(void)
{
    /* Initialize the communication interface */
    ili9341_interface_init();
   138ee:	84 de       	rcall	.-760    	; 0x135f8 <ili9341_interface_init>

    /* Harware Reset the display */
    ili9341_reset_display();
   138f0:	dd de       	rcall	.-582    	; 0x136ac <ili9341_reset_display>

    /* Write all the controller registers with correct values */
    ili9341_controller_init_registers();
   138f2:	2b df       	rcall	.-426    	; 0x1374a <ili9341_controller_init_registers>
	    /* Send commands to exit standby mode */
    ili9341_exit_standby();
   138f4:	f1 de       	rcall	.-542    	; 0x136d8 <ili9341_exit_standby>
	ili9341_deselect_chip();

}
   138f6:	53 ce       	rjmp	.-858    	; 0x1359e <ili9341_deselect_chip>

000138f8 <ili9341_setXY>:
    ili9341_send_word(y0);
    ili9341_send_word(y1);
}

void ili9341_setXY(uint16_t x, uint16_t y)
{
   138f8:	cf 93       	push	r28
   138fa:	df 93       	push	r29
   138fc:	9c 01       	movw	r18, r24
   138fe:	eb 01       	movw	r28, r22
    ili9341_setCol(x, x);
   13900:	b9 01       	movw	r22, r18
   13902:	01 df       	rcall	.-510    	; 0x13706 <ili9341_setCol>
    ili9341_setPage(y, y);
   13904:	ce 01       	movw	r24, r28
   13906:	be 01       	movw	r22, r28
   13908:	0f df       	rcall	.-482    	; 0x13728 <ili9341_setPage>
}
   1390a:	df 91       	pop	r29
   1390c:	cf 91       	pop	r28
   1390e:	08 95       	ret

00013910 <lcdSetFont>:

void lcdSetFont(uint8_t* f)
{
    font = f;
   13910:	90 93 e5 0c 	sts	0x0CE5, r25
   13914:	80 93 e4 0c 	sts	0x0CE4, r24
}
   13918:	08 95       	ret

0001391a <lcdDrawPixel>:

/* ********************** common subs ***************** */

void lcdDrawPixel(uint16_t poX, uint16_t poY, uint16_t color)
{
   1391a:	cf 93       	push	r28
   1391c:	df 93       	push	r29
   1391e:	ea 01       	movw	r28, r20
    ili9341_setXY(poX, poY);
   13920:	eb df       	rcall	.-42     	; 0x138f8 <ili9341_setXY>
	ili9341_send_command(0x2c);
   13922:	8c e2       	ldi	r24, 0x2C	; 44
   13924:	5a de       	rcall	.-844    	; 0x135da <ili9341_send_command>
    ili9341_send_word(color);
   13926:	ce 01       	movw	r24, r28
   13928:	46 de       	rcall	.-884    	; 0x135b6 <ili9341_send_word>
    ili9341_deselect_chip();
   1392a:	39 de       	rcall	.-910    	; 0x1359e <ili9341_deselect_chip>
}
   1392c:	df 91       	pop	r29
   1392e:	cf 91       	pop	r28
   13930:	08 95       	ret

00013932 <lcdFilledRec>:
/* ******** same as drawpixel, but bigger ***** */
void lcdFilledRec(uint16_t x, uint16_t y, uint16_t w, uint16_t h,uint16_t color)
{
   13932:	4f 92       	push	r4
   13934:	5f 92       	push	r5
   13936:	6f 92       	push	r6
   13938:	7f 92       	push	r7
   1393a:	8f 92       	push	r8
   1393c:	9f 92       	push	r9
   1393e:	af 92       	push	r10
   13940:	bf 92       	push	r11
   13942:	cf 92       	push	r12
   13944:	df 92       	push	r13
   13946:	ef 92       	push	r14
   13948:	ff 92       	push	r15
   1394a:	0f 93       	push	r16
   1394c:	1f 93       	push	r17
   1394e:	cf 93       	push	r28
   13950:	df 93       	push	r29
   13952:	ec 01       	movw	r28, r24
   13954:	3b 01       	movw	r6, r22
   13956:	7a 01       	movw	r14, r20
   13958:	49 01       	movw	r8, r18
   1395a:	28 01       	movw	r4, r16
uint32_t i;
uint32_t n=(uint32_t) w*h;
   1395c:	b9 01       	movw	r22, r18
   1395e:	80 e0       	ldi	r24, 0x00	; 0
   13960:	90 e0       	ldi	r25, 0x00	; 0
   13962:	9a 01       	movw	r18, r20
   13964:	40 e0       	ldi	r20, 0x00	; 0
   13966:	50 e0       	ldi	r21, 0x00	; 0
   13968:	0e 94 9d ac 	call	0x1593a	; 0x1593a <__mulsi3>
   1396c:	5b 01       	movw	r10, r22
   1396e:	6c 01       	movw	r12, r24
uint16_t x1=x+w-1;
   13970:	be 01       	movw	r22, r28
   13972:	61 50       	subi	r22, 0x01	; 1
   13974:	70 40       	sbci	r23, 0x00	; 0
   13976:	6e 0d       	add	r22, r14
   13978:	7f 1d       	adc	r23, r15
uint16_t y1=y+h-1;

    ili9341_setCol( x, x1);
   1397a:	ce 01       	movw	r24, r28
   1397c:	c4 de       	rcall	.-632    	; 0x13706 <ili9341_setCol>
void lcdFilledRec(uint16_t x, uint16_t y, uint16_t w, uint16_t h,uint16_t color)
{
uint32_t i;
uint32_t n=(uint32_t) w*h;
uint16_t x1=x+w-1;
uint16_t y1=y+h-1;
   1397e:	b3 01       	movw	r22, r6
   13980:	61 50       	subi	r22, 0x01	; 1
   13982:	70 40       	sbci	r23, 0x00	; 0
   13984:	68 0d       	add	r22, r8
   13986:	79 1d       	adc	r23, r9

    ili9341_setCol( x, x1);
    ili9341_setPage(y, y1);
   13988:	c3 01       	movw	r24, r6
   1398a:	ce de       	rcall	.-612    	; 0x13728 <ili9341_setPage>
    ili9341_send_command(0x2c);
   1398c:	8c e2       	ldi	r24, 0x2C	; 44
   1398e:	25 de       	rcall	.-950    	; 0x135da <ili9341_send_command>
	for(i=0;i<n;i++) { ili9341_send_word(color); }
   13990:	ee 24       	eor	r14, r14
   13992:	ff 24       	eor	r15, r15
   13994:	87 01       	movw	r16, r14
   13996:	07 c0       	rjmp	.+14     	; 0x139a6 <lcdFilledRec+0x74>
   13998:	c2 01       	movw	r24, r4
   1399a:	0d de       	rcall	.-998    	; 0x135b6 <ili9341_send_word>
   1399c:	08 94       	sec
   1399e:	e1 1c       	adc	r14, r1
   139a0:	f1 1c       	adc	r15, r1
   139a2:	01 1d       	adc	r16, r1
   139a4:	11 1d       	adc	r17, r1
   139a6:	ea 14       	cp	r14, r10
   139a8:	fb 04       	cpc	r15, r11
   139aa:	0c 05       	cpc	r16, r12
   139ac:	1d 05       	cpc	r17, r13
   139ae:	a0 f3       	brcs	.-24     	; 0x13998 <lcdFilledRec+0x66>
	ili9341_deselect_chip();
   139b0:	f6 dd       	rcall	.-1044   	; 0x1359e <ili9341_deselect_chip>
}
   139b2:	df 91       	pop	r29
   139b4:	cf 91       	pop	r28
   139b6:	1f 91       	pop	r17
   139b8:	0f 91       	pop	r16
   139ba:	ff 90       	pop	r15
   139bc:	ef 90       	pop	r14
   139be:	df 90       	pop	r13
   139c0:	cf 90       	pop	r12
   139c2:	bf 90       	pop	r11
   139c4:	af 90       	pop	r10
   139c6:	9f 90       	pop	r9
   139c8:	8f 90       	pop	r8
   139ca:	7f 90       	pop	r7
   139cc:	6f 90       	pop	r6
   139ce:	5f 90       	pop	r5
   139d0:	4f 90       	pop	r4
   139d2:	08 95       	ret

000139d4 <lcdFillRGB>:
/* ********** Clear screen ************ */
void lcdFillRGB(uint16_t color)
{
   139d4:	0f 93       	push	r16
   139d6:	1f 93       	push	r17
   139d8:	8c 01       	movw	r16, r24
	lcdFilledRec(0,0,LCD_WIDTH,LCD_HEIGHT,color);
   139da:	80 e0       	ldi	r24, 0x00	; 0
   139dc:	90 e0       	ldi	r25, 0x00	; 0
   139de:	60 e0       	ldi	r22, 0x00	; 0
   139e0:	70 e0       	ldi	r23, 0x00	; 0
   139e2:	40 e4       	ldi	r20, 0x40	; 64
   139e4:	51 e0       	ldi	r21, 0x01	; 1
   139e6:	20 ef       	ldi	r18, 0xF0	; 240
   139e8:	30 e0       	ldi	r19, 0x00	; 0
   139ea:	a3 df       	rcall	.-186    	; 0x13932 <lcdFilledRec>
}
   139ec:	1f 91       	pop	r17
   139ee:	0f 91       	pop	r16
   139f0:	08 95       	ret

000139f2 <lcdDrawHLine>:
    return;
}

/***********H Line*************************************/
void lcdDrawHLine(uint16_t x0, uint16_t y, uint16_t x1, uint16_t color)
{
   139f2:	af 92       	push	r10
   139f4:	bf 92       	push	r11
   139f6:	cf 92       	push	r12
   139f8:	df 92       	push	r13
   139fa:	ef 92       	push	r14
   139fc:	ff 92       	push	r15
   139fe:	0f 93       	push	r16
   13a00:	1f 93       	push	r17
   13a02:	cf 93       	push	r28
   13a04:	df 93       	push	r29
   13a06:	8c 01       	movw	r16, r24
   13a08:	7b 01       	movw	r14, r22
   13a0a:	ea 01       	movw	r28, r20
   13a0c:	69 01       	movw	r12, r18
  // Allows for slightly better performance than setting individual pixels
  uint16_t x, pixels;

  if (x1 < x0)
   13a0e:	48 17       	cp	r20, r24
   13a10:	59 07       	cpc	r21, r25
   13a12:	48 f4       	brcc	.+18     	; 0x13a26 <lcdDrawHLine+0x34>
   13a14:	38 2f       	mov	r19, r24
   13a16:	21 2f       	mov	r18, r17
   13a18:	8a 01       	movw	r16, r20
   13a1a:	c9 01       	movw	r24, r18
   13a1c:	a9 2e       	mov	r10, r25
   13a1e:	e5 01       	movw	r28, r10
   13a20:	5e 01       	movw	r10, r28
   13a22:	b2 2e       	mov	r11, r18
   13a24:	e5 01       	movw	r28, r10
    x1 = x0;
    x0 = x;
  }

  // Check limits
  if (x1 >= LCD_WIDTH)
   13a26:	31 e0       	ldi	r19, 0x01	; 1
   13a28:	c0 34       	cpi	r28, 0x40	; 64
   13a2a:	d3 07       	cpc	r29, r19
   13a2c:	10 f0       	brcs	.+4      	; 0x13a32 <lcdDrawHLine+0x40>
  {
    x1 = LCD_WIDTH ;
   13a2e:	c0 e4       	ldi	r28, 0x40	; 64
   13a30:	d1 e0       	ldi	r29, 0x01	; 1
  }
  if (x0 >= LCD_WIDTH)
   13a32:	81 e0       	ldi	r24, 0x01	; 1
   13a34:	00 34       	cpi	r16, 0x40	; 64
   13a36:	18 07       	cpc	r17, r24
   13a38:	10 f0       	brcs	.+4      	; 0x13a3e <lcdDrawHLine+0x4c>
  {
    x0 = LCD_WIDTH;
   13a3a:	00 e4       	ldi	r16, 0x40	; 64
   13a3c:	11 e0       	ldi	r17, 0x01	; 1
  }
    ili9341_setCol( x0, x1);
   13a3e:	c8 01       	movw	r24, r16
   13a40:	be 01       	movw	r22, r28
   13a42:	61 de       	rcall	.-830    	; 0x13706 <ili9341_setCol>
    ili9341_setPage(y, y);
   13a44:	c7 01       	movw	r24, r14
   13a46:	b7 01       	movw	r22, r14
   13a48:	6f de       	rcall	.-802    	; 0x13728 <ili9341_setPage>
    ili9341_send_command(0x2c);
   13a4a:	8c e2       	ldi	r24, 0x2C	; 44
   13a4c:	c6 dd       	rcall	.-1140   	; 0x135da <ili9341_send_command>

   for (pixels = 0; pixels < x1 - x0 ; pixels++)
   13a4e:	ee 24       	eor	r14, r14
   13a50:	ff 24       	eor	r15, r15
   13a52:	c0 1b       	sub	r28, r16
   13a54:	d1 0b       	sbc	r29, r17
   13a56:	05 c0       	rjmp	.+10     	; 0x13a62 <lcdDrawHLine+0x70>
  {
    ili9341_send_word(color);
   13a58:	c6 01       	movw	r24, r12
   13a5a:	ad dd       	rcall	.-1190   	; 0x135b6 <ili9341_send_word>
  }
    ili9341_setCol( x0, x1);
    ili9341_setPage(y, y);
    ili9341_send_command(0x2c);

   for (pixels = 0; pixels < x1 - x0 ; pixels++)
   13a5c:	08 94       	sec
   13a5e:	e1 1c       	adc	r14, r1
   13a60:	f1 1c       	adc	r15, r1
   13a62:	ec 16       	cp	r14, r28
   13a64:	fd 06       	cpc	r15, r29
   13a66:	c0 f3       	brcs	.-16     	; 0x13a58 <lcdDrawHLine+0x66>
  {
    ili9341_send_word(color);
  }
    ili9341_deselect_chip();
   13a68:	9a dd       	rcall	.-1228   	; 0x1359e <ili9341_deselect_chip>
}
   13a6a:	df 91       	pop	r29
   13a6c:	cf 91       	pop	r28
   13a6e:	1f 91       	pop	r17
   13a70:	0f 91       	pop	r16
   13a72:	ff 90       	pop	r15
   13a74:	ef 90       	pop	r14
   13a76:	df 90       	pop	r13
   13a78:	cf 90       	pop	r12
   13a7a:	bf 90       	pop	r11
   13a7c:	af 90       	pop	r10
   13a7e:	08 95       	ret

00013a80 <lcdDrawVLine>:
/***********V Line*************************************/
void lcdDrawVLine(uint16_t x, uint16_t y0, uint16_t y1, uint16_t color)
{
   13a80:	cf 92       	push	r12
   13a82:	df 92       	push	r13
   13a84:	ef 92       	push	r14
   13a86:	ff 92       	push	r15
   13a88:	0f 93       	push	r16
   13a8a:	1f 93       	push	r17
   13a8c:	cf 93       	push	r28
   13a8e:	df 93       	push	r29
   13a90:	fc 01       	movw	r30, r24
   13a92:	ea 01       	movw	r28, r20
   13a94:	69 01       	movw	r12, r18
 // Allows for slightly better performance than setting individual pixels
  uint16_t y, pixels;

  if (y1 < y0)
   13a96:	46 17       	cp	r20, r22
   13a98:	57 07       	cpc	r21, r23
   13a9a:	48 f4       	brcc	.+18     	; 0x13aae <lcdDrawVLine+0x2e>
   13a9c:	36 2f       	mov	r19, r22
   13a9e:	27 2f       	mov	r18, r23
   13aa0:	ba 01       	movw	r22, r20
   13aa2:	c9 01       	movw	r24, r18
   13aa4:	e9 2e       	mov	r14, r25
   13aa6:	e7 01       	movw	r28, r14
   13aa8:	7e 01       	movw	r14, r28
   13aaa:	f2 2e       	mov	r15, r18
   13aac:	e7 01       	movw	r28, r14
   13aae:	c0 3f       	cpi	r28, 0xF0	; 240
   13ab0:	d1 05       	cpc	r29, r1
   13ab2:	10 f0       	brcs	.+4      	; 0x13ab8 <lcdDrawVLine+0x38>
   13ab4:	cf ee       	ldi	r28, 0xEF	; 239
   13ab6:	d0 e0       	ldi	r29, 0x00	; 0
   13ab8:	8b 01       	movw	r16, r22
   13aba:	60 3f       	cpi	r22, 0xF0	; 240
   13abc:	71 05       	cpc	r23, r1
   13abe:	10 f0       	brcs	.+4      	; 0x13ac4 <lcdDrawVLine+0x44>
   13ac0:	0f ee       	ldi	r16, 0xEF	; 239
   13ac2:	10 e0       	ldi	r17, 0x00	; 0
  if (y0 >= LCD_HEIGHT)
  {
    y0 = LCD_HEIGHT - 1;
  }

    ili9341_setCol( x, x);
   13ac4:	cf 01       	movw	r24, r30
   13ac6:	bf 01       	movw	r22, r30
   13ac8:	1e de       	rcall	.-964    	; 0x13706 <ili9341_setCol>
    ili9341_setPage(y0, y1);
   13aca:	c8 01       	movw	r24, r16
   13acc:	be 01       	movw	r22, r28
   13ace:	2c de       	rcall	.-936    	; 0x13728 <ili9341_setPage>
    ili9341_send_command(0x2c);
   13ad0:	8c e2       	ldi	r24, 0x2C	; 44
   13ad2:	83 dd       	rcall	.-1274   	; 0x135da <ili9341_send_command>

  for (pixels = 0; pixels < y1 - y0 ; pixels++)
   13ad4:	ee 24       	eor	r14, r14
   13ad6:	ff 24       	eor	r15, r15
   13ad8:	c0 1b       	sub	r28, r16
   13ada:	d1 0b       	sbc	r29, r17
   13adc:	05 c0       	rjmp	.+10     	; 0x13ae8 <lcdDrawVLine+0x68>
  {
	ili9341_send_word(color);
   13ade:	c6 01       	movw	r24, r12
   13ae0:	6a dd       	rcall	.-1324   	; 0x135b6 <ili9341_send_word>

    ili9341_setCol( x, x);
    ili9341_setPage(y0, y1);
    ili9341_send_command(0x2c);

  for (pixels = 0; pixels < y1 - y0 ; pixels++)
   13ae2:	08 94       	sec
   13ae4:	e1 1c       	adc	r14, r1
   13ae6:	f1 1c       	adc	r15, r1
   13ae8:	ec 16       	cp	r14, r28
   13aea:	fd 06       	cpc	r15, r29
   13aec:	c0 f3       	brcs	.-16     	; 0x13ade <lcdDrawVLine+0x5e>
  {
	ili9341_send_word(color);
  }
    ili9341_deselect_chip();
   13aee:	57 dd       	rcall	.-1362   	; 0x1359e <ili9341_deselect_chip>
}
   13af0:	df 91       	pop	r29
   13af2:	cf 91       	pop	r28
   13af4:	1f 91       	pop	r17
   13af6:	0f 91       	pop	r16
   13af8:	ff 90       	pop	r15
   13afa:	ef 90       	pop	r14
   13afc:	df 90       	pop	r13
   13afe:	cf 90       	pop	r12
   13b00:	08 95       	ret

00013b02 <lcdDrawLine>:
	lcdFilledRec(0,0,LCD_WIDTH,LCD_HEIGHT,color);
}

/***********Line*************************************/
void lcdDrawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t color)
{
   13b02:	2f 92       	push	r2
   13b04:	3f 92       	push	r3
   13b06:	4f 92       	push	r4
   13b08:	5f 92       	push	r5
   13b0a:	6f 92       	push	r6
   13b0c:	7f 92       	push	r7
   13b0e:	8f 92       	push	r8
   13b10:	9f 92       	push	r9
   13b12:	af 92       	push	r10
   13b14:	bf 92       	push	r11
   13b16:	cf 92       	push	r12
   13b18:	df 92       	push	r13
   13b1a:	ef 92       	push	r14
   13b1c:	ff 92       	push	r15
   13b1e:	0f 93       	push	r16
   13b20:	1f 93       	push	r17
   13b22:	df 93       	push	r29
   13b24:	cf 93       	push	r28
   13b26:	00 d0       	rcall	.+0      	; 0x13b28 <lcdDrawLine+0x26>
   13b28:	00 d0       	rcall	.+0      	; 0x13b2a <lcdDrawLine+0x28>
   13b2a:	cd b7       	in	r28, 0x3d	; 61
   13b2c:	de b7       	in	r29, 0x3e	; 62
   13b2e:	7c 01       	movw	r14, r24
   13b30:	6b 01       	movw	r12, r22
   13b32:	3a 01       	movw	r6, r20
   13b34:	49 01       	movw	r8, r18
    int16_t   dx = 0, dy = 0;
    int16_t   dx_sym = 0, dy_sym = 0;
    int16_t   dx_x2 = 0, dy_x2 = 0;
    int16_t   di = 0;

    dx = x1-x0;
   13b36:	ca 01       	movw	r24, r20
   13b38:	8e 19       	sub	r24, r14
   13b3a:	9f 09       	sbc	r25, r15
    dy = y1-y0;

    if (dx == 0) {        /* vertical line */
   13b3c:	61 f4       	brne	.+24     	; 0x13b56 <lcdDrawLine+0x54>
        if (y1 > y0) lcdDrawVLine(x0,y0,y1,color);
   13b3e:	62 17       	cp	r22, r18
   13b40:	73 07       	cpc	r23, r19
   13b42:	1c f4       	brge	.+6      	; 0x13b4a <lcdDrawLine+0x48>
   13b44:	c7 01       	movw	r24, r14
   13b46:	a9 01       	movw	r20, r18
   13b48:	03 c0       	rjmp	.+6      	; 0x13b50 <lcdDrawLine+0x4e>
        else lcdDrawVLine(x0,y1,y0,color);
   13b4a:	c7 01       	movw	r24, r14
   13b4c:	b9 01       	movw	r22, r18
   13b4e:	a6 01       	movw	r20, r12
   13b50:	98 01       	movw	r18, r16
   13b52:	96 df       	rcall	.-212    	; 0x13a80 <lcdDrawVLine>
   13b54:	83 c0       	rjmp	.+262    	; 0x13c5c <lcdDrawLine+0x15a>
        return;
    }

    if (dx > 0) {
   13b56:	18 16       	cp	r1, r24
   13b58:	19 06       	cpc	r1, r25
   13b5a:	2c f4       	brge	.+10     	; 0x13b66 <lcdDrawLine+0x64>
        dx_sym = 1;
   13b5c:	21 e0       	ldi	r18, 0x01	; 1
   13b5e:	30 e0       	ldi	r19, 0x00	; 0
   13b60:	3a 83       	std	Y+2, r19	; 0x02
   13b62:	29 83       	std	Y+1, r18	; 0x01
   13b64:	04 c0       	rjmp	.+8      	; 0x13b6e <lcdDrawLine+0x6c>
    } else {
        dx_sym = -1;
   13b66:	6f ef       	ldi	r22, 0xFF	; 255
   13b68:	7f ef       	ldi	r23, 0xFF	; 255
   13b6a:	7a 83       	std	Y+2, r23	; 0x02
   13b6c:	69 83       	std	Y+1, r22	; 0x01
    int16_t   dx_sym = 0, dy_sym = 0;
    int16_t   dx_x2 = 0, dy_x2 = 0;
    int16_t   di = 0;

    dx = x1-x0;
    dy = y1-y0;
   13b6e:	a4 01       	movw	r20, r8
   13b70:	4c 19       	sub	r20, r12
   13b72:	5d 09       	sbc	r21, r13
    if (dx > 0) {
        dx_sym = 1;
    } else {
        dx_sym = -1;
    }
    if (dy == 0) {        /* horizontal line */
   13b74:	69 f4       	brne	.+26     	; 0x13b90 <lcdDrawLine+0x8e>
        if (x1 > x0) lcdDrawHLine(x0,y0,x1,color);
   13b76:	e6 14       	cp	r14, r6
   13b78:	f7 04       	cpc	r15, r7
   13b7a:	24 f4       	brge	.+8      	; 0x13b84 <lcdDrawLine+0x82>
   13b7c:	c7 01       	movw	r24, r14
   13b7e:	b6 01       	movw	r22, r12
   13b80:	a3 01       	movw	r20, r6
   13b82:	03 c0       	rjmp	.+6      	; 0x13b8a <lcdDrawLine+0x88>
        else  lcdDrawHLine(x1,y0,x0,color);
   13b84:	c3 01       	movw	r24, r6
   13b86:	b6 01       	movw	r22, r12
   13b88:	a7 01       	movw	r20, r14
   13b8a:	98 01       	movw	r18, r16
   13b8c:	32 df       	rcall	.-412    	; 0x139f2 <lcdDrawHLine>
   13b8e:	66 c0       	rjmp	.+204    	; 0x13c5c <lcdDrawLine+0x15a>
        return;
    }

    if (dy > 0) {
   13b90:	14 16       	cp	r1, r20
   13b92:	15 06       	cpc	r1, r21
   13b94:	2c f4       	brge	.+10     	; 0x13ba0 <lcdDrawLine+0x9e>
        dy_sym = 1;
   13b96:	e1 e0       	ldi	r30, 0x01	; 1
   13b98:	f0 e0       	ldi	r31, 0x00	; 0
   13b9a:	fc 83       	std	Y+4, r31	; 0x04
   13b9c:	eb 83       	std	Y+3, r30	; 0x03
   13b9e:	04 c0       	rjmp	.+8      	; 0x13ba8 <lcdDrawLine+0xa6>
    } else {
        dy_sym = -1;
   13ba0:	2f ef       	ldi	r18, 0xFF	; 255
   13ba2:	3f ef       	ldi	r19, 0xFF	; 255
   13ba4:	3c 83       	std	Y+4, r19	; 0x04
   13ba6:	2b 83       	std	Y+3, r18	; 0x03
    }

    dx = dx_sym*dx;
   13ba8:	69 81       	ldd	r22, Y+1	; 0x01
   13baa:	7a 81       	ldd	r23, Y+2	; 0x02
   13bac:	68 9f       	mul	r22, r24
   13bae:	90 01       	movw	r18, r0
   13bb0:	69 9f       	mul	r22, r25
   13bb2:	30 0d       	add	r19, r0
   13bb4:	78 9f       	mul	r23, r24
   13bb6:	30 0d       	add	r19, r0
   13bb8:	11 24       	eor	r1, r1
    dy = dy_sym*dy;
   13bba:	eb 81       	ldd	r30, Y+3	; 0x03
   13bbc:	fc 81       	ldd	r31, Y+4	; 0x04
   13bbe:	e4 9f       	mul	r30, r20
   13bc0:	c0 01       	movw	r24, r0
   13bc2:	e5 9f       	mul	r30, r21
   13bc4:	90 0d       	add	r25, r0
   13bc6:	f4 9f       	mul	r31, r20
   13bc8:	90 0d       	add	r25, r0
   13bca:	11 24       	eor	r1, r1

    dx_x2 = dx*2;
   13bcc:	29 01       	movw	r4, r18
   13bce:	44 0c       	add	r4, r4
   13bd0:	55 1c       	adc	r5, r5
    dy_x2 = dy*2;
   13bd2:	1c 01       	movw	r2, r24
   13bd4:	22 0c       	add	r2, r2
   13bd6:	33 1c       	adc	r3, r3

    if (dx >= dy) {
   13bd8:	28 17       	cp	r18, r24
   13bda:	39 07       	cpc	r19, r25
   13bdc:	f4 f0       	brlt	.+60     	; 0x13c1a <lcdDrawLine+0x118>
        di = dy_x2 - dx;
   13bde:	51 01       	movw	r10, r2
   13be0:	a2 1a       	sub	r10, r18
   13be2:	b3 0a       	sbc	r11, r19
            lcdDrawPixel(x0, y0, color);
            x0 += dx_sym;
            if (di<0) {
                di += dy_x2;
            } else {
                di += dy_x2 - dx_x2;
   13be4:	41 01       	movw	r8, r2
   13be6:	84 18       	sub	r8, r4
   13be8:	95 08       	sbc	r9, r5
    dx_x2 = dx*2;
    dy_x2 = dy*2;

    if (dx >= dy) {
        di = dy_x2 - dx;
        while (x0 != x1) {
   13bea:	13 c0       	rjmp	.+38     	; 0x13c12 <lcdDrawLine+0x110>

            lcdDrawPixel(x0, y0, color);
   13bec:	c7 01       	movw	r24, r14
   13bee:	b6 01       	movw	r22, r12
   13bf0:	a8 01       	movw	r20, r16
   13bf2:	93 de       	rcall	.-730    	; 0x1391a <lcdDrawPixel>
{
	lcdFilledRec(0,0,LCD_WIDTH,LCD_HEIGHT,color);
}

/***********Line*************************************/
void lcdDrawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t color)
   13bf4:	29 81       	ldd	r18, Y+1	; 0x01
   13bf6:	3a 81       	ldd	r19, Y+2	; 0x02
   13bf8:	e2 0e       	add	r14, r18
   13bfa:	f3 1e       	adc	r15, r19
        di = dy_x2 - dx;
        while (x0 != x1) {

            lcdDrawPixel(x0, y0, color);
            x0 += dx_sym;
            if (di<0) {
   13bfc:	b7 fe       	sbrs	r11, 7
   13bfe:	03 c0       	rjmp	.+6      	; 0x13c06 <lcdDrawLine+0x104>
                di += dy_x2;
   13c00:	a2 0c       	add	r10, r2
   13c02:	b3 1c       	adc	r11, r3
   13c04:	06 c0       	rjmp	.+12     	; 0x13c12 <lcdDrawLine+0x110>
            } else {
                di += dy_x2 - dx_x2;
   13c06:	a8 0c       	add	r10, r8
   13c08:	b9 1c       	adc	r11, r9
                y0 += dy_sym;
   13c0a:	6b 81       	ldd	r22, Y+3	; 0x03
   13c0c:	7c 81       	ldd	r23, Y+4	; 0x04
   13c0e:	c6 0e       	add	r12, r22
   13c10:	d7 1e       	adc	r13, r23
    dx_x2 = dx*2;
    dy_x2 = dy*2;

    if (dx >= dy) {
        di = dy_x2 - dx;
        while (x0 != x1) {
   13c12:	e6 14       	cp	r14, r6
   13c14:	f7 04       	cpc	r15, r7
   13c16:	51 f7       	brne	.-44     	; 0x13bec <lcdDrawLine+0xea>
   13c18:	1d c0       	rjmp	.+58     	; 0x13c54 <lcdDrawLine+0x152>
                y0 += dy_sym;
            }
        }
        lcdDrawPixel(x0, y0, color);
    } else {
        di = dx_x2 - dy;
   13c1a:	52 01       	movw	r10, r4
   13c1c:	a8 1a       	sub	r10, r24
   13c1e:	b9 0a       	sbc	r11, r25
            lcdDrawPixel(x0, y0, color);
            y0 += dy_sym;
            if (di < 0) {
                di += dx_x2;
            } else {
                di += dx_x2 - dy_x2;
   13c20:	32 01       	movw	r6, r4
   13c22:	62 18       	sub	r6, r2
   13c24:	73 08       	sbc	r7, r3
            }
        }
        lcdDrawPixel(x0, y0, color);
    } else {
        di = dx_x2 - dy;
        while (y0 != y1) {
   13c26:	13 c0       	rjmp	.+38     	; 0x13c4e <lcdDrawLine+0x14c>
            lcdDrawPixel(x0, y0, color);
   13c28:	c7 01       	movw	r24, r14
   13c2a:	b6 01       	movw	r22, r12
   13c2c:	a8 01       	movw	r20, r16
   13c2e:	75 de       	rcall	.-790    	; 0x1391a <lcdDrawPixel>
{
	lcdFilledRec(0,0,LCD_WIDTH,LCD_HEIGHT,color);
}

/***********Line*************************************/
void lcdDrawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t color)
   13c30:	8b 81       	ldd	r24, Y+3	; 0x03
   13c32:	9c 81       	ldd	r25, Y+4	; 0x04
   13c34:	c8 0e       	add	r12, r24
   13c36:	d9 1e       	adc	r13, r25
    } else {
        di = dx_x2 - dy;
        while (y0 != y1) {
            lcdDrawPixel(x0, y0, color);
            y0 += dy_sym;
            if (di < 0) {
   13c38:	b7 fe       	sbrs	r11, 7
   13c3a:	03 c0       	rjmp	.+6      	; 0x13c42 <lcdDrawLine+0x140>
                di += dx_x2;
   13c3c:	a4 0c       	add	r10, r4
   13c3e:	b5 1c       	adc	r11, r5
   13c40:	06 c0       	rjmp	.+12     	; 0x13c4e <lcdDrawLine+0x14c>
            } else {
                di += dx_x2 - dy_x2;
   13c42:	a6 0c       	add	r10, r6
   13c44:	b7 1c       	adc	r11, r7
                x0 += dx_sym;
   13c46:	e9 81       	ldd	r30, Y+1	; 0x01
   13c48:	fa 81       	ldd	r31, Y+2	; 0x02
   13c4a:	ee 0e       	add	r14, r30
   13c4c:	ff 1e       	adc	r15, r31
            }
        }
        lcdDrawPixel(x0, y0, color);
    } else {
        di = dx_x2 - dy;
        while (y0 != y1) {
   13c4e:	c8 14       	cp	r12, r8
   13c50:	d9 04       	cpc	r13, r9
   13c52:	51 f7       	brne	.-44     	; 0x13c28 <lcdDrawLine+0x126>
            } else {
                di += dx_x2 - dy_x2;
                x0 += dx_sym;
            }
        }
        lcdDrawPixel(x0, y0, color);
   13c54:	c7 01       	movw	r24, r14
   13c56:	b6 01       	movw	r22, r12
   13c58:	a8 01       	movw	r20, r16
   13c5a:	5f de       	rcall	.-834    	; 0x1391a <lcdDrawPixel>
    }
    return;
}
   13c5c:	0f 90       	pop	r0
   13c5e:	0f 90       	pop	r0
   13c60:	0f 90       	pop	r0
   13c62:	0f 90       	pop	r0
   13c64:	cf 91       	pop	r28
   13c66:	df 91       	pop	r29
   13c68:	1f 91       	pop	r17
   13c6a:	0f 91       	pop	r16
   13c6c:	ff 90       	pop	r15
   13c6e:	ef 90       	pop	r14
   13c70:	df 90       	pop	r13
   13c72:	cf 90       	pop	r12
   13c74:	bf 90       	pop	r11
   13c76:	af 90       	pop	r10
   13c78:	9f 90       	pop	r9
   13c7a:	8f 90       	pop	r8
   13c7c:	7f 90       	pop	r7
   13c7e:	6f 90       	pop	r6
   13c80:	5f 90       	pop	r5
   13c82:	4f 90       	pop	r4
   13c84:	3f 90       	pop	r3
   13c86:	2f 90       	pop	r2
   13c88:	08 95       	ret

00013c8a <lcdDrawRectangle>:



/* ********draw simple frame (rectangle ) *********** */
void lcdDrawRectangle(uint16_t poX, uint16_t poY, uint16_t length, uint16_t width, uint16_t color)
{
   13c8a:	6f 92       	push	r6
   13c8c:	7f 92       	push	r7
   13c8e:	8f 92       	push	r8
   13c90:	9f 92       	push	r9
   13c92:	af 92       	push	r10
   13c94:	bf 92       	push	r11
   13c96:	cf 92       	push	r12
   13c98:	df 92       	push	r13
   13c9a:	ef 92       	push	r14
   13c9c:	ff 92       	push	r15
   13c9e:	0f 93       	push	r16
   13ca0:	1f 93       	push	r17
   13ca2:	cf 93       	push	r28
   13ca4:	df 93       	push	r29
   13ca6:	6c 01       	movw	r12, r24
   13ca8:	5b 01       	movw	r10, r22
   13caa:	7a 01       	movw	r14, r20
   13cac:	39 01       	movw	r6, r18
    lcdDrawHLine(poX, poY, poX + length-1, color);
   13cae:	e8 0e       	add	r14, r24
   13cb0:	f9 1e       	adc	r15, r25
   13cb2:	47 01       	movw	r8, r14
   13cb4:	08 94       	sec
   13cb6:	81 08       	sbc	r8, r1
   13cb8:	91 08       	sbc	r9, r1
   13cba:	a4 01       	movw	r20, r8
   13cbc:	98 01       	movw	r18, r16
   13cbe:	99 de       	rcall	.-718    	; 0x139f2 <lcdDrawHLine>
    lcdDrawHLine(poX, poY + width-1, poX+length, color);
   13cc0:	e5 01       	movw	r28, r10
   13cc2:	21 97       	sbiw	r28, 0x01	; 1
   13cc4:	c6 0d       	add	r28, r6
   13cc6:	d7 1d       	adc	r29, r7
   13cc8:	c6 01       	movw	r24, r12
   13cca:	be 01       	movw	r22, r28
   13ccc:	a7 01       	movw	r20, r14
   13cce:	98 01       	movw	r18, r16
   13cd0:	90 de       	rcall	.-736    	; 0x139f2 <lcdDrawHLine>

    lcdDrawVLine(poX, poY, poY + width-1, color);
   13cd2:	c6 01       	movw	r24, r12
   13cd4:	b5 01       	movw	r22, r10
   13cd6:	ae 01       	movw	r20, r28
   13cd8:	98 01       	movw	r18, r16
   13cda:	d2 de       	rcall	.-604    	; 0x13a80 <lcdDrawVLine>
    lcdDrawVLine(poX + length-1, poY, poY+width-1, color);
   13cdc:	c4 01       	movw	r24, r8
   13cde:	b5 01       	movw	r22, r10
   13ce0:	ae 01       	movw	r20, r28
   13ce2:	98 01       	movw	r18, r16
   13ce4:	cd de       	rcall	.-614    	; 0x13a80 <lcdDrawVLine>
    ili9341_deselect_chip();
   13ce6:	5b dc       	rcall	.-1866   	; 0x1359e <ili9341_deselect_chip>
}
   13ce8:	df 91       	pop	r29
   13cea:	cf 91       	pop	r28
   13cec:	1f 91       	pop	r17
   13cee:	0f 91       	pop	r16
   13cf0:	ff 90       	pop	r15
   13cf2:	ef 90       	pop	r14
   13cf4:	df 90       	pop	r13
   13cf6:	cf 90       	pop	r12
   13cf8:	bf 90       	pop	r11
   13cfa:	af 90       	pop	r10
   13cfc:	9f 90       	pop	r9
   13cfe:	8f 90       	pop	r8
   13d00:	7f 90       	pop	r7
   13d02:	6f 90       	pop	r6
   13d04:	08 95       	ret

00013d06 <lcdDrawChar>:
}

/* draw char or print text. */

uint16_t lcdDrawChar( uint8_t c, uint16_t char_x, uint16_t char_y, uint16_t foreground, uint16_t background)
{
   13d06:	2f 92       	push	r2
   13d08:	3f 92       	push	r3
   13d0a:	4f 92       	push	r4
   13d0c:	5f 92       	push	r5
   13d0e:	6f 92       	push	r6
   13d10:	7f 92       	push	r7
   13d12:	8f 92       	push	r8
   13d14:	9f 92       	push	r9
   13d16:	af 92       	push	r10
   13d18:	bf 92       	push	r11
   13d1a:	cf 92       	push	r12
   13d1c:	df 92       	push	r13
   13d1e:	ef 92       	push	r14
   13d20:	ff 92       	push	r15
   13d22:	0f 93       	push	r16
   13d24:	1f 93       	push	r17
   13d26:	df 93       	push	r29
   13d28:	cf 93       	push	r28
   13d2a:	cd b7       	in	r28, 0x3d	; 61
   13d2c:	de b7       	in	r29, 0x3e	; 62
   13d2e:	29 97       	sbiw	r28, 0x09	; 9
   13d30:	0f b6       	in	r0, 0x3f	; 63
   13d32:	f8 94       	cli
   13d34:	de bf       	out	0x3e, r29	; 62
   13d36:	0f be       	out	0x3f, r0	; 63
   13d38:	cd bf       	out	0x3d, r28	; 61
   13d3a:	c8 2e       	mov	r12, r24
   13d3c:	5b 01       	movw	r10, r22
   13d3e:	7a 01       	movw	r14, r20
   13d40:	2e 83       	std	Y+6, r18	; 0x06
   13d42:	3f 83       	std	Y+7, r19	; 0x07
   13d44:	18 01       	movw	r2, r16
    uint16_t hor,vert,offset,bpl,j,i,b;
    unsigned char* zeichen;
    unsigned char z,w;

    if ((c < 31) || (c > 127)) return 0;   // test char range
   13d46:	8f 51       	subi	r24, 0x1F	; 31
   13d48:	81 36       	cpi	r24, 0x61	; 97
   13d4a:	08 f0       	brcs	.+2      	; 0x13d4e <lcdDrawChar+0x48>
   13d4c:	af c0       	rjmp	.+350    	; 0x13eac <lcdDrawChar+0x1a6>

    // read font parameter from start of array
    offset = pgm_read_byte(&font[0]);                    // bytes / char
   13d4e:	80 91 e4 0c 	lds	r24, 0x0CE4
   13d52:	90 91 e5 0c 	lds	r25, 0x0CE5
   13d56:	fc 01       	movw	r30, r24
   13d58:	04 91       	lpm	r16, Z+
   13d5a:	10 e0       	ldi	r17, 0x00	; 0
    hor = pgm_read_byte(&font[1]);                       // get hor size of font
   13d5c:	31 96       	adiw	r30, 0x01	; 1
   13d5e:	64 90       	lpm	r6, Z+
   13d60:	77 24       	eor	r7, r7
    vert = pgm_read_byte(&font[2]);                      // get vert size of font
   13d62:	fc 01       	movw	r30, r24
   13d64:	32 96       	adiw	r30, 0x02	; 2
   13d66:	84 90       	lpm	r8, Z+
   13d68:	99 24       	eor	r9, r9
    bpl = pgm_read_byte(&font[3]);                       // bytes per line
   13d6a:	03 96       	adiw	r24, 0x03	; 3
   13d6c:	fc 01       	movw	r30, r24
   13d6e:	84 91       	lpm	r24, Z+
   13d70:	28 2f       	mov	r18, r24
   13d72:	30 e0       	ldi	r19, 0x00	; 0
   13d74:	3a 83       	std	Y+2, r19	; 0x02
   13d76:	29 83       	std	Y+1, r18	; 0x01

   if (char_x + hor > LCD_WIDTH) {
   13d78:	c3 01       	movw	r24, r6
   13d7a:	86 0f       	add	r24, r22
   13d7c:	97 1f       	adc	r25, r23
   13d7e:	31 e0       	ldi	r19, 0x01	; 1
   13d80:	81 34       	cpi	r24, 0x41	; 65
   13d82:	93 07       	cpc	r25, r19
   13d84:	68 f0       	brcs	.+26     	; 0x13da0 <lcdDrawChar+0x9a>
        char_x = 0;
        char_y = char_y + vert;
   13d86:	e8 0c       	add	r14, r8
   13d88:	f9 1c       	adc	r15, r9
        if (char_y >= LCD_HEIGHT - pgm_read_byte(&font[2])) {
   13d8a:	80 ef       	ldi	r24, 0xF0	; 240
   13d8c:	90 e0       	ldi	r25, 0x00	; 0
   13d8e:	88 19       	sub	r24, r8
   13d90:	99 09       	sbc	r25, r9
   13d92:	e8 16       	cp	r14, r24
   13d94:	f9 06       	cpc	r15, r25
   13d96:	10 f0       	brcs	.+4      	; 0x13d9c <lcdDrawChar+0x96>
            char_y = 0;
   13d98:	ee 24       	eor	r14, r14
   13d9a:	ff 24       	eor	r15, r15
    hor = pgm_read_byte(&font[1]);                       // get hor size of font
    vert = pgm_read_byte(&font[2]);                      // get vert size of font
    bpl = pgm_read_byte(&font[3]);                       // bytes per line

   if (char_x + hor > LCD_WIDTH) {
        char_x = 0;
   13d9c:	aa 24       	eor	r10, r10
   13d9e:	bb 24       	eor	r11, r11
        if (char_y >= LCD_HEIGHT - pgm_read_byte(&font[2])) {
            char_y = 0;
        }
    }

    ili9341_setCol( char_x, char_x+hor-1); // char box
   13da0:	c5 01       	movw	r24, r10
   13da2:	86 0d       	add	r24, r6
   13da4:	97 1d       	adc	r25, r7
   13da6:	99 87       	std	Y+9, r25	; 0x09
   13da8:	88 87       	std	Y+8, r24	; 0x08
   13daa:	bc 01       	movw	r22, r24
   13dac:	61 50       	subi	r22, 0x01	; 1
   13dae:	70 40       	sbci	r23, 0x00	; 0
   13db0:	c5 01       	movw	r24, r10
   13db2:	a9 dc       	rcall	.-1710   	; 0x13706 <ili9341_setCol>
    ili9341_setPage(char_y,char_y+vert-1);
   13db4:	b4 01       	movw	r22, r8
   13db6:	61 50       	subi	r22, 0x01	; 1
   13db8:	70 40       	sbci	r23, 0x00	; 0
   13dba:	6e 0d       	add	r22, r14
   13dbc:	7f 1d       	adc	r23, r15
   13dbe:	c7 01       	movw	r24, r14
   13dc0:	b3 dc       	rcall	.-1690   	; 0x13728 <ili9341_setPage>

    ili9341_send_command(0x2c);  // send pixel
   13dc2:	8c e2       	ldi	r24, 0x2C	; 44
   13dc4:	0a dc       	rcall	.-2028   	; 0x135da <ili9341_send_command>

    zeichen = &font[((c -32) * offset) + 4];            // start of char bitmap
   13dc6:	2c 2d       	mov	r18, r12
   13dc8:	30 e0       	ldi	r19, 0x00	; 0
   13dca:	20 52       	subi	r18, 0x20	; 32
   13dcc:	30 40       	sbci	r19, 0x00	; 0
   13dce:	02 9f       	mul	r16, r18
   13dd0:	c0 01       	movw	r24, r0
   13dd2:	03 9f       	mul	r16, r19
   13dd4:	90 0d       	add	r25, r0
   13dd6:	12 9f       	mul	r17, r18
   13dd8:	90 0d       	add	r25, r0
   13dda:	11 24       	eor	r1, r1
   13ddc:	04 96       	adiw	r24, 0x04	; 4
   13dde:	c0 90 e4 0c 	lds	r12, 0x0CE4
   13de2:	d0 90 e5 0c 	lds	r13, 0x0CE5
   13de6:	c8 0e       	add	r12, r24
   13de8:	d9 1e       	adc	r13, r25
    w = pgm_read_byte(&zeichen[0]);                     // width of actual char
   13dea:	f6 01       	movw	r30, r12
   13dec:	f4 91       	lpm	r31, Z+
   13dee:	fb 83       	std	Y+3, r31	; 0x03

    for (j=0; j<vert; j++) {  //  vert line
   13df0:	00 e0       	ldi	r16, 0x00	; 0
   13df2:	10 e0       	ldi	r17, 0x00	; 0
   13df4:	1d c0       	rjmp	.+58     	; 0x13e30 <lcdDrawChar+0x12a>
        for (i=0; i<hor; i++) {   //  horz line

            z =  pgm_read_byte(&zeichen[bpl * i + ((j & 0xF8) >> 3)+1]);
   13df6:	f7 01       	movw	r30, r14
   13df8:	84 91       	lpm	r24, Z+

            b = 1 << (j & 0x07);
            if (( z & b ) == 0x00)
   13dfa:	90 e0       	ldi	r25, 0x00	; 0
   13dfc:	2c 81       	ldd	r18, Y+4	; 0x04
   13dfe:	3d 81       	ldd	r19, Y+5	; 0x05
   13e00:	82 23       	and	r24, r18
   13e02:	93 23       	and	r25, r19
   13e04:	00 97       	sbiw	r24, 0x00	; 0
   13e06:	21 f4       	brne	.+8      	; 0x13e10 <lcdDrawChar+0x10a>
            {
               ili9341_send_byte(background >> 8);
   13e08:	83 2d       	mov	r24, r3
   13e0a:	cf db       	rcall	.-2146   	; 0x135aa <ili9341_send_byte>
               ili9341_send_byte(background & 0xff);
   13e0c:	82 2d       	mov	r24, r2
   13e0e:	03 c0       	rjmp	.+6      	; 0x13e16 <lcdDrawChar+0x110>
            }
            else
            {
                ili9341_send_byte(foreground >> 8);
   13e10:	8f 81       	ldd	r24, Y+7	; 0x07
   13e12:	cb db       	rcall	.-2154   	; 0x135aa <ili9341_send_byte>
                ili9341_send_byte(foreground & 0xff);
   13e14:	8e 81       	ldd	r24, Y+6	; 0x06
   13e16:	c9 db       	rcall	.-2158   	; 0x135aa <ili9341_send_byte>

    zeichen = &font[((c -32) * offset) + 4];            // start of char bitmap
    w = pgm_read_byte(&zeichen[0]);                     // width of actual char

    for (j=0; j<vert; j++) {  //  vert line
        for (i=0; i<hor; i++) {   //  horz line
   13e18:	08 94       	sec
   13e1a:	41 1c       	adc	r4, r1
   13e1c:	51 1c       	adc	r5, r1
   13e1e:	89 81       	ldd	r24, Y+1	; 0x01
   13e20:	9a 81       	ldd	r25, Y+2	; 0x02
   13e22:	e8 0e       	add	r14, r24
   13e24:	f9 1e       	adc	r15, r25
   13e26:	46 14       	cp	r4, r6
   13e28:	57 04       	cpc	r5, r7
   13e2a:	28 f3       	brcs	.-54     	; 0x13df6 <lcdDrawChar+0xf0>
    ili9341_send_command(0x2c);  // send pixel

    zeichen = &font[((c -32) * offset) + 4];            // start of char bitmap
    w = pgm_read_byte(&zeichen[0]);                     // width of actual char

    for (j=0; j<vert; j++) {  //  vert line
   13e2c:	0f 5f       	subi	r16, 0xFF	; 255
   13e2e:	1f 4f       	sbci	r17, 0xFF	; 255
   13e30:	08 15       	cp	r16, r8
   13e32:	19 05       	cpc	r17, r9
   13e34:	f0 f4       	brcc	.+60     	; 0x13e72 <lcdDrawChar+0x16c>
        for (i=0; i<hor; i++) {   //  horz line

            z =  pgm_read_byte(&zeichen[bpl * i + ((j & 0xF8) >> 3)+1]);

            b = 1 << (j & 0x07);
   13e36:	c8 01       	movw	r24, r16
   13e38:	87 70       	andi	r24, 0x07	; 7
   13e3a:	90 70       	andi	r25, 0x00	; 0
   13e3c:	e1 e0       	ldi	r30, 0x01	; 1
   13e3e:	f0 e0       	ldi	r31, 0x00	; 0
   13e40:	02 c0       	rjmp	.+4      	; 0x13e46 <lcdDrawChar+0x140>
   13e42:	ee 0f       	add	r30, r30
   13e44:	ff 1f       	adc	r31, r31
   13e46:	8a 95       	dec	r24
   13e48:	e2 f7       	brpl	.-8      	; 0x13e42 <lcdDrawChar+0x13c>
   13e4a:	fd 83       	std	Y+5, r31	; 0x05
   13e4c:	ec 83       	std	Y+4, r30	; 0x04
    w = pgm_read_byte(&zeichen[0]);                     // width of actual char

    for (j=0; j<vert; j++) {  //  vert line
        for (i=0; i<hor; i++) {   //  horz line

            z =  pgm_read_byte(&zeichen[bpl * i + ((j & 0xF8) >> 3)+1]);
   13e4e:	a8 ef       	ldi	r26, 0xF8	; 248
   13e50:	ea 2e       	mov	r14, r26
   13e52:	f1 2c       	mov	r15, r1
   13e54:	e0 22       	and	r14, r16
   13e56:	f1 22       	and	r15, r17
   13e58:	f3 e0       	ldi	r31, 0x03	; 3
   13e5a:	f6 94       	lsr	r15
   13e5c:	e7 94       	ror	r14
   13e5e:	fa 95       	dec	r31
   13e60:	e1 f7       	brne	.-8      	; 0x13e5a <lcdDrawChar+0x154>
   13e62:	08 94       	sec
   13e64:	e1 1c       	adc	r14, r1
   13e66:	f1 1c       	adc	r15, r1
    ili9341_deselect_chip();
}

/* draw char or print text. */

uint16_t lcdDrawChar( uint8_t c, uint16_t char_x, uint16_t char_y, uint16_t foreground, uint16_t background)
   13e68:	ec 0c       	add	r14, r12
   13e6a:	fd 1c       	adc	r15, r13
   13e6c:	44 24       	eor	r4, r4
   13e6e:	55 24       	eor	r5, r5
   13e70:	da cf       	rjmp	.-76     	; 0x13e26 <lcdDrawChar+0x120>
                ili9341_send_byte(foreground & 0xff);
            }
        }
    }

    ili9341_deselect_chip();
   13e72:	95 db       	rcall	.-2262   	; 0x1359e <ili9341_deselect_chip>

    ili9341_setCol( 0, LCD_WIDTH);  // window max
   13e74:	80 e0       	ldi	r24, 0x00	; 0
   13e76:	90 e0       	ldi	r25, 0x00	; 0
   13e78:	60 e4       	ldi	r22, 0x40	; 64
   13e7a:	71 e0       	ldi	r23, 0x01	; 1
   13e7c:	44 dc       	rcall	.-1912   	; 0x13706 <ili9341_setCol>
    ili9341_setPage(0, LCD_HEIGHT);
   13e7e:	80 e0       	ldi	r24, 0x00	; 0
   13e80:	90 e0       	ldi	r25, 0x00	; 0
   13e82:	60 ef       	ldi	r22, 0xF0	; 240
   13e84:	70 e0       	ldi	r23, 0x00	; 0
   13e86:	50 dc       	rcall	.-1888   	; 0x13728 <ili9341_setPage>

    if ((w + 2) < hor) {                   // x offset to next char
   13e88:	fb 81       	ldd	r31, Y+3	; 0x03
   13e8a:	8f 2f       	mov	r24, r31
   13e8c:	90 e0       	ldi	r25, 0x00	; 0
   13e8e:	9c 01       	movw	r18, r24
   13e90:	2e 5f       	subi	r18, 0xFE	; 254
   13e92:	3f 4f       	sbci	r19, 0xFF	; 255
   13e94:	26 15       	cp	r18, r6
   13e96:	37 05       	cpc	r19, r7
   13e98:	38 f4       	brcc	.+14     	; 0x13ea8 <lcdDrawChar+0x1a2>
        char_x += w + 2;
   13e9a:	95 01       	movw	r18, r10
   13e9c:	2e 5f       	subi	r18, 0xFE	; 254
   13e9e:	3f 4f       	sbci	r19, 0xFF	; 255
   13ea0:	28 0f       	add	r18, r24
   13ea2:	39 1f       	adc	r19, r25
   13ea4:	39 87       	std	Y+9, r19	; 0x09
   13ea6:	28 87       	std	Y+8, r18	; 0x08
    } else char_x += hor;

    ili9341_deselect_chip();
   13ea8:	7a db       	rcall	.-2316   	; 0x1359e <ili9341_deselect_chip>

    return char_x;
   13eaa:	02 c0       	rjmp	.+4      	; 0x13eb0 <lcdDrawChar+0x1aa>
{
    uint16_t hor,vert,offset,bpl,j,i,b;
    unsigned char* zeichen;
    unsigned char z,w;

    if ((c < 31) || (c > 127)) return 0;   // test char range
   13eac:	19 86       	std	Y+9, r1	; 0x09
   13eae:	18 86       	std	Y+8, r1	; 0x08
    } else char_x += hor;

    ili9341_deselect_chip();

    return char_x;
}
   13eb0:	88 85       	ldd	r24, Y+8	; 0x08
   13eb2:	99 85       	ldd	r25, Y+9	; 0x09
   13eb4:	29 96       	adiw	r28, 0x09	; 9
   13eb6:	0f b6       	in	r0, 0x3f	; 63
   13eb8:	f8 94       	cli
   13eba:	de bf       	out	0x3e, r29	; 62
   13ebc:	0f be       	out	0x3f, r0	; 63
   13ebe:	cd bf       	out	0x3d, r28	; 61
   13ec0:	cf 91       	pop	r28
   13ec2:	df 91       	pop	r29
   13ec4:	1f 91       	pop	r17
   13ec6:	0f 91       	pop	r16
   13ec8:	ff 90       	pop	r15
   13eca:	ef 90       	pop	r14
   13ecc:	df 90       	pop	r13
   13ece:	cf 90       	pop	r12
   13ed0:	bf 90       	pop	r11
   13ed2:	af 90       	pop	r10
   13ed4:	9f 90       	pop	r9
   13ed6:	8f 90       	pop	r8
   13ed8:	7f 90       	pop	r7
   13eda:	6f 90       	pop	r6
   13edc:	5f 90       	pop	r5
   13ede:	4f 90       	pop	r4
   13ee0:	3f 90       	pop	r3
   13ee2:	2f 90       	pop	r2
   13ee4:	08 95       	ret

00013ee6 <lcdDrawString>:

void lcdDrawString(const char *string,uint16_t poX, uint16_t poY, uint16_t fgcolor,uint16_t bgcolor)
{
   13ee6:	8f 92       	push	r8
   13ee8:	9f 92       	push	r9
   13eea:	af 92       	push	r10
   13eec:	bf 92       	push	r11
   13eee:	cf 92       	push	r12
   13ef0:	df 92       	push	r13
   13ef2:	ef 92       	push	r14
   13ef4:	ff 92       	push	r15
   13ef6:	0f 93       	push	r16
   13ef8:	1f 93       	push	r17
   13efa:	cf 93       	push	r28
   13efc:	df 93       	push	r29
   13efe:	f6 2e       	mov	r15, r22
   13f00:	e7 2e       	mov	r14, r23
   13f02:	5a 01       	movw	r10, r20
   13f04:	49 01       	movw	r8, r18
   13f06:	e8 01       	movw	r28, r16
    uint16_t w;

    while (*string!=0)
	{
       w=lcdDrawChar(*string++, poX, poY, fgcolor, bgcolor);
       if(w < LCD_WIDTH)
   13f08:	c8 2e       	mov	r12, r24
   13f0a:	d9 2e       	mov	r13, r25

void lcdDrawString(const char *string,uint16_t poX, uint16_t poY, uint16_t fgcolor,uint16_t bgcolor)
{
    uint16_t w;

    while (*string!=0)
   13f0c:	0c c0       	rjmp	.+24     	; 0x13f26 <lcdDrawString+0x40>
	{
       w=lcdDrawChar(*string++, poX, poY, fgcolor, bgcolor);
   13f0e:	6f 2d       	mov	r22, r15
   13f10:	7e 2d       	mov	r23, r14
   13f12:	a5 01       	movw	r20, r10
   13f14:	94 01       	movw	r18, r8
   13f16:	8e 01       	movw	r16, r28
   13f18:	f6 de       	rcall	.-532    	; 0x13d06 <lcdDrawChar>
       if(w < LCD_WIDTH)
   13f1a:	21 e0       	ldi	r18, 0x01	; 1
   13f1c:	80 34       	cpi	r24, 0x40	; 64
   13f1e:	92 07       	cpc	r25, r18
   13f20:	10 f4       	brcc	.+4      	; 0x13f26 <lcdDrawString+0x40>
   13f22:	f8 2e       	mov	r15, r24
   13f24:	e9 2e       	mov	r14, r25

void lcdDrawString(const char *string,uint16_t poX, uint16_t poY, uint16_t fgcolor,uint16_t bgcolor)
{
    uint16_t w;

    while (*string!=0)
   13f26:	f6 01       	movw	r30, r12
   13f28:	81 91       	ld	r24, Z+
   13f2a:	6f 01       	movw	r12, r30
   13f2c:	88 23       	and	r24, r24
   13f2e:	79 f7       	brne	.-34     	; 0x13f0e <lcdDrawString+0x28>
       if(w < LCD_WIDTH)
        {
            poX = w;                                     /* Move cursor right            */
        }
    }
}
   13f30:	df 91       	pop	r29
   13f32:	cf 91       	pop	r28
   13f34:	1f 91       	pop	r17
   13f36:	0f 91       	pop	r16
   13f38:	ff 90       	pop	r15
   13f3a:	ef 90       	pop	r14
   13f3c:	df 90       	pop	r13
   13f3e:	cf 90       	pop	r12
   13f40:	bf 90       	pop	r11
   13f42:	af 90       	pop	r10
   13f44:	9f 90       	pop	r9
   13f46:	8f 90       	pop	r8
   13f48:	08 95       	ret

00013f4a <writeAddress>:
uint8_t writeAddress(uint8_t high, uint8_t low, uint8_t value, uint8_t block)
{
	uint8_t temp;
	uint8_t r1, r2, r3, r4;

	WIZNET_CS_Port_Write &= ~(1<<WIZNET_CS);        // ensable Wiznet module, cs -> 0
   13f4a:	74 98       	cbi	0x0e, 4	; 14
			 *  \return Response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_TransferByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline uint8_t SPI_TransferByte(const uint8_t Byte)
			{
				SPDR = Byte;
   13f4c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   13f4e:	0d b4       	in	r0, 0x2d	; 45
   13f50:	07 fe       	sbrs	r0, 7
   13f52:	fd cf       	rjmp	.-6      	; 0x13f4e <writeAddress+0x4>
				return SPDR;
   13f54:	5e b5       	in	r21, 0x2e	; 46
			 *  \return Response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_TransferByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline uint8_t SPI_TransferByte(const uint8_t Byte)
			{
				SPDR = Byte;
   13f56:	6e bd       	out	0x2e, r22	; 46
				while (!(SPSR & (1 << SPIF)));
   13f58:	0d b4       	in	r0, 0x2d	; 45
   13f5a:	07 fe       	sbrs	r0, 7
   13f5c:	fd cf       	rjmp	.-6      	; 0x13f58 <writeAddress+0xe>
				return SPDR;
   13f5e:	3e b5       	in	r19, 0x2e	; 46
	r1 = SPI_TransferByte(high);                    // address phase
	r2 = SPI_TransferByte(low);
	r3 = SPI_TransferByte(0x04|(block<<3));         // control phase
   13f60:	22 0f       	add	r18, r18
   13f62:	22 0f       	add	r18, r18
   13f64:	22 0f       	add	r18, r18
   13f66:	24 60       	ori	r18, 0x04	; 4
			 *  \return Response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_TransferByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline uint8_t SPI_TransferByte(const uint8_t Byte)
			{
				SPDR = Byte;
   13f68:	2e bd       	out	0x2e, r18	; 46
				while (!(SPSR & (1 << SPIF)));
   13f6a:	0d b4       	in	r0, 0x2d	; 45
   13f6c:	07 fe       	sbrs	r0, 7
   13f6e:	fd cf       	rjmp	.-6      	; 0x13f6a <writeAddress+0x20>
				return SPDR;
   13f70:	8e b5       	in	r24, 0x2e	; 46
			 *  \return Response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_TransferByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline uint8_t SPI_TransferByte(const uint8_t Byte)
			{
				SPDR = Byte;
   13f72:	4e bd       	out	0x2e, r20	; 46
				while (!(SPSR & (1 << SPIF)));
   13f74:	0d b4       	in	r0, 0x2d	; 45
   13f76:	07 fe       	sbrs	r0, 7
   13f78:	fd cf       	rjmp	.-6      	; 0x13f74 <writeAddress+0x2a>
				return SPDR;
   13f7a:	9e b5       	in	r25, 0x2e	; 46
	r4 = SPI_TransferByte(value);                   // data phase
	WIZNET_CS_Port_Write |= (1<<WIZNET_CS);         // disable Wiznet module, cs -> 1
   13f7c:	74 9a       	sbi	0x0e, 4	; 14
	if(r1 == 0 && r2==1 && r3==2 && r4 == 3) temp = 1;
   13f7e:	55 23       	and	r21, r21
   13f80:	39 f4       	brne	.+14     	; 0x13f90 <writeAddress+0x46>
   13f82:	31 30       	cpi	r19, 0x01	; 1
   13f84:	29 f4       	brne	.+10     	; 0x13f90 <writeAddress+0x46>
   13f86:	82 30       	cpi	r24, 0x02	; 2
   13f88:	29 f4       	brne	.+10     	; 0x13f94 <writeAddress+0x4a>
//uint8_t  serverip[4] = {192, 168, 1, 83};               // Destination IP Address for PC as HTTP Client
uint8_t destport[2] = {0, 80};                             // Destination Port number for HTTP Client
uint8_t  clientport[2] = {0, 80};                     // Client Port 80


uint8_t writeAddress(uint8_t high, uint8_t low, uint8_t value, uint8_t block)
   13f8a:	81 e0       	ldi	r24, 0x01	; 1
   13f8c:	93 30       	cpi	r25, 0x03	; 3
   13f8e:	19 f0       	breq	.+6      	; 0x13f96 <writeAddress+0x4c>
	r2 = SPI_TransferByte(low);
	r3 = SPI_TransferByte(0x04|(block<<3));         // control phase
	r4 = SPI_TransferByte(value);                   // data phase
	WIZNET_CS_Port_Write |= (1<<WIZNET_CS);         // disable Wiznet module, cs -> 1
	if(r1 == 0 && r2==1 && r3==2 && r4 == 3) temp = 1;
	else temp = 0;
   13f90:	80 e0       	ldi	r24, 0x00	; 0
   13f92:	08 95       	ret
   13f94:	80 e0       	ldi	r24, 0x00	; 0

	return temp;

}
   13f96:	08 95       	ret

00013f98 <readAddress>:
uint8_t readAddress(uint8_t high, uint8_t low, uint8_t block)
{
	uint8_t temp;
	uint8_t r1, r2, r3;

	WIZNET_CS_Port_Write &= ~(1<<WIZNET_CS);         // ensable Wiznet module, cs -> 0
   13f98:	74 98       	cbi	0x0e, 4	; 14
			 *  \return Response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_TransferByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline uint8_t SPI_TransferByte(const uint8_t Byte)
			{
				SPDR = Byte;
   13f9a:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   13f9c:	0d b4       	in	r0, 0x2d	; 45
   13f9e:	07 fe       	sbrs	r0, 7
   13fa0:	fd cf       	rjmp	.-6      	; 0x13f9c <readAddress+0x4>
				return SPDR;
   13fa2:	8e b5       	in	r24, 0x2e	; 46
			 *  \return Response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_TransferByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline uint8_t SPI_TransferByte(const uint8_t Byte)
			{
				SPDR = Byte;
   13fa4:	6e bd       	out	0x2e, r22	; 46
				while (!(SPSR & (1 << SPIF)));
   13fa6:	0d b4       	in	r0, 0x2d	; 45
   13fa8:	07 fe       	sbrs	r0, 7
   13faa:	fd cf       	rjmp	.-6      	; 0x13fa6 <readAddress+0xe>
				return SPDR;
   13fac:	8e b5       	in	r24, 0x2e	; 46
	r1 = SPI_TransferByte(high);                     // address phase
	r2 = SPI_TransferByte(low);
	r3 = SPI_TransferByte(0x00|(block<<3));          // control phase
   13fae:	44 0f       	add	r20, r20
   13fb0:	44 0f       	add	r20, r20
   13fb2:	44 0f       	add	r20, r20
			 *  \return Response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_TransferByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline uint8_t SPI_TransferByte(const uint8_t Byte)
			{
				SPDR = Byte;
   13fb4:	4e bd       	out	0x2e, r20	; 46
				while (!(SPSR & (1 << SPIF)));
   13fb6:	0d b4       	in	r0, 0x2d	; 45
   13fb8:	07 fe       	sbrs	r0, 7
   13fba:	fd cf       	rjmp	.-6      	; 0x13fb6 <readAddress+0x1e>
				return SPDR;
   13fbc:	8e b5       	in	r24, 0x2e	; 46
			 *  \return Response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_TransferByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline uint8_t SPI_TransferByte(const uint8_t Byte)
			{
				SPDR = Byte;
   13fbe:	8f ef       	ldi	r24, 0xFF	; 255
   13fc0:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
   13fc2:	0d b4       	in	r0, 0x2d	; 45
   13fc4:	07 fe       	sbrs	r0, 7
   13fc6:	fd cf       	rjmp	.-6      	; 0x13fc2 <readAddress+0x2a>
				return SPDR;
   13fc8:	8e b5       	in	r24, 0x2e	; 46
	temp = SPI_TransferByte(0xFF);                   // data phase
	WIZNET_CS_Port_Write |= (1<<WIZNET_CS);          // disable Wiznet module, cs -> 1
   13fca:	74 9a       	sbi	0x0e, 4	; 14
	return temp;

}
   13fcc:	08 95       	ret

00013fce <sendData>:

//Send data to socket
uint8_t sendData(uint16_t datlen, char datatosend[],uint8_t socket)
{
   13fce:	8f 92       	push	r8
   13fd0:	9f 92       	push	r9
   13fd2:	af 92       	push	r10
   13fd4:	bf 92       	push	r11
   13fd6:	cf 92       	push	r12
   13fd8:	df 92       	push	r13
   13fda:	ef 92       	push	r14
   13fdc:	ff 92       	push	r15
   13fde:	0f 93       	push	r16
   13fe0:	1f 93       	push	r17
   13fe2:	df 93       	push	r29
   13fe4:	cf 93       	push	r28
   13fe6:	0f 92       	push	r0
   13fe8:	cd b7       	in	r28, 0x3d	; 61
   13fea:	de b7       	in	r29, 0x3e	; 62
   13fec:	5c 01       	movw	r10, r24
   13fee:	e6 2e       	mov	r14, r22
   13ff0:	d4 2e       	mov	r13, r20

	uint8_t q1, q2;
	uint16_t sentcount = 0;
	printf("%s\n", datatosend);
   13ff2:	86 2f       	mov	r24, r22
   13ff4:	97 2f       	mov	r25, r23
   13ff6:	79 83       	std	Y+1, r23	; 0x01
   13ff8:	0e 94 59 ad 	call	0x15ab2	; 0x15ab2 <puts>

	q1 = readAddress(0x00, 0x24, socket);
   13ffc:	80 e0       	ldi	r24, 0x00	; 0
   13ffe:	64 e2       	ldi	r22, 0x24	; 36
   14000:	4d 2d       	mov	r20, r13
   14002:	ca df       	rcall	.-108    	; 0x13f98 <readAddress>
   14004:	08 2f       	mov	r16, r24
	q2 = readAddress(0x00, 0x25, socket);
   14006:	80 e0       	ldi	r24, 0x00	; 0
   14008:	65 e2       	ldi	r22, 0x25	; 37
   1400a:	4d 2d       	mov	r20, r13
   1400c:	c5 df       	rcall	.-118    	; 0x13f98 <readAddress>
	uint16_t wrAdd = 0;
	uint16_t offset;
	uint8_t wrAddHigh = q1;
	uint8_t wrAddLow = 	q2;

	offset = (((q1<<8) | (q2)));
   1400e:	30 2f       	mov	r19, r16
   14010:	20 e0       	ldi	r18, 0x00	; 0
   14012:	08 2f       	mov	r16, r24
   14014:	10 e0       	ldi	r17, 0x00	; 0
   14016:	02 2b       	or	r16, r18
   14018:	13 2b       	or	r17, r19
   1401a:	79 81       	ldd	r23, Y+1	; 0x01
   1401c:	f7 2e       	mov	r15, r23
//Send data to socket
uint8_t sendData(uint16_t datlen, char datatosend[],uint8_t socket)
{

	uint8_t q1, q2;
	uint16_t sentcount = 0;
   1401e:	88 24       	eor	r8, r8
   14020:	99 24       	eor	r9, r9
	while(sentcount < datlen)
	{
		wrAdd = (offset & 0x07ff);
		wrAddHigh = ((wrAdd & 0xff00)>>8);
		wrAddLow = ((wrAdd & 0x00ff));
		writeAddress(wrAddHigh, wrAddLow, datatosend[sentcount],socket+1); // Socket TX Buffer
   14022:	cd 2c       	mov	r12, r13
   14024:	c3 94       	inc	r12
	uint8_t wrAddHigh = q1;
	uint8_t wrAddLow = 	q2;

	offset = (((q1<<8) | (q2)));

	while(sentcount < datlen)
   14026:	0a c0       	rjmp	.+20     	; 0x1403c <sendData+0x6e>
	{
		wrAdd = (offset & 0x07ff);
   14028:	77 70       	andi	r23, 0x07	; 7
		wrAddHigh = ((wrAdd & 0xff00)>>8);
		wrAddLow = ((wrAdd & 0x00ff));
		writeAddress(wrAddHigh, wrAddLow, datatosend[sentcount],socket+1); // Socket TX Buffer
   1402a:	f7 01       	movw	r30, r14
   1402c:	41 91       	ld	r20, Z+
   1402e:	7f 01       	movw	r14, r30
   14030:	87 2f       	mov	r24, r23
   14032:	2c 2d       	mov	r18, r12
   14034:	8a df       	rcall	.-236    	; 0x13f4a <writeAddress>
		sentcount++;
   14036:	08 94       	sec
   14038:	81 1c       	adc	r8, r1
   1403a:	91 1c       	adc	r9, r1
   1403c:	b4 01       	movw	r22, r8
   1403e:	60 0f       	add	r22, r16
   14040:	71 1f       	adc	r23, r17
	uint8_t wrAddHigh = q1;
	uint8_t wrAddLow = 	q2;

	offset = (((q1<<8) | (q2)));

	while(sentcount < datlen)
   14042:	8a 14       	cp	r8, r10
   14044:	9b 04       	cpc	r9, r11
   14046:	80 f3       	brcs	.-32     	; 0x14028 <sendData+0x5a>
   14048:	0a 0d       	add	r16, r10
   1404a:	1b 1d       	adc	r17, r11
		writeAddress(wrAddHigh, wrAddLow, datatosend[sentcount],socket+1); // Socket TX Buffer
		sentcount++;
		offset++;
	}

	writeAddress(0x00, 0x24, (offset & 0xff00)>>8, socket);
   1404c:	80 e0       	ldi	r24, 0x00	; 0
   1404e:	64 e2       	ldi	r22, 0x24	; 36
   14050:	41 2f       	mov	r20, r17
   14052:	2d 2d       	mov	r18, r13
   14054:	7a df       	rcall	.-268    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x25, (offset & 0x00ff), socket);
   14056:	80 e0       	ldi	r24, 0x00	; 0
   14058:	65 e2       	ldi	r22, 0x25	; 37
   1405a:	40 2f       	mov	r20, r16
   1405c:	2d 2d       	mov	r18, r13
   1405e:	75 df       	rcall	.-278    	; 0x13f4a <writeAddress>

	//Send
	q1 = writeAddress(0x00, 0x01, 0x20,socket);	 // Socket Command  Register -> SEND
   14060:	80 e0       	ldi	r24, 0x00	; 0
   14062:	61 e0       	ldi	r22, 0x01	; 1
   14064:	40 e2       	ldi	r20, 0x20	; 32
   14066:	2d 2d       	mov	r18, r13
   14068:	70 df       	rcall	.-288    	; 0x13f4a <writeAddress>

    return q1;
}
   1406a:	0f 90       	pop	r0
   1406c:	cf 91       	pop	r28
   1406e:	df 91       	pop	r29
   14070:	1f 91       	pop	r17
   14072:	0f 91       	pop	r16
   14074:	ff 90       	pop	r15
   14076:	ef 90       	pop	r14
   14078:	df 90       	pop	r13
   1407a:	cf 90       	pop	r12
   1407c:	bf 90       	pop	r11
   1407e:	af 90       	pop	r10
   14080:	9f 90       	pop	r9
   14082:	8f 90       	pop	r8
   14084:	08 95       	ret

00014086 <getData>:

//Get data from socket RX Buffer
uint16_t getData(char buffer[], uint8_t maxLength, uint8_t socket)
{
   14086:	2f 92       	push	r2
   14088:	3f 92       	push	r3
   1408a:	4f 92       	push	r4
   1408c:	5f 92       	push	r5
   1408e:	6f 92       	push	r6
   14090:	7f 92       	push	r7
   14092:	8f 92       	push	r8
   14094:	9f 92       	push	r9
   14096:	af 92       	push	r10
   14098:	bf 92       	push	r11
   1409a:	cf 92       	push	r12
   1409c:	df 92       	push	r13
   1409e:	ef 92       	push	r14
   140a0:	ff 92       	push	r15
   140a2:	0f 93       	push	r16
   140a4:	1f 93       	push	r17
   140a6:	df 93       	push	r29
   140a8:	cf 93       	push	r28
   140aa:	cd b7       	in	r28, 0x3d	; 61
   140ac:	de b7       	in	r29, 0x3e	; 62
   140ae:	2b 97       	sbiw	r28, 0x0b	; 11
   140b0:	0f b6       	in	r0, 0x3f	; 63
   140b2:	f8 94       	cli
   140b4:	de bf       	out	0x3e, r29	; 62
   140b6:	0f be       	out	0x3f, r0	; 63
   140b8:	cd bf       	out	0x3d, r28	; 61
   140ba:	9c 83       	std	Y+4, r25	; 0x04
   140bc:	8b 83       	std	Y+3, r24	; 0x03
   140be:	6d 83       	std	Y+5, r22	; 0x05
   140c0:	b4 2e       	mov	r11, r20
	uint16_t i = 0;
	uint8_t inter0;



	inter0 = readAddress(0x00, 0x02, socket);
   140c2:	80 e0       	ldi	r24, 0x00	; 0
   140c4:	62 e0       	ldi	r22, 0x02	; 2
   140c6:	68 df       	rcall	.-304    	; 0x13f98 <readAddress>

	if(inter0 & 1<<2)                           //Socket interrupt ?
   140c8:	82 ff       	sbrs	r24, 2
   140ca:	88 c0       	rjmp	.+272    	; 0x141dc <getData+0x156>
        //Serial_TxString("\n");

		uint8_t dataSize1;
		uint8_t dataSize2;

		dataSize1 = readAddress(0x00, 0x26, socket);
   140cc:	80 e0       	ldi	r24, 0x00	; 0
   140ce:	66 e2       	ldi	r22, 0x26	; 38
   140d0:	4b 2d       	mov	r20, r11
   140d2:	62 df       	rcall	.-316    	; 0x13f98 <readAddress>
   140d4:	89 83       	std	Y+1, r24	; 0x01
		dataSize2 = readAddress(0x00, 0x27, socket);
   140d6:	80 e0       	ldi	r24, 0x00	; 0
   140d8:	67 e2       	ldi	r22, 0x27	; 39
   140da:	4b 2d       	mov	r20, r11
   140dc:	5d df       	rcall	.-326    	; 0x13f98 <readAddress>
   140de:	8a 83       	std	Y+2, r24	; 0x02
        //Serial_TxString("\n");

		uint8_t pointer1;
		uint8_t pointer2;

		pointer1 = readAddress(0x00, 0x28, socket);
   140e0:	80 e0       	ldi	r24, 0x00	; 0
   140e2:	68 e2       	ldi	r22, 0x28	; 40
   140e4:	4b 2d       	mov	r20, r11
   140e6:	58 df       	rcall	.-336    	; 0x13f98 <readAddress>
   140e8:	98 2e       	mov	r9, r24
		pointer2 = readAddress(0x00, 0x29, socket);
   140ea:	80 e0       	ldi	r24, 0x00	; 0
   140ec:	69 e2       	ldi	r22, 0x29	; 41
   140ee:	4b 2d       	mov	r20, r11
   140f0:	53 df       	rcall	.-346    	; 0x13f98 <readAddress>
   140f2:	a8 2e       	mov	r10, r24

		uint16_t length = ((dataSize1<<8) | dataSize2);
   140f4:	ea 80       	ldd	r14, Y+2	; 0x02
   140f6:	2e 2c       	mov	r2, r14
   140f8:	33 24       	eor	r3, r3
   140fa:	99 81       	ldd	r25, Y+1	; 0x01
   140fc:	80 e0       	ldi	r24, 0x00	; 0
   140fe:	3c 01       	movw	r6, r24
   14100:	62 28       	or	r6, r2
   14102:	73 28       	or	r7, r3
   14104:	0b 81       	ldd	r16, Y+3	; 0x03
   14106:	1c 81       	ldd	r17, Y+4	; 0x04
   14108:	4a 2c       	mov	r4, r10
   1410a:	55 24       	eor	r5, r5

		while(i < length && i < maxLength)
   1410c:	72 01       	movw	r14, r4
{

    //char LineBuffer[16];

	//get data
	uint16_t i = 0;
   1410e:	1b 86       	std	Y+11, r1	; 0x0b
   14110:	1a 86       	std	Y+10, r1	; 0x0a
		pointer1 = readAddress(0x00, 0x28, socket);
		pointer2 = readAddress(0x00, 0x29, socket);

		uint16_t length = ((dataSize1<<8) | dataSize2);

		while(i < length && i < maxLength)
   14112:	3d 81       	ldd	r19, Y+5	; 0x05
   14114:	23 2f       	mov	r18, r19
   14116:	30 e0       	ldi	r19, 0x00	; 0
   14118:	38 87       	std	Y+8, r19	; 0x08
   1411a:	2f 83       	std	Y+7, r18	; 0x07
		{

			if((pointer1%8) + ((i+pointer2)>>8) < 0x08)
   1411c:	c9 2c       	mov	r12, r9
   1411e:	dd 24       	eor	r13, r13
   14120:	87 e0       	ldi	r24, 0x07	; 7
   14122:	c8 22       	and	r12, r24
   14124:	dd 24       	eor	r13, r13
   14126:	97 e0       	ldi	r25, 0x07	; 7
   14128:	89 2e       	mov	r8, r25
   1412a:	89 20       	and	r8, r9
   1412c:	9b 2d       	mov	r25, r11
   1412e:	9e 5f       	subi	r25, 0xFE	; 254
   14130:	9e 83       	std	Y+6, r25	; 0x06
			{
				buffer[i] = readAddress((pointer1%8) + ((i+pointer2)>>8), i+pointer2, socket+2);
			}
			else
			{
				buffer[i] = readAddress((pointer1%8) + ((i+pointer2)>>8) - 0x08, i+pointer2, socket+2);
   14132:	a8 2d       	mov	r26, r8
   14134:	a8 50       	subi	r26, 0x08	; 8
   14136:	a9 87       	std	Y+9, r26	; 0x09
		pointer1 = readAddress(0x00, 0x28, socket);
		pointer2 = readAddress(0x00, 0x29, socket);

		uint16_t length = ((dataSize1<<8) | dataSize2);

		while(i < length && i < maxLength)
   14138:	20 c0       	rjmp	.+64     	; 0x1417a <getData+0xf4>
		{

			if((pointer1%8) + ((i+pointer2)>>8) < 0x08)
   1413a:	8f 2d       	mov	r24, r15
   1413c:	99 27       	eor	r25, r25
   1413e:	9c 01       	movw	r18, r24
   14140:	2c 0d       	add	r18, r12
   14142:	3d 1d       	adc	r19, r13
   14144:	28 30       	cpi	r18, 0x08	; 8
   14146:	31 05       	cpc	r19, r1
   14148:	39 f0       	breq	.+14     	; 0x14158 <getData+0xd2>
			{
				buffer[i] = readAddress((pointer1%8) + ((i+pointer2)>>8), i+pointer2, socket+2);
   1414a:	88 0d       	add	r24, r8
   1414c:	6e 2d       	mov	r22, r14
   1414e:	4e 81       	ldd	r20, Y+6	; 0x06
   14150:	23 df       	rcall	.-442    	; 0x13f98 <readAddress>
   14152:	f8 01       	movw	r30, r16
   14154:	80 83       	st	Z, r24
   14156:	07 c0       	rjmp	.+14     	; 0x14166 <getData+0xe0>
			}
			else
			{
				buffer[i] = readAddress((pointer1%8) + ((i+pointer2)>>8) - 0x08, i+pointer2, socket+2);
   14158:	f9 85       	ldd	r31, Y+9	; 0x09
   1415a:	8f 0f       	add	r24, r31
   1415c:	6e 2d       	mov	r22, r14
   1415e:	4e 81       	ldd	r20, Y+6	; 0x06
   14160:	1b df       	rcall	.-458    	; 0x13f98 <readAddress>
   14162:	d8 01       	movw	r26, r16
   14164:	8c 93       	st	X, r24
			}

			i++;
   14166:	ea 85       	ldd	r30, Y+10	; 0x0a
   14168:	fb 85       	ldd	r31, Y+11	; 0x0b
   1416a:	31 96       	adiw	r30, 0x01	; 1
   1416c:	fb 87       	std	Y+11, r31	; 0x0b
   1416e:	ea 87       	std	Y+10, r30	; 0x0a
   14170:	0f 5f       	subi	r16, 0xFF	; 255
   14172:	1f 4f       	sbci	r17, 0xFF	; 255
   14174:	08 94       	sec
   14176:	e1 1c       	adc	r14, r1
   14178:	f1 1c       	adc	r15, r1
		pointer1 = readAddress(0x00, 0x28, socket);
		pointer2 = readAddress(0x00, 0x29, socket);

		uint16_t length = ((dataSize1<<8) | dataSize2);

		while(i < length && i < maxLength)
   1417a:	2a 85       	ldd	r18, Y+10	; 0x0a
   1417c:	3b 85       	ldd	r19, Y+11	; 0x0b
   1417e:	26 15       	cp	r18, r6
   14180:	37 05       	cpc	r19, r7
   14182:	28 f4       	brcc	.+10     	; 0x1418e <getData+0x108>
   14184:	8f 81       	ldd	r24, Y+7	; 0x07
   14186:	98 85       	ldd	r25, Y+8	; 0x08
   14188:	28 17       	cp	r18, r24
   1418a:	39 07       	cpc	r19, r25
   1418c:	b0 f2       	brcs	.-84     	; 0x1413a <getData+0xb4>
				buffer[i] = readAddress((pointer1%8) + ((i+pointer2)>>8) - 0x08, i+pointer2, socket+2);
			}

			i++;
		}
		if (maxLength < length)
   1418e:	ad 81       	ldd	r26, Y+5	; 0x05
   14190:	8a 2f       	mov	r24, r26
   14192:	90 e0       	ldi	r25, 0x00	; 0
   14194:	86 15       	cp	r24, r6
   14196:	97 05       	cpc	r25, r7
   14198:	60 f4       	brcc	.+24     	; 0x141b2 <getData+0x12c>
		{
			writeAddress(0x00, 0x28, (pointer1 + ((i+pointer2)>>8)), socket);
   1419a:	ea 85       	ldd	r30, Y+10	; 0x0a
   1419c:	fb 85       	ldd	r31, Y+11	; 0x0b
   1419e:	4e 0e       	add	r4, r30
   141a0:	5f 1e       	adc	r5, r31
   141a2:	49 2d       	mov	r20, r9
   141a4:	45 0d       	add	r20, r5
   141a6:	80 e0       	ldi	r24, 0x00	; 0
   141a8:	68 e2       	ldi	r22, 0x28	; 40
   141aa:	2b 2d       	mov	r18, r11
   141ac:	ce de       	rcall	.-612    	; 0x13f4a <writeAddress>
			writeAddress(0x00, 0x29, (uint8_t) i+pointer2, socket);
   141ae:	4a 85       	ldd	r20, Y+10	; 0x0a
   141b0:	0a c0       	rjmp	.+20     	; 0x141c6 <getData+0x140>
		}
		else
		{
			writeAddress(0x00, 0x28, (dataSize1+pointer1 + ((dataSize2+pointer2)>>8)), socket);
   141b2:	49 81       	ldd	r20, Y+1	; 0x01
   141b4:	49 0d       	add	r20, r9
   141b6:	2a 0c       	add	r2, r10
   141b8:	31 1c       	adc	r3, r1
   141ba:	43 0d       	add	r20, r3
   141bc:	80 e0       	ldi	r24, 0x00	; 0
   141be:	68 e2       	ldi	r22, 0x28	; 40
   141c0:	2b 2d       	mov	r18, r11
   141c2:	c3 de       	rcall	.-634    	; 0x13f4a <writeAddress>
			writeAddress(0x00, 0x29, (uint8_t) dataSize2+pointer2, socket);
   141c4:	4a 81       	ldd	r20, Y+2	; 0x02
   141c6:	4a 0d       	add	r20, r10
   141c8:	80 e0       	ldi	r24, 0x00	; 0
   141ca:	69 e2       	ldi	r22, 0x29	; 41
   141cc:	2b 2d       	mov	r18, r11
   141ce:	bd de       	rcall	.-646    	; 0x13f4a <writeAddress>
		}

		//Recv command
		writeAddress(0x00, 0x01, 0x40, socket); // Socket Command  Register -> RECV
   141d0:	80 e0       	ldi	r24, 0x00	; 0
   141d2:	61 e0       	ldi	r22, 0x01	; 1
   141d4:	40 e4       	ldi	r20, 0x40	; 64
   141d6:	2b 2d       	mov	r18, r11
   141d8:	b8 de       	rcall	.-656    	; 0x13f4a <writeAddress>
   141da:	02 c0       	rjmp	.+4      	; 0x141e0 <getData+0x15a>
{

    //char LineBuffer[16];

	//get data
	uint16_t i = 0;
   141dc:	1b 86       	std	Y+11, r1	; 0x0b
   141de:	1a 86       	std	Y+10, r1	; 0x0a
		//writeAddress(0x00, 0x01, 0x10, socket);	 // Socket Command  Register -> CLOSE
		//writeAddress(0x00, 0x01, 0x01, 5);	 // Socket Command  Register -> OPEN
        //writeAddress(0x00, 0x01, 0x02, 5);	 // Socket Command  Register -> LISTEN

	}
	buffer[i] = '\0';
   141e0:	eb 81       	ldd	r30, Y+3	; 0x03
   141e2:	fc 81       	ldd	r31, Y+4	; 0x04
   141e4:	ea 84       	ldd	r14, Y+10	; 0x0a
   141e6:	fb 84       	ldd	r15, Y+11	; 0x0b
   141e8:	ee 0d       	add	r30, r14
   141ea:	ff 1d       	adc	r31, r15
   141ec:	10 82       	st	Z, r1

	return i;

}
   141ee:	8a 85       	ldd	r24, Y+10	; 0x0a
   141f0:	9b 85       	ldd	r25, Y+11	; 0x0b
   141f2:	2b 96       	adiw	r28, 0x0b	; 11
   141f4:	0f b6       	in	r0, 0x3f	; 63
   141f6:	f8 94       	cli
   141f8:	de bf       	out	0x3e, r29	; 62
   141fa:	0f be       	out	0x3f, r0	; 63
   141fc:	cd bf       	out	0x3d, r28	; 61
   141fe:	cf 91       	pop	r28
   14200:	df 91       	pop	r29
   14202:	1f 91       	pop	r17
   14204:	0f 91       	pop	r16
   14206:	ff 90       	pop	r15
   14208:	ef 90       	pop	r14
   1420a:	df 90       	pop	r13
   1420c:	cf 90       	pop	r12
   1420e:	bf 90       	pop	r11
   14210:	af 90       	pop	r10
   14212:	9f 90       	pop	r9
   14214:	8f 90       	pop	r8
   14216:	7f 90       	pop	r7
   14218:	6f 90       	pop	r6
   1421a:	5f 90       	pop	r5
   1421c:	4f 90       	pop	r4
   1421e:	3f 90       	pop	r3
   14220:	2f 90       	pop	r2
   14222:	08 95       	ret

00014224 <Init_W5500>:
{
    //uint8_t temp1;
   // uint8_t temp2, temp3, temp4, temp5, temp6;
    //char LineBuffer[16];

    WIZNET_CS_Port_Write |= (1<<WIZNET_CS);      //disable Wiznet module, cs -> 1
   14224:	74 9a       	sbi	0x0e, 4	; 14
    WIZNET_CS_Port_DDR |= WIZNET_CS_Enable;
   14226:	6c 9a       	sbi	0x0d, 4	; 13

  	writeAddress(0x00, 0x01, gw[0],0);          //gateway address
   14228:	80 e0       	ldi	r24, 0x00	; 0
   1422a:	61 e0       	ldi	r22, 0x01	; 1
   1422c:	40 91 4f 09 	lds	r20, 0x094F
   14230:	20 e0       	ldi	r18, 0x00	; 0
   14232:	8b de       	rcall	.-746    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x02, gw[1],0);
   14234:	80 e0       	ldi	r24, 0x00	; 0
   14236:	62 e0       	ldi	r22, 0x02	; 2
   14238:	40 91 50 09 	lds	r20, 0x0950
   1423c:	20 e0       	ldi	r18, 0x00	; 0
   1423e:	85 de       	rcall	.-758    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x03, gw[2],0);
   14240:	80 e0       	ldi	r24, 0x00	; 0
   14242:	63 e0       	ldi	r22, 0x03	; 3
   14244:	40 91 51 09 	lds	r20, 0x0951
   14248:	20 e0       	ldi	r18, 0x00	; 0
   1424a:	7f de       	rcall	.-770    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x04, gw[3],0);
   1424c:	80 e0       	ldi	r24, 0x00	; 0
   1424e:	64 e0       	ldi	r22, 0x04	; 4
   14250:	40 91 52 09 	lds	r20, 0x0952
   14254:	20 e0       	ldi	r18, 0x00	; 0
   14256:	79 de       	rcall	.-782    	; 0x13f4a <writeAddress>
    writeAddress(0x00, 0x05, subnet[0],0);      //subnet address
   14258:	80 e0       	ldi	r24, 0x00	; 0
   1425a:	65 e0       	ldi	r22, 0x05	; 5
   1425c:	40 91 53 09 	lds	r20, 0x0953
   14260:	20 e0       	ldi	r18, 0x00	; 0
   14262:	73 de       	rcall	.-794    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x06, subnet[1],0);
   14264:	80 e0       	ldi	r24, 0x00	; 0
   14266:	66 e0       	ldi	r22, 0x06	; 6
   14268:	40 91 54 09 	lds	r20, 0x0954
   1426c:	20 e0       	ldi	r18, 0x00	; 0
   1426e:	6d de       	rcall	.-806    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x07, subnet[2],0);
   14270:	80 e0       	ldi	r24, 0x00	; 0
   14272:	67 e0       	ldi	r22, 0x07	; 7
   14274:	40 91 55 09 	lds	r20, 0x0955
   14278:	20 e0       	ldi	r18, 0x00	; 0
   1427a:	67 de       	rcall	.-818    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x08, subnet[3],0);
   1427c:	80 e0       	ldi	r24, 0x00	; 0
   1427e:	68 e0       	ldi	r22, 0x08	; 8
   14280:	40 91 56 09 	lds	r20, 0x0956
   14284:	20 e0       	ldi	r18, 0x00	; 0
   14286:	61 de       	rcall	.-830    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x0F, ip[0],0);          //ip address
   14288:	80 e0       	ldi	r24, 0x00	; 0
   1428a:	6f e0       	ldi	r22, 0x0F	; 15
   1428c:	40 91 4b 09 	lds	r20, 0x094B
   14290:	20 e0       	ldi	r18, 0x00	; 0
   14292:	5b de       	rcall	.-842    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x10, ip[1],0);
   14294:	80 e0       	ldi	r24, 0x00	; 0
   14296:	60 e1       	ldi	r22, 0x10	; 16
   14298:	40 91 4c 09 	lds	r20, 0x094C
   1429c:	20 e0       	ldi	r18, 0x00	; 0
   1429e:	55 de       	rcall	.-854    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x11, ip[2],0);
   142a0:	80 e0       	ldi	r24, 0x00	; 0
   142a2:	61 e1       	ldi	r22, 0x11	; 17
   142a4:	40 91 4d 09 	lds	r20, 0x094D
   142a8:	20 e0       	ldi	r18, 0x00	; 0
   142aa:	4f de       	rcall	.-866    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x12, ip[3],0);
   142ac:	80 e0       	ldi	r24, 0x00	; 0
   142ae:	62 e1       	ldi	r22, 0x12	; 18
   142b0:	40 91 4e 09 	lds	r20, 0x094E
   142b4:	20 e0       	ldi	r18, 0x00	; 0
   142b6:	49 de       	rcall	.-878    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x09, mac[0],0);
   142b8:	80 e0       	ldi	r24, 0x00	; 0
   142ba:	69 e0       	ldi	r22, 0x09	; 9
   142bc:	40 91 45 09 	lds	r20, 0x0945
   142c0:	20 e0       	ldi	r18, 0x00	; 0
   142c2:	43 de       	rcall	.-890    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x0A, mac[1],0);
   142c4:	80 e0       	ldi	r24, 0x00	; 0
   142c6:	6a e0       	ldi	r22, 0x0A	; 10
   142c8:	40 91 46 09 	lds	r20, 0x0946
   142cc:	20 e0       	ldi	r18, 0x00	; 0
   142ce:	3d de       	rcall	.-902    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x0B, mac[2],0);
   142d0:	80 e0       	ldi	r24, 0x00	; 0
   142d2:	6b e0       	ldi	r22, 0x0B	; 11
   142d4:	40 91 47 09 	lds	r20, 0x0947
   142d8:	20 e0       	ldi	r18, 0x00	; 0
   142da:	37 de       	rcall	.-914    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x0C, mac[3],0);
   142dc:	80 e0       	ldi	r24, 0x00	; 0
   142de:	6c e0       	ldi	r22, 0x0C	; 12
   142e0:	40 91 48 09 	lds	r20, 0x0948
   142e4:	20 e0       	ldi	r18, 0x00	; 0
   142e6:	31 de       	rcall	.-926    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x0D, mac[4],0);
   142e8:	80 e0       	ldi	r24, 0x00	; 0
   142ea:	6d e0       	ldi	r22, 0x0D	; 13
   142ec:	40 91 49 09 	lds	r20, 0x0949
   142f0:	20 e0       	ldi	r18, 0x00	; 0
   142f2:	2b de       	rcall	.-938    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x0E, mac[5],0);
   142f4:	80 e0       	ldi	r24, 0x00	; 0
   142f6:	6e e0       	ldi	r22, 0x0E	; 14
   142f8:	40 91 4a 09 	lds	r20, 0x094A
   142fc:	20 e0       	ldi	r18, 0x00	; 0
   142fe:	25 de       	rcall	.-950    	; 0x13f4a <writeAddress>
	//Socket 0 Register
	writeAddress(0x00, 0x0C, serverip[0],1);    //server ip address
   14300:	80 e0       	ldi	r24, 0x00	; 0
   14302:	6c e0       	ldi	r22, 0x0C	; 12
   14304:	40 91 57 09 	lds	r20, 0x0957
   14308:	21 e0       	ldi	r18, 0x01	; 1
   1430a:	1f de       	rcall	.-962    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x0D, serverip[1],1);
   1430c:	80 e0       	ldi	r24, 0x00	; 0
   1430e:	6d e0       	ldi	r22, 0x0D	; 13
   14310:	40 91 58 09 	lds	r20, 0x0958
   14314:	21 e0       	ldi	r18, 0x01	; 1
   14316:	19 de       	rcall	.-974    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x0E, serverip[2],1);
   14318:	80 e0       	ldi	r24, 0x00	; 0
   1431a:	6e e0       	ldi	r22, 0x0E	; 14
   1431c:	40 91 59 09 	lds	r20, 0x0959
   14320:	21 e0       	ldi	r18, 0x01	; 1
   14322:	13 de       	rcall	.-986    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x0F, serverip[3],1);
   14324:	80 e0       	ldi	r24, 0x00	; 0
   14326:	6f e0       	ldi	r22, 0x0F	; 15
   14328:	40 91 5a 09 	lds	r20, 0x095A
   1432c:	21 e0       	ldi	r18, 0x01	; 1
   1432e:	0d de       	rcall	.-998    	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x10, destport[0],1);    //server port
   14330:	80 e0       	ldi	r24, 0x00	; 0
   14332:	60 e1       	ldi	r22, 0x10	; 16
   14334:	40 91 5b 09 	lds	r20, 0x095B
   14338:	21 e0       	ldi	r18, 0x01	; 1
   1433a:	07 de       	rcall	.-1010   	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x11, destport[1],1);
   1433c:	80 e0       	ldi	r24, 0x00	; 0
   1433e:	61 e1       	ldi	r22, 0x11	; 17
   14340:	40 91 5c 09 	lds	r20, 0x095C
   14344:	21 e0       	ldi	r18, 0x01	; 1
   14346:	01 de       	rcall	.-1022   	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x04, clientport[0],1);
   14348:	80 e0       	ldi	r24, 0x00	; 0
   1434a:	64 e0       	ldi	r22, 0x04	; 4
   1434c:	40 91 5d 09 	lds	r20, 0x095D
   14350:	21 e0       	ldi	r18, 0x01	; 1
   14352:	fb dd       	rcall	.-1034   	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x05, clientport[1],1);  //client port socket 0
   14354:	80 e0       	ldi	r24, 0x00	; 0
   14356:	65 e0       	ldi	r22, 0x05	; 5
   14358:	40 91 5e 09 	lds	r20, 0x095E
   1435c:	21 e0       	ldi	r18, 0x01	; 1
   1435e:	f5 dd       	rcall	.-1046   	; 0x13f4a <writeAddress>

	writeAddress(0x00, 0x04, clientport[0],5);
   14360:	80 e0       	ldi	r24, 0x00	; 0
   14362:	64 e0       	ldi	r22, 0x04	; 4
   14364:	40 91 5d 09 	lds	r20, 0x095D
   14368:	25 e0       	ldi	r18, 0x05	; 5
   1436a:	ef dd       	rcall	.-1058   	; 0x13f4a <writeAddress>
	writeAddress(0x00, 0x05, clientport[1],5);  //client port socket 1
   1436c:	80 e0       	ldi	r24, 0x00	; 0
   1436e:	65 e0       	ldi	r22, 0x05	; 5
   14370:	40 91 5e 09 	lds	r20, 0x095E
   14374:	25 e0       	ldi	r18, 0x05	; 5
   14376:	e9 dd       	rcall	.-1070   	; 0x13f4a <writeAddress>

    sprintf (LineBuffer, "Mac: %X.%X.%X.%X.%X.%X", temp1,temp2, temp3, temp4, temp5, temp6);
    Serial_SendString(LineBuffer);
    Serial_SendString("\n");*/

    writeAddress(0x00, 0x00, 0x01,1);	 // Socket 0 Mode Register
   14378:	80 e0       	ldi	r24, 0x00	; 0
   1437a:	60 e0       	ldi	r22, 0x00	; 0
   1437c:	41 e0       	ldi	r20, 0x01	; 1
   1437e:	21 e0       	ldi	r18, 0x01	; 1
   14380:	e4 dd       	rcall	.-1080   	; 0x13f4a <writeAddress>
   	writeAddress(0x00, 0x00, 0x01,5);	 // Socket 1 Mode Register
   14382:	80 e0       	ldi	r24, 0x00	; 0
   14384:	60 e0       	ldi	r22, 0x00	; 0
   14386:	41 e0       	ldi	r20, 0x01	; 1
   14388:	25 e0       	ldi	r18, 0x05	; 5
   1438a:	df dd       	rcall	.-1090   	; 0x13f4a <writeAddress>
    writeAddress(0x00, 0x01, 0x01, 5);	 // Socket Command  Register -> OPEN
   1438c:	80 e0       	ldi	r24, 0x00	; 0
   1438e:	61 e0       	ldi	r22, 0x01	; 1
   14390:	41 e0       	ldi	r20, 0x01	; 1
   14392:	25 e0       	ldi	r18, 0x05	; 5
   14394:	da dd       	rcall	.-1100   	; 0x13f4a <writeAddress>
    writeAddress(0x00, 0x01, 0x02, 5);	 // Socket Command  Register -> LISTEN
   14396:	80 e0       	ldi	r24, 0x00	; 0
   14398:	61 e0       	ldi	r22, 0x01	; 1
   1439a:	42 e0       	ldi	r20, 0x02	; 2
   1439c:	25 e0       	ldi	r18, 0x05	; 5
    //Serial_Disable();

    //writeAddress(0x00, 0x2E, 0xF6,0);	 // Wiznet PowerDown Mode
    //writeAddress(0x00, 0x2E, 0x76,0);	 // Wiznet Reset

}
   1439e:	d5 cd       	rjmp	.-1110   	; 0x13f4a <writeAddress>

000143a0 <Endpoint_Null_Stream>:

uint8_t Endpoint_Null_Stream(uint16_t Length,
                             uint16_t* const BytesProcessed)
{
   143a0:	df 92       	push	r13
   143a2:	ef 92       	push	r14
   143a4:	ff 92       	push	r15
   143a6:	0f 93       	push	r16
   143a8:	1f 93       	push	r17
   143aa:	cf 93       	push	r28
   143ac:	df 93       	push	r29
   143ae:	ec 01       	movw	r28, r24
   143b0:	8b 01       	movw	r16, r22
	uint8_t  ErrorCode;
	uint16_t BytesInTransfer = 0;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
   143b2:	da d2       	rcall	.+1460   	; 0x14968 <Endpoint_WaitUntilReady>
   143b4:	d8 2e       	mov	r13, r24
   143b6:	88 23       	and	r24, r24
   143b8:	79 f5       	brne	.+94     	; 0x14418 <Endpoint_Null_Stream+0x78>
	  return ErrorCode;

	if (BytesProcessed != NULL)
   143ba:	01 15       	cp	r16, r1
   143bc:	11 05       	cpc	r17, r1
   143be:	29 f0       	breq	.+10     	; 0x143ca <Endpoint_Null_Stream+0x2a>
	  Length -= *BytesProcessed;
   143c0:	f8 01       	movw	r30, r16
   143c2:	20 81       	ld	r18, Z
   143c4:	31 81       	ldd	r19, Z+1	; 0x01
   143c6:	c2 1b       	sub	r28, r18
   143c8:	d3 0b       	sbc	r29, r19
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t Endpoint_Null_Stream(uint16_t Length,
                             uint16_t* const BytesProcessed)
{
   143ca:	ee 24       	eor	r14, r14
   143cc:	ff 24       	eor	r15, r15
   143ce:	20 c0       	rjmp	.+64     	; 0x14410 <Endpoint_Null_Stream+0x70>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
   143d0:	80 91 e8 00 	lds	r24, 0x00E8
	if (BytesProcessed != NULL)
	  Length -= *BytesProcessed;

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
   143d4:	85 fd       	sbrc	r24, 5
   143d6:	16 c0       	rjmp	.+44     	; 0x14404 <Endpoint_Null_Stream+0x64>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   143d8:	80 91 e8 00 	lds	r24, 0x00E8
   143dc:	8e 77       	andi	r24, 0x7E	; 126
   143de:	80 93 e8 00 	sts	0x00E8, r24
		{
			Endpoint_ClearIN();

			if (BytesProcessed != NULL)
   143e2:	01 15       	cp	r16, r1
   143e4:	11 05       	cpc	r17, r1
   143e6:	51 f0       	breq	.+20     	; 0x143fc <Endpoint_Null_Stream+0x5c>
			{
				*BytesProcessed += BytesInTransfer;
   143e8:	f8 01       	movw	r30, r16
   143ea:	80 81       	ld	r24, Z
   143ec:	91 81       	ldd	r25, Z+1	; 0x01
   143ee:	8e 0d       	add	r24, r14
   143f0:	9f 1d       	adc	r25, r15
   143f2:	91 83       	std	Z+1, r25	; 0x01
   143f4:	80 83       	st	Z, r24
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
   143f6:	95 e0       	ldi	r25, 0x05	; 5
   143f8:	d9 2e       	mov	r13, r25
   143fa:	0e c0       	rjmp	.+28     	; 0x14418 <Endpoint_Null_Stream+0x78>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
   143fc:	b5 d2       	rcall	.+1386   	; 0x14968 <Endpoint_WaitUntilReady>
   143fe:	88 23       	and	r24, r24
   14400:	39 f0       	breq	.+14     	; 0x14410 <Endpoint_Null_Stream+0x70>
   14402:	09 c0       	rjmp	.+18     	; 0x14416 <Endpoint_Null_Stream+0x76>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
   14404:	10 92 f1 00 	sts	0x00F1, r1
		}
		else
		{
			Endpoint_Write_8(0);

			Length--;
   14408:	21 97       	sbiw	r28, 0x01	; 1
			BytesInTransfer++;
   1440a:	08 94       	sec
   1440c:	e1 1c       	adc	r14, r1
   1440e:	f1 1c       	adc	r15, r1
	  return ErrorCode;

	if (BytesProcessed != NULL)
	  Length -= *BytesProcessed;

	while (Length)
   14410:	20 97       	sbiw	r28, 0x00	; 0
   14412:	f1 f6       	brne	.-68     	; 0x143d0 <Endpoint_Null_Stream+0x30>
   14414:	01 c0       	rjmp	.+2      	; 0x14418 <Endpoint_Null_Stream+0x78>
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
   14416:	d8 2e       	mov	r13, r24
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
   14418:	8d 2d       	mov	r24, r13
   1441a:	df 91       	pop	r29
   1441c:	cf 91       	pop	r28
   1441e:	1f 91       	pop	r17
   14420:	0f 91       	pop	r16
   14422:	ff 90       	pop	r15
   14424:	ef 90       	pop	r14
   14426:	df 90       	pop	r13
   14428:	08 95       	ret

0001442a <Endpoint_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
   1442a:	8f 92       	push	r8
   1442c:	9f 92       	push	r9
   1442e:	bf 92       	push	r11
   14430:	cf 92       	push	r12
   14432:	df 92       	push	r13
   14434:	ef 92       	push	r14
   14436:	ff 92       	push	r15
   14438:	0f 93       	push	r16
   1443a:	1f 93       	push	r17
   1443c:	df 93       	push	r29
   1443e:	cf 93       	push	r28
   14440:	0f 92       	push	r0
   14442:	cd b7       	in	r28, 0x3d	; 61
   14444:	de b7       	in	r29, 0x3e	; 62
   14446:	e8 2e       	mov	r14, r24
   14448:	4b 01       	movw	r8, r22
   1444a:	8a 01       	movw	r16, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
   1444c:	99 83       	std	Y+1, r25	; 0x01
   1444e:	8c d2       	rcall	.+1304   	; 0x14968 <Endpoint_WaitUntilReady>
   14450:	b8 2e       	mov	r11, r24
   14452:	99 81       	ldd	r25, Y+1	; 0x01
   14454:	88 23       	and	r24, r24
   14456:	c1 f5       	brne	.+112    	; 0x144c8 <Endpoint_Write_Stream_LE+0x9e>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
   14458:	f9 2e       	mov	r15, r25
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
   1445a:	01 15       	cp	r16, r1
   1445c:	11 05       	cpc	r17, r1
   1445e:	39 f0       	breq	.+14     	; 0x1446e <Endpoint_Write_Stream_LE+0x44>
	{
		Length -= *BytesProcessed;
   14460:	f8 01       	movw	r30, r16
   14462:	20 81       	ld	r18, Z
   14464:	31 81       	ldd	r19, Z+1	; 0x01
   14466:	82 1a       	sub	r8, r18
   14468:	93 0a       	sbc	r9, r19
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
   1446a:	e2 0e       	add	r14, r18
   1446c:	f3 1e       	adc	r15, r19
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
   1446e:	cc 24       	eor	r12, r12
   14470:	dd 24       	eor	r13, r13
   14472:	25 c0       	rjmp	.+74     	; 0x144be <Endpoint_Write_Stream_LE+0x94>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
   14474:	80 91 e8 00 	lds	r24, 0x00E8
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
   14478:	85 fd       	sbrc	r24, 5
   1447a:	16 c0       	rjmp	.+44     	; 0x144a8 <Endpoint_Write_Stream_LE+0x7e>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   1447c:	80 91 e8 00 	lds	r24, 0x00E8
   14480:	8e 77       	andi	r24, 0x7E	; 126
   14482:	80 93 e8 00 	sts	0x00E8, r24

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if (BytesProcessed != NULL)
   14486:	01 15       	cp	r16, r1
   14488:	11 05       	cpc	r17, r1
   1448a:	51 f0       	breq	.+20     	; 0x144a0 <Endpoint_Write_Stream_LE+0x76>
			{
				*BytesProcessed += BytesInTransfer;
   1448c:	f8 01       	movw	r30, r16
   1448e:	80 81       	ld	r24, Z
   14490:	91 81       	ldd	r25, Z+1	; 0x01
   14492:	8c 0d       	add	r24, r12
   14494:	9d 1d       	adc	r25, r13
   14496:	91 83       	std	Z+1, r25	; 0x01
   14498:	80 83       	st	Z, r24
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
   1449a:	25 e0       	ldi	r18, 0x05	; 5
   1449c:	b2 2e       	mov	r11, r18
   1449e:	14 c0       	rjmp	.+40     	; 0x144c8 <Endpoint_Write_Stream_LE+0x9e>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
   144a0:	63 d2       	rcall	.+1222   	; 0x14968 <Endpoint_WaitUntilReady>
   144a2:	88 23       	and	r24, r24
   144a4:	61 f0       	breq	.+24     	; 0x144be <Endpoint_Write_Stream_LE+0x94>
   144a6:	0f c0       	rjmp	.+30     	; 0x144c6 <Endpoint_Write_Stream_LE+0x9c>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
   144a8:	f7 01       	movw	r30, r14
   144aa:	81 91       	ld	r24, Z+
   144ac:	7f 01       	movw	r14, r30
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
   144ae:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
   144b2:	08 94       	sec
   144b4:	81 08       	sbc	r8, r1
   144b6:	91 08       	sbc	r9, r1
			BytesInTransfer++;
   144b8:	08 94       	sec
   144ba:	c1 1c       	adc	r12, r1
   144bc:	d1 1c       	adc	r13, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
   144be:	81 14       	cp	r8, r1
   144c0:	91 04       	cpc	r9, r1
   144c2:	c1 f6       	brne	.-80     	; 0x14474 <Endpoint_Write_Stream_LE+0x4a>
   144c4:	01 c0       	rjmp	.+2      	; 0x144c8 <Endpoint_Write_Stream_LE+0x9e>
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
   144c6:	b8 2e       	mov	r11, r24
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
   144c8:	8b 2d       	mov	r24, r11
   144ca:	0f 90       	pop	r0
   144cc:	cf 91       	pop	r28
   144ce:	df 91       	pop	r29
   144d0:	1f 91       	pop	r17
   144d2:	0f 91       	pop	r16
   144d4:	ff 90       	pop	r15
   144d6:	ef 90       	pop	r14
   144d8:	df 90       	pop	r13
   144da:	cf 90       	pop	r12
   144dc:	bf 90       	pop	r11
   144de:	9f 90       	pop	r9
   144e0:	8f 90       	pop	r8
   144e2:	08 95       	ret

000144e4 <Endpoint_Write_Stream_BE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
   144e4:	bf 92       	push	r11
   144e6:	cf 92       	push	r12
   144e8:	df 92       	push	r13
   144ea:	ef 92       	push	r14
   144ec:	ff 92       	push	r15
   144ee:	0f 93       	push	r16
   144f0:	1f 93       	push	r17
   144f2:	cf 93       	push	r28
   144f4:	df 93       	push	r29
   144f6:	6c 01       	movw	r12, r24
   144f8:	eb 01       	movw	r28, r22
   144fa:	7a 01       	movw	r14, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
   144fc:	35 d2       	rcall	.+1130   	; 0x14968 <Endpoint_WaitUntilReady>
   144fe:	b8 2e       	mov	r11, r24
   14500:	88 23       	and	r24, r24
   14502:	d1 f5       	brne	.+116    	; 0x14578 <Endpoint_Write_Stream_BE+0x94>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
   14504:	8e 01       	movw	r16, r28
   14506:	01 50       	subi	r16, 0x01	; 1
   14508:	10 40       	sbci	r17, 0x00	; 0
   1450a:	0c 0d       	add	r16, r12
   1450c:	1d 1d       	adc	r17, r13
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
   1450e:	e1 14       	cp	r14, r1
   14510:	f1 04       	cpc	r15, r1
   14512:	39 f0       	breq	.+14     	; 0x14522 <Endpoint_Write_Stream_BE+0x3e>
	{
		Length -= *BytesProcessed;
   14514:	f7 01       	movw	r30, r14
   14516:	20 81       	ld	r18, Z
   14518:	31 81       	ldd	r19, Z+1	; 0x01
   1451a:	c2 1b       	sub	r28, r18
   1451c:	d3 0b       	sbc	r29, r19
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
   1451e:	02 1b       	sub	r16, r18
   14520:	13 0b       	sbc	r17, r19
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
   14522:	cc 24       	eor	r12, r12
   14524:	dd 24       	eor	r13, r13
   14526:	24 c0       	rjmp	.+72     	; 0x14570 <Endpoint_Write_Stream_BE+0x8c>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
   14528:	80 91 e8 00 	lds	r24, 0x00E8
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
   1452c:	85 fd       	sbrc	r24, 5
   1452e:	16 c0       	rjmp	.+44     	; 0x1455c <Endpoint_Write_Stream_BE+0x78>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   14530:	80 91 e8 00 	lds	r24, 0x00E8
   14534:	8e 77       	andi	r24, 0x7E	; 126
   14536:	80 93 e8 00 	sts	0x00E8, r24

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if (BytesProcessed != NULL)
   1453a:	e1 14       	cp	r14, r1
   1453c:	f1 04       	cpc	r15, r1
   1453e:	51 f0       	breq	.+20     	; 0x14554 <Endpoint_Write_Stream_BE+0x70>
			{
				*BytesProcessed += BytesInTransfer;
   14540:	f7 01       	movw	r30, r14
   14542:	80 81       	ld	r24, Z
   14544:	91 81       	ldd	r25, Z+1	; 0x01
   14546:	8c 0d       	add	r24, r12
   14548:	9d 1d       	adc	r25, r13
   1454a:	91 83       	std	Z+1, r25	; 0x01
   1454c:	80 83       	st	Z, r24
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
   1454e:	35 e0       	ldi	r19, 0x05	; 5
   14550:	b3 2e       	mov	r11, r19
   14552:	12 c0       	rjmp	.+36     	; 0x14578 <Endpoint_Write_Stream_BE+0x94>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
   14554:	09 d2       	rcall	.+1042   	; 0x14968 <Endpoint_WaitUntilReady>
   14556:	88 23       	and	r24, r24
   14558:	59 f0       	breq	.+22     	; 0x14570 <Endpoint_Write_Stream_BE+0x8c>
   1455a:	0d c0       	rjmp	.+26     	; 0x14576 <Endpoint_Write_Stream_BE+0x92>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
   1455c:	f8 01       	movw	r30, r16
   1455e:	80 81       	ld	r24, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
   14560:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
   14564:	01 50       	subi	r16, 0x01	; 1
   14566:	10 40       	sbci	r17, 0x00	; 0
			Length--;
   14568:	21 97       	sbiw	r28, 0x01	; 1
			BytesInTransfer++;
   1456a:	08 94       	sec
   1456c:	c1 1c       	adc	r12, r1
   1456e:	d1 1c       	adc	r13, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
   14570:	20 97       	sbiw	r28, 0x00	; 0
   14572:	d1 f6       	brne	.-76     	; 0x14528 <Endpoint_Write_Stream_BE+0x44>
   14574:	01 c0       	rjmp	.+2      	; 0x14578 <Endpoint_Write_Stream_BE+0x94>
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
   14576:	b8 2e       	mov	r11, r24
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
   14578:	8b 2d       	mov	r24, r11
   1457a:	df 91       	pop	r29
   1457c:	cf 91       	pop	r28
   1457e:	1f 91       	pop	r17
   14580:	0f 91       	pop	r16
   14582:	ff 90       	pop	r15
   14584:	ef 90       	pop	r14
   14586:	df 90       	pop	r13
   14588:	cf 90       	pop	r12
   1458a:	bf 90       	pop	r11
   1458c:	08 95       	ret

0001458e <Endpoint_Read_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
   1458e:	8f 92       	push	r8
   14590:	9f 92       	push	r9
   14592:	bf 92       	push	r11
   14594:	cf 92       	push	r12
   14596:	df 92       	push	r13
   14598:	ef 92       	push	r14
   1459a:	ff 92       	push	r15
   1459c:	0f 93       	push	r16
   1459e:	1f 93       	push	r17
   145a0:	df 93       	push	r29
   145a2:	cf 93       	push	r28
   145a4:	0f 92       	push	r0
   145a6:	cd b7       	in	r28, 0x3d	; 61
   145a8:	de b7       	in	r29, 0x3e	; 62
   145aa:	e8 2e       	mov	r14, r24
   145ac:	4b 01       	movw	r8, r22
   145ae:	8a 01       	movw	r16, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
   145b0:	99 83       	std	Y+1, r25	; 0x01
   145b2:	da d1       	rcall	.+948    	; 0x14968 <Endpoint_WaitUntilReady>
   145b4:	b8 2e       	mov	r11, r24
   145b6:	99 81       	ldd	r25, Y+1	; 0x01
   145b8:	88 23       	and	r24, r24
   145ba:	c1 f5       	brne	.+112    	; 0x1462c <Endpoint_Read_Stream_LE+0x9e>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
   145bc:	f9 2e       	mov	r15, r25
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
   145be:	01 15       	cp	r16, r1
   145c0:	11 05       	cpc	r17, r1
   145c2:	39 f0       	breq	.+14     	; 0x145d2 <Endpoint_Read_Stream_LE+0x44>
	{
		Length -= *BytesProcessed;
   145c4:	f8 01       	movw	r30, r16
   145c6:	20 81       	ld	r18, Z
   145c8:	31 81       	ldd	r19, Z+1	; 0x01
   145ca:	82 1a       	sub	r8, r18
   145cc:	93 0a       	sbc	r9, r19
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
   145ce:	e2 0e       	add	r14, r18
   145d0:	f3 1e       	adc	r15, r19
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
   145d2:	cc 24       	eor	r12, r12
   145d4:	dd 24       	eor	r13, r13
   145d6:	25 c0       	rjmp	.+74     	; 0x14622 <Endpoint_Read_Stream_LE+0x94>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
   145d8:	80 91 e8 00 	lds	r24, 0x00E8
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
   145dc:	85 fd       	sbrc	r24, 5
   145de:	16 c0       	rjmp	.+44     	; 0x1460c <Endpoint_Read_Stream_LE+0x7e>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
   145e0:	80 91 e8 00 	lds	r24, 0x00E8
   145e4:	8b 77       	andi	r24, 0x7B	; 123
   145e6:	80 93 e8 00 	sts	0x00E8, r24

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if (BytesProcessed != NULL)
   145ea:	01 15       	cp	r16, r1
   145ec:	11 05       	cpc	r17, r1
   145ee:	51 f0       	breq	.+20     	; 0x14604 <Endpoint_Read_Stream_LE+0x76>
			{
				*BytesProcessed += BytesInTransfer;
   145f0:	f8 01       	movw	r30, r16
   145f2:	80 81       	ld	r24, Z
   145f4:	91 81       	ldd	r25, Z+1	; 0x01
   145f6:	8c 0d       	add	r24, r12
   145f8:	9d 1d       	adc	r25, r13
   145fa:	91 83       	std	Z+1, r25	; 0x01
   145fc:	80 83       	st	Z, r24
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
   145fe:	45 e0       	ldi	r20, 0x05	; 5
   14600:	b4 2e       	mov	r11, r20
   14602:	14 c0       	rjmp	.+40     	; 0x1462c <Endpoint_Read_Stream_LE+0x9e>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
   14604:	b1 d1       	rcall	.+866    	; 0x14968 <Endpoint_WaitUntilReady>
   14606:	88 23       	and	r24, r24
   14608:	61 f0       	breq	.+24     	; 0x14622 <Endpoint_Read_Stream_LE+0x94>
   1460a:	0f c0       	rjmp	.+30     	; 0x1462a <Endpoint_Read_Stream_LE+0x9c>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
   1460c:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
   14610:	f7 01       	movw	r30, r14
   14612:	81 93       	st	Z+, r24
   14614:	7f 01       	movw	r14, r30
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
   14616:	08 94       	sec
   14618:	81 08       	sbc	r8, r1
   1461a:	91 08       	sbc	r9, r1
			BytesInTransfer++;
   1461c:	08 94       	sec
   1461e:	c1 1c       	adc	r12, r1
   14620:	d1 1c       	adc	r13, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
   14622:	81 14       	cp	r8, r1
   14624:	91 04       	cpc	r9, r1
   14626:	c1 f6       	brne	.-80     	; 0x145d8 <Endpoint_Read_Stream_LE+0x4a>
   14628:	01 c0       	rjmp	.+2      	; 0x1462c <Endpoint_Read_Stream_LE+0x9e>
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
   1462a:	b8 2e       	mov	r11, r24
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
   1462c:	8b 2d       	mov	r24, r11
   1462e:	0f 90       	pop	r0
   14630:	cf 91       	pop	r28
   14632:	df 91       	pop	r29
   14634:	1f 91       	pop	r17
   14636:	0f 91       	pop	r16
   14638:	ff 90       	pop	r15
   1463a:	ef 90       	pop	r14
   1463c:	df 90       	pop	r13
   1463e:	cf 90       	pop	r12
   14640:	bf 90       	pop	r11
   14642:	9f 90       	pop	r9
   14644:	8f 90       	pop	r8
   14646:	08 95       	ret

00014648 <Endpoint_Write_Control_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
   14648:	28 2f       	mov	r18, r24
   1464a:	39 2f       	mov	r19, r25
   1464c:	f9 01       	movw	r30, r18
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
   1464e:	80 91 1f 14 	lds	r24, 0x141F
   14652:	90 91 20 14 	lds	r25, 0x1420
   14656:	86 17       	cp	r24, r22
   14658:	97 07       	cpc	r25, r23
   1465a:	18 f4       	brcc	.+6      	; 0x14662 <Endpoint_Write_Control_Stream_LE+0x1a>
   1465c:	bc 01       	movw	r22, r24
   1465e:	20 e0       	ldi	r18, 0x00	; 0
   14660:	35 c0       	rjmp	.+106    	; 0x146cc <Endpoint_Write_Control_Stream_LE+0x84>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
   14662:	61 15       	cp	r22, r1
   14664:	71 05       	cpc	r23, r1
   14666:	d9 f7       	brne	.-10     	; 0x1465e <Endpoint_Write_Control_Stream_LE+0x16>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   14668:	80 91 e8 00 	lds	r24, 0x00E8
   1466c:	8e 77       	andi	r24, 0x7E	; 126
   1466e:	80 93 e8 00 	sts	0x00E8, r24
   14672:	f5 cf       	rjmp	.-22     	; 0x1465e <Endpoint_Write_Control_Stream_LE+0x16>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
   14674:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
   14676:	88 23       	and	r24, r24
   14678:	f1 f1       	breq	.+124    	; 0x146f6 <Endpoint_Write_Control_Stream_LE+0xae>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
   1467a:	85 30       	cpi	r24, 0x05	; 5
   1467c:	c1 f1       	breq	.+112    	; 0x146ee <Endpoint_Write_Control_Stream_LE+0xa6>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
   1467e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
   14682:	83 fd       	sbrc	r24, 3
   14684:	36 c0       	rjmp	.+108    	; 0x146f2 <Endpoint_Write_Control_Stream_LE+0xaa>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
   14686:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
   1468a:	82 fd       	sbrc	r24, 2
   1468c:	2a c0       	rjmp	.+84     	; 0x146e2 <Endpoint_Write_Control_Stream_LE+0x9a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
   1468e:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
   14692:	80 ff       	sbrs	r24, 0
   14694:	1b c0       	rjmp	.+54     	; 0x146cc <Endpoint_Write_Control_Stream_LE+0x84>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
   14696:	80 91 f2 00 	lds	r24, 0x00F2
   1469a:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
   1469e:	06 c0       	rjmp	.+12     	; 0x146ac <Endpoint_Write_Control_Stream_LE+0x64>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
   146a0:	21 91       	ld	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
   146a2:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
   146a6:	61 50       	subi	r22, 0x01	; 1
   146a8:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
   146aa:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
   146ac:	61 15       	cp	r22, r1
   146ae:	71 05       	cpc	r23, r1
   146b0:	19 f0       	breq	.+6      	; 0x146b8 <Endpoint_Write_Control_Stream_LE+0x70>
   146b2:	88 30       	cpi	r24, 0x08	; 8
   146b4:	91 05       	cpc	r25, r1
   146b6:	a0 f3       	brcs	.-24     	; 0x146a0 <Endpoint_Write_Control_Stream_LE+0x58>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
   146b8:	21 e0       	ldi	r18, 0x01	; 1
   146ba:	88 30       	cpi	r24, 0x08	; 8
   146bc:	91 05       	cpc	r25, r1
   146be:	09 f0       	breq	.+2      	; 0x146c2 <Endpoint_Write_Control_Stream_LE+0x7a>
   146c0:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   146c2:	80 91 e8 00 	lds	r24, 0x00E8
   146c6:	8e 77       	andi	r24, 0x7E	; 126
   146c8:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
   146cc:	61 15       	cp	r22, r1
   146ce:	71 05       	cpc	r23, r1
   146d0:	89 f6       	brne	.-94     	; 0x14674 <Endpoint_Write_Control_Stream_LE+0x2c>
   146d2:	22 23       	and	r18, r18
   146d4:	79 f6       	brne	.-98     	; 0x14674 <Endpoint_Write_Control_Stream_LE+0x2c>
   146d6:	05 c0       	rjmp	.+10     	; 0x146e2 <Endpoint_Write_Control_Stream_LE+0x9a>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
   146d8:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
   146da:	88 23       	and	r24, r24
   146dc:	61 f0       	breq	.+24     	; 0x146f6 <Endpoint_Write_Control_Stream_LE+0xae>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
   146de:	85 30       	cpi	r24, 0x05	; 5
   146e0:	61 f0       	breq	.+24     	; 0x146fa <Endpoint_Write_Control_Stream_LE+0xb2>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
   146e2:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
   146e6:	82 ff       	sbrs	r24, 2
   146e8:	f7 cf       	rjmp	.-18     	; 0x146d8 <Endpoint_Write_Control_Stream_LE+0x90>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
   146ea:	80 e0       	ldi	r24, 0x00	; 0
   146ec:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
   146ee:	83 e0       	ldi	r24, 0x03	; 3
   146f0:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
   146f2:	81 e0       	ldi	r24, 0x01	; 1
   146f4:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
   146f6:	82 e0       	ldi	r24, 0x02	; 2
   146f8:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
   146fa:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
   146fc:	08 95       	ret

000146fe <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
   146fe:	61 15       	cp	r22, r1
   14700:	71 05       	cpc	r23, r1
   14702:	29 f5       	brne	.+74     	; 0x1474e <Endpoint_Read_Control_Stream_LE+0x50>
   14704:	1f c0       	rjmp	.+62     	; 0x14744 <Endpoint_Read_Control_Stream_LE+0x46>
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
   14706:	2e b3       	in	r18, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
   14708:	22 23       	and	r18, r18
   1470a:	a1 f1       	breq	.+104    	; 0x14774 <Endpoint_Read_Control_Stream_LE+0x76>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
   1470c:	25 30       	cpi	r18, 0x05	; 5
   1470e:	71 f1       	breq	.+92     	; 0x1476c <Endpoint_Read_Control_Stream_LE+0x6e>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
   14710:	20 91 e8 00 	lds	r18, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
   14714:	23 fd       	sbrc	r18, 3
   14716:	2c c0       	rjmp	.+88     	; 0x14770 <Endpoint_Read_Control_Stream_LE+0x72>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
   14718:	20 91 e8 00 	lds	r18, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
   1471c:	22 ff       	sbrs	r18, 2
   1471e:	f3 cf       	rjmp	.-26     	; 0x14706 <Endpoint_Read_Control_Stream_LE+0x8>
   14720:	e8 2f       	mov	r30, r24
   14722:	f9 2f       	mov	r31, r25
   14724:	07 c0       	rjmp	.+14     	; 0x14734 <Endpoint_Read_Control_Stream_LE+0x36>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
   14726:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
   1472a:	81 93       	st	Z+, r24
   1472c:	cf 01       	movw	r24, r30
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
   1472e:	61 50       	subi	r22, 0x01	; 1
   14730:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
   14732:	41 f0       	breq	.+16     	; 0x14744 <Endpoint_Read_Control_Stream_LE+0x46>
   14734:	cf 01       	movw	r24, r30
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
   14736:	20 91 f2 00 	lds	r18, 0x00F2
   1473a:	30 91 f3 00 	lds	r19, 0x00F3
   1473e:	21 15       	cp	r18, r1
   14740:	31 05       	cpc	r19, r1
   14742:	89 f7       	brne	.-30     	; 0x14726 <Endpoint_Read_Control_Stream_LE+0x28>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
   14744:	20 91 e8 00 	lds	r18, 0x00E8
   14748:	2b 77       	andi	r18, 0x7B	; 123
   1474a:	20 93 e8 00 	sts	0x00E8, r18
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
   1474e:	61 15       	cp	r22, r1
   14750:	71 05       	cpc	r23, r1
   14752:	c9 f6       	brne	.-78     	; 0x14706 <Endpoint_Read_Control_Stream_LE+0x8>
   14754:	05 c0       	rjmp	.+10     	; 0x14760 <Endpoint_Read_Control_Stream_LE+0x62>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
   14756:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
   14758:	88 23       	and	r24, r24
   1475a:	61 f0       	breq	.+24     	; 0x14774 <Endpoint_Read_Control_Stream_LE+0x76>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
   1475c:	85 30       	cpi	r24, 0x05	; 5
   1475e:	61 f0       	breq	.+24     	; 0x14778 <Endpoint_Read_Control_Stream_LE+0x7a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
   14760:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
   14764:	80 ff       	sbrs	r24, 0
   14766:	f7 cf       	rjmp	.-18     	; 0x14756 <Endpoint_Read_Control_Stream_LE+0x58>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
   14768:	80 e0       	ldi	r24, 0x00	; 0
   1476a:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
   1476c:	83 e0       	ldi	r24, 0x03	; 3
   1476e:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
   14770:	81 e0       	ldi	r24, 0x01	; 1
   14772:	08 95       	ret
	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
   14774:	82 e0       	ldi	r24, 0x02	; 2
   14776:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
   14778:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
   1477a:	08 95       	ret

0001477c <Endpoint_Write_Control_PStream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
   1477c:	e8 2f       	mov	r30, r24
   1477e:	f9 2f       	mov	r31, r25
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
   14780:	80 91 1f 14 	lds	r24, 0x141F
   14784:	90 91 20 14 	lds	r25, 0x1420
   14788:	86 17       	cp	r24, r22
   1478a:	97 07       	cpc	r25, r23
   1478c:	18 f4       	brcc	.+6      	; 0x14794 <Endpoint_Write_Control_PStream_LE+0x18>
   1478e:	bc 01       	movw	r22, r24
   14790:	20 e0       	ldi	r18, 0x00	; 0
   14792:	37 c0       	rjmp	.+110    	; 0x14802 <Endpoint_Write_Control_PStream_LE+0x86>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
   14794:	61 15       	cp	r22, r1
   14796:	71 05       	cpc	r23, r1
   14798:	d9 f7       	brne	.-10     	; 0x14790 <Endpoint_Write_Control_PStream_LE+0x14>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   1479a:	80 91 e8 00 	lds	r24, 0x00E8
   1479e:	8e 77       	andi	r24, 0x7E	; 126
   147a0:	80 93 e8 00 	sts	0x00E8, r24
   147a4:	f5 cf       	rjmp	.-22     	; 0x14790 <Endpoint_Write_Control_PStream_LE+0x14>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
   147a6:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
   147a8:	88 23       	and	r24, r24
   147aa:	09 f4       	brne	.+2      	; 0x147ae <Endpoint_Write_Control_PStream_LE+0x32>
   147ac:	3f c0       	rjmp	.+126    	; 0x1482c <Endpoint_Write_Control_PStream_LE+0xb0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
   147ae:	85 30       	cpi	r24, 0x05	; 5
   147b0:	c9 f1       	breq	.+114    	; 0x14824 <Endpoint_Write_Control_PStream_LE+0xa8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
   147b2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
   147b6:	83 fd       	sbrc	r24, 3
   147b8:	37 c0       	rjmp	.+110    	; 0x14828 <Endpoint_Write_Control_PStream_LE+0xac>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
   147ba:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
   147be:	82 fd       	sbrc	r24, 2
   147c0:	2b c0       	rjmp	.+86     	; 0x14818 <Endpoint_Write_Control_PStream_LE+0x9c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
   147c2:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
   147c6:	80 ff       	sbrs	r24, 0
   147c8:	1c c0       	rjmp	.+56     	; 0x14802 <Endpoint_Write_Control_PStream_LE+0x86>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
   147ca:	80 91 f2 00 	lds	r24, 0x00F2
   147ce:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
   147d2:	07 c0       	rjmp	.+14     	; 0x147e2 <Endpoint_Write_Control_PStream_LE+0x66>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
   147d4:	24 91       	lpm	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
   147d6:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
   147da:	31 96       	adiw	r30, 0x01	; 1
				Length--;
   147dc:	61 50       	subi	r22, 0x01	; 1
   147de:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
   147e0:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
   147e2:	61 15       	cp	r22, r1
   147e4:	71 05       	cpc	r23, r1
   147e6:	19 f0       	breq	.+6      	; 0x147ee <Endpoint_Write_Control_PStream_LE+0x72>
   147e8:	88 30       	cpi	r24, 0x08	; 8
   147ea:	91 05       	cpc	r25, r1
   147ec:	98 f3       	brcs	.-26     	; 0x147d4 <Endpoint_Write_Control_PStream_LE+0x58>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
   147ee:	21 e0       	ldi	r18, 0x01	; 1
   147f0:	88 30       	cpi	r24, 0x08	; 8
   147f2:	91 05       	cpc	r25, r1
   147f4:	09 f0       	breq	.+2      	; 0x147f8 <Endpoint_Write_Control_PStream_LE+0x7c>
   147f6:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   147f8:	80 91 e8 00 	lds	r24, 0x00E8
   147fc:	8e 77       	andi	r24, 0x7E	; 126
   147fe:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
   14802:	61 15       	cp	r22, r1
   14804:	71 05       	cpc	r23, r1
   14806:	79 f6       	brne	.-98     	; 0x147a6 <Endpoint_Write_Control_PStream_LE+0x2a>
   14808:	22 23       	and	r18, r18
   1480a:	69 f6       	brne	.-102    	; 0x147a6 <Endpoint_Write_Control_PStream_LE+0x2a>
   1480c:	05 c0       	rjmp	.+10     	; 0x14818 <Endpoint_Write_Control_PStream_LE+0x9c>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
   1480e:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
   14810:	88 23       	and	r24, r24
   14812:	61 f0       	breq	.+24     	; 0x1482c <Endpoint_Write_Control_PStream_LE+0xb0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
   14814:	85 30       	cpi	r24, 0x05	; 5
   14816:	61 f0       	breq	.+24     	; 0x14830 <Endpoint_Write_Control_PStream_LE+0xb4>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
   14818:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
   1481c:	82 ff       	sbrs	r24, 2
   1481e:	f7 cf       	rjmp	.-18     	; 0x1480e <Endpoint_Write_Control_PStream_LE+0x92>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
   14820:	80 e0       	ldi	r24, 0x00	; 0
   14822:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
   14824:	83 e0       	ldi	r24, 0x03	; 3
   14826:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
   14828:	81 e0       	ldi	r24, 0x01	; 1
   1482a:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
   1482c:	82 e0       	ldi	r24, 0x02	; 2
   1482e:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
   14830:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
   14832:	08 95       	ret

00014834 <Endpoint_ConfigureEndpoint_Prv>:
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
   14834:	98 2f       	mov	r25, r24
   14836:	2c c0       	rjmp	.+88     	; 0x14890 <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   14838:	29 2f       	mov	r18, r25
   1483a:	2f 70       	andi	r18, 0x0F	; 15
   1483c:	20 93 e9 00 	sts	0x00E9, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
   14840:	98 17       	cp	r25, r24
   14842:	39 f0       	breq	.+14     	; 0x14852 <Endpoint_ConfigureEndpoint_Prv+0x1e>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
   14844:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
   14848:	20 91 ed 00 	lds	r18, 0x00ED
			UEIENXTemp  = UEIENX;
   1484c:	50 91 f0 00 	lds	r21, 0x00F0
   14850:	03 c0       	rjmp	.+6      	; 0x14858 <Endpoint_ConfigureEndpoint_Prv+0x24>
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
   14852:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
   14854:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
   14856:	50 e0       	ldi	r21, 0x00	; 0
			UECFG0XTemp = UECFG0X;
			UECFG1XTemp = UECFG1X;
			UEIENXTemp  = UEIENX;
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
   14858:	21 ff       	sbrs	r18, 1
   1485a:	19 c0       	rjmp	.+50     	; 0x1488e <Endpoint_ConfigureEndpoint_Prv+0x5a>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
   1485c:	30 91 eb 00 	lds	r19, 0x00EB
   14860:	3e 7f       	andi	r19, 0xFE	; 254
   14862:	30 93 eb 00 	sts	0x00EB, r19
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
   14866:	30 91 ed 00 	lds	r19, 0x00ED
   1486a:	3d 7f       	andi	r19, 0xFD	; 253
   1486c:	30 93 ed 00 	sts	0x00ED, r19
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
   14870:	30 91 eb 00 	lds	r19, 0x00EB
   14874:	31 60       	ori	r19, 0x01	; 1
   14876:	30 93 eb 00 	sts	0x00EB, r19

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
   1487a:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
   1487e:	20 93 ed 00 	sts	0x00ED, r18
		UEIENX  = UEIENXTemp;
   14882:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
   14886:	20 91 ee 00 	lds	r18, 0x00EE

		if (!(Endpoint_IsConfigured()))
   1488a:	27 ff       	sbrs	r18, 7
   1488c:	08 c0       	rjmp	.+16     	; 0x1489e <Endpoint_ConfigureEndpoint_Prv+0x6a>
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
   1488e:	9f 5f       	subi	r25, 0xFF	; 255
   14890:	97 30       	cpi	r25, 0x07	; 7
   14892:	90 f2       	brcs	.-92     	; 0x14838 <Endpoint_ConfigureEndpoint_Prv+0x4>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   14894:	8f 70       	andi	r24, 0x0F	; 15
   14896:	80 93 e9 00 	sts	0x00E9, r24
		if (!(Endpoint_IsConfigured()))
		  return false;
	}

	Endpoint_SelectEndpoint(Number);
	return true;
   1489a:	81 e0       	ldi	r24, 0x01	; 1
   1489c:	08 95       	ret
		UECFG0X = UECFG0XTemp;
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;

		if (!(Endpoint_IsConfigured()))
		  return false;
   1489e:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
   148a0:	08 95       	ret

000148a2 <Endpoint_ConfigureEndpointTable>:
uint8_t USB_Device_ControlEndpointSize = ENDPOINT_CONTROLEP_DEFAULT_SIZE;
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
   148a2:	ef 92       	push	r14
   148a4:	ff 92       	push	r15
   148a6:	0f 93       	push	r16
   148a8:	1f 93       	push	r17
   148aa:	cf 93       	push	r28
   148ac:	df 93       	push	r29
   148ae:	16 2f       	mov	r17, r22
	{
		if (!(Table[i].Address))
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
   148b0:	e8 2e       	mov	r14, r24
   148b2:	e7 01       	movw	r28, r14
   148b4:	7e 01       	movw	r14, r28
   148b6:	f9 2e       	mov	r15, r25
   148b8:	e7 01       	movw	r28, r14
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
   148ba:	00 e0       	ldi	r16, 0x00	; 0
   148bc:	2a c0       	rjmp	.+84     	; 0x14912 <Endpoint_ConfigureEndpointTable+0x70>
	{
		if (!(Table[i].Address))
   148be:	98 81       	ld	r25, Y
   148c0:	99 23       	and	r25, r25
   148c2:	29 f1       	breq	.+74     	; 0x1490e <Endpoint_ConfigureEndpointTable+0x6c>
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
   148c4:	6b 81       	ldd	r22, Y+3	; 0x03
   148c6:	e9 81       	ldd	r30, Y+1	; 0x01
   148c8:	fa 81       	ldd	r31, Y+2	; 0x02
   148ca:	2c 81       	ldd	r18, Y+4	; 0x04
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);
   148cc:	89 2f       	mov	r24, r25
   148ce:	8f 70       	andi	r24, 0x0F	; 15

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
   148d0:	87 30       	cpi	r24, 0x07	; 7
   148d2:	18 f5       	brcc	.+70     	; 0x1491a <Endpoint_ConfigureEndpointTable+0x78>
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
				                                      ((Type << EPTYPE0) | ((Address & ENDPOINT_DIR_IN) ? (1 << EPDIR) : 0)),
   148d4:	62 95       	swap	r22
   148d6:	66 0f       	add	r22, r22
   148d8:	66 0f       	add	r22, r22
   148da:	60 7c       	andi	r22, 0xC0	; 192
   148dc:	99 1f       	adc	r25, r25
   148de:	99 27       	eor	r25, r25
   148e0:	99 1f       	adc	r25, r25
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
   148e2:	69 2b       	or	r22, r25
   148e4:	22 30       	cpi	r18, 0x02	; 2
   148e6:	10 f0       	brcs	.+4      	; 0x148ec <Endpoint_ConfigureEndpointTable+0x4a>
   148e8:	96 e0       	ldi	r25, 0x06	; 6
   148ea:	01 c0       	rjmp	.+2      	; 0x148ee <Endpoint_ConfigureEndpointTable+0x4c>
   148ec:	92 e0       	ldi	r25, 0x02	; 2
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;
   148ee:	28 e0       	ldi	r18, 0x08	; 8
   148f0:	30 e0       	ldi	r19, 0x00	; 0
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
   148f2:	40 e0       	ldi	r20, 0x00	; 0
   148f4:	03 c0       	rjmp	.+6      	; 0x148fc <Endpoint_ConfigureEndpointTable+0x5a>
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
				{
					MaskVal++;
   148f6:	4f 5f       	subi	r20, 0xFF	; 255
					CheckBytes <<= 1;
   148f8:	22 0f       	add	r18, r18
   148fa:	33 1f       	adc	r19, r19
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
   148fc:	2e 17       	cp	r18, r30
   148fe:	3f 07       	cpc	r19, r31
   14900:	d0 f3       	brcs	.-12     	; 0x148f6 <Endpoint_ConfigureEndpointTable+0x54>
				{
					MaskVal++;
					CheckBytes <<= 1;
				}

				return (MaskVal << EPSIZE0);
   14902:	42 95       	swap	r20
   14904:	40 7f       	andi	r20, 0xF0	; 240
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
   14906:	49 2b       	or	r20, r25
   14908:	95 df       	rcall	.-214    	; 0x14834 <Endpoint_ConfigureEndpoint_Prv>
   1490a:	88 23       	and	r24, r24
   1490c:	31 f0       	breq	.+12     	; 0x1491a <Endpoint_ConfigureEndpointTable+0x78>
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
   1490e:	0f 5f       	subi	r16, 0xFF	; 255
   14910:	25 96       	adiw	r28, 0x05	; 5
   14912:	01 17       	cp	r16, r17
   14914:	a0 f2       	brcs	.-88     	; 0x148be <Endpoint_ConfigureEndpointTable+0x1c>

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
	}

	return true;
   14916:	81 e0       	ldi	r24, 0x01	; 1
   14918:	01 c0       	rjmp	.+2      	; 0x1491c <Endpoint_ConfigureEndpointTable+0x7a>
	{
		if (!(Table[i].Address))
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
   1491a:	80 e0       	ldi	r24, 0x00	; 0
	}

	return true;
}
   1491c:	df 91       	pop	r29
   1491e:	cf 91       	pop	r28
   14920:	1f 91       	pop	r17
   14922:	0f 91       	pop	r16
   14924:	ff 90       	pop	r15
   14926:	ef 90       	pop	r14
   14928:	08 95       	ret

0001492a <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
   1492a:	80 91 19 14 	lds	r24, 0x1419
   1492e:	87 ff       	sbrs	r24, 7
   14930:	11 c0       	rjmp	.+34     	; 0x14954 <Endpoint_ClearStatusStage+0x2a>
   14932:	03 c0       	rjmp	.+6      	; 0x1493a <Endpoint_ClearStatusStage+0x10>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
   14934:	8e b3       	in	r24, 0x1e	; 30
   14936:	88 23       	and	r24, r24
   14938:	b1 f0       	breq	.+44     	; 0x14966 <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
   1493a:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
   1493e:	82 ff       	sbrs	r24, 2
   14940:	f9 cf       	rjmp	.-14     	; 0x14934 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
   14942:	80 91 e8 00 	lds	r24, 0x00E8
   14946:	8b 77       	andi	r24, 0x7B	; 123
   14948:	80 93 e8 00 	sts	0x00E8, r24
   1494c:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
   1494e:	8e b3       	in	r24, 0x1e	; 30
   14950:	88 23       	and	r24, r24
   14952:	49 f0       	breq	.+18     	; 0x14966 <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
   14954:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
   14958:	80 ff       	sbrs	r24, 0
   1495a:	f9 cf       	rjmp	.-14     	; 0x1494e <Endpoint_ClearStatusStage+0x24>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   1495c:	80 91 e8 00 	lds	r24, 0x00E8
   14960:	8e 77       	andi	r24, 0x7E	; 126
   14962:	80 93 e8 00 	sts	0x00E8, r24
   14966:	08 95       	ret

00014968 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
   14968:	80 91 e4 00 	lds	r24, 0x00E4
   1496c:	90 91 e5 00 	lds	r25, 0x00E5

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
   14970:	44 e6       	ldi	r20, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
   14972:	20 91 ec 00 	lds	r18, 0x00EC
   14976:	20 ff       	sbrs	r18, 0
   14978:	25 c0       	rjmp	.+74     	; 0x149c4 <Endpoint_WaitUntilReady+0x5c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
   1497a:	20 91 e8 00 	lds	r18, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
   1497e:	20 fd       	sbrc	r18, 0
   14980:	15 c0       	rjmp	.+42     	; 0x149ac <Endpoint_WaitUntilReady+0x44>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
   14982:	2e b3       	in	r18, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
   14984:	22 23       	and	r18, r18
   14986:	a1 f0       	breq	.+40     	; 0x149b0 <Endpoint_WaitUntilReady+0x48>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
   14988:	25 30       	cpi	r18, 0x05	; 5
   1498a:	a1 f0       	breq	.+40     	; 0x149b4 <Endpoint_WaitUntilReady+0x4c>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
   1498c:	20 91 eb 00 	lds	r18, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
   14990:	25 fd       	sbrc	r18, 5
   14992:	12 c0       	rjmp	.+36     	; 0x149b8 <Endpoint_WaitUntilReady+0x50>
   14994:	20 91 e4 00 	lds	r18, 0x00E4
   14998:	30 91 e5 00 	lds	r19, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
   1499c:	28 17       	cp	r18, r24
   1499e:	39 07       	cpc	r19, r25
   149a0:	41 f3       	breq	.-48     	; 0x14972 <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
   149a2:	44 23       	and	r20, r20
   149a4:	59 f0       	breq	.+22     	; 0x149bc <Endpoint_WaitUntilReady+0x54>
   149a6:	41 50       	subi	r20, 0x01	; 1
   149a8:	c9 01       	movw	r24, r18
   149aa:	e3 cf       	rjmp	.-58     	; 0x14972 <Endpoint_WaitUntilReady+0xa>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
   149ac:	80 e0       	ldi	r24, 0x00	; 0
   149ae:	08 95       	ret
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
   149b0:	82 e0       	ldi	r24, 0x02	; 2
   149b2:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
   149b4:	83 e0       	ldi	r24, 0x03	; 3
   149b6:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
   149b8:	81 e0       	ldi	r24, 0x01	; 1
   149ba:	08 95       	ret
		if (CurrentFrameNumber != PreviousFrameNumber)
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
   149bc:	84 e0       	ldi	r24, 0x04	; 4
   149be:	08 95       	ret
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
   149c0:	80 e0       	ldi	r24, 0x00	; 0

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
   149c2:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
   149c4:	20 91 e8 00 	lds	r18, 0x00E8
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
   149c8:	22 ff       	sbrs	r18, 2
   149ca:	db cf       	rjmp	.-74     	; 0x14982 <Endpoint_WaitUntilReady+0x1a>
   149cc:	f9 cf       	rjmp	.-14     	; 0x149c0 <Endpoint_WaitUntilReady+0x58>

000149ce <USB_ResetInterface>:

void USB_ResetInterface(void)
{
   149ce:	0f 93       	push	r16
   149d0:	1f 93       	push	r17
   149d2:	cf 93       	push	r28
   149d4:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
   149d6:	4d d0       	rcall	.+154    	; 0x14a72 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
   149d8:	54 d0       	rcall	.+168    	; 0x14a82 <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
   149da:	c8 ed       	ldi	r28, 0xD8	; 216
   149dc:	d0 e0       	ldi	r29, 0x00	; 0
   149de:	88 81       	ld	r24, Y
   149e0:	8f 77       	andi	r24, 0x7F	; 127
   149e2:	88 83       	st	Y, r24
				USBCON |=  (1 << USBE);
   149e4:	88 81       	ld	r24, Y
   149e6:	80 68       	ori	r24, 0x80	; 128
   149e8:	88 83       	st	Y, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
   149ea:	88 81       	ld	r24, Y
   149ec:	8f 7d       	andi	r24, 0xDF	; 223
   149ee:	88 83       	st	Y, r24

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
   149f0:	e7 ed       	ldi	r30, 0xD7	; 215
   149f2:	f0 e0       	ldi	r31, 0x00	; 0
   149f4:	80 81       	ld	r24, Z
   149f6:	80 68       	ori	r24, 0x80	; 128
   149f8:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
   149fa:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
   149fc:	1e ba       	out	0x1e, r1	; 30
	USB_Device_ConfigurationNumber  = 0;
   149fe:	10 92 15 14 	sts	0x1415, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
   14a02:	10 92 17 14 	sts	0x1417, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
   14a06:	10 92 16 14 	sts	0x1416, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
   14a0a:	00 ee       	ldi	r16, 0xE0	; 224
   14a0c:	10 e0       	ldi	r17, 0x00	; 0
   14a0e:	f8 01       	movw	r30, r16
   14a10:	80 81       	ld	r24, Z
   14a12:	8b 7f       	andi	r24, 0xFB	; 251
   14a14:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
   14a16:	88 81       	ld	r24, Y
   14a18:	81 60       	ori	r24, 0x01	; 1
   14a1a:	88 83       	st	Y, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
   14a1c:	80 e0       	ldi	r24, 0x00	; 0
   14a1e:	60 e0       	ldi	r22, 0x00	; 0
   14a20:	42 e0       	ldi	r20, 0x02	; 2
   14a22:	08 df       	rcall	.-496    	; 0x14834 <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
   14a24:	e1 ee       	ldi	r30, 0xE1	; 225
   14a26:	f0 e0       	ldi	r31, 0x00	; 0
   14a28:	80 81       	ld	r24, Z
   14a2a:	8e 7f       	andi	r24, 0xFE	; 254
   14a2c:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
   14a2e:	e2 ee       	ldi	r30, 0xE2	; 226
   14a30:	f0 e0       	ldi	r31, 0x00	; 0
   14a32:	80 81       	ld	r24, Z
   14a34:	81 60       	ori	r24, 0x01	; 1
   14a36:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
   14a38:	80 81       	ld	r24, Z
   14a3a:	88 60       	ori	r24, 0x08	; 8
   14a3c:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
   14a3e:	f8 01       	movw	r30, r16
   14a40:	80 81       	ld	r24, Z
   14a42:	8e 7f       	andi	r24, 0xFE	; 254
   14a44:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
   14a46:	88 81       	ld	r24, Y
   14a48:	80 61       	ori	r24, 0x10	; 16
   14a4a:	88 83       	st	Y, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
   14a4c:	df 91       	pop	r29
   14a4e:	cf 91       	pop	r28
   14a50:	1f 91       	pop	r17
   14a52:	0f 91       	pop	r16
   14a54:	08 95       	ret

00014a56 <USB_Init>:
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
   14a56:	e8 ed       	ldi	r30, 0xD8	; 216
   14a58:	f0 e0       	ldi	r31, 0x00	; 0
   14a5a:	80 81       	ld	r24, Z
   14a5c:	8f 7e       	andi	r24, 0xEF	; 239
   14a5e:	80 83       	st	Z, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
   14a60:	e7 ed       	ldi	r30, 0xD7	; 215
   14a62:	f0 e0       	ldi	r31, 0x00	; 0
   14a64:	80 81       	ld	r24, Z
   14a66:	81 60       	ori	r24, 0x01	; 1
   14a68:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
   14a6a:	81 e0       	ldi	r24, 0x01	; 1
   14a6c:	80 93 18 14 	sts	0x1418, r24

	USB_ResetInterface();
}
   14a70:	ae cf       	rjmp	.-164    	; 0x149ce <USB_ResetInterface>

00014a72 <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
   14a72:	e8 ed       	ldi	r30, 0xD8	; 216
   14a74:	f0 e0       	ldi	r31, 0x00	; 0
   14a76:	80 81       	ld	r24, Z
   14a78:	8c 7f       	andi	r24, 0xFC	; 252
   14a7a:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
   14a7c:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
   14a80:	08 95       	ret

00014a82 <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
   14a82:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
   14a86:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
   14a8a:	08 95       	ret

00014a8c <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
   14a8c:	1f 92       	push	r1
   14a8e:	0f 92       	push	r0
   14a90:	0f b6       	in	r0, 0x3f	; 63
   14a92:	0f 92       	push	r0
   14a94:	0b b6       	in	r0, 0x3b	; 59
   14a96:	0f 92       	push	r0
   14a98:	11 24       	eor	r1, r1
   14a9a:	2f 93       	push	r18
   14a9c:	3f 93       	push	r19
   14a9e:	4f 93       	push	r20
   14aa0:	5f 93       	push	r21
   14aa2:	6f 93       	push	r22
   14aa4:	7f 93       	push	r23
   14aa6:	8f 93       	push	r24
   14aa8:	9f 93       	push	r25
   14aaa:	af 93       	push	r26
   14aac:	bf 93       	push	r27
   14aae:	ef 93       	push	r30
   14ab0:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
   14ab2:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
   14ab6:	82 ff       	sbrs	r24, 2
   14ab8:	0a c0       	rjmp	.+20     	; 0x14ace <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
   14aba:	80 91 e2 00 	lds	r24, 0x00E2
   14abe:	82 ff       	sbrs	r24, 2
   14ac0:	06 c0       	rjmp	.+12     	; 0x14ace <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
   14ac2:	80 91 e1 00 	lds	r24, 0x00E1
   14ac6:	8b 7f       	andi	r24, 0xFB	; 251
   14ac8:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
   14acc:	4e d2       	rcall	.+1180   	; 0x14f6a <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
   14ace:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
   14ad2:	80 ff       	sbrs	r24, 0
   14ad4:	1d c0       	rjmp	.+58     	; 0x14b10 <__vector_10+0x84>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
   14ad6:	80 91 d8 00 	lds	r24, 0x00D8
   14ada:	80 ff       	sbrs	r24, 0
   14adc:	19 c0       	rjmp	.+50     	; 0x14b10 <__vector_10+0x84>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
   14ade:	80 91 da 00 	lds	r24, 0x00DA
   14ae2:	8e 7f       	andi	r24, 0xFE	; 254
   14ae4:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
   14ae8:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
   14aec:	80 ff       	sbrs	r24, 0
   14aee:	0c c0       	rjmp	.+24     	; 0x14b08 <__vector_10+0x7c>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
   14af0:	8c e0       	ldi	r24, 0x0C	; 12
   14af2:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
   14af4:	8e e0       	ldi	r24, 0x0E	; 14
   14af6:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
   14af8:	09 b4       	in	r0, 0x29	; 41
   14afa:	00 fe       	sbrs	r0, 0
   14afc:	fd cf       	rjmp	.-6      	; 0x14af8 <__vector_10+0x6c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
   14afe:	81 e0       	ldi	r24, 0x01	; 1
   14b00:	8e bb       	out	0x1e, r24	; 30
			EVENT_USB_Device_Connect();
   14b02:	0e 94 df 7f 	call	0xffbe	; 0xffbe <EVENT_USB_Device_Connect>
   14b06:	04 c0       	rjmp	.+8      	; 0x14b10 <__vector_10+0x84>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
   14b08:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
   14b0a:	1e ba       	out	0x1e, r1	; 30
			EVENT_USB_Device_Disconnect();
   14b0c:	0e 94 02 80 	call	0x10004	; 0x10004 <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
   14b10:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
   14b14:	80 ff       	sbrs	r24, 0
   14b16:	17 c0       	rjmp	.+46     	; 0x14b46 <__vector_10+0xba>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
   14b18:	80 91 e2 00 	lds	r24, 0x00E2
   14b1c:	80 ff       	sbrs	r24, 0
   14b1e:	13 c0       	rjmp	.+38     	; 0x14b46 <__vector_10+0xba>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
   14b20:	80 91 e2 00 	lds	r24, 0x00E2
   14b24:	8e 7f       	andi	r24, 0xFE	; 254
   14b26:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
   14b2a:	80 91 e2 00 	lds	r24, 0x00E2
   14b2e:	80 61       	ori	r24, 0x10	; 16
   14b30:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
   14b34:	80 91 d8 00 	lds	r24, 0x00D8
   14b38:	80 62       	ori	r24, 0x20	; 32
   14b3a:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
   14b3e:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
   14b40:	85 e0       	ldi	r24, 0x05	; 5
   14b42:	8e bb       	out	0x1e, r24	; 30
		EVENT_USB_Device_Suspend();
   14b44:	12 d2       	rcall	.+1060   	; 0x14f6a <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
   14b46:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
   14b4a:	84 ff       	sbrs	r24, 4
   14b4c:	2e c0       	rjmp	.+92     	; 0x14baa <__vector_10+0x11e>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
   14b4e:	80 91 e2 00 	lds	r24, 0x00E2
   14b52:	84 ff       	sbrs	r24, 4
   14b54:	2a c0       	rjmp	.+84     	; 0x14baa <__vector_10+0x11e>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
   14b56:	8c e0       	ldi	r24, 0x0C	; 12
   14b58:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
   14b5a:	8e e0       	ldi	r24, 0x0E	; 14
   14b5c:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
   14b5e:	09 b4       	in	r0, 0x29	; 41
   14b60:	00 fe       	sbrs	r0, 0
   14b62:	fd cf       	rjmp	.-6      	; 0x14b5e <__vector_10+0xd2>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
   14b64:	80 91 d8 00 	lds	r24, 0x00D8
   14b68:	8f 7d       	andi	r24, 0xDF	; 223
   14b6a:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
   14b6e:	80 91 e1 00 	lds	r24, 0x00E1
   14b72:	8f 7e       	andi	r24, 0xEF	; 239
   14b74:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
   14b78:	80 91 e2 00 	lds	r24, 0x00E2
   14b7c:	8f 7e       	andi	r24, 0xEF	; 239
   14b7e:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
   14b82:	80 91 e2 00 	lds	r24, 0x00E2
   14b86:	81 60       	ori	r24, 0x01	; 1
   14b88:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
   14b8c:	80 91 15 14 	lds	r24, 0x1415
   14b90:	88 23       	and	r24, r24
   14b92:	11 f0       	breq	.+4      	; 0x14b98 <__vector_10+0x10c>
		  USB_DeviceState = DEVICE_STATE_Configured;
   14b94:	84 e0       	ldi	r24, 0x04	; 4
   14b96:	07 c0       	rjmp	.+14     	; 0x14ba6 <__vector_10+0x11a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
   14b98:	80 91 e3 00 	lds	r24, 0x00E3
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
   14b9c:	87 ff       	sbrs	r24, 7
   14b9e:	02 c0       	rjmp	.+4      	; 0x14ba4 <__vector_10+0x118>
   14ba0:	83 e0       	ldi	r24, 0x03	; 3
   14ba2:	01 c0       	rjmp	.+2      	; 0x14ba6 <__vector_10+0x11a>
   14ba4:	81 e0       	ldi	r24, 0x01	; 1
   14ba6:	8e bb       	out	0x1e, r24	; 30

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
   14ba8:	e0 d1       	rcall	.+960    	; 0x14f6a <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
   14baa:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
   14bae:	83 ff       	sbrs	r24, 3
   14bb0:	26 c0       	rjmp	.+76     	; 0x14bfe <__vector_10+0x172>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
   14bb2:	80 91 e2 00 	lds	r24, 0x00E2
   14bb6:	83 ff       	sbrs	r24, 3
   14bb8:	22 c0       	rjmp	.+68     	; 0x14bfe <__vector_10+0x172>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
   14bba:	80 91 e1 00 	lds	r24, 0x00E1
   14bbe:	87 7f       	andi	r24, 0xF7	; 247
   14bc0:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
   14bc4:	82 e0       	ldi	r24, 0x02	; 2
   14bc6:	8e bb       	out	0x1e, r24	; 30
		USB_Device_ConfigurationNumber = 0;
   14bc8:	10 92 15 14 	sts	0x1415, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
   14bcc:	80 91 e1 00 	lds	r24, 0x00E1
   14bd0:	8e 7f       	andi	r24, 0xFE	; 254
   14bd2:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
   14bd6:	80 91 e2 00 	lds	r24, 0x00E2
   14bda:	8e 7f       	andi	r24, 0xFE	; 254
   14bdc:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
   14be0:	80 91 e2 00 	lds	r24, 0x00E2
   14be4:	80 61       	ori	r24, 0x10	; 16
   14be6:	80 93 e2 00 	sts	0x00E2, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
   14bea:	80 e0       	ldi	r24, 0x00	; 0
   14bec:	60 e0       	ldi	r22, 0x00	; 0
   14bee:	42 e0       	ldi	r20, 0x02	; 2
   14bf0:	21 de       	rcall	.-958    	; 0x14834 <Endpoint_ConfigureEndpoint_Prv>
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX |= (1 << RXSTPE);
   14bf2:	80 91 f0 00 	lds	r24, 0x00F0
   14bf6:	88 60       	ori	r24, 0x08	; 8
   14bf8:	80 93 f0 00 	sts	0x00F0, r24

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
   14bfc:	b6 d1       	rcall	.+876    	; 0x14f6a <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
   14bfe:	ff 91       	pop	r31
   14c00:	ef 91       	pop	r30
   14c02:	bf 91       	pop	r27
   14c04:	af 91       	pop	r26
   14c06:	9f 91       	pop	r25
   14c08:	8f 91       	pop	r24
   14c0a:	7f 91       	pop	r23
   14c0c:	6f 91       	pop	r22
   14c0e:	5f 91       	pop	r21
   14c10:	4f 91       	pop	r20
   14c12:	3f 91       	pop	r19
   14c14:	2f 91       	pop	r18
   14c16:	0f 90       	pop	r0
   14c18:	0b be       	out	0x3b, r0	; 59
   14c1a:	0f 90       	pop	r0
   14c1c:	0f be       	out	0x3f, r0	; 63
   14c1e:	0f 90       	pop	r0
   14c20:	1f 90       	pop	r1
   14c22:	18 95       	reti

00014c24 <__vector_11>:

#if defined(INTERRUPT_CONTROL_ENDPOINT) && defined(USB_CAN_BE_DEVICE)
ISR(USB_COM_vect, ISR_BLOCK)
{
   14c24:	1f 92       	push	r1
   14c26:	0f 92       	push	r0
   14c28:	0f b6       	in	r0, 0x3f	; 63
   14c2a:	0f 92       	push	r0
   14c2c:	0b b6       	in	r0, 0x3b	; 59
   14c2e:	0f 92       	push	r0
   14c30:	11 24       	eor	r1, r1
   14c32:	1f 93       	push	r17
   14c34:	2f 93       	push	r18
   14c36:	3f 93       	push	r19
   14c38:	4f 93       	push	r20
   14c3a:	5f 93       	push	r21
   14c3c:	6f 93       	push	r22
   14c3e:	7f 93       	push	r23
   14c40:	8f 93       	push	r24
   14c42:	9f 93       	push	r25
   14c44:	af 93       	push	r26
   14c46:	bf 93       	push	r27
   14c48:	ef 93       	push	r30
   14c4a:	ff 93       	push	r31
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
   14c4c:	10 91 e9 00 	lds	r17, 0x00E9
   14c50:	1f 70       	andi	r17, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
   14c52:	80 91 ec 00 	lds	r24, 0x00EC
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   14c56:	10 92 e9 00 	sts	0x00E9, r1
						break;
					case USB_INT_SOFI:
						UDIEN  &= ~(1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX &= ~(1 << RXSTPE);
   14c5a:	80 91 f0 00 	lds	r24, 0x00F0
   14c5e:	87 7f       	andi	r24, 0xF7	; 247
   14c60:	80 93 f0 00 	sts	0x00F0, r24
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
   14c64:	78 94       	sei
	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Disable(USB_INT_RXSTPI);

	GlobalInterruptEnable();

	USB_Device_ProcessControlRequest();
   14c66:	1d d0       	rcall	.+58     	; 0x14ca2 <USB_Device_ProcessControlRequest>
   14c68:	10 92 e9 00 	sts	0x00E9, r1
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX |= (1 << RXSTPE);
   14c6c:	80 91 f0 00 	lds	r24, 0x00F0
   14c70:	88 60       	ori	r24, 0x08	; 8
   14c72:	80 93 f0 00 	sts	0x00F0, r24
   14c76:	10 93 e9 00 	sts	0x00E9, r17

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Enable(USB_INT_RXSTPI);
	Endpoint_SelectEndpoint(PrevSelectedEndpoint);
}
   14c7a:	ff 91       	pop	r31
   14c7c:	ef 91       	pop	r30
   14c7e:	bf 91       	pop	r27
   14c80:	af 91       	pop	r26
   14c82:	9f 91       	pop	r25
   14c84:	8f 91       	pop	r24
   14c86:	7f 91       	pop	r23
   14c88:	6f 91       	pop	r22
   14c8a:	5f 91       	pop	r21
   14c8c:	4f 91       	pop	r20
   14c8e:	3f 91       	pop	r19
   14c90:	2f 91       	pop	r18
   14c92:	1f 91       	pop	r17
   14c94:	0f 90       	pop	r0
   14c96:	0b be       	out	0x3b, r0	; 59
   14c98:	0f 90       	pop	r0
   14c9a:	0f be       	out	0x3f, r0	; 63
   14c9c:	0f 90       	pop	r0
   14c9e:	1f 90       	pop	r1
   14ca0:	18 95       	reti

00014ca2 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
   14ca2:	1f 93       	push	r17
   14ca4:	df 93       	push	r29
   14ca6:	cf 93       	push	r28
   14ca8:	cd b7       	in	r28, 0x3d	; 61
   14caa:	de b7       	in	r29, 0x3e	; 62
   14cac:	ac 97       	sbiw	r28, 0x2c	; 44
   14cae:	0f b6       	in	r0, 0x3f	; 63
   14cb0:	f8 94       	cli
   14cb2:	de bf       	out	0x3e, r29	; 62
   14cb4:	0f be       	out	0x3f, r0	; 63
   14cb6:	cd bf       	out	0x3d, r28	; 61
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;
   14cb8:	e9 e1       	ldi	r30, 0x19	; 25
   14cba:	f4 e1       	ldi	r31, 0x14	; 20
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
   14cbc:	80 91 f1 00 	lds	r24, 0x00F1

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
   14cc0:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
   14cc2:	24 e1       	ldi	r18, 0x14	; 20
   14cc4:	e1 32       	cpi	r30, 0x21	; 33
   14cc6:	f2 07       	cpc	r31, r18
   14cc8:	c9 f7       	brne	.-14     	; 0x14cbc <USB_Device_ProcessControlRequest+0x1a>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
   14cca:	0e 94 1f 80 	call	0x1003e	; 0x1003e <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
   14cce:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
   14cd2:	83 ff       	sbrs	r24, 3
   14cd4:	32 c1       	rjmp	.+612    	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
   14cd6:	80 91 19 14 	lds	r24, 0x1419

		switch (USB_ControlRequest.bRequest)
   14cda:	20 91 1a 14 	lds	r18, 0x141A
   14cde:	25 30       	cpi	r18, 0x05	; 5
   14ce0:	09 f4       	brne	.+2      	; 0x14ce4 <USB_Device_ProcessControlRequest+0x42>
   14ce2:	84 c0       	rjmp	.+264    	; 0x14dec <USB_Device_ProcessControlRequest+0x14a>
   14ce4:	26 30       	cpi	r18, 0x06	; 6
   14ce6:	40 f4       	brcc	.+16     	; 0x14cf8 <USB_Device_ProcessControlRequest+0x56>
   14ce8:	21 30       	cpi	r18, 0x01	; 1
   14cea:	a1 f1       	breq	.+104    	; 0x14d54 <USB_Device_ProcessControlRequest+0xb2>
   14cec:	21 30       	cpi	r18, 0x01	; 1
   14cee:	70 f0       	brcs	.+28     	; 0x14d0c <USB_Device_ProcessControlRequest+0x6a>
   14cf0:	23 30       	cpi	r18, 0x03	; 3
   14cf2:	09 f0       	breq	.+2      	; 0x14cf6 <USB_Device_ProcessControlRequest+0x54>
   14cf4:	22 c1       	rjmp	.+580    	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
   14cf6:	2e c0       	rjmp	.+92     	; 0x14d54 <USB_Device_ProcessControlRequest+0xb2>
   14cf8:	28 30       	cpi	r18, 0x08	; 8
   14cfa:	09 f4       	brne	.+2      	; 0x14cfe <USB_Device_ProcessControlRequest+0x5c>
   14cfc:	f0 c0       	rjmp	.+480    	; 0x14ede <USB_Device_ProcessControlRequest+0x23c>
   14cfe:	29 30       	cpi	r18, 0x09	; 9
   14d00:	09 f4       	brne	.+2      	; 0x14d04 <USB_Device_ProcessControlRequest+0x62>
   14d02:	ff c0       	rjmp	.+510    	; 0x14f02 <USB_Device_ProcessControlRequest+0x260>
   14d04:	26 30       	cpi	r18, 0x06	; 6
   14d06:	09 f0       	breq	.+2      	; 0x14d0a <USB_Device_ProcessControlRequest+0x68>
   14d08:	18 c1       	rjmp	.+560    	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
   14d0a:	92 c0       	rjmp	.+292    	; 0x14e30 <USB_Device_ProcessControlRequest+0x18e>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
   14d0c:	80 38       	cpi	r24, 0x80	; 128
   14d0e:	21 f0       	breq	.+8      	; 0x14d18 <USB_Device_ProcessControlRequest+0x76>
   14d10:	82 38       	cpi	r24, 0x82	; 130
   14d12:	09 f0       	breq	.+2      	; 0x14d16 <USB_Device_ProcessControlRequest+0x74>
   14d14:	12 c1       	rjmp	.+548    	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
   14d16:	08 c0       	rjmp	.+16     	; 0x14d28 <USB_Device_ProcessControlRequest+0x86>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
   14d18:	80 91 16 14 	lds	r24, 0x1416
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
   14d1c:	90 91 17 14 	lds	r25, 0x1417
   14d20:	99 23       	and	r25, r25
   14d22:	71 f0       	breq	.+28     	; 0x14d40 <USB_Device_ProcessControlRequest+0x9e>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
   14d24:	82 60       	ori	r24, 0x02	; 2
   14d26:	0c c0       	rjmp	.+24     	; 0x14d40 <USB_Device_ProcessControlRequest+0x9e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   14d28:	80 91 1d 14 	lds	r24, 0x141D
   14d2c:	8f 70       	andi	r24, 0x0F	; 15
   14d2e:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
   14d32:	90 91 eb 00 	lds	r25, 0x00EB
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);

			CurrentStatus = Endpoint_IsStalled();
   14d36:	81 e0       	ldi	r24, 0x01	; 1
   14d38:	95 ff       	sbrs	r25, 5
   14d3a:	80 e0       	ldi	r24, 0x00	; 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   14d3c:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
   14d40:	90 91 e8 00 	lds	r25, 0x00E8
   14d44:	97 7f       	andi	r25, 0xF7	; 247
   14d46:	90 93 e8 00 	sts	0x00E8, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
   14d4a:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Data >> 8);
   14d4e:	10 92 f1 00 	sts	0x00F1, r1
   14d52:	d0 c0       	rjmp	.+416    	; 0x14ef4 <USB_Device_ProcessControlRequest+0x252>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
   14d54:	88 23       	and	r24, r24
   14d56:	19 f0       	breq	.+6      	; 0x14d5e <USB_Device_ProcessControlRequest+0xbc>
   14d58:	82 30       	cpi	r24, 0x02	; 2
   14d5a:	09 f0       	breq	.+2      	; 0x14d5e <USB_Device_ProcessControlRequest+0xbc>
   14d5c:	ee c0       	rjmp	.+476    	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
   14d5e:	90 e0       	ldi	r25, 0x00	; 0
   14d60:	8f 71       	andi	r24, 0x1F	; 31
   14d62:	90 70       	andi	r25, 0x00	; 0
   14d64:	00 97       	sbiw	r24, 0x00	; 0
   14d66:	29 f0       	breq	.+10     	; 0x14d72 <USB_Device_ProcessControlRequest+0xd0>
   14d68:	82 30       	cpi	r24, 0x02	; 2
   14d6a:	91 05       	cpc	r25, r1
   14d6c:	09 f0       	breq	.+2      	; 0x14d70 <USB_Device_ProcessControlRequest+0xce>
   14d6e:	e5 c0       	rjmp	.+458    	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
   14d70:	0b c0       	rjmp	.+22     	; 0x14d88 <USB_Device_ProcessControlRequest+0xe6>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
   14d72:	80 91 1b 14 	lds	r24, 0x141B
   14d76:	81 30       	cpi	r24, 0x01	; 1
   14d78:	09 f0       	breq	.+2      	; 0x14d7c <USB_Device_ProcessControlRequest+0xda>
   14d7a:	df c0       	rjmp	.+446    	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
   14d7c:	23 30       	cpi	r18, 0x03	; 3
   14d7e:	09 f0       	breq	.+2      	; 0x14d82 <USB_Device_ProcessControlRequest+0xe0>
   14d80:	80 e0       	ldi	r24, 0x00	; 0
   14d82:	80 93 17 14 	sts	0x1417, r24
   14d86:	2c c0       	rjmp	.+88     	; 0x14de0 <USB_Device_ProcessControlRequest+0x13e>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
   14d88:	80 91 1b 14 	lds	r24, 0x141B
   14d8c:	88 23       	and	r24, r24
   14d8e:	41 f5       	brne	.+80     	; 0x14de0 <USB_Device_ProcessControlRequest+0x13e>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
   14d90:	20 91 1d 14 	lds	r18, 0x141D
   14d94:	2f 70       	andi	r18, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
   14d96:	09 f4       	brne	.+2      	; 0x14d9a <USB_Device_ProcessControlRequest+0xf8>
   14d98:	d0 c0       	rjmp	.+416    	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   14d9a:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
   14d9e:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
   14da2:	80 ff       	sbrs	r24, 0
   14da4:	1d c0       	rjmp	.+58     	; 0x14de0 <USB_Device_ProcessControlRequest+0x13e>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
   14da6:	80 91 1a 14 	lds	r24, 0x141A
   14daa:	83 30       	cpi	r24, 0x03	; 3
   14dac:	21 f4       	brne	.+8      	; 0x14db6 <USB_Device_ProcessControlRequest+0x114>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
   14dae:	80 91 eb 00 	lds	r24, 0x00EB
   14db2:	80 62       	ori	r24, 0x20	; 32
   14db4:	13 c0       	rjmp	.+38     	; 0x14ddc <USB_Device_ProcessControlRequest+0x13a>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
   14db6:	80 91 eb 00 	lds	r24, 0x00EB
   14dba:	80 61       	ori	r24, 0x10	; 16
   14dbc:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
   14dc0:	81 e0       	ldi	r24, 0x01	; 1
   14dc2:	90 e0       	ldi	r25, 0x00	; 0
   14dc4:	02 c0       	rjmp	.+4      	; 0x14dca <USB_Device_ProcessControlRequest+0x128>
   14dc6:	88 0f       	add	r24, r24
   14dc8:	99 1f       	adc	r25, r25
   14dca:	2a 95       	dec	r18
   14dcc:	e2 f7       	brpl	.-8      	; 0x14dc6 <USB_Device_ProcessControlRequest+0x124>
   14dce:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
   14dd2:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
   14dd6:	80 91 eb 00 	lds	r24, 0x00EB
   14dda:	88 60       	ori	r24, 0x08	; 8
   14ddc:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   14de0:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
   14de4:	80 91 e8 00 	lds	r24, 0x00E8
   14de8:	87 7f       	andi	r24, 0xF7	; 247
   14dea:	87 c0       	rjmp	.+270    	; 0x14efa <USB_Device_ProcessControlRequest+0x258>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
   14dec:	88 23       	and	r24, r24
   14dee:	09 f0       	breq	.+2      	; 0x14df2 <USB_Device_ProcessControlRequest+0x150>
   14df0:	a4 c0       	rjmp	.+328    	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
   14df2:	10 91 1b 14 	lds	r17, 0x141B
   14df6:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
   14df8:	80 91 e3 00 	lds	r24, 0x00E3
   14dfc:	80 78       	andi	r24, 0x80	; 128
   14dfe:	81 2b       	or	r24, r17
   14e00:	80 93 e3 00 	sts	0x00E3, r24
   14e04:	80 91 e8 00 	lds	r24, 0x00E8
   14e08:	87 7f       	andi	r24, 0xF7	; 247
   14e0a:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
   14e0e:	8d dd       	rcall	.-1254   	; 0x1492a <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
   14e10:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
   14e14:	80 ff       	sbrs	r24, 0
   14e16:	fc cf       	rjmp	.-8      	; 0x14e10 <USB_Device_ProcessControlRequest+0x16e>
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;

				UDADDR |= (1 << ADDEN);
   14e18:	80 91 e3 00 	lds	r24, 0x00E3
   14e1c:	80 68       	ori	r24, 0x80	; 128
   14e1e:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
   14e22:	11 23       	and	r17, r17
   14e24:	11 f0       	breq	.+4      	; 0x14e2a <USB_Device_ProcessControlRequest+0x188>
   14e26:	83 e0       	ldi	r24, 0x03	; 3
   14e28:	01 c0       	rjmp	.+2      	; 0x14e2c <USB_Device_ProcessControlRequest+0x18a>
   14e2a:	82 e0       	ldi	r24, 0x02	; 2
   14e2c:	8e bb       	out	0x1e, r24	; 30
   14e2e:	85 c0       	rjmp	.+266    	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
   14e30:	80 58       	subi	r24, 0x80	; 128
   14e32:	82 30       	cpi	r24, 0x02	; 2
   14e34:	08 f0       	brcs	.+2      	; 0x14e38 <USB_Device_ProcessControlRequest+0x196>
   14e36:	81 c0       	rjmp	.+258    	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
   14e38:	80 91 1b 14 	lds	r24, 0x141B
   14e3c:	90 91 1c 14 	lds	r25, 0x141C
   14e40:	23 e0       	ldi	r18, 0x03	; 3
   14e42:	8c 3d       	cpi	r24, 0xDC	; 220
   14e44:	92 07       	cpc	r25, r18
   14e46:	91 f5       	brne	.+100    	; 0x14eac <USB_Device_ProcessControlRequest+0x20a>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
   14e48:	83 e0       	ldi	r24, 0x03	; 3
   14e4a:	8c 83       	std	Y+4, r24	; 0x04
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
   14e4c:	8a e2       	ldi	r24, 0x2A	; 42
   14e4e:	8b 83       	std	Y+3, r24	; 0x03
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
   14e50:	5f b7       	in	r21, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
   14e52:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
   14e54:	de 01       	movw	r26, r28
   14e56:	15 96       	adiw	r26, 0x05	; 5
   14e58:	80 e0       	ldi	r24, 0x00	; 0
   14e5a:	90 e0       	ldi	r25, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
   14e5c:	4e e0       	ldi	r20, 0x0E	; 14

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
   14e5e:	61 e2       	ldi	r22, 0x21	; 33
   14e60:	e4 2f       	mov	r30, r20
   14e62:	f0 e0       	ldi	r31, 0x00	; 0
   14e64:	60 93 57 00 	sts	0x0057, r22
   14e68:	e4 91       	lpm	r30, Z+

					if (SerialCharNum & 0x01)
   14e6a:	80 ff       	sbrs	r24, 0
   14e6c:	03 c0       	rjmp	.+6      	; 0x14e74 <USB_Device_ProcessControlRequest+0x1d2>
					{
						SerialByte >>= 4;
   14e6e:	e2 95       	swap	r30
   14e70:	ef 70       	andi	r30, 0x0F	; 15
						SigReadAddress++;
   14e72:	4f 5f       	subi	r20, 0xFF	; 255
					}

					SerialByte &= 0x0F;
   14e74:	ef 70       	andi	r30, 0x0F	; 15
   14e76:	2e 2f       	mov	r18, r30
   14e78:	30 e0       	ldi	r19, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
   14e7a:	ea 30       	cpi	r30, 0x0A	; 10
   14e7c:	18 f0       	brcs	.+6      	; 0x14e84 <USB_Device_ProcessControlRequest+0x1e2>
   14e7e:	29 5c       	subi	r18, 0xC9	; 201
   14e80:	3f 4f       	sbci	r19, 0xFF	; 255
   14e82:	02 c0       	rjmp	.+4      	; 0x14e88 <USB_Device_ProcessControlRequest+0x1e6>
   14e84:	20 5d       	subi	r18, 0xD0	; 208
   14e86:	3f 4f       	sbci	r19, 0xFF	; 255
   14e88:	2d 93       	st	X+, r18
   14e8a:	3d 93       	st	X+, r19
   14e8c:	01 96       	adiw	r24, 0x01	; 1
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
   14e8e:	84 31       	cpi	r24, 0x14	; 20
   14e90:	91 05       	cpc	r25, r1
   14e92:	31 f7       	brne	.-52     	; 0x14e60 <USB_Device_ProcessControlRequest+0x1be>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
   14e94:	5f bf       	out	0x3f, r21	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
   14e96:	80 91 e8 00 	lds	r24, 0x00E8
   14e9a:	87 7f       	andi	r24, 0xF7	; 247
   14e9c:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
   14ea0:	ce 01       	movw	r24, r28
   14ea2:	03 96       	adiw	r24, 0x03	; 3
   14ea4:	6a e2       	ldi	r22, 0x2A	; 42
   14ea6:	70 e0       	ldi	r23, 0x00	; 0
   14ea8:	cf db       	rcall	.-2146   	; 0x14648 <Endpoint_Write_Control_Stream_LE>
   14eaa:	13 c0       	rjmp	.+38     	; 0x14ed2 <USB_Device_ProcessControlRequest+0x230>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
   14eac:	60 91 1d 14 	lds	r22, 0x141D
   14eb0:	ae 01       	movw	r20, r28
   14eb2:	4f 5f       	subi	r20, 0xFF	; 255
   14eb4:	5f 4f       	sbci	r21, 0xFF	; 255
   14eb6:	0e 94 fe 80 	call	0x101fc	; 0x101fc <CALLBACK_USB_GetDescriptor>
   14eba:	bc 01       	movw	r22, r24
   14ebc:	00 97       	sbiw	r24, 0x00	; 0
   14ebe:	09 f4       	brne	.+2      	; 0x14ec2 <USB_Device_ProcessControlRequest+0x220>
   14ec0:	3c c0       	rjmp	.+120    	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
   14ec2:	80 91 e8 00 	lds	r24, 0x00E8
   14ec6:	87 7f       	andi	r24, 0xF7	; 247
   14ec8:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
   14ecc:	89 81       	ldd	r24, Y+1	; 0x01
   14ece:	9a 81       	ldd	r25, Y+2	; 0x02
   14ed0:	55 dc       	rcall	.-1878   	; 0x1477c <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
   14ed2:	80 91 e8 00 	lds	r24, 0x00E8
   14ed6:	8b 77       	andi	r24, 0x7B	; 123
   14ed8:	80 93 e8 00 	sts	0x00E8, r24
   14edc:	2e c0       	rjmp	.+92     	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
   14ede:	80 38       	cpi	r24, 0x80	; 128
   14ee0:	61 f5       	brne	.+88     	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
   14ee2:	80 91 e8 00 	lds	r24, 0x00E8
   14ee6:	87 7f       	andi	r24, 0xF7	; 247
   14ee8:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
   14eec:	80 91 15 14 	lds	r24, 0x1415
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
   14ef0:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   14ef4:	80 91 e8 00 	lds	r24, 0x00E8
   14ef8:	8e 77       	andi	r24, 0x7E	; 126
   14efa:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
   14efe:	15 dd       	rcall	.-1494   	; 0x1492a <Endpoint_ClearStatusStage>
   14f00:	1c c0       	rjmp	.+56     	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
   14f02:	88 23       	and	r24, r24
   14f04:	d1 f4       	brne	.+52     	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
   14f06:	90 91 1b 14 	lds	r25, 0x141B
   14f0a:	92 30       	cpi	r25, 0x02	; 2
   14f0c:	b0 f4       	brcc	.+44     	; 0x14f3a <USB_Device_ProcessControlRequest+0x298>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
   14f0e:	80 91 e8 00 	lds	r24, 0x00E8
   14f12:	87 7f       	andi	r24, 0xF7	; 247
   14f14:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
   14f18:	90 93 15 14 	sts	0x1415, r25

	Endpoint_ClearStatusStage();
   14f1c:	06 dd       	rcall	.-1524   	; 0x1492a <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
   14f1e:	80 91 15 14 	lds	r24, 0x1415
   14f22:	88 23       	and	r24, r24
   14f24:	21 f4       	brne	.+8      	; 0x14f2e <USB_Device_ProcessControlRequest+0x28c>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
   14f26:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
   14f2a:	87 ff       	sbrs	r24, 7
   14f2c:	02 c0       	rjmp	.+4      	; 0x14f32 <USB_Device_ProcessControlRequest+0x290>
   14f2e:	84 e0       	ldi	r24, 0x04	; 4
   14f30:	01 c0       	rjmp	.+2      	; 0x14f34 <USB_Device_ProcessControlRequest+0x292>
   14f32:	81 e0       	ldi	r24, 0x01	; 1
   14f34:	8e bb       	out	0x1e, r24	; 30

	EVENT_USB_Device_ConfigurationChanged();
   14f36:	0e 94 07 80 	call	0x1000e	; 0x1000e <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
   14f3a:	80 91 e8 00 	lds	r24, 0x00E8
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
   14f3e:	83 ff       	sbrs	r24, 3
   14f40:	0a c0       	rjmp	.+20     	; 0x14f56 <USB_Device_ProcessControlRequest+0x2b4>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
   14f42:	80 91 e8 00 	lds	r24, 0x00E8
   14f46:	87 7f       	andi	r24, 0xF7	; 247
   14f48:	80 93 e8 00 	sts	0x00E8, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
   14f4c:	80 91 eb 00 	lds	r24, 0x00EB
   14f50:	80 62       	ori	r24, 0x20	; 32
   14f52:	80 93 eb 00 	sts	0x00EB, r24
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
   14f56:	ac 96       	adiw	r28, 0x2c	; 44
   14f58:	0f b6       	in	r0, 0x3f	; 63
   14f5a:	f8 94       	cli
   14f5c:	de bf       	out	0x3e, r29	; 62
   14f5e:	0f be       	out	0x3f, r0	; 63
   14f60:	cd bf       	out	0x3d, r28	; 61
   14f62:	cf 91       	pop	r28
   14f64:	df 91       	pop	r29
   14f66:	1f 91       	pop	r17
   14f68:	08 95       	ret

00014f6a <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
   14f6a:	08 95       	ret

00014f6c <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
   14f6c:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
   14f6e:	8e b3       	in	r24, 0x1e	; 30
   14f70:	88 23       	and	r24, r24
   14f72:	a9 f0       	breq	.+42     	; 0x14f9e <USB_USBTask+0x32>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
   14f74:	80 91 e9 00 	lds	r24, 0x00E9
   14f78:	8f 70       	andi	r24, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
   14f7a:	90 91 ec 00 	lds	r25, 0x00EC
   14f7e:	90 ff       	sbrs	r25, 0
   14f80:	02 c0       	rjmp	.+4      	; 0x14f86 <USB_USBTask+0x1a>
   14f82:	10 e8       	ldi	r17, 0x80	; 128
   14f84:	01 c0       	rjmp	.+2      	; 0x14f88 <USB_USBTask+0x1c>
   14f86:	10 e0       	ldi	r17, 0x00	; 0
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
   14f88:	18 2b       	or	r17, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   14f8a:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
   14f8e:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
   14f92:	83 ff       	sbrs	r24, 3
   14f94:	01 c0       	rjmp	.+2      	; 0x14f98 <USB_USBTask+0x2c>
	  USB_Device_ProcessControlRequest();
   14f96:	85 de       	rcall	.-758    	; 0x14ca2 <USB_Device_ProcessControlRequest>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   14f98:	1f 70       	andi	r17, 0x0F	; 15
   14f9a:	10 93 e9 00 	sts	0x00E9, r17
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
   14f9e:	1f 91       	pop	r17
   14fa0:	08 95       	ret

00014fa2 <HID_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_HID_DRIVER
#define  __INCLUDE_FROM_HID_DEVICE_C
#include "HIDClassDevice.h"

void HID_Device_ProcessControlRequest(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
   14fa2:	6f 92       	push	r6
   14fa4:	7f 92       	push	r7
   14fa6:	8f 92       	push	r8
   14fa8:	9f 92       	push	r9
   14faa:	af 92       	push	r10
   14fac:	bf 92       	push	r11
   14fae:	cf 92       	push	r12
   14fb0:	df 92       	push	r13
   14fb2:	ef 92       	push	r14
   14fb4:	ff 92       	push	r15
   14fb6:	0f 93       	push	r16
   14fb8:	1f 93       	push	r17
   14fba:	df 93       	push	r29
   14fbc:	cf 93       	push	r28
   14fbe:	00 d0       	rcall	.+0      	; 0x14fc0 <HID_Device_ProcessControlRequest+0x1e>
   14fc0:	0f 92       	push	r0
   14fc2:	cd b7       	in	r28, 0x3d	; 61
   14fc4:	de b7       	in	r29, 0x3e	; 62
   14fc6:	7c 01       	movw	r14, r24
				Endpoint_ClearStatusStage();
			}

			break;
	}
}
   14fc8:	6d b6       	in	r6, 0x3d	; 61
   14fca:	7e b6       	in	r7, 0x3e	; 62
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
   14fcc:	80 91 e8 00 	lds	r24, 0x00E8
#define  __INCLUDE_FROM_HID_DEVICE_C
#include "HIDClassDevice.h"

void HID_Device_ProcessControlRequest(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	if (!(Endpoint_IsSETUPReceived()))
   14fd0:	83 ff       	sbrs	r24, 3
   14fd2:	0f c1       	rjmp	.+542    	; 0x151f2 <HID_Device_ProcessControlRequest+0x250>
	  return;

	if (USB_ControlRequest.wIndex != HIDInterfaceInfo->Config.InterfaceNumber)
   14fd4:	f7 01       	movw	r30, r14
   14fd6:	80 81       	ld	r24, Z
   14fd8:	90 e0       	ldi	r25, 0x00	; 0
   14fda:	20 91 1d 14 	lds	r18, 0x141D
   14fde:	30 91 1e 14 	lds	r19, 0x141E
   14fe2:	28 17       	cp	r18, r24
   14fe4:	39 07       	cpc	r19, r25
   14fe6:	09 f0       	breq	.+2      	; 0x14fea <HID_Device_ProcessControlRequest+0x48>
   14fe8:	04 c1       	rjmp	.+520    	; 0x151f2 <HID_Device_ProcessControlRequest+0x250>
	  return;

	switch (USB_ControlRequest.bRequest)
   14fea:	80 91 1a 14 	lds	r24, 0x141A
   14fee:	83 30       	cpi	r24, 0x03	; 3
   14ff0:	09 f4       	brne	.+2      	; 0x14ff4 <HID_Device_ProcessControlRequest+0x52>
   14ff2:	a6 c0       	rjmp	.+332    	; 0x15140 <HID_Device_ProcessControlRequest+0x19e>
   14ff4:	84 30       	cpi	r24, 0x04	; 4
   14ff6:	30 f4       	brcc	.+12     	; 0x15004 <HID_Device_ProcessControlRequest+0x62>
   14ff8:	81 30       	cpi	r24, 0x01	; 1
   14ffa:	71 f0       	breq	.+28     	; 0x15018 <HID_Device_ProcessControlRequest+0x76>
   14ffc:	82 30       	cpi	r24, 0x02	; 2
   14ffe:	09 f0       	breq	.+2      	; 0x15002 <HID_Device_ProcessControlRequest+0x60>
   15000:	f8 c0       	rjmp	.+496    	; 0x151f2 <HID_Device_ProcessControlRequest+0x250>
   15002:	db c0       	rjmp	.+438    	; 0x151ba <HID_Device_ProcessControlRequest+0x218>
   15004:	8a 30       	cpi	r24, 0x0A	; 10
   15006:	09 f4       	brne	.+2      	; 0x1500a <HID_Device_ProcessControlRequest+0x68>
   15008:	c0 c0       	rjmp	.+384    	; 0x1518a <HID_Device_ProcessControlRequest+0x1e8>
   1500a:	8b 30       	cpi	r24, 0x0B	; 11
   1500c:	09 f4       	brne	.+2      	; 0x15010 <HID_Device_ProcessControlRequest+0x6e>
   1500e:	a9 c0       	rjmp	.+338    	; 0x15162 <HID_Device_ProcessControlRequest+0x1c0>
   15010:	89 30       	cpi	r24, 0x09	; 9
   15012:	09 f0       	breq	.+2      	; 0x15016 <HID_Device_ProcessControlRequest+0x74>
   15014:	ee c0       	rjmp	.+476    	; 0x151f2 <HID_Device_ProcessControlRequest+0x250>
   15016:	4d c0       	rjmp	.+154    	; 0x150b2 <HID_Device_ProcessControlRequest+0x110>
	{
		case HID_REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
   15018:	80 91 19 14 	lds	r24, 0x1419
   1501c:	81 3a       	cpi	r24, 0xA1	; 161
   1501e:	09 f0       	breq	.+2      	; 0x15022 <HID_Device_ProcessControlRequest+0x80>
   15020:	e8 c0       	rjmp	.+464    	; 0x151f2 <HID_Device_ProcessControlRequest+0x250>
   15022:	cd b6       	in	r12, 0x3d	; 61
   15024:	de b6       	in	r13, 0x3e	; 62
   15026:	9d b6       	in	r9, 0x3d	; 61
   15028:	8d 2c       	mov	r8, r13
			{
				uint16_t ReportSize = 0;
   1502a:	1b 82       	std	Y+3, r1	; 0x03
   1502c:	1a 82       	std	Y+2, r1	; 0x02
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
   1502e:	80 91 1b 14 	lds	r24, 0x141B
   15032:	00 91 1c 14 	lds	r16, 0x141C
   15036:	89 83       	std	Y+1, r24	; 0x01
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
				uint8_t  ReportData[HIDInterfaceInfo->Config.PrevReportINBufferSize];
   15038:	f7 01       	movw	r30, r14
   1503a:	40 85       	ldd	r20, Z+8	; 0x08
   1503c:	c4 1a       	sub	r12, r20
   1503e:	d1 08       	sbc	r13, r1
   15040:	0f b6       	in	r0, 0x3f	; 63
   15042:	f8 94       	cli
   15044:	de be       	out	0x3e, r13	; 62
   15046:	0f be       	out	0x3f, r0	; 63
   15048:	cd be       	out	0x3d, r12	; 61
   1504a:	08 94       	sec
   1504c:	c1 1c       	adc	r12, r1
   1504e:	d1 1c       	adc	r13, r1
   15050:	bc 2c       	mov	r11, r12
   15052:	ad 2c       	mov	r10, r13

				memset(ReportData, 0, sizeof(ReportData));
   15054:	c6 01       	movw	r24, r12
   15056:	60 e0       	ldi	r22, 0x00	; 0
   15058:	70 e0       	ldi	r23, 0x00	; 0
   1505a:	50 e0       	ldi	r21, 0x00	; 0
   1505c:	09 d5       	rcall	.+2578   	; 0x15a70 <memset>
		case HID_REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				uint16_t ReportSize = 0;
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
   1505e:	40 2f       	mov	r20, r16
   15060:	41 50       	subi	r20, 0x01	; 1
				uint8_t  ReportData[HIDInterfaceInfo->Config.PrevReportINBufferSize];

				memset(ReportData, 0, sizeof(ReportData));

				CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, ReportType, ReportData, &ReportSize);
   15062:	c7 01       	movw	r24, r14
   15064:	be 01       	movw	r22, r28
   15066:	6f 5f       	subi	r22, 0xFF	; 255
   15068:	7f 4f       	sbci	r23, 0xFF	; 255
   1506a:	96 01       	movw	r18, r12
   1506c:	8e 01       	movw	r16, r28
   1506e:	0e 5f       	subi	r16, 0xFE	; 254
   15070:	1f 4f       	sbci	r17, 0xFF	; 255
   15072:	0e 94 39 80 	call	0x10072	; 0x10072 <CALLBACK_HID_Device_CreateHIDReport>

				if (HIDInterfaceInfo->Config.PrevReportINBuffer != NULL)
   15076:	f7 01       	movw	r30, r14
   15078:	26 81       	ldd	r18, Z+6	; 0x06
   1507a:	37 81       	ldd	r19, Z+7	; 0x07
   1507c:	21 15       	cp	r18, r1
   1507e:	31 05       	cpc	r19, r1
   15080:	29 f0       	breq	.+10     	; 0x1508c <HID_Device_ProcessControlRequest+0xea>
				{
					memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportData,
   15082:	40 85       	ldd	r20, Z+8	; 0x08
   15084:	c9 01       	movw	r24, r18
   15086:	b6 01       	movw	r22, r12
   15088:	50 e0       	ldi	r21, 0x00	; 0
   1508a:	e9 d4       	rcall	.+2514   	; 0x15a5e <memcpy>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   1508c:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
   15090:	80 91 e8 00 	lds	r24, 0x00E8
   15094:	87 7f       	andi	r24, 0xF7	; 247
   15096:	80 93 e8 00 	sts	0x00E8, r24
				}

				Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(ReportData, ReportSize);
   1509a:	6a 81       	ldd	r22, Y+2	; 0x02
   1509c:	7b 81       	ldd	r23, Y+3	; 0x03
   1509e:	8b 2d       	mov	r24, r11
   150a0:	9a 2d       	mov	r25, r10
   150a2:	d2 da       	rcall	.-2652   	; 0x14648 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
   150a4:	80 91 e8 00 	lds	r24, 0x00E8
   150a8:	8b 77       	andi	r24, 0x7B	; 123
   150aa:	80 93 e8 00 	sts	0x00E8, r24
   150ae:	94 01       	movw	r18, r8
   150b0:	3f c0       	rjmp	.+126    	; 0x15130 <HID_Device_ProcessControlRequest+0x18e>
				Endpoint_ClearOUT();
			}

			break;
		case HID_REQ_SetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
   150b2:	80 91 19 14 	lds	r24, 0x1419
   150b6:	81 32       	cpi	r24, 0x21	; 33
   150b8:	09 f0       	breq	.+2      	; 0x150bc <HID_Device_ProcessControlRequest+0x11a>
   150ba:	9b c0       	rjmp	.+310    	; 0x151f2 <HID_Device_ProcessControlRequest+0x250>
   150bc:	cd b6       	in	r12, 0x3d	; 61
   150be:	de b6       	in	r13, 0x3e	; 62
   150c0:	bd b6       	in	r11, 0x3d	; 61
   150c2:	9d 2c       	mov	r9, r13
			{
				uint16_t ReportSize = USB_ControlRequest.wLength;
   150c4:	00 91 1f 14 	lds	r16, 0x141F
   150c8:	10 91 20 14 	lds	r17, 0x1420
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
   150cc:	a0 90 1b 14 	lds	r10, 0x141B
   150d0:	80 90 1c 14 	lds	r8, 0x141C
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
				uint8_t  ReportData[ReportSize];
   150d4:	8d b7       	in	r24, 0x3d	; 61
   150d6:	9e b7       	in	r25, 0x3e	; 62
   150d8:	80 1b       	sub	r24, r16
   150da:	91 0b       	sbc	r25, r17
   150dc:	0f b6       	in	r0, 0x3f	; 63
   150de:	f8 94       	cli
   150e0:	9e bf       	out	0x3e, r25	; 62
   150e2:	0f be       	out	0x3f, r0	; 63
   150e4:	8d bf       	out	0x3d, r24	; 61
   150e6:	cd b6       	in	r12, 0x3d	; 61
   150e8:	de b6       	in	r13, 0x3e	; 62
   150ea:	08 94       	sec
   150ec:	c1 1c       	adc	r12, r1
   150ee:	d1 1c       	adc	r13, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
   150f0:	80 91 e8 00 	lds	r24, 0x00E8
   150f4:	87 7f       	andi	r24, 0xF7	; 247
   150f6:	80 93 e8 00 	sts	0x00E8, r24

				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(ReportData, ReportSize);
   150fa:	c6 01       	movw	r24, r12
   150fc:	b8 01       	movw	r22, r16
   150fe:	ff da       	rcall	.-2562   	; 0x146fe <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   15100:	80 91 e8 00 	lds	r24, 0x00E8
   15104:	8e 77       	andi	r24, 0x7E	; 126
   15106:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();

				CALLBACK_HID_Device_ProcessHIDReport(HIDInterfaceInfo, ReportID, ReportType,
   1510a:	81 e0       	ldi	r24, 0x01	; 1
   1510c:	90 e0       	ldi	r25, 0x00	; 0
   1510e:	aa 20       	and	r10, r10
   15110:	11 f4       	brne	.+4      	; 0x15116 <HID_Device_ProcessControlRequest+0x174>
   15112:	80 e0       	ldi	r24, 0x00	; 0
   15114:	90 e0       	ldi	r25, 0x00	; 0
		case HID_REQ_SetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				uint16_t ReportSize = USB_ControlRequest.wLength;
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
   15116:	48 2d       	mov	r20, r8
   15118:	41 50       	subi	r20, 0x01	; 1

				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(ReportData, ReportSize);
				Endpoint_ClearIN();

				CALLBACK_HID_Device_ProcessHIDReport(HIDInterfaceInfo, ReportID, ReportType,
   1511a:	96 01       	movw	r18, r12
   1511c:	28 0f       	add	r18, r24
   1511e:	39 1f       	adc	r19, r25
   15120:	08 1b       	sub	r16, r24
   15122:	19 0b       	sbc	r17, r25
   15124:	c7 01       	movw	r24, r14
   15126:	6a 2d       	mov	r22, r10
   15128:	0e 94 77 80 	call	0x100ee	; 0x100ee <CALLBACK_HID_Device_ProcessHIDReport>
   1512c:	3b 2d       	mov	r19, r11
   1512e:	29 2d       	mov	r18, r9
   15130:	83 2f       	mov	r24, r19
   15132:	92 2f       	mov	r25, r18
   15134:	0f b6       	in	r0, 0x3f	; 63
   15136:	f8 94       	cli
   15138:	9e bf       	out	0x3e, r25	; 62
   1513a:	0f be       	out	0x3f, r0	; 63
   1513c:	8d bf       	out	0x3d, r24	; 61
   1513e:	59 c0       	rjmp	.+178    	; 0x151f2 <HID_Device_ProcessControlRequest+0x250>
				                                     &ReportData[ReportID ? 1 : 0], ReportSize - (ReportID ? 1 : 0));
			}

			break;
		case HID_REQ_GetProtocol:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
   15140:	80 91 19 14 	lds	r24, 0x1419
   15144:	81 3a       	cpi	r24, 0xA1	; 161
   15146:	09 f0       	breq	.+2      	; 0x1514a <HID_Device_ProcessControlRequest+0x1a8>
   15148:	54 c0       	rjmp	.+168    	; 0x151f2 <HID_Device_ProcessControlRequest+0x250>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
   1514a:	80 91 e8 00 	lds	r24, 0x00E8
   1514e:	87 7f       	andi	r24, 0xF7	; 247
   15150:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
   15154:	80 91 e8 00 	lds	r24, 0x00E8
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
   15158:	80 ff       	sbrs	r24, 0
   1515a:	fc cf       	rjmp	.-8      	; 0x15154 <HID_Device_ProcessControlRequest+0x1b2>
				Endpoint_Write_8(HIDInterfaceInfo->State.UsingReportProtocol);
   1515c:	f7 01       	movw	r30, r14
   1515e:	81 85       	ldd	r24, Z+9	; 0x09
   15160:	40 c0       	rjmp	.+128    	; 0x151e2 <HID_Device_ProcessControlRequest+0x240>
				Endpoint_ClearStatusStage();
			}

			break;
		case HID_REQ_SetProtocol:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
   15162:	80 91 19 14 	lds	r24, 0x1419
   15166:	81 32       	cpi	r24, 0x21	; 33
   15168:	09 f0       	breq	.+2      	; 0x1516c <HID_Device_ProcessControlRequest+0x1ca>
   1516a:	43 c0       	rjmp	.+134    	; 0x151f2 <HID_Device_ProcessControlRequest+0x250>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
   1516c:	80 91 e8 00 	lds	r24, 0x00E8
   15170:	87 7f       	andi	r24, 0xF7	; 247
   15172:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
   15176:	d9 db       	rcall	.-2126   	; 0x1492a <Endpoint_ClearStatusStage>

				HIDInterfaceInfo->State.UsingReportProtocol = ((USB_ControlRequest.wValue & 0xFF) != 0x00);
   15178:	90 91 1b 14 	lds	r25, 0x141B
   1517c:	81 e0       	ldi	r24, 0x01	; 1
   1517e:	99 23       	and	r25, r25
   15180:	09 f4       	brne	.+2      	; 0x15184 <HID_Device_ProcessControlRequest+0x1e2>
   15182:	80 e0       	ldi	r24, 0x00	; 0
   15184:	f7 01       	movw	r30, r14
   15186:	81 87       	std	Z+9, r24	; 0x09
   15188:	34 c0       	rjmp	.+104    	; 0x151f2 <HID_Device_ProcessControlRequest+0x250>
			}

			break;
		case HID_REQ_SetIdle:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
   1518a:	80 91 19 14 	lds	r24, 0x1419
   1518e:	81 32       	cpi	r24, 0x21	; 33
   15190:	81 f5       	brne	.+96     	; 0x151f2 <HID_Device_ProcessControlRequest+0x250>
   15192:	80 91 e8 00 	lds	r24, 0x00E8
   15196:	87 7f       	andi	r24, 0xF7	; 247
   15198:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
   1519c:	c6 db       	rcall	.-2164   	; 0x1492a <Endpoint_ClearStatusStage>

				HIDInterfaceInfo->State.IdleCount = ((USB_ControlRequest.wValue & 0xFF00) >> 6);
   1519e:	80 91 1b 14 	lds	r24, 0x141B
   151a2:	90 91 1c 14 	lds	r25, 0x141C
   151a6:	80 70       	andi	r24, 0x00	; 0
   151a8:	36 e0       	ldi	r19, 0x06	; 6
   151aa:	96 95       	lsr	r25
   151ac:	87 95       	ror	r24
   151ae:	3a 95       	dec	r19
   151b0:	e1 f7       	brne	.-8      	; 0x151aa <HID_Device_ProcessControlRequest+0x208>
   151b2:	f7 01       	movw	r30, r14
   151b4:	95 87       	std	Z+13, r25	; 0x0d
   151b6:	84 87       	std	Z+12, r24	; 0x0c
   151b8:	1c c0       	rjmp	.+56     	; 0x151f2 <HID_Device_ProcessControlRequest+0x250>
			}

			break;
		case HID_REQ_GetIdle:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
   151ba:	80 91 19 14 	lds	r24, 0x1419
   151be:	81 3a       	cpi	r24, 0xA1	; 161
   151c0:	c1 f4       	brne	.+48     	; 0x151f2 <HID_Device_ProcessControlRequest+0x250>
   151c2:	80 91 e8 00 	lds	r24, 0x00E8
   151c6:	87 7f       	andi	r24, 0xF7	; 247
   151c8:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
   151cc:	80 91 e8 00 	lds	r24, 0x00E8
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
   151d0:	80 ff       	sbrs	r24, 0
   151d2:	fc cf       	rjmp	.-8      	; 0x151cc <HID_Device_ProcessControlRequest+0x22a>
				Endpoint_Write_8(HIDInterfaceInfo->State.IdleCount >> 2);
   151d4:	f7 01       	movw	r30, r14
   151d6:	84 85       	ldd	r24, Z+12	; 0x0c
   151d8:	95 85       	ldd	r25, Z+13	; 0x0d
   151da:	96 95       	lsr	r25
   151dc:	87 95       	ror	r24
   151de:	96 95       	lsr	r25
   151e0:	87 95       	ror	r24
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
   151e2:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   151e6:	80 91 e8 00 	lds	r24, 0x00E8
   151ea:	8e 77       	andi	r24, 0x7E	; 126
   151ec:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
   151f0:	9c db       	rcall	.-2248   	; 0x1492a <Endpoint_ClearStatusStage>
			}

			break;
	}
}
   151f2:	0f b6       	in	r0, 0x3f	; 63
   151f4:	f8 94       	cli
   151f6:	7e be       	out	0x3e, r7	; 62
   151f8:	0f be       	out	0x3f, r0	; 63
   151fa:	6d be       	out	0x3d, r6	; 61
   151fc:	0f 90       	pop	r0
   151fe:	0f 90       	pop	r0
   15200:	0f 90       	pop	r0
   15202:	cf 91       	pop	r28
   15204:	df 91       	pop	r29
   15206:	1f 91       	pop	r17
   15208:	0f 91       	pop	r16
   1520a:	ff 90       	pop	r15
   1520c:	ef 90       	pop	r14
   1520e:	df 90       	pop	r13
   15210:	cf 90       	pop	r12
   15212:	bf 90       	pop	r11
   15214:	af 90       	pop	r10
   15216:	9f 90       	pop	r9
   15218:	8f 90       	pop	r8
   1521a:	7f 90       	pop	r7
   1521c:	6f 90       	pop	r6
   1521e:	08 95       	ret

00015220 <HID_Device_ConfigureEndpoints>:

bool HID_Device_ConfigureEndpoints(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
   15220:	cf 93       	push	r28
   15222:	df 93       	push	r29
   15224:	fc 01       	movw	r30, r24
	memset(&HIDInterfaceInfo->State, 0x00, sizeof(HIDInterfaceInfo->State));
   15226:	09 96       	adiw	r24, 0x09	; 9
   15228:	dc 01       	movw	r26, r24
   1522a:	87 e0       	ldi	r24, 0x07	; 7
   1522c:	ed 01       	movw	r28, r26
   1522e:	19 92       	st	Y+, r1
   15230:	8a 95       	dec	r24
   15232:	e9 f7       	brne	.-6      	; 0x1522e <HID_Device_ConfigureEndpoints+0xe>
	HIDInterfaceInfo->State.UsingReportProtocol = true;
   15234:	81 e0       	ldi	r24, 0x01	; 1
   15236:	81 87       	std	Z+9, r24	; 0x09
	HIDInterfaceInfo->State.IdleCount           = 500;
   15238:	84 ef       	ldi	r24, 0xF4	; 244
   1523a:	91 e0       	ldi	r25, 0x01	; 1
   1523c:	95 87       	std	Z+13, r25	; 0x0d
   1523e:	84 87       	std	Z+12, r24	; 0x0c

	HIDInterfaceInfo->Config.ReportINEndpoint.Type = EP_TYPE_INTERRUPT;
   15240:	83 e0       	ldi	r24, 0x03	; 3
   15242:	84 83       	std	Z+4, r24	; 0x04

	if (!(Endpoint_ConfigureEndpointTable(&HIDInterfaceInfo->Config.ReportINEndpoint, 1)))
   15244:	cf 01       	movw	r24, r30
   15246:	01 96       	adiw	r24, 0x01	; 1
   15248:	61 e0       	ldi	r22, 0x01	; 1
   1524a:	2b db       	rcall	.-2474   	; 0x148a2 <Endpoint_ConfigureEndpointTable>
	  return false;

	return true;
}
   1524c:	df 91       	pop	r29
   1524e:	cf 91       	pop	r28
   15250:	08 95       	ret

00015252 <HID_Device_USBTask>:

void HID_Device_USBTask(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
   15252:	5f 92       	push	r5
   15254:	6f 92       	push	r6
   15256:	7f 92       	push	r7
   15258:	8f 92       	push	r8
   1525a:	9f 92       	push	r9
   1525c:	af 92       	push	r10
   1525e:	bf 92       	push	r11
   15260:	cf 92       	push	r12
   15262:	df 92       	push	r13
   15264:	ef 92       	push	r14
   15266:	ff 92       	push	r15
   15268:	0f 93       	push	r16
   1526a:	1f 93       	push	r17
   1526c:	df 93       	push	r29
   1526e:	cf 93       	push	r28
   15270:	00 d0       	rcall	.+0      	; 0x15272 <HID_Device_USBTask+0x20>
   15272:	00 d0       	rcall	.+0      	; 0x15274 <HID_Device_USBTask+0x22>
   15274:	cd b7       	in	r28, 0x3d	; 61
   15276:	de b7       	in	r29, 0x3e	; 62
   15278:	7c 01       	movw	r14, r24
			Endpoint_ClearIN();
		}

		HIDInterfaceInfo->State.PrevFrameNum = USB_Device_GetFrameNumber();
	}
}
   1527a:	6d b6       	in	r6, 0x3d	; 61
   1527c:	7e b6       	in	r7, 0x3e	; 62
	return true;
}

void HID_Device_USBTask(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	if (USB_DeviceState != DEVICE_STATE_Configured)
   1527e:	8e b3       	in	r24, 0x1e	; 30
   15280:	84 30       	cpi	r24, 0x04	; 4
   15282:	09 f0       	breq	.+2      	; 0x15286 <HID_Device_USBTask+0x34>
   15284:	99 c0       	rjmp	.+306    	; 0x153b8 <HID_Device_USBTask+0x166>
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
   15286:	80 91 e4 00 	lds	r24, 0x00E4
   1528a:	90 91 e5 00 	lds	r25, 0x00E5
	  return;

	if (HIDInterfaceInfo->State.PrevFrameNum == USB_Device_GetFrameNumber())
   1528e:	f7 01       	movw	r30, r14
   15290:	22 85       	ldd	r18, Z+10	; 0x0a
   15292:	33 85       	ldd	r19, Z+11	; 0x0b
   15294:	28 17       	cp	r18, r24
   15296:	39 07       	cpc	r19, r25
   15298:	09 f4       	brne	.+2      	; 0x1529c <HID_Device_USBTask+0x4a>
   1529a:	8e c0       	rjmp	.+284    	; 0x153b8 <HID_Device_USBTask+0x166>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   1529c:	81 81       	ldd	r24, Z+1	; 0x01
   1529e:	8f 70       	andi	r24, 0x0F	; 15
   152a0:	80 93 e9 00 	sts	0x00E9, r24
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
   152a4:	80 91 e8 00 	lds	r24, 0x00E8
		#endif
	}

	Endpoint_SelectEndpoint(HIDInterfaceInfo->Config.ReportINEndpoint.Address);

	if (Endpoint_IsReadWriteAllowed())
   152a8:	85 ff       	sbrs	r24, 5
   152aa:	86 c0       	rjmp	.+268    	; 0x153b8 <HID_Device_USBTask+0x166>
   152ac:	8d b6       	in	r8, 0x3d	; 61
   152ae:	57 2c       	mov	r5, r7
	{
		uint8_t  ReportINData[HIDInterfaceInfo->Config.PrevReportINBufferSize];
   152b0:	40 85       	ldd	r20, Z+8	; 0x08
   152b2:	cd b6       	in	r12, 0x3d	; 61
   152b4:	de b6       	in	r13, 0x3e	; 62
   152b6:	c4 1a       	sub	r12, r20
   152b8:	d1 08       	sbc	r13, r1
   152ba:	0f b6       	in	r0, 0x3f	; 63
   152bc:	f8 94       	cli
   152be:	de be       	out	0x3e, r13	; 62
   152c0:	0f be       	out	0x3f, r0	; 63
   152c2:	cd be       	out	0x3d, r12	; 61
   152c4:	0d b7       	in	r16, 0x3d	; 61
   152c6:	1e b7       	in	r17, 0x3e	; 62
   152c8:	0f 5f       	subi	r16, 0xFF	; 255
   152ca:	1f 4f       	sbci	r17, 0xFF	; 255
   152cc:	b0 2e       	mov	r11, r16
   152ce:	a1 2e       	mov	r10, r17
		uint8_t  ReportID     = 0;
   152d0:	19 82       	std	Y+1, r1	; 0x01
		uint16_t ReportINSize = 0;
   152d2:	1b 82       	std	Y+3, r1	; 0x03
   152d4:	1a 82       	std	Y+2, r1	; 0x02

		memset(ReportINData, 0, sizeof(ReportINData));
   152d6:	c8 01       	movw	r24, r16
   152d8:	60 e0       	ldi	r22, 0x00	; 0
   152da:	70 e0       	ldi	r23, 0x00	; 0
   152dc:	50 e0       	ldi	r21, 0x00	; 0
   152de:	c8 d3       	rcall	.+1936   	; 0x15a70 <memset>

		bool ForceSend         = CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, HID_REPORT_ITEM_In,
   152e0:	c7 01       	movw	r24, r14
   152e2:	be 01       	movw	r22, r28
   152e4:	6f 5f       	subi	r22, 0xFF	; 255
   152e6:	7f 4f       	sbci	r23, 0xFF	; 255
   152e8:	40 e0       	ldi	r20, 0x00	; 0
   152ea:	98 01       	movw	r18, r16
   152ec:	8e 01       	movw	r16, r28
   152ee:	0e 5f       	subi	r16, 0xFE	; 254
   152f0:	1f 4f       	sbci	r17, 0xFF	; 255
   152f2:	0e 94 39 80 	call	0x10072	; 0x10072 <CALLBACK_HID_Device_CreateHIDReport>
   152f6:	98 2e       	mov	r9, r24
		                                                             ReportINData, &ReportINSize);
		bool StatesChanged     = false;
		bool IdlePeriodElapsed = (HIDInterfaceInfo->State.IdleCount && !(HIDInterfaceInfo->State.IdleMSRemaining));
   152f8:	f7 01       	movw	r30, r14
   152fa:	84 85       	ldd	r24, Z+12	; 0x0c
   152fc:	95 85       	ldd	r25, Z+13	; 0x0d
   152fe:	00 97       	sbiw	r24, 0x00	; 0
   15300:	59 f0       	breq	.+22     	; 0x15318 <HID_Device_USBTask+0xc6>
	  return false;

	return true;
}

void HID_Device_USBTask(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
   15302:	81 e0       	ldi	r24, 0x01	; 1
   15304:	90 e0       	ldi	r25, 0x00	; 0
   15306:	26 85       	ldd	r18, Z+14	; 0x0e
   15308:	37 85       	ldd	r19, Z+15	; 0x0f
   1530a:	21 15       	cp	r18, r1
   1530c:	31 05       	cpc	r19, r1
   1530e:	11 f0       	breq	.+4      	; 0x15314 <HID_Device_USBTask+0xc2>
   15310:	80 e0       	ldi	r24, 0x00	; 0
   15312:	90 e0       	ldi	r25, 0x00	; 0
		memset(ReportINData, 0, sizeof(ReportINData));

		bool ForceSend         = CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, HID_REPORT_ITEM_In,
		                                                             ReportINData, &ReportINSize);
		bool StatesChanged     = false;
		bool IdlePeriodElapsed = (HIDInterfaceInfo->State.IdleCount && !(HIDInterfaceInfo->State.IdleMSRemaining));
   15314:	6c 01       	movw	r12, r24
   15316:	02 c0       	rjmp	.+4      	; 0x1531c <HID_Device_USBTask+0xca>
   15318:	cc 24       	eor	r12, r12
   1531a:	dd 24       	eor	r13, r13

		if (HIDInterfaceInfo->Config.PrevReportINBuffer != NULL)
   1531c:	f7 01       	movw	r30, r14
   1531e:	06 81       	ldd	r16, Z+6	; 0x06
   15320:	17 81       	ldd	r17, Z+7	; 0x07
   15322:	01 15       	cp	r16, r1
   15324:	11 05       	cpc	r17, r1
   15326:	a1 f0       	breq	.+40     	; 0x15350 <HID_Device_USBTask+0xfe>
		{
			StatesChanged = (memcmp(ReportINData, HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINSize) != 0);
   15328:	4a 81       	ldd	r20, Y+2	; 0x02
   1532a:	5b 81       	ldd	r21, Y+3	; 0x03
   1532c:	8b 2d       	mov	r24, r11
   1532e:	9a 2d       	mov	r25, r10
   15330:	b8 01       	movw	r22, r16
   15332:	88 d3       	rcall	.+1808   	; 0x15a44 <memcmp>
   15334:	21 e0       	ldi	r18, 0x01	; 1
   15336:	00 97       	sbiw	r24, 0x00	; 0
   15338:	09 f4       	brne	.+2      	; 0x1533c <HID_Device_USBTask+0xea>
   1533a:	20 e0       	ldi	r18, 0x00	; 0
			memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINData, HIDInterfaceInfo->Config.PrevReportINBufferSize);
   1533c:	f7 01       	movw	r30, r14
   1533e:	40 85       	ldd	r20, Z+8	; 0x08
   15340:	c8 01       	movw	r24, r16
   15342:	6b 2d       	mov	r22, r11
   15344:	7a 2d       	mov	r23, r10
   15346:	50 e0       	ldi	r21, 0x00	; 0
   15348:	2c 83       	std	Y+4, r18	; 0x04
   1534a:	89 d3       	rcall	.+1810   	; 0x15a5e <memcpy>
   1534c:	2c 81       	ldd	r18, Y+4	; 0x04
   1534e:	01 c0       	rjmp	.+2      	; 0x15352 <HID_Device_USBTask+0x100>

		memset(ReportINData, 0, sizeof(ReportINData));

		bool ForceSend         = CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, HID_REPORT_ITEM_In,
		                                                             ReportINData, &ReportINSize);
		bool StatesChanged     = false;
   15350:	20 e0       	ldi	r18, 0x00	; 0
		{
			StatesChanged = (memcmp(ReportINData, HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINSize) != 0);
			memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINData, HIDInterfaceInfo->Config.PrevReportINBufferSize);
		}

		if (ReportINSize && (ForceSend || StatesChanged || IdlePeriodElapsed))
   15352:	8a 81       	ldd	r24, Y+2	; 0x02
   15354:	9b 81       	ldd	r25, Y+3	; 0x03
   15356:	00 97       	sbiw	r24, 0x00	; 0
   15358:	09 f1       	breq	.+66     	; 0x1539c <HID_Device_USBTask+0x14a>
   1535a:	99 20       	and	r9, r9
   1535c:	29 f4       	brne	.+10     	; 0x15368 <HID_Device_USBTask+0x116>
   1535e:	22 23       	and	r18, r18
   15360:	19 f4       	brne	.+6      	; 0x15368 <HID_Device_USBTask+0x116>
   15362:	c1 14       	cp	r12, r1
   15364:	d1 04       	cpc	r13, r1
   15366:	d1 f0       	breq	.+52     	; 0x1539c <HID_Device_USBTask+0x14a>
		{
			HIDInterfaceInfo->State.IdleMSRemaining = HIDInterfaceInfo->State.IdleCount;
   15368:	f7 01       	movw	r30, r14
   1536a:	84 85       	ldd	r24, Z+12	; 0x0c
   1536c:	95 85       	ldd	r25, Z+13	; 0x0d
   1536e:	97 87       	std	Z+15, r25	; 0x0f
   15370:	86 87       	std	Z+14, r24	; 0x0e
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   15372:	81 81       	ldd	r24, Z+1	; 0x01
   15374:	8f 70       	andi	r24, 0x0F	; 15
   15376:	80 93 e9 00 	sts	0x00E9, r24

			Endpoint_SelectEndpoint(HIDInterfaceInfo->Config.ReportINEndpoint.Address);

			if (ReportID)
   1537a:	89 81       	ldd	r24, Y+1	; 0x01
   1537c:	88 23       	and	r24, r24
   1537e:	11 f0       	breq	.+4      	; 0x15384 <HID_Device_USBTask+0x132>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
   15380:	80 93 f1 00 	sts	0x00F1, r24
			  Endpoint_Write_8(ReportID);

			Endpoint_Write_Stream_LE(ReportINData, ReportINSize, NULL);
   15384:	6a 81       	ldd	r22, Y+2	; 0x02
   15386:	7b 81       	ldd	r23, Y+3	; 0x03
   15388:	8b 2d       	mov	r24, r11
   1538a:	9a 2d       	mov	r25, r10
   1538c:	40 e0       	ldi	r20, 0x00	; 0
   1538e:	50 e0       	ldi	r21, 0x00	; 0
   15390:	4c d8       	rcall	.-3944   	; 0x1442a <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   15392:	80 91 e8 00 	lds	r24, 0x00E8
   15396:	8e 77       	andi	r24, 0x7E	; 126
   15398:	80 93 e8 00 	sts	0x00E8, r24
   1539c:	80 91 e4 00 	lds	r24, 0x00E4
   153a0:	90 91 e5 00 	lds	r25, 0x00E5

			Endpoint_ClearIN();
		}

		HIDInterfaceInfo->State.PrevFrameNum = USB_Device_GetFrameNumber();
   153a4:	f7 01       	movw	r30, r14
   153a6:	93 87       	std	Z+11, r25	; 0x0b
   153a8:	82 87       	std	Z+10, r24	; 0x0a
   153aa:	88 2d       	mov	r24, r8
   153ac:	95 2d       	mov	r25, r5
   153ae:	0f b6       	in	r0, 0x3f	; 63
   153b0:	f8 94       	cli
   153b2:	9e bf       	out	0x3e, r25	; 62
   153b4:	0f be       	out	0x3f, r0	; 63
   153b6:	8d bf       	out	0x3d, r24	; 61
	}
}
   153b8:	0f b6       	in	r0, 0x3f	; 63
   153ba:	f8 94       	cli
   153bc:	7e be       	out	0x3e, r7	; 62
   153be:	0f be       	out	0x3f, r0	; 63
   153c0:	6d be       	out	0x3d, r6	; 61
   153c2:	0f 90       	pop	r0
   153c4:	0f 90       	pop	r0
   153c6:	0f 90       	pop	r0
   153c8:	0f 90       	pop	r0
   153ca:	cf 91       	pop	r28
   153cc:	df 91       	pop	r29
   153ce:	1f 91       	pop	r17
   153d0:	0f 91       	pop	r16
   153d2:	ff 90       	pop	r15
   153d4:	ef 90       	pop	r14
   153d6:	df 90       	pop	r13
   153d8:	cf 90       	pop	r12
   153da:	bf 90       	pop	r11
   153dc:	af 90       	pop	r10
   153de:	9f 90       	pop	r9
   153e0:	8f 90       	pop	r8
   153e2:	7f 90       	pop	r7
   153e4:	6f 90       	pop	r6
   153e6:	5f 90       	pop	r5
   153e8:	08 95       	ret

000153ea <MS_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_MS_DRIVER
#define  __INCLUDE_FROM_MASSSTORAGE_DEVICE_C
#include "MassStorageClassDevice.h"

void MS_Device_ProcessControlRequest(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
   153ea:	cf 93       	push	r28
   153ec:	df 93       	push	r29
   153ee:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
   153f0:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
   153f4:	83 ff       	sbrs	r24, 3
   153f6:	33 c0       	rjmp	.+102    	; 0x1545e <MS_Device_ProcessControlRequest+0x74>
	  return;

	if (USB_ControlRequest.wIndex != MSInterfaceInfo->Config.InterfaceNumber)
   153f8:	88 81       	ld	r24, Y
   153fa:	90 e0       	ldi	r25, 0x00	; 0
   153fc:	20 91 1d 14 	lds	r18, 0x141D
   15400:	30 91 1e 14 	lds	r19, 0x141E
   15404:	28 17       	cp	r18, r24
   15406:	39 07       	cpc	r19, r25
   15408:	51 f5       	brne	.+84     	; 0x1545e <MS_Device_ProcessControlRequest+0x74>
	  return;

	switch (USB_ControlRequest.bRequest)
   1540a:	80 91 1a 14 	lds	r24, 0x141A
   1540e:	8e 3f       	cpi	r24, 0xFE	; 254
   15410:	79 f0       	breq	.+30     	; 0x15430 <MS_Device_ProcessControlRequest+0x46>
   15412:	8f 3f       	cpi	r24, 0xFF	; 255
   15414:	21 f5       	brne	.+72     	; 0x1545e <MS_Device_ProcessControlRequest+0x74>
	{
		case MS_REQ_MassStorageReset:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
   15416:	80 91 19 14 	lds	r24, 0x1419
   1541a:	81 32       	cpi	r24, 0x21	; 33
   1541c:	01 f5       	brne	.+64     	; 0x1545e <MS_Device_ProcessControlRequest+0x74>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
   1541e:	80 91 e8 00 	lds	r24, 0x00E8
   15422:	87 7f       	andi	r24, 0xF7	; 247
   15424:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
   15428:	80 da       	rcall	.-2816   	; 0x1492a <Endpoint_ClearStatusStage>

				MSInterfaceInfo->State.IsMassStoreReset = true;
   1542a:	81 e0       	ldi	r24, 0x01	; 1
   1542c:	88 af       	std	Y+56, r24	; 0x38
   1542e:	17 c0       	rjmp	.+46     	; 0x1545e <MS_Device_ProcessControlRequest+0x74>
			}

			break;
		case MS_REQ_GetMaxLUN:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
   15430:	80 91 19 14 	lds	r24, 0x1419
   15434:	81 3a       	cpi	r24, 0xA1	; 161
   15436:	99 f4       	brne	.+38     	; 0x1545e <MS_Device_ProcessControlRequest+0x74>
   15438:	80 91 e8 00 	lds	r24, 0x00E8
   1543c:	87 7f       	andi	r24, 0xF7	; 247
   1543e:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
   15442:	80 91 e8 00 	lds	r24, 0x00E8
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
   15446:	80 ff       	sbrs	r24, 0
   15448:	fc cf       	rjmp	.-8      	; 0x15442 <MS_Device_ProcessControlRequest+0x58>
				Endpoint_Write_8(MSInterfaceInfo->Config.TotalLUNs - 1);
   1544a:	8b 85       	ldd	r24, Y+11	; 0x0b
   1544c:	81 50       	subi	r24, 0x01	; 1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
   1544e:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   15452:	80 91 e8 00 	lds	r24, 0x00E8
   15456:	8e 77       	andi	r24, 0x7E	; 126
   15458:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
   1545c:	66 da       	rcall	.-2868   	; 0x1492a <Endpoint_ClearStatusStage>
			}

			break;
	}
}
   1545e:	df 91       	pop	r29
   15460:	cf 91       	pop	r28
   15462:	08 95       	ret

00015464 <MS_Device_ConfigureEndpoints>:

bool MS_Device_ConfigureEndpoints(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
   15464:	cf 93       	push	r28
   15466:	df 93       	push	r29
   15468:	ec 01       	movw	r28, r24
	memset(&MSInterfaceInfo->State, 0x00, sizeof(MSInterfaceInfo->State));
   1546a:	0c 96       	adiw	r24, 0x0c	; 12
   1546c:	fc 01       	movw	r30, r24
   1546e:	8d e2       	ldi	r24, 0x2D	; 45
   15470:	df 01       	movw	r26, r30
   15472:	1d 92       	st	X+, r1
   15474:	8a 95       	dec	r24
   15476:	e9 f7       	brne	.-6      	; 0x15472 <MS_Device_ConfigureEndpoints+0xe>

	MSInterfaceInfo->Config.DataINEndpoint.Type  = EP_TYPE_BULK;
   15478:	82 e0       	ldi	r24, 0x02	; 2
   1547a:	8c 83       	std	Y+4, r24	; 0x04
	MSInterfaceInfo->Config.DataOUTEndpoint.Type = EP_TYPE_BULK;
   1547c:	89 87       	std	Y+9, r24	; 0x09

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataINEndpoint, 1)))
   1547e:	ce 01       	movw	r24, r28
   15480:	01 96       	adiw	r24, 0x01	; 1
   15482:	61 e0       	ldi	r22, 0x01	; 1
   15484:	0e da       	rcall	.-3044   	; 0x148a2 <Endpoint_ConfigureEndpointTable>
   15486:	88 23       	and	r24, r24
   15488:	29 f0       	breq	.+10     	; 0x15494 <MS_Device_ConfigureEndpoints+0x30>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataOUTEndpoint, 1)))
   1548a:	ce 01       	movw	r24, r28
   1548c:	06 96       	adiw	r24, 0x06	; 6
   1548e:	61 e0       	ldi	r22, 0x01	; 1
   15490:	08 da       	rcall	.-3056   	; 0x148a2 <Endpoint_ConfigureEndpointTable>
   15492:	01 c0       	rjmp	.+2      	; 0x15496 <MS_Device_ConfigureEndpoints+0x32>

	MSInterfaceInfo->Config.DataINEndpoint.Type  = EP_TYPE_BULK;
	MSInterfaceInfo->Config.DataOUTEndpoint.Type = EP_TYPE_BULK;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataINEndpoint, 1)))
	  return false;
   15494:	80 e0       	ldi	r24, 0x00	; 0

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataOUTEndpoint, 1)))
	  return false;

	return true;
}
   15496:	df 91       	pop	r29
   15498:	cf 91       	pop	r28
   1549a:	08 95       	ret

0001549c <MS_Device_USBTask>:

void MS_Device_USBTask(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
   1549c:	cf 92       	push	r12
   1549e:	df 92       	push	r13
   154a0:	ef 92       	push	r14
   154a2:	ff 92       	push	r15
   154a4:	0f 93       	push	r16
   154a6:	1f 93       	push	r17
   154a8:	df 93       	push	r29
   154aa:	cf 93       	push	r28
   154ac:	00 d0       	rcall	.+0      	; 0x154ae <MS_Device_USBTask+0x12>
   154ae:	cd b7       	in	r28, 0x3d	; 61
   154b0:	de b7       	in	r29, 0x3e	; 62
   154b2:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
   154b4:	8e b3       	in	r24, 0x1e	; 30
   154b6:	84 30       	cpi	r24, 0x04	; 4
   154b8:	09 f0       	breq	.+2      	; 0x154bc <MS_Device_USBTask+0x20>
   154ba:	16 c1       	rjmp	.+556    	; 0x156e8 <MS_Device_USBTask+0x24c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   154bc:	f8 01       	movw	r30, r16
   154be:	86 81       	ldd	r24, Z+6	; 0x06
   154c0:	8f 70       	andi	r24, 0x0F	; 15
   154c2:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
   154c6:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	if (Endpoint_IsOUTReceived())
   154ca:	82 ff       	sbrs	r24, 2
   154cc:	d3 c0       	rjmp	.+422    	; 0x15674 <MS_Device_USBTask+0x1d8>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   154ce:	86 81       	ldd	r24, Z+6	; 0x06
   154d0:	8f 70       	andi	r24, 0x0F	; 15
   154d2:	80 93 e9 00 	sts	0x00E9, r24
{
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	BytesProcessed = 0;
   154d6:	1a 82       	std	Y+2, r1	; 0x02
   154d8:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
   154da:	2c e0       	ldi	r18, 0x0C	; 12
   154dc:	c2 2e       	mov	r12, r18
   154de:	d1 2c       	mov	r13, r1
   154e0:	c0 0e       	add	r12, r16
   154e2:	d1 1e       	adc	r13, r17
   154e4:	7e 01       	movw	r14, r28
   154e6:	08 94       	sec
   154e8:	e1 1c       	adc	r14, r1
   154ea:	f1 1c       	adc	r15, r1
   154ec:	05 c0       	rjmp	.+10     	; 0x154f8 <MS_Device_USBTask+0x5c>
	                               (sizeof(MS_CommandBlockWrapper_t) - 16), &BytesProcessed) ==
	                               ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
   154ee:	f8 01       	movw	r30, r16
   154f0:	80 ad       	ldd	r24, Z+56	; 0x38
   154f2:	88 23       	and	r24, r24
   154f4:	09 f0       	breq	.+2      	; 0x154f8 <MS_Device_USBTask+0x5c>
   154f6:	be c0       	rjmp	.+380    	; 0x15674 <MS_Device_USBTask+0x1d8>
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
   154f8:	c6 01       	movw	r24, r12
   154fa:	6f e0       	ldi	r22, 0x0F	; 15
   154fc:	70 e0       	ldi	r23, 0x00	; 0
   154fe:	a7 01       	movw	r20, r14
   15500:	46 d8       	rcall	.-3956   	; 0x1458e <Endpoint_Read_Stream_LE>
   15502:	85 30       	cpi	r24, 0x05	; 5
   15504:	a1 f3       	breq	.-24     	; 0x154ee <MS_Device_USBTask+0x52>
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
   15506:	f8 01       	movw	r30, r16
   15508:	84 85       	ldd	r24, Z+12	; 0x0c
   1550a:	95 85       	ldd	r25, Z+13	; 0x0d
   1550c:	a6 85       	ldd	r26, Z+14	; 0x0e
   1550e:	b7 85       	ldd	r27, Z+15	; 0x0f
   15510:	85 35       	cpi	r24, 0x55	; 85
   15512:	f3 e5       	ldi	r31, 0x53	; 83
   15514:	9f 07       	cpc	r25, r31
   15516:	f2 e4       	ldi	r31, 0x42	; 66
   15518:	af 07       	cpc	r26, r31
   1551a:	f3 e4       	ldi	r31, 0x43	; 67
   1551c:	bf 07       	cpc	r27, r31
   1551e:	81 f4       	brne	.+32     	; 0x15540 <MS_Device_USBTask+0xa4>
   15520:	f8 01       	movw	r30, r16
   15522:	91 8d       	ldd	r25, Z+25	; 0x19
   15524:	83 85       	ldd	r24, Z+11	; 0x0b
   15526:	98 17       	cp	r25, r24
   15528:	58 f4       	brcc	.+22     	; 0x15540 <MS_Device_USBTask+0xa4>
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
   1552a:	80 8d       	ldd	r24, Z+24	; 0x18
   1552c:	90 e0       	ldi	r25, 0x00	; 0
   1552e:	8f 71       	andi	r24, 0x1F	; 31
   15530:	90 70       	andi	r25, 0x00	; 0
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
   15532:	00 97       	sbiw	r24, 0x00	; 0
   15534:	29 f4       	brne	.+10     	; 0x15540 <MS_Device_USBTask+0xa4>
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
		(MSInterfaceInfo->State.CommandBlock.SCSICommandLength == 0)                                 ||
   15536:	82 8d       	ldd	r24, Z+26	; 0x1a
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
   15538:	88 23       	and	r24, r24
   1553a:	11 f0       	breq	.+4      	; 0x15540 <MS_Device_USBTask+0xa4>
		(MSInterfaceInfo->State.CommandBlock.SCSICommandLength == 0)                                 ||
   1553c:	81 31       	cpi	r24, 0x11	; 17
   1553e:	80 f0       	brcs	.+32     	; 0x15560 <MS_Device_USBTask+0xc4>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
   15540:	80 91 eb 00 	lds	r24, 0x00EB
   15544:	80 62       	ori	r24, 0x20	; 32
   15546:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   1554a:	f8 01       	movw	r30, r16
   1554c:	81 81       	ldd	r24, Z+1	; 0x01
   1554e:	8f 70       	andi	r24, 0x0F	; 15
   15550:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
   15554:	80 91 eb 00 	lds	r24, 0x00EB
   15558:	80 62       	ori	r24, 0x20	; 32
   1555a:	80 93 eb 00 	sts	0x00EB, r24
   1555e:	8a c0       	rjmp	.+276    	; 0x15674 <MS_Device_USBTask+0x1d8>
		Endpoint_StallTransaction();

		return false;
	}

	BytesProcessed = 0;
   15560:	1a 82       	std	Y+2, r1	; 0x02
   15562:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
   15564:	9b e1       	ldi	r25, 0x1B	; 27
   15566:	c9 2e       	mov	r12, r25
   15568:	d1 2c       	mov	r13, r1
   1556a:	c0 0e       	add	r12, r16
   1556c:	d1 1e       	adc	r13, r17
   1556e:	7e 01       	movw	r14, r28
   15570:	08 94       	sec
   15572:	e1 1c       	adc	r14, r1
   15574:	f1 1c       	adc	r15, r1
   15576:	05 c0       	rjmp	.+10     	; 0x15582 <MS_Device_USBTask+0xe6>
	                                MSInterfaceInfo->State.CommandBlock.SCSICommandLength, &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
   15578:	f8 01       	movw	r30, r16
   1557a:	80 ad       	ldd	r24, Z+56	; 0x38
   1557c:	88 23       	and	r24, r24
   1557e:	09 f0       	breq	.+2      	; 0x15582 <MS_Device_USBTask+0xe6>
   15580:	79 c0       	rjmp	.+242    	; 0x15674 <MS_Device_USBTask+0x1d8>

		return false;
	}

	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
   15582:	f8 01       	movw	r30, r16
   15584:	62 8d       	ldd	r22, Z+26	; 0x1a
   15586:	c6 01       	movw	r24, r12
   15588:	70 e0       	ldi	r23, 0x00	; 0
   1558a:	a7 01       	movw	r20, r14
   1558c:	00 d8       	rcall	.-4096   	; 0x1458e <Endpoint_Read_Stream_LE>
   1558e:	85 30       	cpi	r24, 0x05	; 5
   15590:	99 f3       	breq	.-26     	; 0x15578 <MS_Device_USBTask+0xdc>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
   15592:	80 91 e8 00 	lds	r24, 0x00E8
   15596:	8b 77       	andi	r24, 0x7B	; 123
   15598:	80 93 e8 00 	sts	0x00E8, r24

	if (Endpoint_IsOUTReceived())
	{
		if (MS_Device_ReadInCommandBlock(MSInterfaceInfo))
		{
			if (MSInterfaceInfo->State.CommandBlock.Flags & MS_COMMAND_DIR_DATA_IN)
   1559c:	f8 01       	movw	r30, r16
   1559e:	80 8d       	ldd	r24, Z+24	; 0x18
   155a0:	87 ff       	sbrs	r24, 7
   155a2:	04 c0       	rjmp	.+8      	; 0x155ac <MS_Device_USBTask+0x110>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   155a4:	81 81       	ldd	r24, Z+1	; 0x01
   155a6:	8f 70       	andi	r24, 0x0F	; 15
   155a8:	80 93 e9 00 	sts	0x00E9, r24
			  Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

			bool SCSICommandResult = CALLBACK_MS_Device_SCSICommandReceived(MSInterfaceInfo);
   155ac:	c8 01       	movw	r24, r16
   155ae:	0e 94 27 80 	call	0x1004e	; 0x1004e <CALLBACK_MS_Device_SCSICommandReceived>
	  return false;

	return true;
}

void MS_Device_USBTask(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
   155b2:	91 e0       	ldi	r25, 0x01	; 1
   155b4:	98 27       	eor	r25, r24
			if (MSInterfaceInfo->State.CommandBlock.Flags & MS_COMMAND_DIR_DATA_IN)
			  Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

			bool SCSICommandResult = CALLBACK_MS_Device_SCSICommandReceived(MSInterfaceInfo);

			MSInterfaceInfo->State.CommandStatus.Status              = (SCSICommandResult) ? MS_SCSI_COMMAND_Pass : MS_SCSI_COMMAND_Fail;
   155b6:	f8 01       	movw	r30, r16
   155b8:	97 ab       	std	Z+55, r25	; 0x37
			MSInterfaceInfo->State.CommandStatus.Signature           = CPU_TO_LE32(MS_CSW_SIGNATURE);
   155ba:	25 e5       	ldi	r18, 0x55	; 85
   155bc:	33 e5       	ldi	r19, 0x53	; 83
   155be:	42 e4       	ldi	r20, 0x42	; 66
   155c0:	53 e5       	ldi	r21, 0x53	; 83
   155c2:	23 a7       	std	Z+43, r18	; 0x2b
   155c4:	34 a7       	std	Z+44, r19	; 0x2c
   155c6:	45 a7       	std	Z+45, r20	; 0x2d
   155c8:	56 a7       	std	Z+46, r21	; 0x2e
			MSInterfaceInfo->State.CommandStatus.Tag                 = MSInterfaceInfo->State.CommandBlock.Tag;
   155ca:	20 89       	ldd	r18, Z+16	; 0x10
   155cc:	31 89       	ldd	r19, Z+17	; 0x11
   155ce:	42 89       	ldd	r20, Z+18	; 0x12
   155d0:	53 89       	ldd	r21, Z+19	; 0x13
   155d2:	27 a7       	std	Z+47, r18	; 0x2f
   155d4:	30 ab       	std	Z+48, r19	; 0x30
   155d6:	41 ab       	std	Z+49, r20	; 0x31
   155d8:	52 ab       	std	Z+50, r21	; 0x32
			MSInterfaceInfo->State.CommandStatus.DataTransferResidue = MSInterfaceInfo->State.CommandBlock.DataTransferLength;
   155da:	24 89       	ldd	r18, Z+20	; 0x14
   155dc:	35 89       	ldd	r19, Z+21	; 0x15
   155de:	46 89       	ldd	r20, Z+22	; 0x16
   155e0:	57 89       	ldd	r21, Z+23	; 0x17
   155e2:	23 ab       	std	Z+51, r18	; 0x33
   155e4:	34 ab       	std	Z+52, r19	; 0x34
   155e6:	45 ab       	std	Z+53, r20	; 0x35
   155e8:	56 ab       	std	Z+54, r21	; 0x36

			if (!(SCSICommandResult) && (le32_to_cpu(MSInterfaceInfo->State.CommandStatus.DataTransferResidue)))
   155ea:	88 23       	and	r24, r24
   155ec:	51 f4       	brne	.+20     	; 0x15602 <MS_Device_USBTask+0x166>
   155ee:	21 15       	cp	r18, r1
   155f0:	31 05       	cpc	r19, r1
   155f2:	41 05       	cpc	r20, r1
   155f4:	51 05       	cpc	r21, r1
   155f6:	29 f0       	breq	.+10     	; 0x15602 <MS_Device_USBTask+0x166>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
   155f8:	80 91 eb 00 	lds	r24, 0x00EB
   155fc:	80 62       	ori	r24, 0x20	; 32
   155fe:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   15602:	f8 01       	movw	r30, r16
   15604:	86 81       	ldd	r24, Z+6	; 0x06
   15606:	8f 70       	andi	r24, 0x0F	; 15
   15608:	80 93 e9 00 	sts	0x00E9, r24
   1560c:	04 c0       	rjmp	.+8      	; 0x15616 <MS_Device_USBTask+0x17a>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
   1560e:	f8 01       	movw	r30, r16
   15610:	80 ad       	ldd	r24, Z+56	; 0x38
   15612:	88 23       	and	r24, r24
   15614:	79 f5       	brne	.+94     	; 0x15674 <MS_Device_USBTask+0x1d8>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
   15616:	80 91 eb 00 	lds	r24, 0x00EB

static void MS_Device_ReturnCommandStatus(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	while (Endpoint_IsStalled())
   1561a:	85 fd       	sbrc	r24, 5
   1561c:	f8 cf       	rjmp	.-16     	; 0x1560e <MS_Device_USBTask+0x172>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   1561e:	f8 01       	movw	r30, r16
   15620:	81 81       	ldd	r24, Z+1	; 0x01
   15622:	8f 70       	andi	r24, 0x0F	; 15
   15624:	80 93 e9 00 	sts	0x00E9, r24
   15628:	04 c0       	rjmp	.+8      	; 0x15632 <MS_Device_USBTask+0x196>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
   1562a:	f8 01       	movw	r30, r16
   1562c:	80 ad       	ldd	r24, Z+56	; 0x38
   1562e:	88 23       	and	r24, r24
   15630:	09 f5       	brne	.+66     	; 0x15674 <MS_Device_USBTask+0x1d8>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
   15632:	80 91 eb 00 	lds	r24, 0x00EB
		  return;
	}

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

	while (Endpoint_IsStalled())
   15636:	85 fd       	sbrc	r24, 5
   15638:	f8 cf       	rjmp	.-16     	; 0x1562a <MS_Device_USBTask+0x18e>

		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	uint16_t BytesProcessed = 0;
   1563a:	1a 82       	std	Y+2, r1	; 0x02
   1563c:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
   1563e:	8b e2       	ldi	r24, 0x2B	; 43
   15640:	c8 2e       	mov	r12, r24
   15642:	d1 2c       	mov	r13, r1
   15644:	c0 0e       	add	r12, r16
   15646:	d1 1e       	adc	r13, r17
   15648:	7e 01       	movw	r14, r28
   1564a:	08 94       	sec
   1564c:	e1 1c       	adc	r14, r1
   1564e:	f1 1c       	adc	r15, r1
   15650:	04 c0       	rjmp	.+8      	; 0x1565a <MS_Device_USBTask+0x1be>
	                                sizeof(MS_CommandStatusWrapper_t), &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
   15652:	f8 01       	movw	r30, r16
   15654:	80 ad       	ldd	r24, Z+56	; 0x38
   15656:	88 23       	and	r24, r24
   15658:	69 f4       	brne	.+26     	; 0x15674 <MS_Device_USBTask+0x1d8>
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	uint16_t BytesProcessed = 0;
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
   1565a:	c6 01       	movw	r24, r12
   1565c:	6d e0       	ldi	r22, 0x0D	; 13
   1565e:	70 e0       	ldi	r23, 0x00	; 0
   15660:	a7 01       	movw	r20, r14
   15662:	0e 94 15 a2 	call	0x1442a	; 0x1442a <Endpoint_Write_Stream_LE>
   15666:	85 30       	cpi	r24, 0x05	; 5
   15668:	a1 f3       	breq	.-24     	; 0x15652 <MS_Device_USBTask+0x1b6>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
   1566a:	80 91 e8 00 	lds	r24, 0x00E8
   1566e:	8e 77       	andi	r24, 0x7E	; 126
   15670:	80 93 e8 00 	sts	0x00E8, r24

			MS_Device_ReturnCommandStatus(MSInterfaceInfo);
		}
	}

	if (MSInterfaceInfo->State.IsMassStoreReset)
   15674:	f8 01       	movw	r30, r16
   15676:	80 ad       	ldd	r24, Z+56	; 0x38
   15678:	88 23       	and	r24, r24
   1567a:	b1 f1       	breq	.+108    	; 0x156e8 <MS_Device_USBTask+0x24c>
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
   1567c:	26 81       	ldd	r18, Z+6	; 0x06
   1567e:	2f 70       	andi	r18, 0x0F	; 15
   15680:	81 e0       	ldi	r24, 0x01	; 1
   15682:	90 e0       	ldi	r25, 0x00	; 0
   15684:	ac 01       	movw	r20, r24
   15686:	02 c0       	rjmp	.+4      	; 0x1568c <MS_Device_USBTask+0x1f0>
   15688:	44 0f       	add	r20, r20
   1568a:	55 1f       	adc	r21, r21
   1568c:	2a 95       	dec	r18
   1568e:	e2 f7       	brpl	.-8      	; 0x15688 <MS_Device_USBTask+0x1ec>
   15690:	40 93 ea 00 	sts	0x00EA, r20
				UERST = 0;
   15694:	10 92 ea 00 	sts	0x00EA, r1
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
   15698:	21 81       	ldd	r18, Z+1	; 0x01
   1569a:	2f 70       	andi	r18, 0x0F	; 15
   1569c:	02 c0       	rjmp	.+4      	; 0x156a2 <MS_Device_USBTask+0x206>
   1569e:	88 0f       	add	r24, r24
   156a0:	99 1f       	adc	r25, r25
   156a2:	2a 95       	dec	r18
   156a4:	e2 f7       	brpl	.-8      	; 0x1569e <MS_Device_USBTask+0x202>
   156a6:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
   156aa:	10 92 ea 00 	sts	0x00EA, r1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   156ae:	86 81       	ldd	r24, Z+6	; 0x06
   156b0:	8f 70       	andi	r24, 0x0F	; 15
   156b2:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
   156b6:	80 91 eb 00 	lds	r24, 0x00EB
   156ba:	80 61       	ori	r24, 0x10	; 16
   156bc:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
   156c0:	80 91 eb 00 	lds	r24, 0x00EB
   156c4:	88 60       	ori	r24, 0x08	; 8
   156c6:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
   156ca:	81 81       	ldd	r24, Z+1	; 0x01
   156cc:	8f 70       	andi	r24, 0x0F	; 15
   156ce:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
   156d2:	80 91 eb 00 	lds	r24, 0x00EB
   156d6:	80 61       	ori	r24, 0x10	; 16
   156d8:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
   156dc:	80 91 eb 00 	lds	r24, 0x00EB
   156e0:	88 60       	ori	r24, 0x08	; 8
   156e2:	80 93 eb 00 	sts	0x00EB, r24
		Endpoint_ResetDataToggle();
		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);
		Endpoint_ClearStall();
		Endpoint_ResetDataToggle();

		MSInterfaceInfo->State.IsMassStoreReset = false;
   156e6:	10 ae       	std	Z+56, r1	; 0x38
	}
}
   156e8:	0f 90       	pop	r0
   156ea:	0f 90       	pop	r0
   156ec:	cf 91       	pop	r28
   156ee:	df 91       	pop	r29
   156f0:	1f 91       	pop	r17
   156f2:	0f 91       	pop	r16
   156f4:	ff 90       	pop	r15
   156f6:	ef 90       	pop	r14
   156f8:	df 90       	pop	r13
   156fa:	cf 90       	pop	r12
   156fc:	08 95       	ret

000156fe <TWI_StartTransmission>:
	for (;;)
	{
		bool     BusCaptured = false;
		uint16_t TimeoutRemaining;

		TWCR = ((1 << TWINT) | (1 << TWSTA) | (1 << TWEN));
   156fe:	94 ea       	ldi	r25, 0xA4	; 164
   15700:	90 93 bc 00 	sts	0x00BC, r25

		TimeoutRemaining = (TimeoutMS * 100);
   15704:	94 e6       	ldi	r25, 0x64	; 100
   15706:	69 9f       	mul	r22, r25
   15708:	b0 01       	movw	r22, r0
   1570a:	11 24       	eor	r1, r1
   1570c:	ab 01       	movw	r20, r22
uint8_t TWI_StartTransmission(const uint8_t SlaveAddress,
                              const uint8_t TimeoutMS)
{
	for (;;)
	{
		bool     BusCaptured = false;
   1570e:	90 e0       	ldi	r25, 0x00	; 0
					case TW_START:
					case TW_REP_START:
						BusCaptured = true;
						break;
					case TW_MT_ARB_LOST:
						TWCR = ((1 << TWINT) | (1 << TWSTA) | (1 << TWEN));
   15710:	e4 ea       	ldi	r30, 0xA4	; 164
		uint16_t TimeoutRemaining;

		TWCR = ((1 << TWINT) | (1 << TWSTA) | (1 << TWEN));

		TimeoutRemaining = (TimeoutMS * 100);
		while (TimeoutRemaining && !(BusCaptured))
   15712:	22 c0       	rjmp	.+68     	; 0x15758 <TWI_StartTransmission+0x5a>
		{
			if (TWCR & (1 << TWINT))
   15714:	20 91 bc 00 	lds	r18, 0x00BC
   15718:	27 ff       	sbrs	r18, 7
   1571a:	18 c0       	rjmp	.+48     	; 0x1574c <TWI_StartTransmission+0x4e>
			{
				switch (TWSR & TW_STATUS_MASK)
   1571c:	20 91 b9 00 	lds	r18, 0x00B9
   15720:	30 e0       	ldi	r19, 0x00	; 0
   15722:	28 7f       	andi	r18, 0xF8	; 248
   15724:	30 70       	andi	r19, 0x00	; 0
   15726:	20 31       	cpi	r18, 0x10	; 16
   15728:	31 05       	cpc	r19, r1
   1572a:	79 f0       	breq	.+30     	; 0x1574a <TWI_StartTransmission+0x4c>
   1572c:	28 33       	cpi	r18, 0x38	; 56
   1572e:	31 05       	cpc	r19, r1
   15730:	21 f0       	breq	.+8      	; 0x1573a <TWI_StartTransmission+0x3c>
   15732:	28 30       	cpi	r18, 0x08	; 8
   15734:	31 05       	cpc	r19, r1
   15736:	21 f4       	brne	.+8      	; 0x15740 <TWI_StartTransmission+0x42>
   15738:	08 c0       	rjmp	.+16     	; 0x1574a <TWI_StartTransmission+0x4c>
					case TW_START:
					case TW_REP_START:
						BusCaptured = true;
						break;
					case TW_MT_ARB_LOST:
						TWCR = ((1 << TWINT) | (1 << TWSTA) | (1 << TWEN));
   1573a:	e0 93 bc 00 	sts	0x00BC, r30
						continue;
   1573e:	0c c0       	rjmp	.+24     	; 0x15758 <TWI_StartTransmission+0x5a>
					default:
						TWCR = (1 << TWEN);
   15740:	84 e0       	ldi	r24, 0x04	; 4
   15742:	80 93 bc 00 	sts	0x00BC, r24
						return TWI_ERROR_BusFault;
   15746:	81 e0       	ldi	r24, 0x01	; 1
   15748:	08 95       	ret
			{
				switch (TWSR & TW_STATUS_MASK)
				{
					case TW_START:
					case TW_REP_START:
						BusCaptured = true;
   1574a:	91 e0       	ldi	r25, 0x01	; 1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
   1574c:	2a e1       	ldi	r18, 0x1A	; 26
   1574e:	2a 95       	dec	r18
   15750:	f1 f7       	brne	.-4      	; 0x1574e <TWI_StartTransmission+0x50>
   15752:	00 c0       	rjmp	.+0      	; 0x15754 <TWI_StartTransmission+0x56>
						return TWI_ERROR_BusFault;
				}
			}

			_delay_us(10);
			TimeoutRemaining--;
   15754:	41 50       	subi	r20, 0x01	; 1
   15756:	50 40       	sbci	r21, 0x00	; 0
		uint16_t TimeoutRemaining;

		TWCR = ((1 << TWINT) | (1 << TWSTA) | (1 << TWEN));

		TimeoutRemaining = (TimeoutMS * 100);
		while (TimeoutRemaining && !(BusCaptured))
   15758:	41 15       	cp	r20, r1
   1575a:	51 05       	cpc	r21, r1
   1575c:	19 f0       	breq	.+6      	; 0x15764 <TWI_StartTransmission+0x66>
   1575e:	99 23       	and	r25, r25
   15760:	c9 f2       	breq	.-78     	; 0x15714 <TWI_StartTransmission+0x16>
   15762:	26 c0       	rjmp	.+76     	; 0x157b0 <TWI_StartTransmission+0xb2>
			TimeoutRemaining--;
		}

		if (!(TimeoutRemaining))
		{
			TWCR = (1 << TWEN);
   15764:	84 e0       	ldi	r24, 0x04	; 4
   15766:	80 93 bc 00 	sts	0x00BC, r24
			return TWI_ERROR_BusCaptureTimeout;
   1576a:	82 e0       	ldi	r24, 0x02	; 2
   1576c:	08 95       	ret
		TWCR = ((1 << TWINT) | (1 << TWEN));

		TimeoutRemaining = (TimeoutMS * 100);
		while (TimeoutRemaining)
		{
			if (TWCR & (1 << TWINT))
   1576e:	80 91 bc 00 	lds	r24, 0x00BC
   15772:	87 fd       	sbrc	r24, 7
   15774:	0b c0       	rjmp	.+22     	; 0x1578c <TWI_StartTransmission+0x8e>
   15776:	8a e1       	ldi	r24, 0x1A	; 26
   15778:	8a 95       	dec	r24
   1577a:	f1 f7       	brne	.-4      	; 0x15778 <TWI_StartTransmission+0x7a>
   1577c:	00 c0       	rjmp	.+0      	; 0x1577e <TWI_StartTransmission+0x80>
			  break;

			_delay_us(10);
			TimeoutRemaining--;
   1577e:	61 50       	subi	r22, 0x01	; 1
   15780:	70 40       	sbci	r23, 0x00	; 0

		TWDR = SlaveAddress;
		TWCR = ((1 << TWINT) | (1 << TWEN));

		TimeoutRemaining = (TimeoutMS * 100);
		while (TimeoutRemaining)
   15782:	61 15       	cp	r22, r1
   15784:	71 05       	cpc	r23, r1
   15786:	99 f7       	brne	.-26     	; 0x1576e <TWI_StartTransmission+0x70>
			_delay_us(10);
			TimeoutRemaining--;
		}

		if (!(TimeoutRemaining))
		  return TWI_ERROR_SlaveResponseTimeout;
   15788:	83 e0       	ldi	r24, 0x03	; 3
   1578a:	08 95       	ret

		switch (TWSR & TW_STATUS_MASK)
   1578c:	80 91 b9 00 	lds	r24, 0x00B9
   15790:	90 e0       	ldi	r25, 0x00	; 0
   15792:	88 7f       	andi	r24, 0xF8	; 248
   15794:	90 70       	andi	r25, 0x00	; 0
   15796:	88 31       	cpi	r24, 0x18	; 24
   15798:	91 05       	cpc	r25, r1
   1579a:	41 f0       	breq	.+16     	; 0x157ac <TWI_StartTransmission+0xae>
   1579c:	80 34       	cpi	r24, 0x40	; 64
   1579e:	91 05       	cpc	r25, r1
   157a0:	29 f0       	breq	.+10     	; 0x157ac <TWI_StartTransmission+0xae>
		{
			case TW_MT_SLA_ACK:
			case TW_MR_SLA_ACK:
				return TWI_ERROR_NoError;
			default:
				TWCR = ((1 << TWINT) | (1 << TWSTO) | (1 << TWEN));
   157a2:	84 e9       	ldi	r24, 0x94	; 148
   157a4:	80 93 bc 00 	sts	0x00BC, r24
				return TWI_ERROR_SlaveNotReady;
   157a8:	84 e0       	ldi	r24, 0x04	; 4
   157aa:	08 95       	ret

		switch (TWSR & TW_STATUS_MASK)
		{
			case TW_MT_SLA_ACK:
			case TW_MR_SLA_ACK:
				return TWI_ERROR_NoError;
   157ac:	80 e0       	ldi	r24, 0x00	; 0
			default:
				TWCR = ((1 << TWINT) | (1 << TWSTO) | (1 << TWEN));
				return TWI_ERROR_SlaveNotReady;
		}
	}
}
   157ae:	08 95       	ret
		{
			TWCR = (1 << TWEN);
			return TWI_ERROR_BusCaptureTimeout;
		}

		TWDR = SlaveAddress;
   157b0:	80 93 bb 00 	sts	0x00BB, r24
		TWCR = ((1 << TWINT) | (1 << TWEN));
   157b4:	84 e8       	ldi	r24, 0x84	; 132
   157b6:	80 93 bc 00 	sts	0x00BC, r24

		TimeoutRemaining = (TimeoutMS * 100);
		while (TimeoutRemaining)
   157ba:	e3 cf       	rjmp	.-58     	; 0x15782 <TWI_StartTransmission+0x84>

000157bc <TWI_SendByte>:
	}
}

bool TWI_SendByte(const uint8_t Byte)
{
	TWDR = Byte;
   157bc:	80 93 bb 00 	sts	0x00BB, r24
	TWCR = ((1 << TWINT) | (1 << TWEN));
   157c0:	84 e8       	ldi	r24, 0x84	; 132
   157c2:	80 93 bc 00 	sts	0x00BC, r24
	while (!(TWCR & (1 << TWINT)));
   157c6:	80 91 bc 00 	lds	r24, 0x00BC
   157ca:	87 ff       	sbrs	r24, 7
   157cc:	fc cf       	rjmp	.-8      	; 0x157c6 <TWI_SendByte+0xa>

	return ((TWSR & TW_STATUS_MASK) == TW_MT_DATA_ACK);
   157ce:	90 91 b9 00 	lds	r25, 0x00B9
   157d2:	98 7f       	andi	r25, 0xF8	; 248
   157d4:	81 e0       	ldi	r24, 0x01	; 1
   157d6:	98 32       	cpi	r25, 0x28	; 40
   157d8:	09 f0       	breq	.+2      	; 0x157dc <TWI_SendByte+0x20>
   157da:	80 e0       	ldi	r24, 0x00	; 0
}
   157dc:	08 95       	ret

000157de <TWI_ReceiveByte>:
bool TWI_ReceiveByte(uint8_t* const Byte,
					 const bool LastByte)
{
	uint8_t TWCRMask;

	if (LastByte)
   157de:	66 23       	and	r22, r22
   157e0:	11 f0       	breq	.+4      	; 0x157e6 <TWI_ReceiveByte+0x8>
	  TWCRMask = ((1 << TWINT) | (1 << TWEN));
   157e2:	24 e8       	ldi	r18, 0x84	; 132
   157e4:	01 c0       	rjmp	.+2      	; 0x157e8 <TWI_ReceiveByte+0xa>
	else
	  TWCRMask = ((1 << TWINT) | (1 << TWEN) | (1 << TWEA));
   157e6:	24 ec       	ldi	r18, 0xC4	; 196

	TWCR = TWCRMask;
   157e8:	20 93 bc 00 	sts	0x00BC, r18
	while (!(TWCR & (1 << TWINT)));
   157ec:	20 91 bc 00 	lds	r18, 0x00BC
   157f0:	27 ff       	sbrs	r18, 7
   157f2:	fc cf       	rjmp	.-8      	; 0x157ec <TWI_ReceiveByte+0xe>
	*Byte = TWDR;
   157f4:	20 91 bb 00 	lds	r18, 0x00BB
   157f8:	fc 01       	movw	r30, r24
   157fa:	20 83       	st	Z, r18

	uint8_t Status = (TWSR & TW_STATUS_MASK);
   157fc:	90 91 b9 00 	lds	r25, 0x00B9
   15800:	98 7f       	andi	r25, 0xF8	; 248

	return ((LastByte) ? (Status == TW_MR_DATA_NACK) : (Status == TW_MR_DATA_ACK));
   15802:	66 23       	and	r22, r22
   15804:	29 f0       	breq	.+10     	; 0x15810 <TWI_ReceiveByte+0x32>
   15806:	81 e0       	ldi	r24, 0x01	; 1
   15808:	98 35       	cpi	r25, 0x58	; 88
   1580a:	31 f0       	breq	.+12     	; 0x15818 <TWI_ReceiveByte+0x3a>
   1580c:	80 e0       	ldi	r24, 0x00	; 0
   1580e:	08 95       	ret
   15810:	81 e0       	ldi	r24, 0x01	; 1
   15812:	90 35       	cpi	r25, 0x50	; 80
   15814:	09 f0       	breq	.+2      	; 0x15818 <TWI_ReceiveByte+0x3a>
   15816:	80 e0       	ldi	r24, 0x00	; 0
}
   15818:	08 95       	ret

0001581a <TWI_ReadPacket>:
                       const uint8_t TimeoutMS,
                       const uint8_t* InternalAddress,
                       uint8_t InternalAddressLen,
                       uint8_t* Buffer,
                       uint8_t Length)
{
   1581a:	af 92       	push	r10
   1581c:	bf 92       	push	r11
   1581e:	cf 92       	push	r12
   15820:	df 92       	push	r13
   15822:	ef 92       	push	r14
   15824:	ff 92       	push	r15
   15826:	0f 93       	push	r16
   15828:	1f 93       	push	r17
   1582a:	df 93       	push	r29
   1582c:	cf 93       	push	r28
   1582e:	00 d0       	rcall	.+0      	; 0x15830 <TWI_ReadPacket+0x16>
   15830:	cd b7       	in	r28, 0x3d	; 61
   15832:	de b7       	in	r29, 0x3e	; 62
   15834:	d8 2e       	mov	r13, r24
   15836:	f6 2e       	mov	r15, r22
   15838:	c2 2e       	mov	r12, r18
	uint8_t ErrorCode;

	if ((ErrorCode = TWI_StartTransmission((SlaveAddress & TWI_DEVICE_ADDRESS_MASK) | TWI_ADDRESS_WRITE,
   1583a:	8e 7f       	andi	r24, 0xFE	; 254
   1583c:	49 83       	std	Y+1, r20	; 0x01
   1583e:	5a 83       	std	Y+2, r21	; 0x02
   15840:	5e df       	rcall	.-324    	; 0x156fe <TWI_StartTransmission>
   15842:	b8 2e       	mov	r11, r24
   15844:	49 81       	ldd	r20, Y+1	; 0x01
   15846:	5a 81       	ldd	r21, Y+2	; 0x02
   15848:	88 23       	and	r24, r24
   1584a:	29 f5       	brne	.+74     	; 0x15896 <TWI_ReadPacket+0x7c>
   1584c:	5a 01       	movw	r10, r20
   1584e:	07 c0       	rjmp	.+14     	; 0x1585e <TWI_ReadPacket+0x44>
	                                       TimeoutMS)) == TWI_ERROR_NoError)
	{
		while (InternalAddressLen--)
		{
			if (!(TWI_SendByte(*(InternalAddress++))))
   15850:	f5 01       	movw	r30, r10
   15852:	81 91       	ld	r24, Z+
   15854:	5f 01       	movw	r10, r30
   15856:	b2 df       	rcall	.-156    	; 0x157bc <TWI_SendByte>
   15858:	ca 94       	dec	r12
   1585a:	88 23       	and	r24, r24
   1585c:	11 f0       	breq	.+4      	; 0x15862 <TWI_ReadPacket+0x48>
	uint8_t ErrorCode;

	if ((ErrorCode = TWI_StartTransmission((SlaveAddress & TWI_DEVICE_ADDRESS_MASK) | TWI_ADDRESS_WRITE,
	                                       TimeoutMS)) == TWI_ERROR_NoError)
	{
		while (InternalAddressLen--)
   1585e:	cc 20       	and	r12, r12
   15860:	b9 f7       	brne	.-18     	; 0x15850 <TWI_ReadPacket+0x36>
				ErrorCode = TWI_ERROR_SlaveNAK;
				break;
			}
		}

		if ((ErrorCode = TWI_StartTransmission((SlaveAddress & TWI_DEVICE_ADDRESS_MASK) | TWI_ADDRESS_READ,
   15862:	8d 2d       	mov	r24, r13
   15864:	81 60       	ori	r24, 0x01	; 1
   15866:	6f 2d       	mov	r22, r15
   15868:	4a df       	rcall	.-364    	; 0x156fe <TWI_StartTransmission>
   1586a:	b8 2e       	mov	r11, r24
   1586c:	88 23       	and	r24, r24
   1586e:	59 f0       	breq	.+22     	; 0x15886 <TWI_ReadPacket+0x6c>
   15870:	12 c0       	rjmp	.+36     	; 0x15896 <TWI_ReadPacket+0x7c>
											   TimeoutMS)) == TWI_ERROR_NoError)
		{
			while (Length--)
   15872:	ea 94       	dec	r14
			{
				if (!(TWI_ReceiveByte(Buffer++, (Length == 0))))
   15874:	61 e0       	ldi	r22, 0x01	; 1
   15876:	09 f0       	breq	.+2      	; 0x1587a <TWI_ReadPacket+0x60>
   15878:	60 e0       	ldi	r22, 0x00	; 0
   1587a:	c8 01       	movw	r24, r16
   1587c:	b0 df       	rcall	.-160    	; 0x157de <TWI_ReceiveByte>
   1587e:	88 23       	and	r24, r24
   15880:	29 f0       	breq	.+10     	; 0x1588c <TWI_ReadPacket+0x72>
   15882:	0f 5f       	subi	r16, 0xFF	; 255
   15884:	1f 4f       	sbci	r17, 0xFF	; 255
		}

		if ((ErrorCode = TWI_StartTransmission((SlaveAddress & TWI_DEVICE_ADDRESS_MASK) | TWI_ADDRESS_READ,
											   TimeoutMS)) == TWI_ERROR_NoError)
		{
			while (Length--)
   15886:	ee 20       	and	r14, r14
   15888:	a1 f7       	brne	.-24     	; 0x15872 <TWI_ReadPacket+0x58>
   1588a:	02 c0       	rjmp	.+4      	; 0x15890 <TWI_ReadPacket+0x76>
			{
				if (!(TWI_ReceiveByte(Buffer++, (Length == 0))))
				{
					ErrorCode = TWI_ERROR_SlaveNAK;
   1588c:	85 e0       	ldi	r24, 0x05	; 5
   1588e:	b8 2e       	mov	r11, r24

			/** Sends a TWI STOP onto the TWI bus, terminating communication with the currently addressed device. */
			static inline void TWI_StopTransmission(void) ATTR_ALWAYS_INLINE;
			static inline void TWI_StopTransmission(void)
			{
				TWCR = ((1 << TWINT) | (1 << TWSTO) | (1 << TWEN));
   15890:	84 e9       	ldi	r24, 0x94	; 148
   15892:	80 93 bc 00 	sts	0x00BC, r24
			TWI_StopTransmission();
		}
	}

	return ErrorCode;
}
   15896:	8b 2d       	mov	r24, r11
   15898:	0f 90       	pop	r0
   1589a:	0f 90       	pop	r0
   1589c:	cf 91       	pop	r28
   1589e:	df 91       	pop	r29
   158a0:	1f 91       	pop	r17
   158a2:	0f 91       	pop	r16
   158a4:	ff 90       	pop	r15
   158a6:	ef 90       	pop	r14
   158a8:	df 90       	pop	r13
   158aa:	cf 90       	pop	r12
   158ac:	bf 90       	pop	r11
   158ae:	af 90       	pop	r10
   158b0:	08 95       	ret

000158b2 <TWI_WritePacket>:
                        const uint8_t TimeoutMS,
                        const uint8_t* InternalAddress,
                        uint8_t InternalAddressLen,
                        const uint8_t* Buffer,
                        uint8_t Length)
{
   158b2:	af 92       	push	r10
   158b4:	bf 92       	push	r11
   158b6:	df 92       	push	r13
   158b8:	ef 92       	push	r14
   158ba:	ff 92       	push	r15
   158bc:	0f 93       	push	r16
   158be:	1f 93       	push	r17
   158c0:	df 93       	push	r29
   158c2:	cf 93       	push	r28
   158c4:	00 d0       	rcall	.+0      	; 0x158c6 <TWI_WritePacket+0x14>
   158c6:	cd b7       	in	r28, 0x3d	; 61
   158c8:	de b7       	in	r29, 0x3e	; 62
   158ca:	f2 2e       	mov	r15, r18
	uint8_t ErrorCode;

	if ((ErrorCode = TWI_StartTransmission((SlaveAddress & TWI_DEVICE_ADDRESS_MASK) | TWI_ADDRESS_WRITE,
   158cc:	8e 7f       	andi	r24, 0xFE	; 254
   158ce:	49 83       	std	Y+1, r20	; 0x01
   158d0:	5a 83       	std	Y+2, r21	; 0x02
   158d2:	15 df       	rcall	.-470    	; 0x156fe <TWI_StartTransmission>
   158d4:	d8 2e       	mov	r13, r24
   158d6:	49 81       	ldd	r20, Y+1	; 0x01
   158d8:	5a 81       	ldd	r21, Y+2	; 0x02
   158da:	88 23       	and	r24, r24
   158dc:	09 f5       	brne	.+66     	; 0x15920 <TWI_WritePacket+0x6e>
   158de:	5a 01       	movw	r10, r20
   158e0:	07 c0       	rjmp	.+14     	; 0x158f0 <TWI_WritePacket+0x3e>
	                                       TimeoutMS)) == TWI_ERROR_NoError)
	{
		while (InternalAddressLen--)
		{
			if (!(TWI_SendByte(*(InternalAddress++))))
   158e2:	f5 01       	movw	r30, r10
   158e4:	81 91       	ld	r24, Z+
   158e6:	5f 01       	movw	r10, r30
   158e8:	69 df       	rcall	.-302    	; 0x157bc <TWI_SendByte>
   158ea:	fa 94       	dec	r15
   158ec:	88 23       	and	r24, r24
   158ee:	59 f0       	breq	.+22     	; 0x15906 <TWI_WritePacket+0x54>
	uint8_t ErrorCode;

	if ((ErrorCode = TWI_StartTransmission((SlaveAddress & TWI_DEVICE_ADDRESS_MASK) | TWI_ADDRESS_WRITE,
	                                       TimeoutMS)) == TWI_ERROR_NoError)
	{
		while (InternalAddressLen--)
   158f0:	ff 20       	and	r15, r15
   158f2:	b9 f7       	brne	.-18     	; 0x158e2 <TWI_WritePacket+0x30>
   158f4:	0a c0       	rjmp	.+20     	; 0x1590a <TWI_WritePacket+0x58>
			}
		}

		while (Length--)
		{
			if (!(TWI_SendByte(*(Buffer++))))
   158f6:	f8 01       	movw	r30, r16
   158f8:	81 91       	ld	r24, Z+
   158fa:	8f 01       	movw	r16, r30
   158fc:	5f df       	rcall	.-322    	; 0x157bc <TWI_SendByte>
   158fe:	ea 94       	dec	r14
   15900:	88 23       	and	r24, r24
   15902:	31 f4       	brne	.+12     	; 0x15910 <TWI_WritePacket+0x5e>
   15904:	08 c0       	rjmp	.+16     	; 0x15916 <TWI_WritePacket+0x64>
	{
		while (InternalAddressLen--)
		{
			if (!(TWI_SendByte(*(InternalAddress++))))
			{
				ErrorCode = TWI_ERROR_SlaveNAK;
   15906:	25 e0       	ldi	r18, 0x05	; 5
   15908:	d2 2e       	mov	r13, r18
			}
		}

		while (Length--)
		{
			if (!(TWI_SendByte(*(Buffer++))))
   1590a:	40 2f       	mov	r20, r16
   1590c:	51 2f       	mov	r21, r17
   1590e:	8a 01       	movw	r16, r20
				ErrorCode = TWI_ERROR_SlaveNAK;
				break;
			}
		}

		while (Length--)
   15910:	ee 20       	and	r14, r14
   15912:	89 f7       	brne	.-30     	; 0x158f6 <TWI_WritePacket+0x44>
   15914:	02 c0       	rjmp	.+4      	; 0x1591a <TWI_WritePacket+0x68>
		{
			if (!(TWI_SendByte(*(Buffer++))))
			{
				ErrorCode = TWI_ERROR_SlaveNAK;
   15916:	95 e0       	ldi	r25, 0x05	; 5
   15918:	d9 2e       	mov	r13, r25
   1591a:	84 e9       	ldi	r24, 0x94	; 148
   1591c:	80 93 bc 00 	sts	0x00BC, r24

		TWI_StopTransmission();
	}

	return ErrorCode;
}
   15920:	8d 2d       	mov	r24, r13
   15922:	0f 90       	pop	r0
   15924:	0f 90       	pop	r0
   15926:	cf 91       	pop	r28
   15928:	df 91       	pop	r29
   1592a:	1f 91       	pop	r17
   1592c:	0f 91       	pop	r16
   1592e:	ff 90       	pop	r15
   15930:	ef 90       	pop	r14
   15932:	df 90       	pop	r13
   15934:	bf 90       	pop	r11
   15936:	af 90       	pop	r10
   15938:	08 95       	ret

0001593a <__mulsi3>:
   1593a:	62 9f       	mul	r22, r18
   1593c:	d0 01       	movw	r26, r0
   1593e:	73 9f       	mul	r23, r19
   15940:	f0 01       	movw	r30, r0
   15942:	82 9f       	mul	r24, r18
   15944:	e0 0d       	add	r30, r0
   15946:	f1 1d       	adc	r31, r1
   15948:	64 9f       	mul	r22, r20
   1594a:	e0 0d       	add	r30, r0
   1594c:	f1 1d       	adc	r31, r1
   1594e:	92 9f       	mul	r25, r18
   15950:	f0 0d       	add	r31, r0
   15952:	83 9f       	mul	r24, r19
   15954:	f0 0d       	add	r31, r0
   15956:	74 9f       	mul	r23, r20
   15958:	f0 0d       	add	r31, r0
   1595a:	65 9f       	mul	r22, r21
   1595c:	f0 0d       	add	r31, r0
   1595e:	99 27       	eor	r25, r25
   15960:	72 9f       	mul	r23, r18
   15962:	b0 0d       	add	r27, r0
   15964:	e1 1d       	adc	r30, r1
   15966:	f9 1f       	adc	r31, r25
   15968:	63 9f       	mul	r22, r19
   1596a:	b0 0d       	add	r27, r0
   1596c:	e1 1d       	adc	r30, r1
   1596e:	f9 1f       	adc	r31, r25
   15970:	bd 01       	movw	r22, r26
   15972:	cf 01       	movw	r24, r30
   15974:	11 24       	eor	r1, r1
   15976:	08 95       	ret

00015978 <__udivmodqi4>:
   15978:	99 1b       	sub	r25, r25
   1597a:	79 e0       	ldi	r23, 0x09	; 9
   1597c:	04 c0       	rjmp	.+8      	; 0x15986 <__udivmodqi4_ep>

0001597e <__udivmodqi4_loop>:
   1597e:	99 1f       	adc	r25, r25
   15980:	96 17       	cp	r25, r22
   15982:	08 f0       	brcs	.+2      	; 0x15986 <__udivmodqi4_ep>
   15984:	96 1b       	sub	r25, r22

00015986 <__udivmodqi4_ep>:
   15986:	88 1f       	adc	r24, r24
   15988:	7a 95       	dec	r23
   1598a:	c9 f7       	brne	.-14     	; 0x1597e <__udivmodqi4_loop>
   1598c:	80 95       	com	r24
   1598e:	08 95       	ret

00015990 <__udivmodsi4>:
   15990:	a1 e2       	ldi	r26, 0x21	; 33
   15992:	1a 2e       	mov	r1, r26
   15994:	aa 1b       	sub	r26, r26
   15996:	bb 1b       	sub	r27, r27
   15998:	fd 01       	movw	r30, r26
   1599a:	0d c0       	rjmp	.+26     	; 0x159b6 <__udivmodsi4_ep>

0001599c <__udivmodsi4_loop>:
   1599c:	aa 1f       	adc	r26, r26
   1599e:	bb 1f       	adc	r27, r27
   159a0:	ee 1f       	adc	r30, r30
   159a2:	ff 1f       	adc	r31, r31
   159a4:	a2 17       	cp	r26, r18
   159a6:	b3 07       	cpc	r27, r19
   159a8:	e4 07       	cpc	r30, r20
   159aa:	f5 07       	cpc	r31, r21
   159ac:	20 f0       	brcs	.+8      	; 0x159b6 <__udivmodsi4_ep>
   159ae:	a2 1b       	sub	r26, r18
   159b0:	b3 0b       	sbc	r27, r19
   159b2:	e4 0b       	sbc	r30, r20
   159b4:	f5 0b       	sbc	r31, r21

000159b6 <__udivmodsi4_ep>:
   159b6:	66 1f       	adc	r22, r22
   159b8:	77 1f       	adc	r23, r23
   159ba:	88 1f       	adc	r24, r24
   159bc:	99 1f       	adc	r25, r25
   159be:	1a 94       	dec	r1
   159c0:	69 f7       	brne	.-38     	; 0x1599c <__udivmodsi4_loop>
   159c2:	60 95       	com	r22
   159c4:	70 95       	com	r23
   159c6:	80 95       	com	r24
   159c8:	90 95       	com	r25
   159ca:	9b 01       	movw	r18, r22
   159cc:	ac 01       	movw	r20, r24
   159ce:	bd 01       	movw	r22, r26
   159d0:	cf 01       	movw	r24, r30
   159d2:	08 95       	ret

000159d4 <__divmodsi4>:
   159d4:	97 fb       	bst	r25, 7
   159d6:	09 2e       	mov	r0, r25
   159d8:	05 26       	eor	r0, r21
   159da:	0e d0       	rcall	.+28     	; 0x159f8 <__divmodsi4_neg1>
   159dc:	57 fd       	sbrc	r21, 7
   159de:	04 d0       	rcall	.+8      	; 0x159e8 <__divmodsi4_neg2>
   159e0:	d7 df       	rcall	.-82     	; 0x15990 <__udivmodsi4>
   159e2:	0a d0       	rcall	.+20     	; 0x159f8 <__divmodsi4_neg1>
   159e4:	00 1c       	adc	r0, r0
   159e6:	38 f4       	brcc	.+14     	; 0x159f6 <__divmodsi4_exit>

000159e8 <__divmodsi4_neg2>:
   159e8:	50 95       	com	r21
   159ea:	40 95       	com	r20
   159ec:	30 95       	com	r19
   159ee:	21 95       	neg	r18
   159f0:	3f 4f       	sbci	r19, 0xFF	; 255
   159f2:	4f 4f       	sbci	r20, 0xFF	; 255
   159f4:	5f 4f       	sbci	r21, 0xFF	; 255

000159f6 <__divmodsi4_exit>:
   159f6:	08 95       	ret

000159f8 <__divmodsi4_neg1>:
   159f8:	f6 f7       	brtc	.-4      	; 0x159f6 <__divmodsi4_exit>
   159fa:	90 95       	com	r25
   159fc:	80 95       	com	r24
   159fe:	70 95       	com	r23
   15a00:	61 95       	neg	r22
   15a02:	7f 4f       	sbci	r23, 0xFF	; 255
   15a04:	8f 4f       	sbci	r24, 0xFF	; 255
   15a06:	9f 4f       	sbci	r25, 0xFF	; 255
   15a08:	08 95       	ret

00015a0a <atoi>:
   15a0a:	fc 01       	movw	r30, r24
   15a0c:	88 27       	eor	r24, r24
   15a0e:	99 27       	eor	r25, r25
   15a10:	e8 94       	clt
   15a12:	21 91       	ld	r18, Z+
   15a14:	20 32       	cpi	r18, 0x20	; 32
   15a16:	e9 f3       	breq	.-6      	; 0x15a12 <atoi+0x8>
   15a18:	29 30       	cpi	r18, 0x09	; 9
   15a1a:	10 f0       	brcs	.+4      	; 0x15a20 <atoi+0x16>
   15a1c:	2e 30       	cpi	r18, 0x0E	; 14
   15a1e:	c8 f3       	brcs	.-14     	; 0x15a12 <atoi+0x8>
   15a20:	2b 32       	cpi	r18, 0x2B	; 43
   15a22:	39 f0       	breq	.+14     	; 0x15a32 <atoi+0x28>
   15a24:	2d 32       	cpi	r18, 0x2D	; 45
   15a26:	31 f4       	brne	.+12     	; 0x15a34 <atoi+0x2a>
   15a28:	68 94       	set
   15a2a:	03 c0       	rjmp	.+6      	; 0x15a32 <atoi+0x28>
   15a2c:	3a d0       	rcall	.+116    	; 0x15aa2 <__mulhi_const_10>
   15a2e:	82 0f       	add	r24, r18
   15a30:	91 1d       	adc	r25, r1
   15a32:	21 91       	ld	r18, Z+
   15a34:	20 53       	subi	r18, 0x30	; 48
   15a36:	2a 30       	cpi	r18, 0x0A	; 10
   15a38:	c8 f3       	brcs	.-14     	; 0x15a2c <atoi+0x22>
   15a3a:	1e f4       	brtc	.+6      	; 0x15a42 <atoi+0x38>
   15a3c:	90 95       	com	r25
   15a3e:	81 95       	neg	r24
   15a40:	9f 4f       	sbci	r25, 0xFF	; 255
   15a42:	08 95       	ret

00015a44 <memcmp>:
   15a44:	fb 01       	movw	r30, r22
   15a46:	dc 01       	movw	r26, r24
   15a48:	04 c0       	rjmp	.+8      	; 0x15a52 <memcmp+0xe>
   15a4a:	8d 91       	ld	r24, X+
   15a4c:	01 90       	ld	r0, Z+
   15a4e:	80 19       	sub	r24, r0
   15a50:	21 f4       	brne	.+8      	; 0x15a5a <memcmp+0x16>
   15a52:	41 50       	subi	r20, 0x01	; 1
   15a54:	50 40       	sbci	r21, 0x00	; 0
   15a56:	c8 f7       	brcc	.-14     	; 0x15a4a <memcmp+0x6>
   15a58:	88 1b       	sub	r24, r24
   15a5a:	99 0b       	sbc	r25, r25
   15a5c:	08 95       	ret

00015a5e <memcpy>:
   15a5e:	fb 01       	movw	r30, r22
   15a60:	dc 01       	movw	r26, r24
   15a62:	02 c0       	rjmp	.+4      	; 0x15a68 <memcpy+0xa>
   15a64:	01 90       	ld	r0, Z+
   15a66:	0d 92       	st	X+, r0
   15a68:	41 50       	subi	r20, 0x01	; 1
   15a6a:	50 40       	sbci	r21, 0x00	; 0
   15a6c:	d8 f7       	brcc	.-10     	; 0x15a64 <memcpy+0x6>
   15a6e:	08 95       	ret

00015a70 <memset>:
   15a70:	dc 01       	movw	r26, r24
   15a72:	01 c0       	rjmp	.+2      	; 0x15a76 <memset+0x6>
   15a74:	6d 93       	st	X+, r22
   15a76:	41 50       	subi	r20, 0x01	; 1
   15a78:	50 40       	sbci	r21, 0x00	; 0
   15a7a:	e0 f7       	brcc	.-8      	; 0x15a74 <memset+0x4>
   15a7c:	08 95       	ret

00015a7e <strcat>:
   15a7e:	fb 01       	movw	r30, r22
   15a80:	dc 01       	movw	r26, r24
   15a82:	0d 90       	ld	r0, X+
   15a84:	00 20       	and	r0, r0
   15a86:	e9 f7       	brne	.-6      	; 0x15a82 <strcat+0x4>
   15a88:	11 97       	sbiw	r26, 0x01	; 1
   15a8a:	01 90       	ld	r0, Z+
   15a8c:	0d 92       	st	X+, r0
   15a8e:	00 20       	and	r0, r0
   15a90:	e1 f7       	brne	.-8      	; 0x15a8a <strcat+0xc>
   15a92:	08 95       	ret

00015a94 <strcpy>:
   15a94:	fb 01       	movw	r30, r22
   15a96:	dc 01       	movw	r26, r24
   15a98:	01 90       	ld	r0, Z+
   15a9a:	0d 92       	st	X+, r0
   15a9c:	00 20       	and	r0, r0
   15a9e:	e1 f7       	brne	.-8      	; 0x15a98 <strcpy+0x4>
   15aa0:	08 95       	ret

00015aa2 <__mulhi_const_10>:
   15aa2:	7a e0       	ldi	r23, 0x0A	; 10
   15aa4:	97 9f       	mul	r25, r23
   15aa6:	90 2d       	mov	r25, r0
   15aa8:	87 9f       	mul	r24, r23
   15aaa:	80 2d       	mov	r24, r0
   15aac:	91 0d       	add	r25, r1
   15aae:	11 24       	eor	r1, r1
   15ab0:	08 95       	ret

00015ab2 <puts>:
   15ab2:	ef 92       	push	r14
   15ab4:	ff 92       	push	r15
   15ab6:	0f 93       	push	r16
   15ab8:	1f 93       	push	r17
   15aba:	cf 93       	push	r28
   15abc:	df 93       	push	r29
   15abe:	8c 01       	movw	r16, r24
   15ac0:	e0 91 23 14 	lds	r30, 0x1423
   15ac4:	f0 91 24 14 	lds	r31, 0x1424
   15ac8:	83 81       	ldd	r24, Z+3	; 0x03
   15aca:	81 ff       	sbrs	r24, 1
   15acc:	1f c0       	rjmp	.+62     	; 0x15b0c <puts+0x5a>
   15ace:	c0 e0       	ldi	r28, 0x00	; 0
   15ad0:	d0 e0       	ldi	r29, 0x00	; 0
   15ad2:	0a c0       	rjmp	.+20     	; 0x15ae8 <puts+0x36>
   15ad4:	db 01       	movw	r26, r22
   15ad6:	18 96       	adiw	r26, 0x08	; 8
   15ad8:	ed 91       	ld	r30, X+
   15ada:	fc 91       	ld	r31, X
   15adc:	19 97       	sbiw	r26, 0x09	; 9
   15ade:	09 95       	icall
   15ae0:	00 97       	sbiw	r24, 0x00	; 0
   15ae2:	11 f0       	breq	.+4      	; 0x15ae8 <puts+0x36>
   15ae4:	cf ef       	ldi	r28, 0xFF	; 255
   15ae6:	df ef       	ldi	r29, 0xFF	; 255
   15ae8:	f8 01       	movw	r30, r16
   15aea:	81 91       	ld	r24, Z+
   15aec:	8f 01       	movw	r16, r30
   15aee:	60 91 23 14 	lds	r22, 0x1423
   15af2:	70 91 24 14 	lds	r23, 0x1424
   15af6:	88 23       	and	r24, r24
   15af8:	69 f7       	brne	.-38     	; 0x15ad4 <puts+0x22>
   15afa:	db 01       	movw	r26, r22
   15afc:	18 96       	adiw	r26, 0x08	; 8
   15afe:	ed 91       	ld	r30, X+
   15b00:	fc 91       	ld	r31, X
   15b02:	19 97       	sbiw	r26, 0x09	; 9
   15b04:	8a e0       	ldi	r24, 0x0A	; 10
   15b06:	09 95       	icall
   15b08:	00 97       	sbiw	r24, 0x00	; 0
   15b0a:	11 f0       	breq	.+4      	; 0x15b10 <puts+0x5e>
   15b0c:	cf ef       	ldi	r28, 0xFF	; 255
   15b0e:	df ef       	ldi	r29, 0xFF	; 255
   15b10:	ce 01       	movw	r24, r28
   15b12:	df 91       	pop	r29
   15b14:	cf 91       	pop	r28
   15b16:	1f 91       	pop	r17
   15b18:	0f 91       	pop	r16
   15b1a:	ff 90       	pop	r15
   15b1c:	ef 90       	pop	r14
   15b1e:	08 95       	ret

00015b20 <sprintf>:
   15b20:	0f 93       	push	r16
   15b22:	1f 93       	push	r17
   15b24:	df 93       	push	r29
   15b26:	cf 93       	push	r28
   15b28:	cd b7       	in	r28, 0x3d	; 61
   15b2a:	de b7       	in	r29, 0x3e	; 62
   15b2c:	2e 97       	sbiw	r28, 0x0e	; 14
   15b2e:	0f b6       	in	r0, 0x3f	; 63
   15b30:	f8 94       	cli
   15b32:	de bf       	out	0x3e, r29	; 62
   15b34:	0f be       	out	0x3f, r0	; 63
   15b36:	cd bf       	out	0x3d, r28	; 61
   15b38:	0d 89       	ldd	r16, Y+21	; 0x15
   15b3a:	1e 89       	ldd	r17, Y+22	; 0x16
   15b3c:	86 e0       	ldi	r24, 0x06	; 6
   15b3e:	8c 83       	std	Y+4, r24	; 0x04
   15b40:	1a 83       	std	Y+2, r17	; 0x02
   15b42:	09 83       	std	Y+1, r16	; 0x01
   15b44:	8f ef       	ldi	r24, 0xFF	; 255
   15b46:	9f e7       	ldi	r25, 0x7F	; 127
   15b48:	9e 83       	std	Y+6, r25	; 0x06
   15b4a:	8d 83       	std	Y+5, r24	; 0x05
   15b4c:	9e 01       	movw	r18, r28
   15b4e:	27 5e       	subi	r18, 0xE7	; 231
   15b50:	3f 4f       	sbci	r19, 0xFF	; 255
   15b52:	ce 01       	movw	r24, r28
   15b54:	01 96       	adiw	r24, 0x01	; 1
   15b56:	6f 89       	ldd	r22, Y+23	; 0x17
   15b58:	78 8d       	ldd	r23, Y+24	; 0x18
   15b5a:	a9 01       	movw	r20, r18
   15b5c:	10 d0       	rcall	.+32     	; 0x15b7e <vfprintf>
   15b5e:	ef 81       	ldd	r30, Y+7	; 0x07
   15b60:	f8 85       	ldd	r31, Y+8	; 0x08
   15b62:	e0 0f       	add	r30, r16
   15b64:	f1 1f       	adc	r31, r17
   15b66:	10 82       	st	Z, r1
   15b68:	2e 96       	adiw	r28, 0x0e	; 14
   15b6a:	0f b6       	in	r0, 0x3f	; 63
   15b6c:	f8 94       	cli
   15b6e:	de bf       	out	0x3e, r29	; 62
   15b70:	0f be       	out	0x3f, r0	; 63
   15b72:	cd bf       	out	0x3d, r28	; 61
   15b74:	cf 91       	pop	r28
   15b76:	df 91       	pop	r29
   15b78:	1f 91       	pop	r17
   15b7a:	0f 91       	pop	r16
   15b7c:	08 95       	ret

00015b7e <vfprintf>:
   15b7e:	2f 92       	push	r2
   15b80:	3f 92       	push	r3
   15b82:	4f 92       	push	r4
   15b84:	5f 92       	push	r5
   15b86:	6f 92       	push	r6
   15b88:	7f 92       	push	r7
   15b8a:	8f 92       	push	r8
   15b8c:	9f 92       	push	r9
   15b8e:	af 92       	push	r10
   15b90:	bf 92       	push	r11
   15b92:	cf 92       	push	r12
   15b94:	df 92       	push	r13
   15b96:	ef 92       	push	r14
   15b98:	ff 92       	push	r15
   15b9a:	0f 93       	push	r16
   15b9c:	1f 93       	push	r17
   15b9e:	df 93       	push	r29
   15ba0:	cf 93       	push	r28
   15ba2:	cd b7       	in	r28, 0x3d	; 61
   15ba4:	de b7       	in	r29, 0x3e	; 62
   15ba6:	2c 97       	sbiw	r28, 0x0c	; 12
   15ba8:	0f b6       	in	r0, 0x3f	; 63
   15baa:	f8 94       	cli
   15bac:	de bf       	out	0x3e, r29	; 62
   15bae:	0f be       	out	0x3f, r0	; 63
   15bb0:	cd bf       	out	0x3d, r28	; 61
   15bb2:	6c 01       	movw	r12, r24
   15bb4:	1b 01       	movw	r2, r22
   15bb6:	8a 01       	movw	r16, r20
   15bb8:	fc 01       	movw	r30, r24
   15bba:	17 82       	std	Z+7, r1	; 0x07
   15bbc:	16 82       	std	Z+6, r1	; 0x06
   15bbe:	83 81       	ldd	r24, Z+3	; 0x03
   15bc0:	81 ff       	sbrs	r24, 1
   15bc2:	c4 c1       	rjmp	.+904    	; 0x15f4c <vfprintf+0x3ce>
   15bc4:	2e 01       	movw	r4, r28
   15bc6:	08 94       	sec
   15bc8:	41 1c       	adc	r4, r1
   15bca:	51 1c       	adc	r5, r1
   15bcc:	f6 01       	movw	r30, r12
   15bce:	93 81       	ldd	r25, Z+3	; 0x03
   15bd0:	f1 01       	movw	r30, r2
   15bd2:	93 fd       	sbrc	r25, 3
   15bd4:	85 91       	lpm	r24, Z+
   15bd6:	93 ff       	sbrs	r25, 3
   15bd8:	81 91       	ld	r24, Z+
   15bda:	1f 01       	movw	r2, r30
   15bdc:	88 23       	and	r24, r24
   15bde:	09 f4       	brne	.+2      	; 0x15be2 <vfprintf+0x64>
   15be0:	b1 c1       	rjmp	.+866    	; 0x15f44 <vfprintf+0x3c6>
   15be2:	85 32       	cpi	r24, 0x25	; 37
   15be4:	39 f4       	brne	.+14     	; 0x15bf4 <vfprintf+0x76>
   15be6:	93 fd       	sbrc	r25, 3
   15be8:	85 91       	lpm	r24, Z+
   15bea:	93 ff       	sbrs	r25, 3
   15bec:	81 91       	ld	r24, Z+
   15bee:	1f 01       	movw	r2, r30
   15bf0:	85 32       	cpi	r24, 0x25	; 37
   15bf2:	21 f4       	brne	.+8      	; 0x15bfc <vfprintf+0x7e>
   15bf4:	90 e0       	ldi	r25, 0x00	; 0
   15bf6:	b6 01       	movw	r22, r12
   15bf8:	fe d1       	rcall	.+1020   	; 0x15ff6 <fputc>
   15bfa:	e8 cf       	rjmp	.-48     	; 0x15bcc <vfprintf+0x4e>
   15bfc:	ee 24       	eor	r14, r14
   15bfe:	ff 24       	eor	r15, r15
   15c00:	20 e0       	ldi	r18, 0x00	; 0
   15c02:	20 32       	cpi	r18, 0x20	; 32
   15c04:	b0 f4       	brcc	.+44     	; 0x15c32 <vfprintf+0xb4>
   15c06:	8b 32       	cpi	r24, 0x2B	; 43
   15c08:	69 f0       	breq	.+26     	; 0x15c24 <vfprintf+0xa6>
   15c0a:	8c 32       	cpi	r24, 0x2C	; 44
   15c0c:	28 f4       	brcc	.+10     	; 0x15c18 <vfprintf+0x9a>
   15c0e:	80 32       	cpi	r24, 0x20	; 32
   15c10:	51 f0       	breq	.+20     	; 0x15c26 <vfprintf+0xa8>
   15c12:	83 32       	cpi	r24, 0x23	; 35
   15c14:	71 f4       	brne	.+28     	; 0x15c32 <vfprintf+0xb4>
   15c16:	0b c0       	rjmp	.+22     	; 0x15c2e <vfprintf+0xb0>
   15c18:	8d 32       	cpi	r24, 0x2D	; 45
   15c1a:	39 f0       	breq	.+14     	; 0x15c2a <vfprintf+0xac>
   15c1c:	80 33       	cpi	r24, 0x30	; 48
   15c1e:	49 f4       	brne	.+18     	; 0x15c32 <vfprintf+0xb4>
   15c20:	21 60       	ori	r18, 0x01	; 1
   15c22:	2c c0       	rjmp	.+88     	; 0x15c7c <vfprintf+0xfe>
   15c24:	22 60       	ori	r18, 0x02	; 2
   15c26:	24 60       	ori	r18, 0x04	; 4
   15c28:	29 c0       	rjmp	.+82     	; 0x15c7c <vfprintf+0xfe>
   15c2a:	28 60       	ori	r18, 0x08	; 8
   15c2c:	27 c0       	rjmp	.+78     	; 0x15c7c <vfprintf+0xfe>
   15c2e:	20 61       	ori	r18, 0x10	; 16
   15c30:	25 c0       	rjmp	.+74     	; 0x15c7c <vfprintf+0xfe>
   15c32:	27 fd       	sbrc	r18, 7
   15c34:	2c c0       	rjmp	.+88     	; 0x15c8e <vfprintf+0x110>
   15c36:	38 2f       	mov	r19, r24
   15c38:	30 53       	subi	r19, 0x30	; 48
   15c3a:	3a 30       	cpi	r19, 0x0A	; 10
   15c3c:	98 f4       	brcc	.+38     	; 0x15c64 <vfprintf+0xe6>
   15c3e:	26 ff       	sbrs	r18, 6
   15c40:	08 c0       	rjmp	.+16     	; 0x15c52 <vfprintf+0xd4>
   15c42:	8e 2d       	mov	r24, r14
   15c44:	88 0f       	add	r24, r24
   15c46:	e8 2e       	mov	r14, r24
   15c48:	ee 0c       	add	r14, r14
   15c4a:	ee 0c       	add	r14, r14
   15c4c:	e8 0e       	add	r14, r24
   15c4e:	e3 0e       	add	r14, r19
   15c50:	15 c0       	rjmp	.+42     	; 0x15c7c <vfprintf+0xfe>
   15c52:	8f 2d       	mov	r24, r15
   15c54:	88 0f       	add	r24, r24
   15c56:	f8 2e       	mov	r15, r24
   15c58:	ff 0c       	add	r15, r15
   15c5a:	ff 0c       	add	r15, r15
   15c5c:	f8 0e       	add	r15, r24
   15c5e:	f3 0e       	add	r15, r19
   15c60:	20 62       	ori	r18, 0x20	; 32
   15c62:	0c c0       	rjmp	.+24     	; 0x15c7c <vfprintf+0xfe>
   15c64:	8e 32       	cpi	r24, 0x2E	; 46
   15c66:	21 f4       	brne	.+8      	; 0x15c70 <vfprintf+0xf2>
   15c68:	26 fd       	sbrc	r18, 6
   15c6a:	6c c1       	rjmp	.+728    	; 0x15f44 <vfprintf+0x3c6>
   15c6c:	20 64       	ori	r18, 0x40	; 64
   15c6e:	06 c0       	rjmp	.+12     	; 0x15c7c <vfprintf+0xfe>
   15c70:	8c 36       	cpi	r24, 0x6C	; 108
   15c72:	11 f4       	brne	.+4      	; 0x15c78 <vfprintf+0xfa>
   15c74:	20 68       	ori	r18, 0x80	; 128
   15c76:	02 c0       	rjmp	.+4      	; 0x15c7c <vfprintf+0xfe>
   15c78:	88 36       	cpi	r24, 0x68	; 104
   15c7a:	49 f4       	brne	.+18     	; 0x15c8e <vfprintf+0x110>
   15c7c:	f1 01       	movw	r30, r2
   15c7e:	93 fd       	sbrc	r25, 3
   15c80:	85 91       	lpm	r24, Z+
   15c82:	93 ff       	sbrs	r25, 3
   15c84:	81 91       	ld	r24, Z+
   15c86:	1f 01       	movw	r2, r30
   15c88:	88 23       	and	r24, r24
   15c8a:	09 f0       	breq	.+2      	; 0x15c8e <vfprintf+0x110>
   15c8c:	ba cf       	rjmp	.-140    	; 0x15c02 <vfprintf+0x84>
   15c8e:	98 2f       	mov	r25, r24
   15c90:	95 54       	subi	r25, 0x45	; 69
   15c92:	93 30       	cpi	r25, 0x03	; 3
   15c94:	18 f0       	brcs	.+6      	; 0x15c9c <vfprintf+0x11e>
   15c96:	90 52       	subi	r25, 0x20	; 32
   15c98:	93 30       	cpi	r25, 0x03	; 3
   15c9a:	28 f4       	brcc	.+10     	; 0x15ca6 <vfprintf+0x128>
   15c9c:	0c 5f       	subi	r16, 0xFC	; 252
   15c9e:	1f 4f       	sbci	r17, 0xFF	; 255
   15ca0:	ff e3       	ldi	r31, 0x3F	; 63
   15ca2:	f9 83       	std	Y+1, r31	; 0x01
   15ca4:	0d c0       	rjmp	.+26     	; 0x15cc0 <vfprintf+0x142>
   15ca6:	83 36       	cpi	r24, 0x63	; 99
   15ca8:	31 f0       	breq	.+12     	; 0x15cb6 <vfprintf+0x138>
   15caa:	83 37       	cpi	r24, 0x73	; 115
   15cac:	71 f0       	breq	.+28     	; 0x15cca <vfprintf+0x14c>
   15cae:	83 35       	cpi	r24, 0x53	; 83
   15cb0:	09 f0       	breq	.+2      	; 0x15cb4 <vfprintf+0x136>
   15cb2:	5c c0       	rjmp	.+184    	; 0x15d6c <vfprintf+0x1ee>
   15cb4:	21 c0       	rjmp	.+66     	; 0x15cf8 <vfprintf+0x17a>
   15cb6:	f8 01       	movw	r30, r16
   15cb8:	80 81       	ld	r24, Z
   15cba:	89 83       	std	Y+1, r24	; 0x01
   15cbc:	0e 5f       	subi	r16, 0xFE	; 254
   15cbe:	1f 4f       	sbci	r17, 0xFF	; 255
   15cc0:	42 01       	movw	r8, r4
   15cc2:	71 e0       	ldi	r23, 0x01	; 1
   15cc4:	a7 2e       	mov	r10, r23
   15cc6:	b1 2c       	mov	r11, r1
   15cc8:	15 c0       	rjmp	.+42     	; 0x15cf4 <vfprintf+0x176>
   15cca:	62 e0       	ldi	r22, 0x02	; 2
   15ccc:	66 2e       	mov	r6, r22
   15cce:	71 2c       	mov	r7, r1
   15cd0:	60 0e       	add	r6, r16
   15cd2:	71 1e       	adc	r7, r17
   15cd4:	f8 01       	movw	r30, r16
   15cd6:	80 80       	ld	r8, Z
   15cd8:	91 80       	ldd	r9, Z+1	; 0x01
   15cda:	26 ff       	sbrs	r18, 6
   15cdc:	03 c0       	rjmp	.+6      	; 0x15ce4 <vfprintf+0x166>
   15cde:	6e 2d       	mov	r22, r14
   15ce0:	70 e0       	ldi	r23, 0x00	; 0
   15ce2:	02 c0       	rjmp	.+4      	; 0x15ce8 <vfprintf+0x16a>
   15ce4:	6f ef       	ldi	r22, 0xFF	; 255
   15ce6:	7f ef       	ldi	r23, 0xFF	; 255
   15ce8:	c4 01       	movw	r24, r8
   15cea:	2c 87       	std	Y+12, r18	; 0x0c
   15cec:	79 d1       	rcall	.+754    	; 0x15fe0 <strnlen>
   15cee:	5c 01       	movw	r10, r24
   15cf0:	83 01       	movw	r16, r6
   15cf2:	2c 85       	ldd	r18, Y+12	; 0x0c
   15cf4:	2f 77       	andi	r18, 0x7F	; 127
   15cf6:	16 c0       	rjmp	.+44     	; 0x15d24 <vfprintf+0x1a6>
   15cf8:	52 e0       	ldi	r21, 0x02	; 2
   15cfa:	65 2e       	mov	r6, r21
   15cfc:	71 2c       	mov	r7, r1
   15cfe:	60 0e       	add	r6, r16
   15d00:	71 1e       	adc	r7, r17
   15d02:	f8 01       	movw	r30, r16
   15d04:	80 80       	ld	r8, Z
   15d06:	91 80       	ldd	r9, Z+1	; 0x01
   15d08:	26 ff       	sbrs	r18, 6
   15d0a:	03 c0       	rjmp	.+6      	; 0x15d12 <vfprintf+0x194>
   15d0c:	6e 2d       	mov	r22, r14
   15d0e:	70 e0       	ldi	r23, 0x00	; 0
   15d10:	02 c0       	rjmp	.+4      	; 0x15d16 <vfprintf+0x198>
   15d12:	6f ef       	ldi	r22, 0xFF	; 255
   15d14:	7f ef       	ldi	r23, 0xFF	; 255
   15d16:	c4 01       	movw	r24, r8
   15d18:	2c 87       	std	Y+12, r18	; 0x0c
   15d1a:	57 d1       	rcall	.+686    	; 0x15fca <strnlen_P>
   15d1c:	5c 01       	movw	r10, r24
   15d1e:	2c 85       	ldd	r18, Y+12	; 0x0c
   15d20:	20 68       	ori	r18, 0x80	; 128
   15d22:	83 01       	movw	r16, r6
   15d24:	23 fd       	sbrc	r18, 3
   15d26:	1e c0       	rjmp	.+60     	; 0x15d64 <vfprintf+0x1e6>
   15d28:	07 c0       	rjmp	.+14     	; 0x15d38 <vfprintf+0x1ba>
   15d2a:	80 e2       	ldi	r24, 0x20	; 32
   15d2c:	90 e0       	ldi	r25, 0x00	; 0
   15d2e:	b6 01       	movw	r22, r12
   15d30:	2c 87       	std	Y+12, r18	; 0x0c
   15d32:	61 d1       	rcall	.+706    	; 0x15ff6 <fputc>
   15d34:	fa 94       	dec	r15
   15d36:	2c 85       	ldd	r18, Y+12	; 0x0c
   15d38:	8f 2d       	mov	r24, r15
   15d3a:	90 e0       	ldi	r25, 0x00	; 0
   15d3c:	a8 16       	cp	r10, r24
   15d3e:	b9 06       	cpc	r11, r25
   15d40:	a0 f3       	brcs	.-24     	; 0x15d2a <vfprintf+0x1ac>
   15d42:	10 c0       	rjmp	.+32     	; 0x15d64 <vfprintf+0x1e6>
   15d44:	f4 01       	movw	r30, r8
   15d46:	27 fd       	sbrc	r18, 7
   15d48:	85 91       	lpm	r24, Z+
   15d4a:	27 ff       	sbrs	r18, 7
   15d4c:	81 91       	ld	r24, Z+
   15d4e:	4f 01       	movw	r8, r30
   15d50:	90 e0       	ldi	r25, 0x00	; 0
   15d52:	b6 01       	movw	r22, r12
   15d54:	2c 87       	std	Y+12, r18	; 0x0c
   15d56:	4f d1       	rcall	.+670    	; 0x15ff6 <fputc>
   15d58:	2c 85       	ldd	r18, Y+12	; 0x0c
   15d5a:	f1 10       	cpse	r15, r1
   15d5c:	fa 94       	dec	r15
   15d5e:	08 94       	sec
   15d60:	a1 08       	sbc	r10, r1
   15d62:	b1 08       	sbc	r11, r1
   15d64:	a1 14       	cp	r10, r1
   15d66:	b1 04       	cpc	r11, r1
   15d68:	69 f7       	brne	.-38     	; 0x15d44 <vfprintf+0x1c6>
   15d6a:	e9 c0       	rjmp	.+466    	; 0x15f3e <vfprintf+0x3c0>
   15d6c:	84 36       	cpi	r24, 0x64	; 100
   15d6e:	11 f0       	breq	.+4      	; 0x15d74 <vfprintf+0x1f6>
   15d70:	89 36       	cpi	r24, 0x69	; 105
   15d72:	41 f5       	brne	.+80     	; 0x15dc4 <vfprintf+0x246>
   15d74:	27 ff       	sbrs	r18, 7
   15d76:	08 c0       	rjmp	.+16     	; 0x15d88 <vfprintf+0x20a>
   15d78:	f8 01       	movw	r30, r16
   15d7a:	60 81       	ld	r22, Z
   15d7c:	71 81       	ldd	r23, Z+1	; 0x01
   15d7e:	82 81       	ldd	r24, Z+2	; 0x02
   15d80:	93 81       	ldd	r25, Z+3	; 0x03
   15d82:	0c 5f       	subi	r16, 0xFC	; 252
   15d84:	1f 4f       	sbci	r17, 0xFF	; 255
   15d86:	09 c0       	rjmp	.+18     	; 0x15d9a <vfprintf+0x21c>
   15d88:	f8 01       	movw	r30, r16
   15d8a:	60 81       	ld	r22, Z
   15d8c:	71 81       	ldd	r23, Z+1	; 0x01
   15d8e:	88 27       	eor	r24, r24
   15d90:	77 fd       	sbrc	r23, 7
   15d92:	80 95       	com	r24
   15d94:	98 2f       	mov	r25, r24
   15d96:	0e 5f       	subi	r16, 0xFE	; 254
   15d98:	1f 4f       	sbci	r17, 0xFF	; 255
   15d9a:	4f e6       	ldi	r20, 0x6F	; 111
   15d9c:	b4 2e       	mov	r11, r20
   15d9e:	b2 22       	and	r11, r18
   15da0:	97 ff       	sbrs	r25, 7
   15da2:	09 c0       	rjmp	.+18     	; 0x15db6 <vfprintf+0x238>
   15da4:	90 95       	com	r25
   15da6:	80 95       	com	r24
   15da8:	70 95       	com	r23
   15daa:	61 95       	neg	r22
   15dac:	7f 4f       	sbci	r23, 0xFF	; 255
   15dae:	8f 4f       	sbci	r24, 0xFF	; 255
   15db0:	9f 4f       	sbci	r25, 0xFF	; 255
   15db2:	f0 e8       	ldi	r31, 0x80	; 128
   15db4:	bf 2a       	or	r11, r31
   15db6:	a2 01       	movw	r20, r4
   15db8:	2a e0       	ldi	r18, 0x0A	; 10
   15dba:	30 e0       	ldi	r19, 0x00	; 0
   15dbc:	48 d1       	rcall	.+656    	; 0x1604e <__ultoa_invert>
   15dbe:	78 2e       	mov	r7, r24
   15dc0:	74 18       	sub	r7, r4
   15dc2:	44 c0       	rjmp	.+136    	; 0x15e4c <vfprintf+0x2ce>
   15dc4:	85 37       	cpi	r24, 0x75	; 117
   15dc6:	31 f4       	brne	.+12     	; 0x15dd4 <vfprintf+0x256>
   15dc8:	3f ee       	ldi	r19, 0xEF	; 239
   15dca:	b3 2e       	mov	r11, r19
   15dcc:	b2 22       	and	r11, r18
   15dce:	2a e0       	ldi	r18, 0x0A	; 10
   15dd0:	30 e0       	ldi	r19, 0x00	; 0
   15dd2:	25 c0       	rjmp	.+74     	; 0x15e1e <vfprintf+0x2a0>
   15dd4:	99 ef       	ldi	r25, 0xF9	; 249
   15dd6:	b9 2e       	mov	r11, r25
   15dd8:	b2 22       	and	r11, r18
   15dda:	8f 36       	cpi	r24, 0x6F	; 111
   15ddc:	c1 f0       	breq	.+48     	; 0x15e0e <vfprintf+0x290>
   15dde:	80 37       	cpi	r24, 0x70	; 112
   15de0:	20 f4       	brcc	.+8      	; 0x15dea <vfprintf+0x26c>
   15de2:	88 35       	cpi	r24, 0x58	; 88
   15de4:	09 f0       	breq	.+2      	; 0x15de8 <vfprintf+0x26a>
   15de6:	ae c0       	rjmp	.+348    	; 0x15f44 <vfprintf+0x3c6>
   15de8:	0d c0       	rjmp	.+26     	; 0x15e04 <vfprintf+0x286>
   15dea:	80 37       	cpi	r24, 0x70	; 112
   15dec:	21 f0       	breq	.+8      	; 0x15df6 <vfprintf+0x278>
   15dee:	88 37       	cpi	r24, 0x78	; 120
   15df0:	09 f0       	breq	.+2      	; 0x15df4 <vfprintf+0x276>
   15df2:	a8 c0       	rjmp	.+336    	; 0x15f44 <vfprintf+0x3c6>
   15df4:	02 c0       	rjmp	.+4      	; 0x15dfa <vfprintf+0x27c>
   15df6:	20 e1       	ldi	r18, 0x10	; 16
   15df8:	b2 2a       	or	r11, r18
   15dfa:	b4 fe       	sbrs	r11, 4
   15dfc:	0b c0       	rjmp	.+22     	; 0x15e14 <vfprintf+0x296>
   15dfe:	84 e0       	ldi	r24, 0x04	; 4
   15e00:	b8 2a       	or	r11, r24
   15e02:	08 c0       	rjmp	.+16     	; 0x15e14 <vfprintf+0x296>
   15e04:	b4 fe       	sbrs	r11, 4
   15e06:	09 c0       	rjmp	.+18     	; 0x15e1a <vfprintf+0x29c>
   15e08:	e6 e0       	ldi	r30, 0x06	; 6
   15e0a:	be 2a       	or	r11, r30
   15e0c:	06 c0       	rjmp	.+12     	; 0x15e1a <vfprintf+0x29c>
   15e0e:	28 e0       	ldi	r18, 0x08	; 8
   15e10:	30 e0       	ldi	r19, 0x00	; 0
   15e12:	05 c0       	rjmp	.+10     	; 0x15e1e <vfprintf+0x2a0>
   15e14:	20 e1       	ldi	r18, 0x10	; 16
   15e16:	30 e0       	ldi	r19, 0x00	; 0
   15e18:	02 c0       	rjmp	.+4      	; 0x15e1e <vfprintf+0x2a0>
   15e1a:	20 e1       	ldi	r18, 0x10	; 16
   15e1c:	32 e0       	ldi	r19, 0x02	; 2
   15e1e:	b7 fe       	sbrs	r11, 7
   15e20:	08 c0       	rjmp	.+16     	; 0x15e32 <vfprintf+0x2b4>
   15e22:	f8 01       	movw	r30, r16
   15e24:	60 81       	ld	r22, Z
   15e26:	71 81       	ldd	r23, Z+1	; 0x01
   15e28:	82 81       	ldd	r24, Z+2	; 0x02
   15e2a:	93 81       	ldd	r25, Z+3	; 0x03
   15e2c:	0c 5f       	subi	r16, 0xFC	; 252
   15e2e:	1f 4f       	sbci	r17, 0xFF	; 255
   15e30:	07 c0       	rjmp	.+14     	; 0x15e40 <vfprintf+0x2c2>
   15e32:	f8 01       	movw	r30, r16
   15e34:	60 81       	ld	r22, Z
   15e36:	71 81       	ldd	r23, Z+1	; 0x01
   15e38:	80 e0       	ldi	r24, 0x00	; 0
   15e3a:	90 e0       	ldi	r25, 0x00	; 0
   15e3c:	0e 5f       	subi	r16, 0xFE	; 254
   15e3e:	1f 4f       	sbci	r17, 0xFF	; 255
   15e40:	a2 01       	movw	r20, r4
   15e42:	05 d1       	rcall	.+522    	; 0x1604e <__ultoa_invert>
   15e44:	78 2e       	mov	r7, r24
   15e46:	74 18       	sub	r7, r4
   15e48:	ff e7       	ldi	r31, 0x7F	; 127
   15e4a:	bf 22       	and	r11, r31
   15e4c:	b6 fe       	sbrs	r11, 6
   15e4e:	0b c0       	rjmp	.+22     	; 0x15e66 <vfprintf+0x2e8>
   15e50:	2e ef       	ldi	r18, 0xFE	; 254
   15e52:	b2 22       	and	r11, r18
   15e54:	7e 14       	cp	r7, r14
   15e56:	38 f4       	brcc	.+14     	; 0x15e66 <vfprintf+0x2e8>
   15e58:	b4 fe       	sbrs	r11, 4
   15e5a:	07 c0       	rjmp	.+14     	; 0x15e6a <vfprintf+0x2ec>
   15e5c:	b2 fc       	sbrc	r11, 2
   15e5e:	05 c0       	rjmp	.+10     	; 0x15e6a <vfprintf+0x2ec>
   15e60:	8f ee       	ldi	r24, 0xEF	; 239
   15e62:	b8 22       	and	r11, r24
   15e64:	02 c0       	rjmp	.+4      	; 0x15e6a <vfprintf+0x2ec>
   15e66:	a7 2c       	mov	r10, r7
   15e68:	01 c0       	rjmp	.+2      	; 0x15e6c <vfprintf+0x2ee>
   15e6a:	ae 2c       	mov	r10, r14
   15e6c:	8b 2d       	mov	r24, r11
   15e6e:	90 e0       	ldi	r25, 0x00	; 0
   15e70:	b4 fe       	sbrs	r11, 4
   15e72:	0d c0       	rjmp	.+26     	; 0x15e8e <vfprintf+0x310>
   15e74:	fe 01       	movw	r30, r28
   15e76:	e7 0d       	add	r30, r7
   15e78:	f1 1d       	adc	r31, r1
   15e7a:	20 81       	ld	r18, Z
   15e7c:	20 33       	cpi	r18, 0x30	; 48
   15e7e:	19 f4       	brne	.+6      	; 0x15e86 <vfprintf+0x308>
   15e80:	e9 ee       	ldi	r30, 0xE9	; 233
   15e82:	be 22       	and	r11, r30
   15e84:	09 c0       	rjmp	.+18     	; 0x15e98 <vfprintf+0x31a>
   15e86:	a3 94       	inc	r10
   15e88:	b2 fe       	sbrs	r11, 2
   15e8a:	06 c0       	rjmp	.+12     	; 0x15e98 <vfprintf+0x31a>
   15e8c:	04 c0       	rjmp	.+8      	; 0x15e96 <vfprintf+0x318>
   15e8e:	86 78       	andi	r24, 0x86	; 134
   15e90:	90 70       	andi	r25, 0x00	; 0
   15e92:	00 97       	sbiw	r24, 0x00	; 0
   15e94:	09 f0       	breq	.+2      	; 0x15e98 <vfprintf+0x31a>
   15e96:	a3 94       	inc	r10
   15e98:	8b 2c       	mov	r8, r11
   15e9a:	99 24       	eor	r9, r9
   15e9c:	b3 fc       	sbrc	r11, 3
   15e9e:	13 c0       	rjmp	.+38     	; 0x15ec6 <vfprintf+0x348>
   15ea0:	b0 fe       	sbrs	r11, 0
   15ea2:	0e c0       	rjmp	.+28     	; 0x15ec0 <vfprintf+0x342>
   15ea4:	af 14       	cp	r10, r15
   15ea6:	28 f4       	brcc	.+10     	; 0x15eb2 <vfprintf+0x334>
   15ea8:	e7 2c       	mov	r14, r7
   15eaa:	ef 0c       	add	r14, r15
   15eac:	ea 18       	sub	r14, r10
   15eae:	af 2c       	mov	r10, r15
   15eb0:	07 c0       	rjmp	.+14     	; 0x15ec0 <vfprintf+0x342>
   15eb2:	e7 2c       	mov	r14, r7
   15eb4:	05 c0       	rjmp	.+10     	; 0x15ec0 <vfprintf+0x342>
   15eb6:	80 e2       	ldi	r24, 0x20	; 32
   15eb8:	90 e0       	ldi	r25, 0x00	; 0
   15eba:	b6 01       	movw	r22, r12
   15ebc:	9c d0       	rcall	.+312    	; 0x15ff6 <fputc>
   15ebe:	a3 94       	inc	r10
   15ec0:	af 14       	cp	r10, r15
   15ec2:	c8 f3       	brcs	.-14     	; 0x15eb6 <vfprintf+0x338>
   15ec4:	04 c0       	rjmp	.+8      	; 0x15ece <vfprintf+0x350>
   15ec6:	af 14       	cp	r10, r15
   15ec8:	10 f4       	brcc	.+4      	; 0x15ece <vfprintf+0x350>
   15eca:	fa 18       	sub	r15, r10
   15ecc:	01 c0       	rjmp	.+2      	; 0x15ed0 <vfprintf+0x352>
   15ece:	ff 24       	eor	r15, r15
   15ed0:	84 fe       	sbrs	r8, 4
   15ed2:	0e c0       	rjmp	.+28     	; 0x15ef0 <vfprintf+0x372>
   15ed4:	80 e3       	ldi	r24, 0x30	; 48
   15ed6:	90 e0       	ldi	r25, 0x00	; 0
   15ed8:	b6 01       	movw	r22, r12
   15eda:	8d d0       	rcall	.+282    	; 0x15ff6 <fputc>
   15edc:	82 fe       	sbrs	r8, 2
   15ede:	1d c0       	rjmp	.+58     	; 0x15f1a <vfprintf+0x39c>
   15ee0:	81 fe       	sbrs	r8, 1
   15ee2:	03 c0       	rjmp	.+6      	; 0x15eea <vfprintf+0x36c>
   15ee4:	88 e5       	ldi	r24, 0x58	; 88
   15ee6:	90 e0       	ldi	r25, 0x00	; 0
   15ee8:	10 c0       	rjmp	.+32     	; 0x15f0a <vfprintf+0x38c>
   15eea:	88 e7       	ldi	r24, 0x78	; 120
   15eec:	90 e0       	ldi	r25, 0x00	; 0
   15eee:	0d c0       	rjmp	.+26     	; 0x15f0a <vfprintf+0x38c>
   15ef0:	c4 01       	movw	r24, r8
   15ef2:	86 78       	andi	r24, 0x86	; 134
   15ef4:	90 70       	andi	r25, 0x00	; 0
   15ef6:	00 97       	sbiw	r24, 0x00	; 0
   15ef8:	81 f0       	breq	.+32     	; 0x15f1a <vfprintf+0x39c>
   15efa:	81 fc       	sbrc	r8, 1
   15efc:	02 c0       	rjmp	.+4      	; 0x15f02 <vfprintf+0x384>
   15efe:	80 e2       	ldi	r24, 0x20	; 32
   15f00:	01 c0       	rjmp	.+2      	; 0x15f04 <vfprintf+0x386>
   15f02:	8b e2       	ldi	r24, 0x2B	; 43
   15f04:	b7 fc       	sbrc	r11, 7
   15f06:	8d e2       	ldi	r24, 0x2D	; 45
   15f08:	90 e0       	ldi	r25, 0x00	; 0
   15f0a:	b6 01       	movw	r22, r12
   15f0c:	74 d0       	rcall	.+232    	; 0x15ff6 <fputc>
   15f0e:	05 c0       	rjmp	.+10     	; 0x15f1a <vfprintf+0x39c>
   15f10:	80 e3       	ldi	r24, 0x30	; 48
   15f12:	90 e0       	ldi	r25, 0x00	; 0
   15f14:	b6 01       	movw	r22, r12
   15f16:	6f d0       	rcall	.+222    	; 0x15ff6 <fputc>
   15f18:	ea 94       	dec	r14
   15f1a:	7e 14       	cp	r7, r14
   15f1c:	c8 f3       	brcs	.-14     	; 0x15f10 <vfprintf+0x392>
   15f1e:	7a 94       	dec	r7
   15f20:	f2 01       	movw	r30, r4
   15f22:	e7 0d       	add	r30, r7
   15f24:	f1 1d       	adc	r31, r1
   15f26:	80 81       	ld	r24, Z
   15f28:	90 e0       	ldi	r25, 0x00	; 0
   15f2a:	b6 01       	movw	r22, r12
   15f2c:	64 d0       	rcall	.+200    	; 0x15ff6 <fputc>
   15f2e:	77 20       	and	r7, r7
   15f30:	b1 f7       	brne	.-20     	; 0x15f1e <vfprintf+0x3a0>
   15f32:	05 c0       	rjmp	.+10     	; 0x15f3e <vfprintf+0x3c0>
   15f34:	80 e2       	ldi	r24, 0x20	; 32
   15f36:	90 e0       	ldi	r25, 0x00	; 0
   15f38:	b6 01       	movw	r22, r12
   15f3a:	5d d0       	rcall	.+186    	; 0x15ff6 <fputc>
   15f3c:	fa 94       	dec	r15
   15f3e:	ff 20       	and	r15, r15
   15f40:	c9 f7       	brne	.-14     	; 0x15f34 <vfprintf+0x3b6>
   15f42:	44 ce       	rjmp	.-888    	; 0x15bcc <vfprintf+0x4e>
   15f44:	f6 01       	movw	r30, r12
   15f46:	26 81       	ldd	r18, Z+6	; 0x06
   15f48:	37 81       	ldd	r19, Z+7	; 0x07
   15f4a:	02 c0       	rjmp	.+4      	; 0x15f50 <vfprintf+0x3d2>
   15f4c:	2f ef       	ldi	r18, 0xFF	; 255
   15f4e:	3f ef       	ldi	r19, 0xFF	; 255
   15f50:	c9 01       	movw	r24, r18
   15f52:	2c 96       	adiw	r28, 0x0c	; 12
   15f54:	0f b6       	in	r0, 0x3f	; 63
   15f56:	f8 94       	cli
   15f58:	de bf       	out	0x3e, r29	; 62
   15f5a:	0f be       	out	0x3f, r0	; 63
   15f5c:	cd bf       	out	0x3d, r28	; 61
   15f5e:	cf 91       	pop	r28
   15f60:	df 91       	pop	r29
   15f62:	1f 91       	pop	r17
   15f64:	0f 91       	pop	r16
   15f66:	ff 90       	pop	r15
   15f68:	ef 90       	pop	r14
   15f6a:	df 90       	pop	r13
   15f6c:	cf 90       	pop	r12
   15f6e:	bf 90       	pop	r11
   15f70:	af 90       	pop	r10
   15f72:	9f 90       	pop	r9
   15f74:	8f 90       	pop	r8
   15f76:	7f 90       	pop	r7
   15f78:	6f 90       	pop	r6
   15f7a:	5f 90       	pop	r5
   15f7c:	4f 90       	pop	r4
   15f7e:	3f 90       	pop	r3
   15f80:	2f 90       	pop	r2
   15f82:	08 95       	ret

00015f84 <__eerd_byte_usb1287>:
   15f84:	f9 99       	sbic	0x1f, 1	; 31
   15f86:	fe cf       	rjmp	.-4      	; 0x15f84 <__eerd_byte_usb1287>
   15f88:	92 bd       	out	0x22, r25	; 34
   15f8a:	81 bd       	out	0x21, r24	; 33
   15f8c:	f8 9a       	sbi	0x1f, 0	; 31
   15f8e:	99 27       	eor	r25, r25
   15f90:	80 b5       	in	r24, 0x20	; 32
   15f92:	08 95       	ret

00015f94 <__eerd_word_usb1287>:
   15f94:	a8 e1       	ldi	r26, 0x18	; 24
   15f96:	b0 e0       	ldi	r27, 0x00	; 0
   15f98:	42 e0       	ldi	r20, 0x02	; 2
   15f9a:	50 e0       	ldi	r21, 0x00	; 0
   15f9c:	b8 c0       	rjmp	.+368    	; 0x1610e <__eerd_blraw_usb1287>

00015f9e <__eeupd_byte_usb1287>:
   15f9e:	26 2f       	mov	r18, r22

00015fa0 <__eeupd_r18_usb1287>:
   15fa0:	f9 99       	sbic	0x1f, 1	; 31
   15fa2:	fe cf       	rjmp	.-4      	; 0x15fa0 <__eeupd_r18_usb1287>
   15fa4:	92 bd       	out	0x22, r25	; 34
   15fa6:	81 bd       	out	0x21, r24	; 33
   15fa8:	f8 9a       	sbi	0x1f, 0	; 31
   15faa:	01 97       	sbiw	r24, 0x01	; 1
   15fac:	00 b4       	in	r0, 0x20	; 32
   15fae:	02 16       	cp	r0, r18
   15fb0:	39 f0       	breq	.+14     	; 0x15fc0 <__eeupd_r18_usb1287+0x20>
   15fb2:	1f ba       	out	0x1f, r1	; 31
   15fb4:	20 bd       	out	0x20, r18	; 32
   15fb6:	0f b6       	in	r0, 0x3f	; 63
   15fb8:	f8 94       	cli
   15fba:	fa 9a       	sbi	0x1f, 2	; 31
   15fbc:	f9 9a       	sbi	0x1f, 1	; 31
   15fbe:	0f be       	out	0x3f, r0	; 63
   15fc0:	08 95       	ret

00015fc2 <__eeupd_word_usb1287>:
   15fc2:	01 96       	adiw	r24, 0x01	; 1
   15fc4:	27 2f       	mov	r18, r23
   15fc6:	ec df       	rcall	.-40     	; 0x15fa0 <__eeupd_r18_usb1287>
   15fc8:	ea cf       	rjmp	.-44     	; 0x15f9e <__eeupd_byte_usb1287>

00015fca <strnlen_P>:
   15fca:	fc 01       	movw	r30, r24
   15fcc:	05 90       	lpm	r0, Z+
   15fce:	61 50       	subi	r22, 0x01	; 1
   15fd0:	70 40       	sbci	r23, 0x00	; 0
   15fd2:	01 10       	cpse	r0, r1
   15fd4:	d8 f7       	brcc	.-10     	; 0x15fcc <strnlen_P+0x2>
   15fd6:	80 95       	com	r24
   15fd8:	90 95       	com	r25
   15fda:	8e 0f       	add	r24, r30
   15fdc:	9f 1f       	adc	r25, r31
   15fde:	08 95       	ret

00015fe0 <strnlen>:
   15fe0:	fc 01       	movw	r30, r24
   15fe2:	61 50       	subi	r22, 0x01	; 1
   15fe4:	70 40       	sbci	r23, 0x00	; 0
   15fe6:	01 90       	ld	r0, Z+
   15fe8:	01 10       	cpse	r0, r1
   15fea:	d8 f7       	brcc	.-10     	; 0x15fe2 <strnlen+0x2>
   15fec:	80 95       	com	r24
   15fee:	90 95       	com	r25
   15ff0:	8e 0f       	add	r24, r30
   15ff2:	9f 1f       	adc	r25, r31
   15ff4:	08 95       	ret

00015ff6 <fputc>:
   15ff6:	0f 93       	push	r16
   15ff8:	1f 93       	push	r17
   15ffa:	cf 93       	push	r28
   15ffc:	df 93       	push	r29
   15ffe:	8c 01       	movw	r16, r24
   16000:	eb 01       	movw	r28, r22
   16002:	8b 81       	ldd	r24, Y+3	; 0x03
   16004:	81 ff       	sbrs	r24, 1
   16006:	1b c0       	rjmp	.+54     	; 0x1603e <fputc+0x48>
   16008:	82 ff       	sbrs	r24, 2
   1600a:	0d c0       	rjmp	.+26     	; 0x16026 <fputc+0x30>
   1600c:	2e 81       	ldd	r18, Y+6	; 0x06
   1600e:	3f 81       	ldd	r19, Y+7	; 0x07
   16010:	8c 81       	ldd	r24, Y+4	; 0x04
   16012:	9d 81       	ldd	r25, Y+5	; 0x05
   16014:	28 17       	cp	r18, r24
   16016:	39 07       	cpc	r19, r25
   16018:	64 f4       	brge	.+24     	; 0x16032 <fputc+0x3c>
   1601a:	e8 81       	ld	r30, Y
   1601c:	f9 81       	ldd	r31, Y+1	; 0x01
   1601e:	01 93       	st	Z+, r16
   16020:	f9 83       	std	Y+1, r31	; 0x01
   16022:	e8 83       	st	Y, r30
   16024:	06 c0       	rjmp	.+12     	; 0x16032 <fputc+0x3c>
   16026:	e8 85       	ldd	r30, Y+8	; 0x08
   16028:	f9 85       	ldd	r31, Y+9	; 0x09
   1602a:	80 2f       	mov	r24, r16
   1602c:	09 95       	icall
   1602e:	00 97       	sbiw	r24, 0x00	; 0
   16030:	31 f4       	brne	.+12     	; 0x1603e <fputc+0x48>
   16032:	8e 81       	ldd	r24, Y+6	; 0x06
   16034:	9f 81       	ldd	r25, Y+7	; 0x07
   16036:	01 96       	adiw	r24, 0x01	; 1
   16038:	9f 83       	std	Y+7, r25	; 0x07
   1603a:	8e 83       	std	Y+6, r24	; 0x06
   1603c:	02 c0       	rjmp	.+4      	; 0x16042 <fputc+0x4c>
   1603e:	0f ef       	ldi	r16, 0xFF	; 255
   16040:	1f ef       	ldi	r17, 0xFF	; 255
   16042:	c8 01       	movw	r24, r16
   16044:	df 91       	pop	r29
   16046:	cf 91       	pop	r28
   16048:	1f 91       	pop	r17
   1604a:	0f 91       	pop	r16
   1604c:	08 95       	ret

0001604e <__ultoa_invert>:
   1604e:	fa 01       	movw	r30, r20
   16050:	aa 27       	eor	r26, r26
   16052:	28 30       	cpi	r18, 0x08	; 8
   16054:	51 f1       	breq	.+84     	; 0x160aa <__ultoa_invert+0x5c>
   16056:	20 31       	cpi	r18, 0x10	; 16
   16058:	81 f1       	breq	.+96     	; 0x160ba <__ultoa_invert+0x6c>
   1605a:	e8 94       	clt
   1605c:	6f 93       	push	r22
   1605e:	6e 7f       	andi	r22, 0xFE	; 254
   16060:	6e 5f       	subi	r22, 0xFE	; 254
   16062:	7f 4f       	sbci	r23, 0xFF	; 255
   16064:	8f 4f       	sbci	r24, 0xFF	; 255
   16066:	9f 4f       	sbci	r25, 0xFF	; 255
   16068:	af 4f       	sbci	r26, 0xFF	; 255
   1606a:	b1 e0       	ldi	r27, 0x01	; 1
   1606c:	3e d0       	rcall	.+124    	; 0x160ea <__ultoa_invert+0x9c>
   1606e:	b4 e0       	ldi	r27, 0x04	; 4
   16070:	3c d0       	rcall	.+120    	; 0x160ea <__ultoa_invert+0x9c>
   16072:	67 0f       	add	r22, r23
   16074:	78 1f       	adc	r23, r24
   16076:	89 1f       	adc	r24, r25
   16078:	9a 1f       	adc	r25, r26
   1607a:	a1 1d       	adc	r26, r1
   1607c:	68 0f       	add	r22, r24
   1607e:	79 1f       	adc	r23, r25
   16080:	8a 1f       	adc	r24, r26
   16082:	91 1d       	adc	r25, r1
   16084:	a1 1d       	adc	r26, r1
   16086:	6a 0f       	add	r22, r26
   16088:	71 1d       	adc	r23, r1
   1608a:	81 1d       	adc	r24, r1
   1608c:	91 1d       	adc	r25, r1
   1608e:	a1 1d       	adc	r26, r1
   16090:	20 d0       	rcall	.+64     	; 0x160d2 <__ultoa_invert+0x84>
   16092:	09 f4       	brne	.+2      	; 0x16096 <__ultoa_invert+0x48>
   16094:	68 94       	set
   16096:	3f 91       	pop	r19
   16098:	2a e0       	ldi	r18, 0x0A	; 10
   1609a:	26 9f       	mul	r18, r22
   1609c:	11 24       	eor	r1, r1
   1609e:	30 19       	sub	r19, r0
   160a0:	30 5d       	subi	r19, 0xD0	; 208
   160a2:	31 93       	st	Z+, r19
   160a4:	de f6       	brtc	.-74     	; 0x1605c <__ultoa_invert+0xe>
   160a6:	cf 01       	movw	r24, r30
   160a8:	08 95       	ret
   160aa:	46 2f       	mov	r20, r22
   160ac:	47 70       	andi	r20, 0x07	; 7
   160ae:	40 5d       	subi	r20, 0xD0	; 208
   160b0:	41 93       	st	Z+, r20
   160b2:	b3 e0       	ldi	r27, 0x03	; 3
   160b4:	0f d0       	rcall	.+30     	; 0x160d4 <__ultoa_invert+0x86>
   160b6:	c9 f7       	brne	.-14     	; 0x160aa <__ultoa_invert+0x5c>
   160b8:	f6 cf       	rjmp	.-20     	; 0x160a6 <__ultoa_invert+0x58>
   160ba:	46 2f       	mov	r20, r22
   160bc:	4f 70       	andi	r20, 0x0F	; 15
   160be:	40 5d       	subi	r20, 0xD0	; 208
   160c0:	4a 33       	cpi	r20, 0x3A	; 58
   160c2:	18 f0       	brcs	.+6      	; 0x160ca <__ultoa_invert+0x7c>
   160c4:	49 5d       	subi	r20, 0xD9	; 217
   160c6:	31 fd       	sbrc	r19, 1
   160c8:	40 52       	subi	r20, 0x20	; 32
   160ca:	41 93       	st	Z+, r20
   160cc:	02 d0       	rcall	.+4      	; 0x160d2 <__ultoa_invert+0x84>
   160ce:	a9 f7       	brne	.-22     	; 0x160ba <__ultoa_invert+0x6c>
   160d0:	ea cf       	rjmp	.-44     	; 0x160a6 <__ultoa_invert+0x58>
   160d2:	b4 e0       	ldi	r27, 0x04	; 4
   160d4:	a6 95       	lsr	r26
   160d6:	97 95       	ror	r25
   160d8:	87 95       	ror	r24
   160da:	77 95       	ror	r23
   160dc:	67 95       	ror	r22
   160de:	ba 95       	dec	r27
   160e0:	c9 f7       	brne	.-14     	; 0x160d4 <__ultoa_invert+0x86>
   160e2:	00 97       	sbiw	r24, 0x00	; 0
   160e4:	61 05       	cpc	r22, r1
   160e6:	71 05       	cpc	r23, r1
   160e8:	08 95       	ret
   160ea:	9b 01       	movw	r18, r22
   160ec:	ac 01       	movw	r20, r24
   160ee:	0a 2e       	mov	r0, r26
   160f0:	06 94       	lsr	r0
   160f2:	57 95       	ror	r21
   160f4:	47 95       	ror	r20
   160f6:	37 95       	ror	r19
   160f8:	27 95       	ror	r18
   160fa:	ba 95       	dec	r27
   160fc:	c9 f7       	brne	.-14     	; 0x160f0 <__ultoa_invert+0xa2>
   160fe:	62 0f       	add	r22, r18
   16100:	73 1f       	adc	r23, r19
   16102:	84 1f       	adc	r24, r20
   16104:	95 1f       	adc	r25, r21
   16106:	a0 1d       	adc	r26, r0
   16108:	08 95       	ret

0001610a <__eerd_block_usb1287>:
   1610a:	dc 01       	movw	r26, r24
   1610c:	cb 01       	movw	r24, r22

0001610e <__eerd_blraw_usb1287>:
   1610e:	fc 01       	movw	r30, r24
   16110:	f9 99       	sbic	0x1f, 1	; 31
   16112:	fe cf       	rjmp	.-4      	; 0x16110 <__eerd_blraw_usb1287+0x2>
   16114:	06 c0       	rjmp	.+12     	; 0x16122 <__eerd_blraw_usb1287+0x14>
   16116:	f2 bd       	out	0x22, r31	; 34
   16118:	e1 bd       	out	0x21, r30	; 33
   1611a:	f8 9a       	sbi	0x1f, 0	; 31
   1611c:	31 96       	adiw	r30, 0x01	; 1
   1611e:	00 b4       	in	r0, 0x20	; 32
   16120:	0d 92       	st	X+, r0
   16122:	41 50       	subi	r20, 0x01	; 1
   16124:	50 40       	sbci	r21, 0x00	; 0
   16126:	b8 f7       	brcc	.-18     	; 0x16116 <__eerd_blraw_usb1287+0x8>
   16128:	08 95       	ret

0001612a <_exit>:
   1612a:	f8 94       	cli

0001612c <__stop_program>:
   1612c:	ff cf       	rjmp	.-2      	; 0x1612c <__stop_program>
